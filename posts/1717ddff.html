<!DOCTYPE html><html lang="zh-TW" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>替換後的最長重複字元 | Medium | LeetCode#424. Longest Repeating Character Replacement | Kevin Liu's 部落格 || Technical || Travel</title><meta name="author" content="Kevin Liu"><meta name="copyright" content="Kevin Liu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="題目敘述  題目難度： Medium 題目描述： 給定一個字串 s 以及整數 k ，題目要求我們需要去將 s 中的任意字元替換成其他英文大寫字母，這樣的替換操作可以進行 k 次，在進行 k 次操做後，請回傳具有相同字母的最長的子字串  解法一開始的想法對於關鍵字，最長子字串，可以直接聯想到要使用 Sliding Window，但這題除了找到子字串之外，還需要透過 Hash Table 來去紀錄個別">
<meta property="og:type" content="article">
<meta property="og:title" content="替換後的最長重複字元 | Medium | LeetCode#424. Longest Repeating Character Replacement">
<meta property="og:url" content="https://leozzmc.github.io/posts/1717ddff.html">
<meta property="og:site_name" content="Kevin Liu&#39;s 部落格 || Technical || Travel">
<meta property="og:description" content="題目敘述  題目難度： Medium 題目描述： 給定一個字串 s 以及整數 k ，題目要求我們需要去將 s 中的任意字元替換成其他英文大寫字母，這樣的替換操作可以進行 k 次，在進行 k 次操做後，請回傳具有相同字母的最長的子字串  解法一開始的想法對於關鍵字，最長子字串，可以直接聯想到要使用 Sliding Window，但這題除了找到子字串之外，還需要透過 Hash Table 來去紀錄個別">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://leozzmc.github.io/img/LeetCode/424/cover.png">
<meta property="article:published_time" content="2025-01-14T11:42:32.000Z">
<meta property="article:modified_time" content="2025-01-27T06:00:32.839Z">
<meta property="article:author" content="Kevin Liu">
<meta property="article:tag" content="String">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Medium">
<meta property="article:tag" content="Hash Table">
<meta property="article:tag" content="Sliding Window">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leozzmc.github.io/img/LeetCode/424/cover.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "替換後的最長重複字元 | Medium | LeetCode#424. Longest Repeating Character Replacement",
  "url": "https://leozzmc.github.io/posts/1717ddff.html",
  "image": "https://leozzmc.github.io/img/LeetCode/424/cover.png",
  "datePublished": "2025-01-14T11:42:32.000Z",
  "dateModified": "2025-01-27T06:00:32.839Z",
  "author": [
    {
      "@type": "Person",
      "name": "Kevin Liu",
      "url": "https://leozzmc.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/kevin3.png"><link rel="canonical" href="https://leozzmc.github.io/posts/1717ddff.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-T4SFRRLLZ0"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-T4SFRRLLZ0')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-T4SFRRLLZ0', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":3,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '複製成功',
    error: '複製失敗',
    noSupport: '瀏覽器不支援'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '剛剛',
    min: '分鐘前',
    hour: '小時前',
    day: '天前',
    month: '個月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '載入更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '替換後的最長重複字元 | Medium | LeetCode#424. Longest Repeating Character Replacement',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg" style="background-color: #f5f1ed;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">119</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 找文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 歸檔</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 鏈結</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 語言:</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/LeetCode/424/cover.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://i.imgur.com/P19VCm0.png" alt="Logo"><span class="site-name">Kevin Liu's 部落格 || Technical || Travel</span></a><a class="nav-page-title" href="/"><span class="site-name">替換後的最長重複字元 | Medium | LeetCode#424. Longest Repeating Character Replacement</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首頁</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 找文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 歸檔</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 鏈結</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 語言:</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fa-c"></i><span> 中文</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">替換後的最長重複字元 | Medium | LeetCode#424. Longest Repeating Character Replacement</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2025-01-14T11:42:32.000Z" title="發表於 2025-01-14 19:42:32">2025-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2025-01-27T06:00:32.839Z" title="更新於 2025-01-27 14:00:32">2025-01-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode%E7%AD%86%E8%A8%98/">LeetCode筆記</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">瀏覽量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/424/question.jpeg"></p>
<ul>
<li>題目難度： <code>Medium</code></li>
<li>題目描述： 給定一個字串 <code>s</code> 以及整數 <code>k</code> ，題目要求我們需要去將 <code>s</code> 中的任意字元替換成其他英文大寫字母，這樣的替換操作可以進行 <code>k</code> 次，在進行 <code>k</code> 次操做後，請回傳具有相同字母的最長的子字串</li>
</ul>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>對於關鍵字，最長子字串，可以直接聯想到要使用 Sliding Window，但這題除了找到子字串之外，還需要透過 Hash Table 來去紀錄個別字母的出現頻率，同時在滑動窗口的同時需要紀錄最大長度。</p>
<h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">        <span class="type">int</span> maxFreq = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        string tempStr = s;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>; right&lt;s.<span class="built_in">length</span>();right++)&#123;</span><br><span class="line">            umap[s[right]]++;</span><br><span class="line">            maxFreq = <span class="built_in">max</span>(maxFreq, umap[s[right]]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>((right - left +<span class="number">1</span>) - maxFreq &gt; k )&#123;</span><br><span class="line">                umap[s[left]]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxLength = <span class="built_in">max</span>(maxLength, right-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這裡的 Hash Table <code>unordered_map&lt;char, int&gt;</code>  <strong>主要用於儲存子字串中的個別字母出現頻率</strong> ， 這裡還額外初始化了兩個變數 <code>maxFreq</code> 以及 <code>maxLength</code> 分別用來儲存，子字串中出現最高頻率字母的個數，以及最長子字串的長度。 </p>
<p>這裡也先將左指針 <code>left</code> 歸零，透過 for 迴圈來去移動右指針 <code>right</code> ，每次移動右指針，<code>umap</code> 中對應字元的出現次數就增加 (<code>umap[s[right]]++</code>)，並且每到一個字母就去取出當前最高頻率的字母的次數 (<code>maxFreq = max(maxFreq, umap[s[right]])</code>)，這個 <code>maxFreq</code> 的目的在於，如果窗口中的元素，在進行 <code>k</code> 次替換後還有剩餘元素，這樣就需要去把窗口收窄，因此如果在迴圈中發現當前窗口大小 <code>right-left+1</code> 在扣掉最高頻率字母的個數 <code>maxFreq</code> 後，仍然比 <code>k</code> 還要大，那這時候就需要將窗口收窄，收窄的行為會包含： </p>
<p>(1) 更新 <code>umap</code>，因為它代表當前窗口底下不同字母的出現次數<br>(2) 更新左指針。</p>
<p>每次移動右指針中，如果窗口大小調整適當，則會去與當前最長子字串長度 <code>maxLength</code> 進行比較 (<code>maxLength = max(maxLength, right-left+1)</code>)，全部結束後就回傳最長子字串長度。</p>
<h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/424/result.jpeg"></p>
<h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度<br>$O(n)$ &#x3D; $O(n)$ + $O(n)$ : 左右指針都只會便字串一次。每個指針最多移動 $n$ 次</p>
<p>空間複雜度</p>
<p>$O(1)$: Hash Table 僅會記錄大寫英文字母，因此為 $O(26)$ &#x3D; $O(1)$</p>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://leozzmc.github.io">Kevin Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章連結: </span><span class="post-copyright-info"><a href="https://leozzmc.github.io/posts/1717ddff.html">https://leozzmc.github.io/posts/1717ddff.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 授權協議。轉載請註明來源 <a href="https://leozzmc.github.io" target="_blank">Kevin Liu's 部落格 || Technical || Travel</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/String/">String</a><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/Medium/">Medium</a><a class="post-meta__tags" href="/tags/Hash-Table/">Hash Table</a><a class="post-meta__tags" href="/tags/Sliding-Window/">Sliding Window</a></div><div class="post-share"><div class="social-share" data-image="/img/LeetCode/424/cover.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/7fd7eb24.html" title="太平洋-大西洋水流 | Medium | LeetCode#417. Pacific Atlantic Water Flow"><img class="cover" src="/img/LeetCode/417/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">太平洋-大西洋水流 | Medium | LeetCode#417. Pacific Atlantic Water Flow</div></div><div class="info-2"><div class="info-item-1">題目敘述   題目難度： Medium 題目描述： 有個大小 m x n 的長方形島嶼，它的邊界被太平洋與大西洋包圍。與太平洋交界的會是島嶼的上方以及左側邊緣，與大西洋交界的會是島嶼的下方和右側邊緣。島嶼被切分成許多網格單元，可以視為一個 m x n 大小的矩陣 heights，其中 heights[r][c] 代表座標 (r,c) 位置的海拔高度。 島上很常下雨， 只要當前單元格的海拔高度大於或等於其上下左右單元格的海拔高度，則雨水可以自由流向他的上下左右單元格。 雨水可以透過相鄰單元格一路流到海洋中。 題目要求回傳一個 2D 矩陣 result， 其中 result[i] = [r_i, c_i] 代表雨水可以從座標 (r_i, c_i) 同時流到太平洋與大西洋。  解法一開始的想法一開始覺得這題一樣會是 connected components 只是 connected 的條件...</div></div></div></a><a class="pagination-related" href="/posts/7a271795.html" title="KoKo 吃香蕉 | Medium | LeetCode#875. Koko Eating Bananas"><img class="cover" src="/img/LeetCode/875/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">KoKo 吃香蕉 | Medium | LeetCode#875. Koko Eating Bananas</div></div><div class="info-2"><div class="info-item-1">題目敘述  題目難度： Medium 題目描述：Koko 愛吃香蕉，今天有 n 堆的香蕉，第 i 堆香蕉的數量會是 piles[i]，香蕉由守衛看守，守衛目前不在，但他會在 h 小時候回來。Koko 每小時吃香蕉的速度會是 k，每一小時 Koko 會去挑選一堆香蕉吃，如果某堆香蕉的數量小於 k 則Koko 會將它們全吃掉，並且在那一小時中不會再去吃其他堆香蕉。雖然 Koko 吃的很慢，但是他還是希望在守衛回來前將所有的香蕉都吃完，為了達到這個目的，Koko 每小時吃香蕉的速度 k 最小會是多少？  解法一開始的想法一開始還在想要怎麼樣決定k，這裡可以透過 Binary Search 的方式去將不同堆的元素作為 k 去嘗試，嘗試的方式就是將每堆元素扣除 K 直到變成 0，同時記錄時數，只要最終時數小於 h 則回傳 k 值，只要最終時數大於 h 則繼續透過二元法找其他的 k 我的解法12...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/5701a21.html" title="無重複字元的最長字串 | Medium | LeetCode#3. Longest Substring Without Repeating Characters"><img class="cover" src="/img/LeetCode/3/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-04</div><div class="info-item-2">無重複字元的最長字串 | Medium | LeetCode#3. Longest Substring Without Repeating Characters</div></div><div class="info-2"><div class="info-item-1">題目敘述  題目難度: Medium 題目描述：給定一個字串 s，求最長子字串的長度，並且該子字串中不能有重複的字元  解法一開始的想法這題的暴力解就會是透過雙重迴圈來去找各種子字串，然後查找多種不同非重複子字串的長度，然後回傳最長的那個，但在迴圈查找過程中，由於要查找的是輸入資料中的變動長度的字串，因此可以用 sliding window 來解題。其中在確認字元是否重複的過程，則可以用Hash Table 來去儲存和查找。 我的做法1234567891011121314151617181920class Solution &#123;public:    int  lengthOfLongestSubstring(string s)&#123;        if(s.size()==0) return 0;        int left=0, right=0;        i...</div></div></div></a><a class="pagination-related" href="/posts/33b92d95.html" title="長度最小的子陣列和 | Medium | LeetCode#209. Minimum Size Subarray Sum"><img class="cover" src="/img/LeetCode/209/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-01</div><div class="info-item-2">長度最小的子陣列和 | Medium | LeetCode#209. Minimum Size Subarray Sum</div></div><div class="info-2"><div class="info-item-1">題目敘述  題目難度： Medium 題目描述： 給定一個整數陣列 nums，以及正整數 target，請回傳長度最短的子陣列，其所有元素和大於或等於 target 值。若沒有任何子陣列，則回傳 0  解法一開始的想法這題的關鍵就是要 回傳滿足條件的子陣列 ，因此可以很直覺地聯想到要用 sliding windo來去找出滿足要求的子陣列。 我的做法123456789101112131415161718192021class Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums)&#123;        int left=0, right=0;        int sum = 0;        int length = INT_MAX;        while(r...</div></div></div></a><a class="pagination-related" href="/posts/9081d01d.html" title="拆分字句 | Medium | LeetCode#139. Word Break"><img class="cover" src="/img/LeetCode/139/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-18</div><div class="info-item-2">拆分字句 | Medium | LeetCode#139. Word Break</div></div><div class="info-2"><div class="info-item-1">題目敘述  題目難度：Medium 題目描述：給定一個字串 s，以及一個字串形成的陣列 wordDict，若 s 可以被分割成一個或多個 wordDict 當中的單字序列，則回傳 True  Note that the same word in the dictionary may be reused multiple times in the segmentation.   解法一開始的想法s 中的每個字元可以 選或不選，每次形成一個子字串，就去跟 wordDict 進行比較看當前子字串是否存在於 wordDict 當中，一旦嘗試過每個子字串，則回傳結果。 我的解答1234567891011121314151617181920212223242526class Solution &#123;public:    vector&lt;int&gt; dp;     bool help...</div></div></div></a><a class="pagination-related" href="/posts/14d09d4a.html" title="字詞模式 | Easy | LeetCode#290. Word Pattern"><img class="cover" src="/img/LeetCode/290/cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-14</div><div class="info-item-2">字詞模式 | Easy | LeetCode#290. Word Pattern</div></div><div class="info-2"><div class="info-item-1">題目敘述   題目難度: Easy 題目描述: 給定字串 pattern 以及 字串 s，檢查 s 是否遵循相同模式  題目有說明這裡 相同模式 的意思: pattern 中的任一字元與 s 中的非空字串完全匹配的 1對1映射關係，具體來說規則如下:  在 pattern 中的每個字母，都有明確的對應到 s 中的 unique 字串 在 s 中的 unique 字串，明確對應到 pattern 中的一個字母 沒有兩個字母映射到同一個單詞，也沒有兩個單詞映射到同一個字母     解法一開始的想法這裡想法很單純就是透過 Hash Table 來去建立並儲存映射關係。而在建立過程中可以去檢查當前的字母和對應字串是否已經存在映射關係於 hash table 中，如果有救回傳 false，如果整個 hash table都建立好後都沒有重複的映射關係那就回傳 true。 我的解法12345678...</div></div></div></a><a class="pagination-related" href="/posts/c95a58c1.html" title="最佳股票買賣時機含冷凍期 | Medium | LeetCode#309. Best Time to Buy and Sell Stock with Cooldown"><img class="cover" src="/img/LeetCode/309/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-27</div><div class="info-item-2">最佳股票買賣時機含冷凍期 | Medium | LeetCode#309. Best Time to Buy and Sell Stock with Cooldown</div></div><div class="info-2"><div class="info-item-1">前言121. Best Time to Buy and Sell Stock122. Best Time to Buy and Sell Stock II123. Best Time to Buy and Sell Stock III188. Best Time to Buy and Sell Stock IV 題目敘述  題目難度：Medium 題目描述： 給定一個整數陣列 prices，其中 prices[i] 代表給定股票在第 i 天的價格，請找到你能獲得的最高股票收益，可以買賣股票多次，但是有以下限制： 當你賣出股票後，隔一天為冷卻期，無法進行買賣 在你買股票前，需要把先前持有的股票賣出 (i.e. 你不能夠 第一天買然後第二天也買，要先把第一天的賣掉)    解法一開始的想法這題我後來參考了 NeetCode 的影片，裡面的樹狀圖幫助很大， Decision Tree   ...</div></div></div></a><a class="pagination-related" href="/posts/14bd70a5.html" title="最長遞增子序列 | Medium | 300. Longest Increasing Subsequence"><img class="cover" src="/img/LeetCode/300/cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-17</div><div class="info-item-2">最長遞增子序列 | Medium | 300. Longest Increasing Subsequence</div></div><div class="info-2"><div class="info-item-1">題目敘述  題目難度: Medium 題目敘述: 題目給定一個整數陣列 nums，回傳所有可能的遞增子序列中最長的長度  子序列(Subsequence) 可由原先陣列中刪除多個元素來得到，但不可更動其元素順序，其中遞增子序列代表元素由左至右數字漸增 Ex. [5,8,3,2,4,5,9,15,7,20]其子序列包含:[5,8,4,5,20] 非遞增子序列[2,4,9,15] 遞增子序列[15,7,20]  非遞增子序列[5,9,15,20]  遞增子序列   解法一開始的想法一開始的想法比較偏向暴力解，一開始先思考要怎麼手動找出遞增子序列，並且要找到最長的。 對於 nums = [10,9,2,5,3,7,101,18] 1234567i=0 [10,9]i=1 [10,2]i=2 [10,5]i=3 [10,3]i=4 [10,7]i=5 [10,101]i=6 [10,18] ...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 評論</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Kevin Liu</div><div class="author-info-description">👍👍👍👍👍</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">119</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/leozzmc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/leozzmc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zzmczzmczzmc870125@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #e0ad5a;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/kevin-liu087" target="_blank" title="LinkedIn"><i class="fa-brands fa-linkedin" style="color: #0373fc;"></i></a><a class="social-icon" href="https://www.youtube.com/channel/UC2AU_vpxPu0oKcgZl3UJSNg" target="_blank" title="Youtube"><i class="fa-brands fa-youtube" style="color: #dc1e1e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">🛫🛬</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%8C%E7%9B%AE%E6%95%98%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">題目敘述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">解法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E9%96%8B%E5%A7%8B%E7%9A%84%E6%83%B3%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">一開始的想法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E8%A7%A3%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">我的解法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%B7%E8%A1%8C%E7%B5%90%E6%9E%9C"><span class="toc-number">2.2.1.</span> <span class="toc-text">執行結果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A4%87%E9%9B%9C%E5%BA%A6"><span class="toc-number">3.</span> <span class="toc-text">複雜度</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/d0fc136d.html" title="LeetCode 刷題知識總整理">LeetCode 刷題知識總整理</a><time datetime="2100-11-29T01:08:02.000Z" title="發表於 2100-11-29 09:08:02">2100-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dce71546.html" title="DevOps技能樹知識整理 |【筆記目錄】"><img src="/img/devops/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DevOps技能樹知識整理 |【筆記目錄】"/></a><div class="content"><a class="title" href="/posts/dce71546.html" title="DevOps技能樹知識整理 |【筆記目錄】">DevOps技能樹知識整理 |【筆記目錄】</a><time datetime="2060-11-05T13:45:50.000Z" title="發表於 2060-11-05 21:45:50">2060-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/22911275.html" title="Git for DevOps 筆記 |【DevOps技能樹】"><img src="/img/devops/git/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git for DevOps 筆記 |【DevOps技能樹】"/></a><div class="content"><a class="title" href="/posts/22911275.html" title="Git for DevOps 筆記 |【DevOps技能樹】">Git for DevOps 筆記 |【DevOps技能樹】</a><time datetime="2025-11-11T03:45:46.000Z" title="發表於 2025-11-11 11:45:46">2025-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/85addf17.html" title="合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String"><img src="/img/LeetCode/678/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String"/></a><div class="content"><a class="title" href="/posts/85addf17.html" title="合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String">合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String</a><time datetime="2025-10-26T07:05:24.000Z" title="發表於 2025-10-26 15:05:24">2025-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8a835d3b.html" title="Pow(x, n) | Medium | LeetCode#50. Pow(x, n)"><img src="/img/LeetCode/50/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Pow(x, n) | Medium | LeetCode#50. Pow(x, n)"/></a><div class="content"><a class="title" href="/posts/8a835d3b.html" title="Pow(x, n) | Medium | LeetCode#50. Pow(x, n)">Pow(x, n) | Medium | LeetCode#50. Pow(x, n)</a><time datetime="2025-10-23T06:03:36.000Z" title="發表於 2025-10-23 14:03:36">2025-10-23</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By Kevin Liu</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="繁簡轉換">EN</button><button id="darkmode" type="button" title="日夜模式切換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往評論"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到頂端"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'dark'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null
  const getUtterancesTheme = theme => theme === 'dark' ? 'photon-dark' : 'github-light'

  const loadUtterances = (el = document, key) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyUtterances = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const config = {
      src: 'https://utteranc.es/client.js',
      repo: 'leozzmc/Blog_Reply',
      theme: getUtterancesTheme(document.documentElement.getAttribute('data-theme')),
      crossorigin: 'anonymous',
      async: true,
      ...option,
      'issue-term': isShuoshuo ? key : (option && option['issue-term']) || 'pathname'
    }

    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => ele.setAttribute(key, value))
    el.querySelector('#utterances-wrap').appendChild(ele)
  }

  const changeUtterancesTheme = theme => {
    const iframe = document.querySelector('#utterances-wrap iframe')
    if (iframe) {
      const message = {
        type: 'set-theme',
        theme: getUtterancesTheme(theme)
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es')
    }
  }

  btf.addGlobalFn('themeChange', changeUtterancesTheme, 'utterances')

  if (isShuoshuo) {
    'Utterances' === 'Utterances'
      ? window.shuoshuoComment = { loadComment: loadUtterances }
      : window.loadOtherComment = loadUtterances
    return
  }
  
  if ('Utterances' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script></div><script data-pjax src="/self/btf.js"></script><script data-pjax src="/self/tw_en.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script data-pjax src="/self/calendar.js"></script><script data-pjax src="/self/languages.js"></script><script id="canvas_nest" defer="defer" color="34,34,34" opacity="0.8" zIndex="-1" count="350" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>