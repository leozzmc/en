<!DOCTYPE html><html lang="zh-TW" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>LeetCode 刷題知識總整理 | Kevin Liu's 部落格 || Technical || Travel</title><meta name="author" content="Kevin Liu"><meta name="copyright" content="Kevin Liu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="前言這篇用來記錄刷leetcode 的各類主題，以及不同情境下要用的對應解題策略是哪些，也連接到之前所做的筆記跟部落格 Roadmap 這邊是參考 NeetCode 官網的roadmap 按照不同主題進行刷題的  Big-O   https:&#x2F;&#x2F;www.bigocheatsheet.com&#x2F;  Two PointersTwo pointer 如果出現在陣列題目中，代表兩個索引(index)，如果出">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode 刷題知識總整理">
<meta property="og:url" content="https://leozzmc.github.io/posts/d0fc136d.html">
<meta property="og:site_name" content="Kevin Liu&#39;s 部落格 || Technical || Travel">
<meta property="og:description" content="前言這篇用來記錄刷leetcode 的各類主題，以及不同情境下要用的對應解題策略是哪些，也連接到之前所做的筆記跟部落格 Roadmap 這邊是參考 NeetCode 官網的roadmap 按照不同主題進行刷題的  Big-O   https:&#x2F;&#x2F;www.bigocheatsheet.com&#x2F;  Two PointersTwo pointer 如果出現在陣列題目中，代表兩個索引(index)，如果出">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://leozzmc.github.io/img/me.jpg">
<meta property="article:published_time" content="2100-11-29T01:08:02.000Z">
<meta property="article:modified_time" content="2025-01-27T06:00:32.876Z">
<meta property="article:author" content="Kevin Liu">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leozzmc.github.io/img/me.jpg"><link rel="shortcut icon" href="/img/kevin3.png"><link rel="canonical" href="https://leozzmc.github.io/posts/d0fc136d.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-T4SFRRLLZ0"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-T4SFRRLLZ0');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查詢的內容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":3,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":600},
  copy: {
    success: '複製成功',
    error: '複製錯誤',
    noSupport: '瀏覽器不支援'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '剛剛',
    min: '分鐘前',
    hour: '小時前',
    day: '天前',
    month: '個月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LeetCode 刷題知識總整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-27 14:00:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/me.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">119</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 找文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 歸檔</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 鏈結</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-language"></i><span> 語言:</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover7.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Kevin Liu's 部落格 || Technical || Travel"><img class="site-icon" src="https://i.imgur.com/P19VCm0.png"/><span class="site-name">Kevin Liu's 部落格 || Technical || Travel</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜尋</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 找文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 歸檔</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 鏈結</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-language"></i><span> 語言:</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fa-c"></i><span> 中文</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">LeetCode 刷題知識總整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2100-11-29T01:08:02.000Z" title="發表於 2100-11-29 09:08:02">2100-11-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2025-01-27T06:00:32.876Z" title="更新於 2025-01-27 14:00:32">2025-01-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode%E7%AD%86%E8%A8%98/">LeetCode筆記</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="LeetCode 刷題知識總整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這篇用來記錄刷leetcode 的各類主題，以及不同情境下要用的對應解題策略是哪些，也連接到之前所做的筆記跟部落格</p>
<h3 id="Roadmap"><a href="#Roadmap" class="headerlink" title="Roadmap"></a>Roadmap</h3><blockquote>
<p>這邊是參考 <a target="_blank" rel="noopener" href="https://neetcode.io/roadmap">NeetCode 官網的roadmap</a> 按照不同主題進行刷題的</p>
</blockquote>
<h1 id="Big-O"><a href="#Big-O" class="headerlink" title="Big-O"></a>Big-O</h1><p><img src="/img/LeetCode/org/bigo.jpeg"></p>
<p><img src="/img/LeetCode/org/bigo-2.jpeg"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bigocheatsheet.com/">https://www.bigocheatsheet.com/</a></p>
</blockquote>
<h1 id="Two-Pointers"><a href="#Two-Pointers" class="headerlink" title="Two Pointers"></a>Two Pointers</h1><p>Two pointer 如果出現在陣列題目中，代表兩個索引(index)，如果出現在 Linked List題目中，代表兩個不同的指標。但核心目的都是一樣的，透過移動pointer位置來減少溶於計算提高效率。</p>
<p>常見的Two pointer類型：</p>
<ul>
<li>反向指針: 一個指向頭部一個指向尾部，逐漸向中間靠攏，檢查回文, 兩數之和通常很常用這種類型</li>
<li>快慢指針: 一個指針較快，另一個指針較慢，可以用於檢測Linked List 中是否有環。</li>
</ul>
<p>某些情況下會搭配 Sliding Windows 來去動態調整子陣列的大小，Ex.右指針擴展Windows，左指針收斂windows。以下整理常見的 Two Pointer 使用時機：</p>
<ol>
<li><strong>$O(N^2)$ 降低成 $O(N)$,題目要求降低複雜度</strong></li>
<li><strong>輸入資料是有序的</strong></li>
<li><strong>題目要求將不同索引作比較</strong></li>
<li><strong>題目要求要在不同索引間交換</strong></li>
<li><strong>題目要求將陣列分區</strong></li>
</ol>
<blockquote>
<p>注意，如果要用反向指針逐步收斂問題範圍，會有條件，<strong>那就是資料必須是已排序的</strong><br>但如果題目是要搭配 Sliding Windows 或者linked list 則資料不一定要排序</p>
</blockquote>
<ul>
<li><a href="">LeetCode#392. Is Subsequence</a></li>
<li><a href="https://leozzmc.github.io/posts/7abe6380.html">LeetCode#125. Valid Palindrome</a></li>
<li><a href="">LeetCode#167. Two Sum II - Input Array Is Sorted</a></li>
<li><a href="">LeetCode#15. 3Sum</a></li>
</ul>
<h1 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h1><p>Sliding Window 算是 Two Pointer 的其中一種變化，可以透過兩個指標 <code>left</code> 以及 <code>right</code> 來去建立窗口(Window)， <strong>通常題目會要求返回特定條件的最大或最小子範圍</strong>，利用 <code>[Left, Right]</code> 夾出來的 Window 來在運算過程中滑動(收縮和擴展)來找出最佳的範圍。</p>
<h2 id="三個關鍵步驟"><a href="#三個關鍵步驟" class="headerlink" title="三個關鍵步驟"></a>三個關鍵步驟</h2><ol>
<li>Expand out window</li>
<li>Meet the condition and process the window</li>
<li>Shrink the window</li>
</ol>
<p>通常會由 <code>right</code> 指針去往外擴展，一旦滿足條件時，則可透過增加 <code>left</code> 來收斂 window，其解題邏輯如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// Iterate through the input</span></span><br><span class="line">    <span class="comment">// Expand out window</span></span><br><span class="line">    <span class="comment">// If meet the condition to stop expansion</span></span><br><span class="line">        <span class="comment">// process the window</span></span><br><span class="line">        <span class="comment">// contract the window</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 sliding window 題目中一定會出現三種變數:</p>
<ol>
<li>Window 邊界: <code>left</code>, <code>right</code></li>
<li>紀錄條件的變數，看是否到達expansion 停止條件</li>
<li>紀錄回傳值的變數</li>
</ol>
<h2 id="解題流程"><a href="#解題流程" class="headerlink" title="解題流程"></a>解題流程</h2><ol>
<li><strong>定義停止擴展window的條件</strong>：先明確在什麼情況下需要停止擴展窗口</li>
<li><strong>擴展window直到滿足條件</strong>：在擴展window之前，先處理當前 <code>right</code> 指標所指向的元素</li>
<li><strong>當滿足停止擴展的條件時，處理當前window</strong>：在滿足條件時，針對當前window進行需要的處理</li>
<li><strong>收縮當前window</strong>：在收縮window之前，先處理當前 <code>left</code> 指標所指向的元素</li>
<li><strong>處理邊界情況</strong>：確保對特殊情況（例如空輸入、極端值等）進行適當處理</li>
</ol>
<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><ul>
<li><a href="">leetcode#487. Max Consecutive Ones II</a> </li>
<li><a href="https://leozzmc.github.io/posts/1717ddff.html">LeetCode#424. Longest Repeating Character Replacement</a> 這題在窗口擴展的時候同時透過雜湊表記錄字母出現頻率，接著收窄窗口直到窗口等於最高字母頻率次數 +  K(題目給的替換操作次數)，窗口收窄後再去紀錄最大子字串長度(窗口長度)</li>
</ul>
<blockquote>
<p>參考：<br><a target="_blank" rel="noopener" href="https://shannonhung.github.io/posts/lecture-two-pointer-and-sliding-window">https://shannonhung.github.io/posts/lecture-two-pointer-and-sliding-window</a><br><a target="_blank" rel="noopener" href="https://medium.com/@timpark0807/leetcode-is-easy-sliding-window-c44c11cc33e1">https://medium.com/@timpark0807/leetcode-is-easy-sliding-window-c44c11cc33e1</a></p>
</blockquote>
<h1 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;stin, <span class="type">int</span>&gt; dp =&#123;&#123;<span class="string">&quot;Kevin&quot;</span>, <span class="number">1</span>&#125;,&#123;<span class="string">&quot;Shannon&quot;</span>, <span class="number">2</span>&#125;,&#123;<span class="string">&quot;Roger&quot;</span>, <span class="number">3</span>&#125;&#125;; <span class="comment">// Initialization</span></span><br><span class="line">dp[<span class="string">&quot;Alan&quot;</span>] = <span class="number">4</span>; <span class="comment">// Insertion, overwriting existing value</span></span><br><span class="line">dp.<span class="built_in">insert</span>(<span class="built_in">pair</span>(<span class="string">&quot;Alan&quot;</span>, <span class="number">4</span>)); <span class="comment">// If key exists, return failure</span></span><br><span class="line">dp.<span class="built_in">erase</span>(dp.<span class="built_in">begin</span>()); <span class="comment">// Erase element</span></span><br><span class="line">dp.<span class="built_in">erase</span>(<span class="string">&quot;Alan&quot;</span>); <span class="comment">//Erase element</span></span><br><span class="line">dp.<span class="built_in">erase</span>(dp.<span class="built_in">find</span>(<span class="string">&quot;Shannon&quot;</span>),dp.<span class="built_in">end</span>()); <span class="comment">// Erase a range of elements</span></span><br></pre></td></tr></table></figure>

<p>迭代存取 <code>unordered_map</code> 元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;n : dp)&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; n.first &lt;&lt; <span class="string">&quot;, id:&quot;</span> &lt;&lt; n.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=dp.<span class="built_in">begin</span>(); it!=dp.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; (*it).first &lt;&lt; <span class="string">&quot;,id:&quot;</span> &lt;&lt; (*it).second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找特定值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dp.<span class="built_in">find</span>(<span class="string">&quot;KEY&quot;</span>)!=dp.<span class="built_in">end</span>())&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清空 <code>unordered_map</code> 容器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>


<blockquote>
<p>參考：<a target="_blank" rel="noopener" href="https://shengyu7697.github.io/std-unordered_map/">https://shengyu7697.github.io/std-unordered_map/</a></p>
</blockquote>
<h2 id="使用時機1-用於快速存取元素"><a href="#使用時機1-用於快速存取元素" class="headerlink" title="使用時機1: 用於快速存取元素"></a>使用時機1: 用於快速存取元素</h2><p>一旦建立好 Hash Table 就可以用 $O(1)$ 的時間複雜度來存取元素</p>
<ul>
<li><a href="https://leozzmc.github.io/posts/cb46ac9d.html">leetcode#1 two sum</a></li>
</ul>
<h2 id="使用時機2-比對無序資料"><a href="#使用時機2-比對無序資料" class="headerlink" title="使用時機2: 比對無序資料"></a>使用時機2: 比對無序資料</h2><p>在 Python 中實踐 Hash Table的方式就是 Dictionary，而在C++中則是透過 <code>unordered_map</code>，他們的特點就是都是 Key-Value Pair，這代表他們就是一個無序元素映射的集合。因此在比較無序資料時也會用到 Hash Table，像是可以用來記錄特定單字在某個文章出現的頻率那也可以使用 Hash Table</p>
<ul>
<li><a href="https://leozzmc.github.io/posts/e106a70e.html">leetCode#49 Group Anagrams</a></li>
</ul>
<h2 id="使用時機3-Deep-Copy"><a href="#使用時機3-Deep-Copy" class="headerlink" title="使用時機3: Deep Copy"></a>使用時機3: Deep Copy</h2><p>如果今天對於 Linked List 的結構有Deep Copy 的需求 (Ex. 錄製出一個一模一樣的Linked List結構)，則會需要儲存舊節點的鏈結關係以及新節點的鏈結關係。這時就可以用 Hash Table 來去做映射。</p>
<ul>
<li><a href="https://leozzmc.github.io/posts/28674f4b.html">leetCode#138. Copy List with Random Pointer</a>: 這裡宣告一個 Hash Table 來分別儲存舊的list跟複製後的list。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map &lt;Node*, Node*&gt; randomMap;</span><br></pre></td></tr></table></figure>

<h2 id="unordered-map-vs-unordered-set"><a href="#unordered-map-vs-unordered-set" class="headerlink" title="unordered_map vs unordered_set"></a>unordered_map vs unordered_set</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">unordered_set &lt;<span class="type">int</span>&gt; uset;</span><br></pre></td></tr></table></figure>

<p>從宣告上就可以看出差異， <code>unordered_map</code> 會是 Key-Value Pair 然而 <code>unordered_set</code> 會只有 Key 或 value，總之他並不是 pair，也並不能儲存映射關係。 <strong>兩者的共同點就是都是無序的 ，並且實踐都是基於 Hash Table，因此 <code>unordered_set</code>中的元素都會是唯一的</strong></p>
<p>以下是 <code>unordered_map</code> 和 <code>unordered_set</code> 在解 LeetCode 題目時的使用時機整理：</p>
<table>
<thead>
<tr>
<th>功能&#x2F;特性</th>
<th><strong><code>unordered_map</code></strong></th>
<th><strong><code>unordered_set</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>結構定義</strong></td>
<td>雜湊表存儲鍵值對（Key-Value Pair）</td>
<td>雜湊表存儲唯一的鍵（Key）</td>
</tr>
<tr>
<td><strong>典型使用情境</strong></td>
<td>當需要同時儲存一個值（Value）與其對應的鍵（Key）時，例如計數、鍵值對查詢</td>
<td>當只需要快速查詢某元素是否存在，或需要儲存唯一元素集合時，例如去重、檢查存在性</td>
</tr>
<tr>
<td><strong>插入&#x2F;刪除&#x2F;查詢操作時間複雜度</strong></td>
<td>平均 $ O(1) $，最差 $ O(n) $</td>
<td>平均 $O(1)$，最差 $O(n)$</td>
</tr>
<tr>
<td><strong>重點功能</strong></td>
<td>- 可用於統計出現次數（如頻率計數）。<br>- 快速通過鍵查詢值</td>
<td>- 快速判斷元素是否存在。<br>- 快速存儲唯一元素（無需額外邏輯進行去重）</td>
</tr>
<tr>
<td><strong>典型應用場景</strong></td>
<td>1. <strong>頻率計數</strong>：統計字元、數字或其他資料的出現次數，例如異位詞檢查、子陣列和問題 <br>2. <strong>映射查詢</strong>：需要通過鍵快速找到值<br>3. <strong>分組</strong>：按某些條件將資料分組並存儲對應的值</td>
<td>1. <strong>集合操作</strong>：判斷某元素是否存在，例如兩數和問題<br>2. <strong>去除重複</strong>：快速生成唯一元素集合，例如找出數組中的唯一值</td>
</tr>
<tr>
<td><strong>常見 LeetCode 題目範例</strong></td>
<td>- <strong>Two Sum</strong> (#1)：用於記錄目標數字的補數和其索引 <br>- <strong>Group Anagrams</strong> (#49)：統計異位詞分組</td>
<td>- <strong>Contains Duplicate</strong> (#217)：檢查數組中是否存在重複值<br>- <strong>Intersection of Two Arrays</strong> (#349)：找出兩數組交集</td>
</tr>
<tr>
<td><strong>注意事項</strong></td>
<td>- 若只需要檢查元素存在性，使用 <code>unordered_set</code> 更高效，避免存儲多餘的值</td>
<td>- 若需要儲存並操作鍵對應的值，應使用 <code>unordered_map</code>，<code>unordered_set</code> 無法完成此需求</td>
</tr>
</tbody></table>
<p>Example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">find</span>(num) != st.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">insert</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><blockquote>
<p><a href="https://leozzmc.github.io/posts/a27c9492.html">Stack 筆記整理</a>： 介紹如何實作Stack，以及一些Stack STL 的基本操作</p>
</blockquote>
<h2 id="使用時機1-LIFO-問題"><a href="#使用時機1-LIFO-問題" class="headerlink" title="使用時機1: LIFO 問題"></a>使用時機1: LIFO 問題</h2><p>像是 <strong>括號匹配問題(Parentheses)</strong> <code>&#123;()&#125;</code> 這種檢查括號是否閉合的問題就是後進先出(LIFO)的問題，可以由左至右將左括號依序 Push 進入 Stack，碰到右括號就 Pop 出來看是否匹配。或是像用相對路徑存取檔案的這種題目，像是 <code>/var/www/html</code> 這種 <strong>檔案路徑的情境題</strong> 也很適合用 Stack 去做，先 push 進先前的目錄，而如果要從子目錄移動到上一層，則也需要先將子目錄 Pop 出來，這也會是 LIFO 的情境。 </p>
<ul>
<li><a href="https://leozzmc.github.io/posts/92b56b8e.html">leetcode#20 Valid Parentheses</a></li>
<li><a href="https://leozzmc.github.io/posts/59f3a7b5.html">leetcode#71 Simplify Path</a></li>
</ul>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><blockquote>
<p><a href="https://leozzmc.github.io/posts/22a8b30b.html">Queue 筆記整理</a>: 介紹怎麼實作Queue，並且介紹Queue STL 的基本操作</p>
</blockquote>
<h2 id="使用時機1-FIFO-問題"><a href="#使用時機1-FIFO-問題" class="headerlink" title="使用時機1: FIFO 問題"></a>使用時機1: FIFO 問題</h2><p>如果題目情境很講求順序，例如系統接收請求的順序這種 FIFO的問題，就很適合用到Queue，但我目前並未做到這類的 Queue題目，只有類似資料結構實作題目</p>
<ul>
<li><a href="https://leozzmc.github.io/posts/6dfa2271.html">LeetCode#225. Implement Stack using Queues</a></li>
</ul>
<h1 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h1><blockquote>
<p><a href="https://leozzmc.github.io/posts/c1fe4928.html">Linked List 筆記整理</a> 當時主要是用C來進行實作，但是C與C++在Linked List實踐邏輯中其實一樣，語法稍有差異而已，但不太影響解題</p>
</blockquote>
<h2 id="建立節點"><a href="#建立節點" class="headerlink" title="建立節點"></a>建立節點</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(): <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> a): <span class="built_in">val</span>(a), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> a, ListNode *node): <span class="built_in">val</span>(a), <span class="built_in">next</span>(node) &#123;&#125;;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function">Node <span class="title">node1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">   <span class="function">Node <span class="title">node2</span><span class="params">(<span class="number">3</span>, &amp;node1)</span></span>;</span><br><span class="line">   <span class="function">Node <span class="title">node3</span><span class="params">(<span class="number">2</span>, &amp;node2)</span></span>;</span><br><span class="line">   <span class="function">Node <span class="title">node4</span><span class="params">(<span class="number">1</span>, &amp;node3)</span></span>;</span><br><span class="line">  <span class="comment">// Print the list:  1-&gt;2-&gt;3-&gt;4-&gt;NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="使用時機1-Two-Pointer"><a href="#使用時機1-Two-Pointer" class="headerlink" title="使用時機1. Two Pointer"></a>使用時機1. Two Pointer</h2><p><strong>當需要遍歷Linked List，並且需要快速找到特定節點或結構時</strong>，快慢指針可以在一次遍歷中完成查找，適合處理效率要求較高的問題，例如尋找中間節點或判斷是否有循環。<strong>或者今天需要比較或操作多個指針時</strong>，雙指針可以用來實現倒數第 N 個節點的定位，或在兩條list間進行同步操作</p>
<ul>
<li><a href="https://leozzmc.github.io/posts/the_middle_of_the_list.html"><strong>LeetCode#876 Middle of the Linked List</strong></a><br>快慢指針找中點</li>
<li><a href="https://leozzmc.github.io/posts/992d29db.html"><strong>LeetCode#141 Linked List Cycle</strong></a><br>快慢指針檢測循環</li>
<li><a href="https://leozzmc.github.io/posts/a0e0ab51.html"><strong>LeetCode#19 Remove Nth Node From End of List</strong></a><br>雙指針刪除倒數第 N 個節點</li>
<li><a href="https://leozzmc.github.io/posts/94b01956.html"><strong>LeetCode#143 Reorder List</strong></a><br>快慢指針找中點 + 鏈表翻轉 + 交替合併</li>
</ul>
<h2 id="使用時機2-Dummy-Head"><a href="#使用時機2-Dummy-Head" class="headerlink" title="使用時機2. Dummy Head"></a>使用時機2. Dummy Head</h2><p><strong>通常如果要新增或刪除節點，抑或是頻繁的操作頭節點</strong>，dummy head 就會試一種簡化操作的基礎技巧，<strong>也可以用來避免特殊判斷</strong></p>
<ul>
<li><a href="https://leozzmc.github.io/posts/2db2c541.html"><strong>LeetCode#203 Remove Linked List Elements</strong></a><br>使用 dummy head 刪除指定值的節點</li>
<li><a href="https://leozzmc.github.io/posts/8b576379.html"><strong>LeetCode#21 Merge Two Sorted Lists</strong></a><br>使用 dummy head 合併Linked List</li>
<li><a href="https://leozzmc.github.io/posts/3864fd1b.html"><strong>LeetCode#2 Add Two Numbers</strong></a><br>使用 dummy head 構建新Linked List處理多位數相加</li>
</ul>
<h2 id="使用時機3-反轉與結構轉換"><a href="#使用時機3-反轉與結構轉換" class="headerlink" title="使用時機3. 反轉與結構轉換"></a>使用時機3. 反轉與結構轉換</h2><p>處理single Linked List反轉、旋轉等結構轉換相關的問題，或是將其他資料結構轉換成linked list</p>
<ul>
<li><a href="https://leozzmc.github.io/posts/a6b83df3.html"><strong>LeetCode#206 Reverse Linked List</strong></a><br>經典Linked List反轉</li>
<li><a href="https://leozzmc.github.io/posts/ea1b4e6c.html"><strong>LeetCode#61 Rotate List</strong></a><br>利用反轉實現旋轉操作</li>
<li><a href="https://leozzmc.github.io/posts/f15c47a9.html"><strong>LeetCode#114 Flatten Binary Tree to Linked List</strong></a><br>將二叉樹轉換為單向Linked List</li>
</ul>
<h2 id="使用時機4-排序與合併"><a href="#使用時機4-排序與合併" class="headerlink" title="使用時機4. 排序與合併"></a>使用時機4. 排序與合併</h2><p>處理Linked List的合併、重排和排序問題</p>
<ul>
<li><a href="https://leozzmc.github.io/posts/8b576379.html"><strong>LeetCode#21 Merge Two Sorted Lists</strong></a><br>合併兩個排序Linked List</li>
<li><a href="https://leozzmc.github.io/posts/Odd_Even_Linked_List.html"><strong>LeetCode#328 Odd Even Linked List</strong></a><br>根據奇偶節點位置重排</li>
<li><a href="https://leozzmc.github.io/posts/94b01956.html"><strong>LeetCode#143 Reorder List</strong></a><br>合併已翻轉和未翻轉的Linked List</li>
</ul>
<h2 id="使用時機5-特殊指標處理"><a href="#使用時機5-特殊指標處理" class="headerlink" title="使用時機5. 特殊指標處理"></a>使用時機5. 特殊指標處理</h2><p>處理Linked List中帶有隨機指針或其他特殊結構的問題</p>
<ul>
<li><a href="https://leozzmc.github.io/posts/28674f4b.html"><strong>LeetCode#138 Copy List with Random Pointer</strong></a><br>深拷貝帶隨機指針的Linked List</li>
<li><a href="https://leozzmc.github.io/posts/3864fd1b.html"><strong>LeetCode#2 Add Two Numbers</strong></a><br>處理帶進位的Linked List</li>
</ul>
<h2 id="使用時機6-刪除重複節點"><a href="#使用時機6-刪除重複節點" class="headerlink" title="使用時機6. 刪除重複節點"></a>使用時機6. 刪除重複節點</h2><p>刪除Linked List中多餘或重複的節點</p>
<ul>
<li><a href="https://leozzmc.github.io/posts/c8064a2b.html"><strong>LeetCode#83 Remove Duplicates from Sorted List</strong></a><br>刪除排序Linked List中的重複節點</li>
</ul>
<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><blockquote>
<p><a href="https://leozzmc.github.io/posts/tree_for_leetcode.html">Tree 筆記整理-基本</a><br><a href="https://leozzmc.github.io/posts/tree_for_leetcode_2.html">Tree 筆記整理-進階</a></p>
</blockquote>
<h2 id="Tree-的建構"><a href="#Tree-的建構" class="headerlink" title="Tree 的建構"></a>Tree 的建構</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TreeNode *left, *right;</span><br><span class="line">        <span class="built_in">TreeNode</span>(): <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *lnode, TreeNode *rnode): <span class="built_in">val</span>(x), <span class="built_in">left</span>(lnode), <span class="built_in">right</span>(rnode)&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BT</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BT</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TreeNode *root;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">BT</span>():<span class="built_in">root</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">        <span class="built_in">BT</span>(TreeNode* node): <span class="built_in">root</span>(node)&#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//member functions;</span></span><br><span class="line">        <span class="comment">// void dfs(TreeNode *root);</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    TreeNode *nodeA = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    TreeNode *nodeB = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    TreeNode *nodeC = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    TreeNode *nodeD = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    TreeNode *nodeE = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">    TreeNode *nodeF = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    nodeA -&gt; left = nodeB;</span><br><span class="line">    nodeA -&gt; right = nodeC;</span><br><span class="line">    nodeB -&gt; left = nodeD;</span><br><span class="line">    nodeC -&gt; left = nodeE;</span><br><span class="line">    nodeC -&gt; right = nodeF;</span><br><span class="line">    </span><br><span class="line">    <span class="function">BT <span class="title">T</span><span class="params">(nodeA)</span></span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>又稱 Level-Order Traversal</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BT::bfs</span><span class="params">(TreeNode *head)</span></span>&#123;</span><br><span class="line">  queue&lt;TreeNode*&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(head);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    TreeNode *current = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; current-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;left!=<span class="literal">nullptr</span>) q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;right!=<span class="literal">nullptr</span>) q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>前序(Preorder)</p>
<p>中序(Inorder)</p>
<p>後序(Postorder)</p>
<h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><blockquote>
<p><a href="https://leozzmc.github.io/posts/2009beb7.html">Graph 筆記整理-1</a><br><a href="https://leozzmc.github.io/posts/2e799f6d.html">Graph 筆記整理-2</a></p>
</blockquote>
<p>Graph 主要由節點(vertex, node)跟邊(edge)構成，基本上有分成有向跟無向圖，還有一些特性像是是否是連接(connected) 以及是否有環(circle) 存在。 圖的題目類型通常會是給定一個2D陣列要你去求數量或是面積還有路徑，或者有些會給 Adjacency Matrix (List) 來告訴你節點的連接關係。目前學到的走訪方式有: <strong>DFS</strong>,  <strong>BFS</strong> (後續好像還有 Topological Sort)</p>
<table>
<thead>
<tr>
<th></th>
<th>DFS</th>
<th>BFS</th>
</tr>
</thead>
<tbody><tr>
<td>適用範圍</td>
<td>有向圖、無向圖</td>
<td>有向圖、無向圖</td>
</tr>
<tr>
<td>用途</td>
<td>找路徑(不一定最短)</td>
<td>找最短路徑</td>
</tr>
</tbody></table>
<h2 id="無向圖"><a href="#無向圖" class="headerlink" title="無向圖"></a>無向圖</h2><p>(1) <strong>找出陣列中的 Connected Components</strong><br>可使用 <code>DFS</code>, <code>BFS</code> 在走訪過程中透過 counter 來記錄數量，這種題目也會有其他變形題目</p>
<ul>
<li><a href="https://leozzmc.github.io/posts/b7e69c9.html">LeetCode#200. Number of Islands</a> 這題就是單純紀錄　connected components 數量</li>
<li><a href="https://leozzmc.github.io/posts/6c6d3ce.html">LeetCode#695. Max Area of Island</a>  這題就是單純紀錄　connected components 數量，還需要累加大小並做比較</li>
<li><a href="https://leozzmc.github.io/posts/8d1c6ed0.html">LeetCode#133. Clone Graph</a> 這題為了deep copy 一個 graph，會需要先走訪tree並記錄到 hash table</li>
<li><a href="https://leozzmc.github.io/posts/51295e83.html">LeetCode#130. Surrounded Regions</a> 這題比較特別，他會是從矩陣邊緣開始先找搜尋起點，再去走訪，並且搜尋起點只會在邊緣。</li>
<li><a href="https://leozzmc.github.io/posts/7fd7eb24.html">417. Pacific Atlantic Water Flow</a> 這題的策略也是需要先從矩陣邊緣作為起點開始走訪，並且會進行兩次 BFS 來去取交集找出座標位置。</li>
</ul>
<p>(2) <strong>找出最短路徑</strong></p>
<ul>
<li><a href="https://leozzmc.github.io/posts/79e94c86.html">LeetCode#286. Walls and Gates</a> 這題需要透過 BFS 走訪網格，並且直接將距離更新到網格中，這題的bfs 會優先將搜尋起點(閘門)推入Queue中去解</li>
</ul>
<h1 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h1><blockquote>
<p><a href="https://leozzmc.github.io/posts/48f553b3.html">Recursion 和 Backtracking 筆記整理</a></p>
</blockquote>
<h2 id="使用情境1-排列組合"><a href="#使用情境1-排列組合" class="headerlink" title="使用情境1: 排列組合"></a>使用情境1: 排列組合</h2><h2 id="使用情境2-子集"><a href="#使用情境2-子集" class="headerlink" title="使用情境2: 子集"></a>使用情境2: 子集</h2><h2 id="使用情境3-迴文"><a href="#使用情境3-迴文" class="headerlink" title="使用情境3: 迴文"></a>使用情境3: 迴文</h2><h1 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h1><p>題目可能會給陣列或字串，然後要做的事就是要先定義出左右兩側邊界以及中間值，</p>
<p>框架會像是下面這樣</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = &lt;MIN_VALUE&gt;;</span><br><span class="line"><span class="type">int</span> right = &lt;MAX_VALUE&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// left ~ mid ~ right</span></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">  <span class="type">int</span> mid = left + (right-left) /<span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(&lt;VALID&gt;)&#123;</span><br><span class="line">    <span class="comment">// 將範圍收窄成陣列左半邊</span></span><br><span class="line">    <span class="comment">// left ~ mid-1</span></span><br><span class="line">    right = mid <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//將範圍收窄成陣列右半邊</span></span><br><span class="line">    <span class="comment">// mid +1 ~ right</span></span><br><span class="line">    left = mid +<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="常見題目"><a href="#常見題目" class="headerlink" title="常見題目"></a>常見題目</h2><ul>
<li><a href="https://leozzmc.github.io/posts/7a271795.html"> LeetCode#875. Koko Eating Bananas</a>: 這題主要是透過先定義出最大跟最小吃香蕉的速度，然後透過 Binary Search 來去挑選吃相較的速度值，再去透過其他函數驗證這個值是否能夠在時間內吃完香蕉。接著會去收窄範圍，最終得出的吃香蕉速度就會是最小的。</li>
</ul>
<h1 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h1><h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><blockquote>
<p><a href="https://leozzmc.github.io/posts/dynamic_programming.html">DP 筆記整理</a> 整理了Dynamic Programming 的解題邏輯，跟問題背景會是怎樣的， <strong>DP會是最佳化解答的好工具!</strong></p>
</blockquote>
<p>判斷：<strong>1. 大量重複子問題</strong>, <strong>2. 解決所有子問題，可以得到整體問題的最最佳化答案</strong> 這時候就可以先找出題目的遞迴關係式(暴力解)，接著再透過 Memoization進行最佳化，或者如果透過Iteration 的方式直接提出最佳解。</p>
<h2 id="使用情境1-選與不選的問題"><a href="#使用情境1-選與不選的問題" class="headerlink" title="使用情境1: 選與不選的問題"></a>使用情境1: 選與不選的問題</h2><p><strong>對於每個元素，都可以選或不選，藉由多種選或不選的組合，可以找出正確結果，但包含了大量的重複計算</strong></p>
<ul>
<li><a href="https://leozzmc.github.io/posts/355cc876.html">LeetCode#70. Climbing Stairs</a></li>
<li><a href="https://leozzmc.github.io/posts/35e03d8a.html">LeetCode#322. Coin Change</a></li>
<li><a href="https://leozzmc.github.io/posts/9081d01d.html">LeetCode#139. Word Break</a></li>
<li><a href="https://leozzmc.github.io/posts/cd4d1860.html">LeetCode#120. Triangle</a></li>
</ul>
<p>其中還包括許多變形，像是股票交易的題目</p>
<ul>
<li><a href="https://leozzmc.github.io/posts/c95a58c1.html">LeetCode#309. Best Time to Buy and Sell Stock with Cooldown</a></li>
</ul>
<h2 id="使用情境2-迴文系列問題"><a href="#使用情境2-迴文系列問題" class="headerlink" title="使用情境2: 迴文系列問題"></a>使用情境2: 迴文系列問題</h2><p>這類題目通常在遞迴函數之外還需要額外定義的 **用於檢查回文的函數 <code>checkPalindrome</code>**，通常會將最佳化的 <code>dp</code> 陣列用於這個函數，來避免大量重複計算，如果直接用 <code>reverse()</code> 會是較高的複雜度，通常會透過 Two Pointer 的方式來去實踐回文檢查</p>
<p>Example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[left] != s[right])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    left++;</span><br><span class="line">    right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leozzmc.github.io/posts/141899d4.html">LeetCode#647. Palindromic Substrings</a></li>
<li><a href="https://leozzmc.github.io/posts/bf0dee7b.html">LeetCode#5. Longest Palindromic Substring</a></li>
</ul>
<h1 id="常見演算法"><a href="#常見演算法" class="headerlink" title="常見演算法"></a>常見演算法</h1><hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://leozzmc.github.io">Kevin Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章連結: </span><span class="post-copyright-info"><a href="https://leozzmc.github.io/posts/d0fc136d.html">https://leozzmc.github.io/posts/d0fc136d.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 許可協議。轉載請註明來自 <a href="https://leozzmc.github.io" target="_blank">Kevin Liu's 部落格 || Technical || Travel</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a></div><div class="post_share"><div class="social-share" data-image="/img/me.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/dce71546.html" title="DevOps技能樹知識整理 |【筆記目錄】"><img class="cover" src="/img/devops/cover3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">DevOps技能樹知識整理 |【筆記目錄】</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><div><a href="/posts/cf1b9e8c.html" title="Q1. Make Array Elements Equal to Zero | Easy | LeetCode Weekly Contest"><img class="cover" src="/img/LeetCode/1117_q1/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-17</div><div class="title">Q1. Make Array Elements Equal to Zero | Easy | LeetCode Weekly Contest</div></div></a></div><div><a href="/posts/22bf447e.html" title="二元搜尋法 | Easy | LeetCode#704 Binary Search"><img class="cover" src="/img/LeetCode/BS_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-28</div><div class="title">二元搜尋法 | Easy | LeetCode#704 Binary Search</div></div></a></div><div><a href="/posts/efa232a7.html" title="C++ 刷題利器 - STL (Standard Template Library) | LeetCode"><img class="cover" src="/img/LeetCode/C++_STL/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-18</div><div class="title">C++ 刷題利器 - STL (Standard Template Library) | LeetCode</div></div></a></div><div><a href="/posts/db053989.html" title="二元樹 Level Order Traversal | Medium | LeetCode#102. Binary Tree Level Order Traversal"><img class="cover" src="/img/LeetCode/102/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-04</div><div class="title">二元樹 Level Order Traversal | Medium | LeetCode#102. Binary Tree Level Order Traversal</div></div></a></div><div><a href="/posts/60d71d58.html" title="二元樹Z字形走訪 | Medium | LeetCode#103. Binary Tree Zigzag Level Order Traversal"><img class="cover" src="/img/LeetCode/103/cover.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-03</div><div class="title">二元樹Z字形走訪 | Medium | LeetCode#103. Binary Tree Zigzag Level Order Traversal</div></div></a></div><div><a href="/posts/3dab679e.html" title="相同的二元樹 | Easy | LeetCode#100. Same Tree"><img class="cover" src="/img/LeetCode/100/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-03</div><div class="title">相同的二元樹 | Easy | LeetCode#100. Same Tree</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 評論</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Kevin Liu</div><div class="author-info__description">👍👍👍👍👍</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">119</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/leozzmc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/leozzmc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zzmczzmczzmc870125@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #e0ad5a;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/kevin-liu087" target="_blank" title="LinkedIn"><i class="fa-brands fa-linkedin" style="color: #0373fc;"></i></a><a class="social-icon" href="https://www.youtube.com/channel/UC2AU_vpxPu0oKcgZl3UJSNg" target="_blank" title="Youtube"><i class="fa-brands fa-youtube" style="color: #dc1e1e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">🛫🛬</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Roadmap"><span class="toc-number">1.0.1.</span> <span class="toc-text">Roadmap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Big-O"><span class="toc-number">2.</span> <span class="toc-text">Big-O</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Two-Pointers"><span class="toc-number">3.</span> <span class="toc-text">Two Pointers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Sliding-Window"><span class="toc-number">4.</span> <span class="toc-text">Sliding Window</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%80%8B%E9%97%9C%E9%8D%B5%E6%AD%A5%E9%A9%9F"><span class="toc-number">4.1.</span> <span class="toc-text">三個關鍵步驟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">解題流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%8C%E7%9B%AE"><span class="toc-number">4.3.</span> <span class="toc-text">題目</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hash-Table"><span class="toc-number">5.</span> <span class="toc-text">Hash Table</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F1-%E7%94%A8%E6%96%BC%E5%BF%AB%E9%80%9F%E5%AD%98%E5%8F%96%E5%85%83%E7%B4%A0"><span class="toc-number">5.2.</span> <span class="toc-text">使用時機1: 用於快速存取元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F2-%E6%AF%94%E5%B0%8D%E7%84%A1%E5%BA%8F%E8%B3%87%E6%96%99"><span class="toc-number">5.3.</span> <span class="toc-text">使用時機2: 比對無序資料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F3-Deep-Copy"><span class="toc-number">5.4.</span> <span class="toc-text">使用時機3: Deep Copy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-map-vs-unordered-set"><span class="toc-number">5.5.</span> <span class="toc-text">unordered_map vs unordered_set</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stack"><span class="toc-number">6.</span> <span class="toc-text">Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F1-LIFO-%E5%95%8F%E9%A1%8C"><span class="toc-number">6.1.</span> <span class="toc-text">使用時機1: LIFO 問題</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Queue"><span class="toc-number">7.</span> <span class="toc-text">Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F1-FIFO-%E5%95%8F%E9%A1%8C"><span class="toc-number">7.1.</span> <span class="toc-text">使用時機1: FIFO 問題</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linked-List"><span class="toc-number">8.</span> <span class="toc-text">Linked List</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E7%AF%80%E9%BB%9E"><span class="toc-number">8.1.</span> <span class="toc-text">建立節點</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F1-Two-Pointer"><span class="toc-number">8.2.</span> <span class="toc-text">使用時機1. Two Pointer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F2-Dummy-Head"><span class="toc-number">8.3.</span> <span class="toc-text">使用時機2. Dummy Head</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F3-%E5%8F%8D%E8%BD%89%E8%88%87%E7%B5%90%E6%A7%8B%E8%BD%89%E6%8F%9B"><span class="toc-number">8.4.</span> <span class="toc-text">使用時機3. 反轉與結構轉換</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F4-%E6%8E%92%E5%BA%8F%E8%88%87%E5%90%88%E4%BD%B5"><span class="toc-number">8.5.</span> <span class="toc-text">使用時機4. 排序與合併</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F5-%E7%89%B9%E6%AE%8A%E6%8C%87%E6%A8%99%E8%99%95%E7%90%86"><span class="toc-number">8.6.</span> <span class="toc-text">使用時機5. 特殊指標處理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F6-%E5%88%AA%E9%99%A4%E9%87%8D%E8%A4%87%E7%AF%80%E9%BB%9E"><span class="toc-number">8.7.</span> <span class="toc-text">使用時機6. 刪除重複節點</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tree"><span class="toc-number">9.</span> <span class="toc-text">Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Tree-%E7%9A%84%E5%BB%BA%E6%A7%8B"><span class="toc-number">9.1.</span> <span class="toc-text">Tree 的建構</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-number">9.2.</span> <span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-number">9.3.</span> <span class="toc-text">DFS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Graph"><span class="toc-number">10.</span> <span class="toc-text">Graph</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%84%A1%E5%90%91%E5%9C%96"><span class="toc-number">10.1.</span> <span class="toc-text">無向圖</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Recursion"><span class="toc-number">11.</span> <span class="toc-text">Recursion</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%83%85%E5%A2%831-%E6%8E%92%E5%88%97%E7%B5%84%E5%90%88"><span class="toc-number">11.1.</span> <span class="toc-text">使用情境1: 排列組合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%83%85%E5%A2%832-%E5%AD%90%E9%9B%86"><span class="toc-number">11.2.</span> <span class="toc-text">使用情境2: 子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%83%85%E5%A2%833-%E8%BF%B4%E6%96%87"><span class="toc-number">11.3.</span> <span class="toc-text">使用情境3: 迴文</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Binary-Search"><span class="toc-number">12.</span> <span class="toc-text">Binary Search</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A6%8B%E9%A1%8C%E7%9B%AE"><span class="toc-number">12.1.</span> <span class="toc-text">常見題目</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Heap"><span class="toc-number">13.</span> <span class="toc-text">Heap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dynamic-Programming"><span class="toc-number">14.</span> <span class="toc-text">Dynamic Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%83%85%E5%A2%831-%E9%81%B8%E8%88%87%E4%B8%8D%E9%81%B8%E7%9A%84%E5%95%8F%E9%A1%8C"><span class="toc-number">14.1.</span> <span class="toc-text">使用情境1: 選與不選的問題</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%83%85%E5%A2%832-%E8%BF%B4%E6%96%87%E7%B3%BB%E5%88%97%E5%95%8F%E9%A1%8C"><span class="toc-number">14.2.</span> <span class="toc-text">使用情境2: 迴文系列問題</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A6%8B%E6%BC%94%E7%AE%97%E6%B3%95"><span class="toc-number">15.</span> <span class="toc-text">常見演算法</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/d0fc136d.html" title="LeetCode 刷題知識總整理">LeetCode 刷題知識總整理</a><time datetime="2100-11-29T01:08:02.000Z" title="發表於 2100-11-29 09:08:02">2100-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dce71546.html" title="DevOps技能樹知識整理 |【筆記目錄】"><img src="/img/devops/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DevOps技能樹知識整理 |【筆記目錄】"/></a><div class="content"><a class="title" href="/posts/dce71546.html" title="DevOps技能樹知識整理 |【筆記目錄】">DevOps技能樹知識整理 |【筆記目錄】</a><time datetime="2060-11-05T13:45:50.000Z" title="發表於 2060-11-05 21:45:50">2060-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/22911275.html" title="Git for DevOps 筆記 |【DevOps技能樹】"><img src="/img/devops/git/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git for DevOps 筆記 |【DevOps技能樹】"/></a><div class="content"><a class="title" href="/posts/22911275.html" title="Git for DevOps 筆記 |【DevOps技能樹】">Git for DevOps 筆記 |【DevOps技能樹】</a><time datetime="2025-11-11T03:45:46.000Z" title="發表於 2025-11-11 11:45:46">2025-11-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/85addf17.html" title="合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String">合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String</a><time datetime="2025-10-26T07:05:24.000Z" title="發表於 2025-10-26 15:05:24">2025-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8a835d3b.html" title="Pow(x, n) | Medium | LeetCode#50. Pow(x, n)"><img src="/img/LeetCode/50/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Pow(x, n) | Medium | LeetCode#50. Pow(x, n)"/></a><div class="content"><a class="title" href="/posts/8a835d3b.html" title="Pow(x, n) | Medium | LeetCode#50. Pow(x, n)">Pow(x, n) | Medium | LeetCode#50. Pow(x, n)</a><time datetime="2025-10-23T06:03:36.000Z" title="發表於 2025-10-23 14:03:36">2025-10-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Kevin Liu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主題 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="簡繁轉換">EN</button><button id="darkmode" type="button" title="淺色和深色模式轉換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直達評論"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到頂部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'dark'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'leozzmc/Blog_Reply')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme (theme) {
  const iframe = document.querySelector('.utterances-frame')
  if (iframe) {
    const theme = theme === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

btf.addModeChange('utterances', utterancesTheme)

if ('Utterances' === 'Utterances' || !false) {
  if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script></div><script data-pjax src="/self/btf.js"></script><script data-pjax src="/self/tw_en.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script data-pjax src="/self/calendar.js"></script><script data-pjax src="/self/languages.js"></script><script id="canvas_nest" defer="defer" color="34,34,34" opacity="0.8" zIndex="-1" count="350" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="👍,👾,💊,🧪,👁️" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜尋</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  資料庫載入中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜尋文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>