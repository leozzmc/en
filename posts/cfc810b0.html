<!DOCTYPE html><html lang="zh-TW" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>買賣股票的最佳時機III | Hard | LeetCode#123. Best Time to Buy and Sell Stock III | Kevin Liu's 部落格 || Technical || Travel</title><meta name="author" content="Kevin Liu"><meta name="copyright" content="Kevin Liu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="前言這題是股票買賣系列的題目: 121. Best Time to Buy and Sell Stock122. Best Time to Buy and Sell Stock II188. Best Time to Buy and Sell Stock IV309. Best Time to Buy and Sell Stock with Cooldown 題目敘述  題目難度：Hard 題目描">
<meta property="og:type" content="article">
<meta property="og:title" content="買賣股票的最佳時機III | Hard | LeetCode#123. Best Time to Buy and Sell Stock III">
<meta property="og:url" content="https://leozzmc.github.io/posts/cfc810b0.html">
<meta property="og:site_name" content="Kevin Liu&#39;s 部落格 || Technical || Travel">
<meta property="og:description" content="前言這題是股票買賣系列的題目: 121. Best Time to Buy and Sell Stock122. Best Time to Buy and Sell Stock II188. Best Time to Buy and Sell Stock IV309. Best Time to Buy and Sell Stock with Cooldown 題目敘述  題目難度：Hard 題目描">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://leozzmc.github.io/img/LeetCode/123/cover.png">
<meta property="article:published_time" content="2024-12-12T03:29:11.000Z">
<meta property="article:modified_time" content="2025-10-26T12:28:30.501Z">
<meta property="article:author" content="Kevin Liu">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Dynamic Programming">
<meta property="article:tag" content="Hard">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leozzmc.github.io/img/LeetCode/123/cover.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "買賣股票的最佳時機III | Hard | LeetCode#123. Best Time to Buy and Sell Stock III",
  "url": "https://leozzmc.github.io/posts/cfc810b0.html",
  "image": "https://leozzmc.github.io/img/LeetCode/123/cover.png",
  "datePublished": "2024-12-12T03:29:11.000Z",
  "dateModified": "2025-10-26T12:28:30.501Z",
  "author": [
    {
      "@type": "Person",
      "name": "Kevin Liu",
      "url": "https://leozzmc.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/kevin3.png"><link rel="canonical" href="https://leozzmc.github.io/posts/cfc810b0.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-T4SFRRLLZ0"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-T4SFRRLLZ0')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-T4SFRRLLZ0', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"找不到符合您查詢的內容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '複製成功',
    error: '複製失敗',
    noSupport: '瀏覽器不支援'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '剛剛',
    min: '分鐘前',
    hour: '小時前',
    day: '天前',
    month: '個月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '載入更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '買賣股票的最佳時機III | Hard | LeetCode#123. Best Time to Buy and Sell Stock III',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg" style="background-color: #f5f1ed;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">119</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 找文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 歸檔</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 鏈結</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 語言:</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="https://leozzmc.github.io/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/LeetCode/123/cover.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://i.imgur.com/P19VCm0.png" alt="Logo"><span class="site-name">Kevin Liu's 部落格 || Technical || Travel</span></a><a class="nav-page-title" href="/"><span class="site-name">買賣股票的最佳時機III | Hard | LeetCode#123. Best Time to Buy and Sell Stock III</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首頁</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜尋</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 找文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 歸檔</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 鏈結</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 語言:</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="https://leozzmc.github.io/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">買賣股票的最佳時機III | Hard | LeetCode#123. Best Time to Buy and Sell Stock III</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2024-12-12T03:29:11.000Z" title="發表於 2024-12-12 11:29:11">2024-12-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2025-10-26T12:28:30.501Z" title="更新於 2025-10-26 20:28:30">2025-10-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode%E7%AD%86%E8%A8%98/">LeetCode筆記</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">總字數:</span><span class="word-count">1.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀時間:</span><span>6分鐘</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">瀏覽量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這題是股票買賣系列的題目:</p>
<p><a href="https://leozzmc.github.io/posts/a0e35335.html">121. Best Time to Buy and Sell Stock</a><br><a href="https://leozzmc.github.io/posts/fcfb0850.html">122. Best Time to Buy and Sell Stock II</a><br><a href="https://leozzmc.github.io/posts/96bf11ff.html">188. Best Time to Buy and Sell Stock IV</a><br><a href="https://leozzmc.github.io/posts/c95a58c1.html">309. Best Time to Buy and Sell Stock with Cooldown</a></p>
<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/123/question.jpeg"></p>
<ul>
<li>題目難度：<code>Hard</code></li>
<li>題目描述： 給定一個整數陣列 <code>prices</code>，<code>prices[i]</code> 代表第 <code>i</code> 天的股票價格，每一天可以選擇買或賣股票，最多只能交易兩次 (買賣兩次)，請找出最大收益。</li>
</ul>
<div class="note info flat"><p>與先前幾題的原則一樣，只能先買後賣，並且不允許同時有多筆交易，手上股票要賣出才能夠繼續買</p>
</div>

<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始的想法蠻簡單的，就是與前面幾題一樣，假設 <code>prices=[3,4,5,0,0,3,1,4]</code> 那漲跌幅值如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+1 +1 -5 +0 +3 -2 +3</span><br></pre></td></tr></table></figure>

<p>只要有連續漲幅，就加總起來，並加入到 <code>dp</code> 中，因此會是 <code>dp=&#123;2,3,3&#125;</code> 只要將 <code>dp</code> 排序後取最後兩個元素相加就會是兩次交易的最大收益。</p>
<blockquote>
<p>但這想法其實是有問題的</p>
</blockquote>
<h2 id="我的解法-錯誤"><a href="#我的解法-錯誤" class="headerlink" title="我的解法 - 錯誤"></a>我的解法 - 錯誤</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sumIncrease=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt;= prices[i<span class="number">-1</span>])&#123;</span><br><span class="line">                sumIncrease += prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(i==n<span class="number">-1</span>) dp.<span class="built_in">push_back</span>(sumIncrease);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp.<span class="built_in">push_back</span>(sumIncrease);</span><br><span class="line">                sumIncrease =<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=dp.<span class="built_in">begin</span>(); it!=dp.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp.<span class="built_in">size</span>() &gt;=<span class="number">2</span>) <span class="keyword">return</span> dp[dp.<span class="built_in">size</span>()<span class="number">-1</span>]+dp[dp.<span class="built_in">size</span>()<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這段程式碼使用 <code>sumIncrease</code> 來紀錄股價隨日期增加的金額， <strong>但這並沒有考慮到應該將所有可以分割成的交易加總，而不是單純只選兩段最大增益</strong>，以 <code>prices=[1,2,4,2,5,7,2,4,9,0]</code> 為例，上面程式最後會紀錄三段連續漲幅 <code>dp = &#123;3,5,7&#125;</code> 最後只會挑選出後兩個元素進行加總 <code>12</code>，但正確答案會是 <code>13</code>，會是在股價為 <code>1</code>時買入，股價為 <code>7</code> 時賣出 (此時收益為 <code>6</code>)，第二次交易為股價為 <code>2</code> 時買入，股價為 <code>9</code> 時賣出 (此時收益為 <code>6+7</code>)，因此最終最大收益會是 <code>13</code>，因此上面程式碼忽略了 <strong>非連續遞增子序列多次買賣的狀況</strong> </p>
<h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/123/error.jpeg"></p>
<h2 id="正確解法"><a href="#正確解法" class="headerlink" title="正確解法"></a>正確解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftProfit</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightProfit</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, prices[i]);</span><br><span class="line">            leftProfit[i] = <span class="built_in">max</span>(leftProfit[i<span class="number">-1</span>], prices[i] - minPrice);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxPrice = prices[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxPrice = <span class="built_in">max</span>(maxPrice, prices[i]);</span><br><span class="line">            rightProfit[i] = <span class="built_in">max</span>(rightProfit[i+<span class="number">1</span>], maxPrice - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            maxProfit = <span class="built_in">max</span>(maxProfit, leftProfit[i] + rightProfit[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這裡透過兩種陣列 <code>leftProfit</code> 以及 <code>rightProfit</code> 來個別紀錄一次交易中能獲得的最大利潤，並且之後合併結果。 以下是舉裡說明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prices = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>


<p>對於每一天 <code>i</code> 開始紀錄從第 <code>0</code>天到第 <code>i</code>天只進行一次交易的最大利潤。首先初始化 <code>minPrice = prices[0] = 3, leftProfit[0] = 0</code> 接著開始遍歷 <code>prices</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第 1 天 - minPrice = min(3,3) = 3, leftProfit[1] = max(0, 3-3) = 0</span><br><span class="line">第 2 天 - minPrice = min(3,5) = 3, leftProfit[2] = max(0, 5-3) = 2</span><br><span class="line">第 3 天 - minPrice = min(3,0) = 0, leftProfit[3] = max(2, 0-0) = 2</span><br><span class="line">第 4 天 - minPrice = min(0,0) = 0, leftProfit[4] = max(2, 0-0) = 2</span><br><span class="line">第 5 天 - minPrice = min(0,3) = 0, leftProfit[5] = max(2, 3-0) = 3</span><br><span class="line">第 6 天 - minPrice = min(0,1) = 0, leftProfit[6] = max(3, 1-0) = 3</span><br><span class="line">第 7 天 - minPrice = min(0,4) = 0, leftProfit[7] = max(3, 4-0) = 4</span><br><span class="line"></span><br><span class="line">最後 leftProfit = [0, 0, 2, 2, 2, 3, 3, 4]</span><br></pre></td></tr></table></figure>

<p>對於每一天 <code>i</code>，計算從第 <code>i</code> 天到最後一天只進行一次交易的最大利潤。初始化 <code>maxPrice = prices[n-1] = 4, rightProfit[n-1]=0</code>，接著由右至左迭代 <code>prices</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第 6 天 - maxPrice = max(4,1) = 4, rightProfit[6] = max(0, 4-1) = 3</span><br><span class="line">第 5 天 - maxPrice = max(4,3) = 4, rightProfit[5] = max(3, 4-3) = 3</span><br><span class="line">第 4 天 - maxPrice = max(4,0) = 4, rightProfit[4] = max(3, 4-0) = 4</span><br><span class="line">第 3 天 - maxPrice = max(4,0) = 4, rightProfit[3] = max(4, 4-0) = 4</span><br><span class="line">第 2 天 - maxPrice = max(4,5) = 5, rightProfit[2] = max(4, 5-5) = 4</span><br><span class="line">第 1 天 - maxPrice = max(5,3) = 5, rightProfit[1] = max(4, 5-3) = 4</span><br><span class="line">第 0 天 - maxPrice = max(5,3) = 5, rightProfit[0] = max(4, 5-3) = 4</span><br><span class="line"></span><br><span class="line">最後 rightProfit = [4, 4, 4, 4, 4, 3, 3, 0]</span><br></pre></td></tr></table></figure>

<p>最後需要合併結果，對於每一天 <code>i</code>，計算 <code>leftProfit[i] + rightProfit[i]</code>，並找出最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第 0 天：maxProfit = max(0 + 4) = 4</span><br><span class="line">第 1 天：maxProfit = max(0 + 4) = 4</span><br><span class="line">第 2 天：maxProfit = max(2 + 4) = 6</span><br><span class="line">第 3 天：maxProfit = max(2 + 4) = 6</span><br><span class="line">第 4 天：maxProfit = max(2 + 4) = 6</span><br><span class="line">第 5 天：maxProfit = max(3 + 3) = 6</span><br><span class="line">第 6 天：maxProfit = max(3 + 3) = 6</span><br><span class="line">第 7 天：maxProfit = max(4 + 0) = 6</span><br></pre></td></tr></table></figure>

<p>因此最大利潤為 <code>6</code></p>
<h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/123/result.jpeg"></p>
<h2 id="最佳化解法"><a href="#最佳化解法" class="headerlink" title="最佳化解法"></a>最佳化解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> firstBuy = INT_MIN;</span><br><span class="line">        <span class="type">int</span> firstSell = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> secondBuy = INT_MIN;</span><br><span class="line">        <span class="type">int</span> secondSell = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> price: prices)&#123;</span><br><span class="line">            firstBuy = <span class="built_in">max</span>(firstBuy, -price);</span><br><span class="line">            firstSell = <span class="built_in">max</span>(firstSell, firstBuy + price);</span><br><span class="line">            secondBuy = <span class="built_in">max</span>(secondBuy, firstSell - price);</span><br><span class="line">            secondSell = <span class="built_in">max</span>(secondSell, secondBuy + price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> secondSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這個解法最佳化了空間複雜度，從 $O(n)$ 降到 $O(1)$。這裡定義了四個變數</p>
<p><code>firstBuy</code>: 第一次買入的最大利潤 (為負值，因為要扣除買入成本，上位賣出都不會是賺的)<br><code>firstSell</code>:  第一次賣出的最大利潤<br><code>secondBuy</code>: 第二次買入的最大利潤 (基於第一次的利潤減去當前價格)<br><code>secondSell</code>: 第二次賣出的最大利潤</p>
<p>迭代完畢 <code>prices</code> 後得到的 <code>secondSell</code> 則會是兩次交易後的最大利潤。</p>
<h3 id="執行結果-2"><a href="#執行結果-2" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/123/result2.jpeg"></p>
<h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table>
<thead>
<tr>
<th>方法</th>
<th>時間複雜度</th>
<th>空間複雜度</th>
<th>分析說明</th>
</tr>
</thead>
<tbody><tr>
<td>左右分解法</td>
<td>$O(n)$</td>
<td>$O(n)$</td>
<td>透過兩次遍歷計算左、右兩部分的最大利潤，並存入兩個輔助陣列 <code>leftProfit</code> 和 <code>rightProfit</code>。最終合併結果，找出最大利潤。空間使用受限於輔助陣列大小</td>
</tr>
<tr>
<td>動態規劃解法</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
<td>優化空間後的動態規劃只使用常數空間記錄當前狀態，例如 <code>firstBuy</code>、<code>firstSell</code> 等四個變數，直接在遍歷中更新最大利潤。減少了輔助陣列的使用，空間效率更高</td>
</tr>
</tbody></table>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://leozzmc.github.io">Kevin Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章連結: </span><span class="post-copyright-info"><a href="https://leozzmc.github.io/posts/cfc810b0.html">https://leozzmc.github.io/posts/cfc810b0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 授權協議。轉載請註明來源 <a href="https://leozzmc.github.io" target="_blank">Kevin Liu's 部落格 || Technical || Travel</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/Dynamic-Programming/">Dynamic Programming</a><a class="post-meta__tags" href="/tags/Hard/">Hard</a></div><div class="post-share"><div class="social-share" data-image="/img/LeetCode/123/cover.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/fcfb0850.html" title="買賣股票的最佳時機II | Medium | LeetCode#122. Best Time to Buy and Sell Stock II"><img class="cover" src="/img/LeetCode/122/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">買賣股票的最佳時機II | Medium | LeetCode#122. Best Time to Buy and Sell Stock II</div></div><div class="info-2"><div class="info-item-1">前言這題是股票買賣系列的題目: 121. Best Time to Buy and Sell Stock123. Best Time to Buy and Sell Stock III309. Best Time to Buy and Sell Stock with Cooldown 題目敘述  題目難度: Medium 題目描述： 給定一個整數陣列 prices，prices[i] 代表第 i 天的股票價格，每一天可以選擇買或賣股票，允許當日買在當日立刻賣出，然而任意時間段最多僅能持有一份股票  解法一開始的想法這題跟 LeetCode-121 Best Time to Buy and Sell Stock 不太一樣的是，這題允許多次交易，所以要求的是， 多筆買賣的總收益要最大化。 假設今天 prices = &#123;7, 1, 5, 3, 6, 4&#125; 則在股價為 1 時買入，隔天為 5 時賣出，此時收益為 4 然後在隔天股價為 3 的時候再度買入，隔天股價為 6 的時候賣出，此時總收益為 4+3 =7 這題會有個特性，就是跨天數的收益，可以拆解！假設 price...</div></div></div></a><a class="pagination-related" href="/posts/96bf11ff.html" title="買賣股票的最佳時機IV | Hard | LeetCode#188. Best Time to Buy and Sell Stock IV"><img class="cover" src="/img/LeetCode/188/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">買賣股票的最佳時機IV | Hard | LeetCode#188. Best Time to Buy and Sell Stock IV</div></div><div class="info-2"><div class="info-item-1">前言這題是股票買賣系列的題目: 121. Best Time to Buy and Sell Stock122. Best Time to Buy and Sell Stock II123. Best Time to Buy and Sell Stock III309. Best Time to Buy and Sell Stock with Cooldown 題目敘述  題目難度：Hard 題目描述： 給定一個整數陣列 prices，prices[i] 代表第 i 天的股票價格，每一天可以選擇買或賣股票，給定整數 k 代表可以進行的交易次數上限，請找出最大收益。  解法一開始的想法 這題基本上是完全延續 LeetCode#123. Best Time to Buy and Sell Stock III 的題目描述，因此我直接按照這題的經驗來去實踐  我的解法12345678910111213141516171819class Solution &#123;public:    int maxProfit(int k, vector&lt;int&gt;&amp; prices)...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/bea79d96.html" title="二元樹最大路徑總和 | Hard | LeetCode#124. Binary Tree Maximum Path Sum"><img class="cover" src="/img/LeetCode/124/cover.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-07</div><div class="info-item-2">二元樹最大路徑總和 | Hard | LeetCode#124. Binary Tree Maximum Path Sum</div></div><div class="info-2"><div class="info-item-1">題目敘述   題目難度：Hard 題目敘述： 題目給定你一個 Binary Tree 的 root，求這棵二元樹中的所有路徑中，最大路徑和  這裡二元樹的路徑的代表的是 節點序列，序列由每個由邊連接的相鄰節點組成。一個節點最多只能在序列中出現一次。請注意，該路徑不需要經過Root節點   解法 這是第一次解 Hard，真的花比較久的時間，但也學習到很多  一開始的想法我一開始的想法是有問題的，但還是紀錄一下這個錯誤思路，我一開始想得太簡單了，以為就先把所有二元樹的節點DFS 走訪一遍，就能夠得到一個節點順序，接著就是 backtracking 中的子集問題，在序列中找子集元素和最大的組合就是答案。   但這有一個缺陷，那就是DFS(inorder)走訪過程的順序不滿足題目敘述的節點序列  像是下面這個例子，經過 inorder 走訪過後的順序會是 -8, 10, 20, -5, -10 那這樣後面就可能以為 10 跟 20 會是相鄰的，且最大的就輸出 30，但實際情況就是他們之間根本沒有邊相連。  因此這樣的做法會是錯的。  所以做法其實也算是 DFS 但不會是傳統意義上的 ba...</div></div></div></a><a class="pagination-related" href="/posts/96bf11ff.html" title="買賣股票的最佳時機IV | Hard | LeetCode#188. Best Time to Buy and Sell Stock IV"><img class="cover" src="/img/LeetCode/188/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-13</div><div class="info-item-2">買賣股票的最佳時機IV | Hard | LeetCode#188. Best Time to Buy and Sell Stock IV</div></div><div class="info-2"><div class="info-item-1">前言這題是股票買賣系列的題目: 121. Best Time to Buy and Sell Stock122. Best Time to Buy and Sell Stock II123. Best Time to Buy and Sell Stock III309. Best Time to Buy and Sell Stock with Cooldown 題目敘述  題目難度：Hard 題目描述： 給定一個整數陣列 prices，prices[i] 代表第 i 天的股票價格，每一天可以選擇買或賣股票，給定整數 k 代表可以進行的交易次數上限，請找出最大收益。  解法一開始的想法 這題基本上是完全延續 LeetCode#123. Best Time to Buy and Sell Stock III 的題目描述，因此我直接按照這題的經驗來去實踐  我的解法12345678910111213141516171819class Solution &#123;public:    int maxProfit(int k, vector&lt;int&gt;&amp; prices)...</div></div></div></a><a class="pagination-related" href="/posts/fcfb0850.html" title="買賣股票的最佳時機II | Medium | LeetCode#122. Best Time to Buy and Sell Stock II"><img class="cover" src="/img/LeetCode/122/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-11</div><div class="info-item-2">買賣股票的最佳時機II | Medium | LeetCode#122. Best Time to Buy and Sell Stock II</div></div><div class="info-2"><div class="info-item-1">前言這題是股票買賣系列的題目: 121. Best Time to Buy and Sell Stock123. Best Time to Buy and Sell Stock III309. Best Time to Buy and Sell Stock with Cooldown 題目敘述  題目難度: Medium 題目描述： 給定一個整數陣列 prices，prices[i] 代表第 i 天的股票價格，每一天可以選擇買或賣股票，允許當日買在當日立刻賣出，然而任意時間段最多僅能持有一份股票  解法一開始的想法這題跟 LeetCode-121 Best Time to Buy and Sell Stock 不太一樣的是，這題允許多次交易，所以要求的是， 多筆買賣的總收益要最大化。 假設今天 prices = &#123;7, 1, 5, 3, 6, 4&#125; 則在股價為 1 時買入，隔天為 5 時賣出，此時收益為 4 然後在隔天股價為 3 的時候再度買入，隔天股價為 6 的時候賣出，此時總收益為 4+3 =7 這題會有個特性，就是跨天數的收益，可以拆解！假設 price...</div></div></div></a><a class="pagination-related" href="/posts/cd4d1860.html" title="三角形 | Medium | LeetCode#120. Triangle"><img class="cover" src="/img/LeetCode/120/cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-19</div><div class="info-item-2">三角形 | Medium | LeetCode#120. Triangle</div></div><div class="info-2"><div class="info-item-1">題目敘述  題目難度: Medium 題目敘述: 題目給定一個2D陣列 triangle，求從最頂端走到最底端的最小路徑總和值  對於每個 row 只能往下一層走，並且每次都會有兩種走法，假設現在在當前row的位置是 i，則下一層能夠選擇繼續走到 i 或者是 i+1 的位置。   123456範例:   2  3 4 6 5 74 1 8 3最短路徑總和會是: 2 + 3 + 5 + 1 = 11  解法一開始的想法想法其實也還蠻單純的，就是每層都可以有選或不選特定路徑，由於要找最短的路徑和， 因此需要兩條路徑都選擇，比較回傳結果大小 ，然後選小的回傳，這樣整體遞迴呼叫完畢後就能夠求出最短路徑和。 我的解法Recursive1234567891011121314151617181920212223class Solution &#123;public:        int helper(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int row, int index ,int result )&#123;        if(r...</div></div></div></a><a class="pagination-related" href="/posts/a0e35335.html" title="買賣股票的最佳時機 | Easy | LeetCode#121. Best Time to Buy and Sell Stock"><img class="cover" src="/img/LeetCode/121/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-09</div><div class="info-item-2">買賣股票的最佳時機 | Easy | LeetCode#121. Best Time to Buy and Sell Stock</div></div><div class="info-2"><div class="info-item-1">前言這題是股票買賣系列的題目，與他類似的題目會是  122. Best Time to Buy and Sell Stock II123. Best Time to Buy and Sell Stock III188. Best Time to Buy and Sell Stock IV309. Best Time to Buy and Sell Stock with Cooldown 題目敘述  題目難度： Easy 題目描述： 給定一個陣列 prices，prices[i] 代表在第 i 天的股票價格。請選一天進買入股票，但在不同天賣出股票 (買賣股票不能在同一天，且須先買股票才能賣股票)，求股票的最大化收益。  解法一開始的想法一開始的想法複雜度其實比較高，就是透過一個迴圈來決定買入，透過另一個內部迴圈決定賣出，然後透過一個變數 maxValue 保存第 i 天買入然後第 j 天賣出的的最大股票收益值。但這樣的做法會導致 time limit excceded! 123456789101112131415class Solution &#123;public:    int...</div></div></div></a><a class="pagination-related" href="/posts/9081d01d.html" title="拆分字句 | Medium | LeetCode#139. Word Break"><img class="cover" src="/img/LeetCode/139/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-18</div><div class="info-item-2">拆分字句 | Medium | LeetCode#139. Word Break</div></div><div class="info-2"><div class="info-item-1">題目敘述  題目難度：Medium 題目描述：給定一個字串 s，以及一個字串形成的陣列 wordDict，若 s 可以被分割成一個或多個 wordDict 當中的單字序列，則回傳 True  Note that the same word in the dictionary may be reused multiple times in the segmentation.   解法一開始的想法s 中的每個字元可以 選或不選，每次形成一個子字串，就去跟 wordDict 進行比較看當前子字串是否存在於 wordDict 當中，一旦嘗試過每個子字串，則回傳結果。 我的解答1234567891011121314151617181920212223242526class Solution &#123;public:    vector&lt;int&gt; dp;     bool helper(string s, int start, vector&lt;string&gt;&amp; wordDict)&#123;        if(start == s.length())&#12...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 評論</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Kevin Liu</div><div class="author-info-description">👍👍👍👍👍</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">119</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/leozzmc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/leozzmc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zzmczzmczzmc870125@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #e0ad5a;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/kevin-liu087" target="_blank" title="LinkedIn"><i class="fa-brands fa-linkedin" style="color: #0373fc;"></i></a><a class="social-icon" href="https://www.youtube.com/channel/UC2AU_vpxPu0oKcgZl3UJSNg" target="_blank" title="Youtube"><i class="fa-brands fa-youtube" style="color: #dc1e1e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">不定期更新中</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%8C%E7%9B%AE%E6%95%98%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">題目敘述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">解法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E9%96%8B%E5%A7%8B%E7%9A%84%E6%83%B3%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">一開始的想法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E8%A7%A3%E6%B3%95-%E9%8C%AF%E8%AA%A4"><span class="toc-number">3.2.</span> <span class="toc-text">我的解法 - 錯誤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%B7%E8%A1%8C%E7%B5%90%E6%9E%9C"><span class="toc-number">3.2.1.</span> <span class="toc-text">執行結果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E7%A2%BA%E8%A7%A3%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">正確解法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%B7%E8%A1%8C%E7%B5%90%E6%9E%9C-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">執行結果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%8C%96%E8%A7%A3%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">最佳化解法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%B7%E8%A1%8C%E7%B5%90%E6%9E%9C-2"><span class="toc-number">3.4.1.</span> <span class="toc-text">執行結果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A4%87%E9%9B%9C%E5%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">複雜度</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/d0fc136d.html" title="LeetCode 刷題知識總整理">LeetCode 刷題知識總整理</a><time datetime="2100-11-29T01:08:02.000Z" title="發表於 2100-11-29 09:08:02">2100-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dce71546.html" title="DevOps技能樹知識整理 |【筆記目錄】"><img src="/img/devops/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DevOps技能樹知識整理 |【筆記目錄】"/></a><div class="content"><a class="title" href="/posts/dce71546.html" title="DevOps技能樹知識整理 |【筆記目錄】">DevOps技能樹知識整理 |【筆記目錄】</a><time datetime="2060-11-05T13:45:50.000Z" title="發表於 2060-11-05 21:45:50">2060-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/22911275.html" title="Git for DevOps 筆記 |【DevOps技能樹】"><img src="/img/devops/git/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git for DevOps 筆記 |【DevOps技能樹】"/></a><div class="content"><a class="title" href="/posts/22911275.html" title="Git for DevOps 筆記 |【DevOps技能樹】">Git for DevOps 筆記 |【DevOps技能樹】</a><time datetime="2025-11-11T03:45:46.000Z" title="發表於 2025-11-11 11:45:46">2025-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/85addf17.html" title="合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String"><img src="/img/LeetCode/678/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String"/></a><div class="content"><a class="title" href="/posts/85addf17.html" title="合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String">合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String</a><time datetime="2025-10-26T07:05:24.000Z" title="發表於 2025-10-26 15:05:24">2025-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8a835d3b.html" title="Pow(x, n) | Medium | LeetCode#50. Pow(x, n)"><img src="/img/LeetCode/50/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Pow(x, n) | Medium | LeetCode#50. Pow(x, n)"/></a><div class="content"><a class="title" href="/posts/8a835d3b.html" title="Pow(x, n) | Medium | LeetCode#50. Pow(x, n)">Pow(x, n) | Medium | LeetCode#50. Pow(x, n)</a><time datetime="2025-10-23T06:03:36.000Z" title="發表於 2025-10-23 14:03:36">2025-10-23</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By Kevin Liu</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主題 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日夜模式切換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往評論"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到頂端"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'dark'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null
  const getUtterancesTheme = theme => theme === 'dark' ? 'photon-dark' : 'github-light'

  const loadUtterances = (el = document, key) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyUtterances = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const config = {
      src: 'https://utteranc.es/client.js',
      repo: 'leozzmc/Blog_Reply',
      theme: getUtterancesTheme(document.documentElement.getAttribute('data-theme')),
      crossorigin: 'anonymous',
      async: true,
      ...option,
      'issue-term': isShuoshuo ? key : (option && option['issue-term']) || 'pathname'
    }

    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => ele.setAttribute(key, value))
    el.querySelector('#utterances-wrap').appendChild(ele)
  }

  const changeUtterancesTheme = theme => {
    const iframe = document.querySelector('#utterances-wrap iframe')
    if (iframe) {
      const message = {
        type: 'set-theme',
        theme: getUtterancesTheme(theme)
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es')
    }
  }

  btf.addGlobalFn('themeChange', changeUtterancesTheme, 'utterances')

  if (isShuoshuo) {
    'Utterances' === 'Utterances'
      ? window.shuoshuoComment = { loadComment: loadUtterances }
      : window.loadOtherComment = loadUtterances
    return
  }
  
  if ('Utterances' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script></div><script data-pjax src="/self/btf.js"></script><script data-pjax src="/self/tw_en.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script data-pjax src="/self/calendar.js"></script><script data-pjax src="/self/languages.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-show-text.min.js" data-mobile="false" data-text="👍,👾,💊,🧪,👁️" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜尋</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  資料載入中</span></div><div class="local-search-input"><input placeholder="搜尋文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>