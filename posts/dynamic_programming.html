<!DOCTYPE html><html lang="zh-TW" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>刷題知識整理 | 動態規劃 Dynamic Programming(DP) | Kevin Liu's 部落格 || Technical || Travel</title><meta name="author" content="Kevin Liu"><meta name="copyright" content="Kevin Liu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="前言從還沒開始刷題前就耳聞了DP題目的恐怖，因此想說在實際開始刷類似題目前整理一下DP的知識。  在閱讀網路資料的時候發現這篇文章解釋得很好，因此非常推薦先閱讀這篇 文章，作者有提到要理解 DP，耐心很重要，然後還需要熟悉遞迴，因為DP問題通常會用遞迴來解決  甚麼是 Dynamic Programming(DP)?這裡我必須提到上面那篇文章說的結論: Dynamic Programming 是一">
<meta property="og:type" content="article">
<meta property="og:title" content="刷題知識整理 | 動態規劃 Dynamic Programming(DP)">
<meta property="og:url" content="https://leozzmc.github.io/posts/dynamic_programming.html">
<meta property="og:site_name" content="Kevin Liu&#39;s 部落格 || Technical || Travel">
<meta property="og:description" content="前言從還沒開始刷題前就耳聞了DP題目的恐怖，因此想說在實際開始刷類似題目前整理一下DP的知識。  在閱讀網路資料的時候發現這篇文章解釋得很好，因此非常推薦先閱讀這篇 文章，作者有提到要理解 DP，耐心很重要，然後還需要熟悉遞迴，因為DP問題通常會用遞迴來解決  甚麼是 Dynamic Programming(DP)?這裡我必須提到上面那篇文章說的結論: Dynamic Programming 是一">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://leozzmc.github.io/img/LeetCode/dp/cover.jpg">
<meta property="article:published_time" content="2024-10-20T06:44:06.000Z">
<meta property="article:modified_time" content="2025-10-26T12:28:30.621Z">
<meta property="article:author" content="Kevin Liu">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="Dynamic Programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leozzmc.github.io/img/LeetCode/dp/cover.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "刷題知識整理 | 動態規劃 Dynamic Programming(DP)",
  "url": "https://leozzmc.github.io/posts/dynamic_programming.html",
  "image": "https://leozzmc.github.io/img/LeetCode/dp/cover.jpg",
  "datePublished": "2024-10-20T06:44:06.000Z",
  "dateModified": "2025-10-26T12:28:30.621Z",
  "author": [
    {
      "@type": "Person",
      "name": "Kevin Liu",
      "url": "https://leozzmc.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/kevin3.png"><link rel="canonical" href="https://leozzmc.github.io/posts/dynamic_programming.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-T4SFRRLLZ0"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-T4SFRRLLZ0')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-T4SFRRLLZ0', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":3,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '複製成功',
    error: '複製失敗',
    noSupport: '瀏覽器不支援'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '剛剛',
    min: '分鐘前',
    hour: '小時前',
    day: '天前',
    month: '個月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '載入更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '刷題知識整理 | 動態規劃 Dynamic Programming(DP)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg" style="background-color: #f5f1ed;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">119</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 找文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 歸檔</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 鏈結</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 語言:</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/LeetCode/dp/cover.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://i.imgur.com/P19VCm0.png" alt="Logo"><span class="site-name">Kevin Liu's 部落格 || Technical || Travel</span></a><a class="nav-page-title" href="/"><span class="site-name">刷題知識整理 | 動態規劃 Dynamic Programming(DP)</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首頁</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 找文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 歸檔</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 鏈結</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 語言:</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fa-c"></i><span> 中文</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">刷題知識整理 | 動態規劃 Dynamic Programming(DP)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2024-10-20T06:44:06.000Z" title="發表於 2024-10-20 14:44:06">2024-10-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2025-10-26T12:28:30.621Z" title="更新於 2025-10-26 20:28:30">2025-10-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode%E7%AD%86%E8%A8%98/">LeetCode筆記</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">瀏覽量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>從還沒開始刷題前就耳聞了DP題目的恐怖，因此想說在實際開始刷類似題目前整理一下DP的知識。</p>
<blockquote>
<p>在閱讀網路資料的時候發現這篇文章解釋得很好，因此非常推薦先閱讀這篇 <a target="_blank" rel="noopener" href="https://medium.com/@al.eks/the-ultimate-guide-to-dynamic-programming-65865ef7ec5b">文章</a>，作者有提到要理解 DP，<strong>耐心很重要，然後還需要熟悉遞迴，因為DP問題通常會用遞迴來解決</strong></p>
</blockquote>
<h1 id="甚麼是-Dynamic-Programming-DP"><a href="#甚麼是-Dynamic-Programming-DP" class="headerlink" title="甚麼是 Dynamic Programming(DP)?"></a>甚麼是 Dynamic Programming(DP)?</h1><p>這裡我必須提到上面那篇文章說的結論: <strong>Dynamic Programming 是一種用來幫助遞迴程式碼更加有效率的工具</strong>，所以文章作者也認為不該在面對一個問題的時候就先去識別這個問題是否是一個 DP問題，而是先判斷是否需要用到遞迴，而在遞迴的基礎上，會延伸思考到這個遞迴程式碼可能會很冗，因此有答案應該會有改善空間，<strong>而改善的方式就透過 Dynamic Programming</strong></p>
<blockquote>
<p>DP 是用來改善現有 Solution 的方式 !</p>
</blockquote>
<p>接下來介紹使用這個工具的步驟，其中包含了4個步驟，這裡會用一個題目來逐步解釋</p>
<p>題目:　<a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths/description/">LeetCode62. Unique Paths</a></p>
<p><img src="/img/LeetCode/dp/robot_maze.png"></p>
<p>這題中給了一個大小 <em>m x n</em> 的格子，有一個機器人在最左上角的位置，機器人每次執行可以往下或往右走一格，機器人要試圖抵達最右下角的 Finish 格，要找出有多少種可能的獨特的路徑組合。</p>
<h2 id="步驟一-Recursion"><a href="#步驟一-Recursion" class="headerlink" title="步驟一: Recursion"></a>步驟一: Recursion</h2><p>這個步驟通常是最重要的一步會是制定整個解題計畫的關鍵!，需要做的事就是要回歸到最純粹的中心思想 - 遞迴，其實也就是相當於 <strong>先提出暴力解</strong></p>
<blockquote>
<p>同時這也能先說服面試官，你知道這題要使用怎樣的遞迴關係來解，也就是說要先找到遞迴關係，才有後面改善的空間</p>
</blockquote>
<p><img src="/img/LeetCode/dp/unipath.png"></p>
<p>首先這題要找的是最終有多少條路徑可以到終點，那會需要先知道甚麼? <strong>會需要知道從起點到任一格會有幾條路徑</strong>，我們從上面的圖看，可以知道從起點 <code>grid[0][0]</code> 到它右下角那格 <code>grid[1][1]</code> 可以從右邊走也可以從下面走 (題目規定只能右或往下移動) 一共是兩條路線，那從起點單獨往右以及單獨往下都各只有一條路線。</p>
<p>上面的例子應該也能看出，對於任意格 <code>[i][j]</code>，它的上一步可能是:</p>
<ul>
<li>從上面一格一移動下來，即 <code>[i-1][j]</code></li>
<li>從左邊一格一移動下來，即 <code>[i][j-1]</code></li>
</ul>
<p>而從上或從左移動一格都是在相同路徑上，因此數量不變，因此可以知道對於任意格 <code>[i][j]</code>，從起點到達它的路徑數量會是 <code>[i-1][j] + [i][j-1]</code></p>
<p><img src="/img/LeetCode/dp/unipath2.png"></p>
<p>在舉例一次也能驗證，若想移動到 <code>grid[2][2]</code>，所有的路徑數量勢必為 <code>grid[1][2] + grid[2][1]</code></p>
<p><img src="/img/LeetCode/dp/unipath3.png"></p>
<p>若我們將上面的想法寫成遞迴式如下，遞迴的終止條件會發生在執行到 <strong>起點的右邊一行或者是下面一列就停止</strong> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span> || n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">uniquePaths</span>(m<span class="number">-1</span>,n) + <span class="built_in">uniquePaths</span>(m,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>但實際跑下去會發現錯誤，Time Limit Exceeded ! 這就代表會有需要改善的地方，所以接下來第二步</p>
</blockquote>
<h2 id="步驟二-Recursion-Memoization"><a href="#步驟二-Recursion-Memoization" class="headerlink" title="步驟二: Recursion + Memoization"></a>步驟二: Recursion + Memoization</h2><p>這一步驟才真正開始使用 DP，但並不是所有沒有效率的問題都需要用 DP 解決，<strong>因此要先衡量這個問題值不值得用 DP 來解</strong>，根據步驟一的結果，<strong>若以下狀況存在並同時成立，才需要使用DP來解決</strong></p>
<ul>
<li>具有重疊的子問題 (Overlapping subproblems):  <em>你有多次解決相同的子問題</em> </li>
<li>具有最佳子結構 (An optimal substructure): <em>透過獲取每個子問題的最佳解，你可以得到整個問題的最佳解</em></li>
</ul>
<p>如果在面試或解題過程中發現這兩點沒辦法完全滿足，那就不該使用DP (或本篇介紹的方式)，可能可以用其他像是 backtracking 技巧來解。</p>
<blockquote>
<p>所以要怎麼確定，這題題目中有滿足這兩個條件呢?</p>
</blockquote>
<p>我下面畫了 Step1 的遞迴樹，可以發現其實並非所有子問題都重疊，但還是可以看到有很多重複計算，像是 <code>uniquePaths(2, 6)</code> 和 <code>uniquePaths(2, 5)</code>，所以還是可以看成是有重疊的子問題。</p>
<details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Step1 解法的遞迴樹</summary><div class="toggle-content"><p>可以放大來看</p>
<p><img src="/img/LeetCode/dp/unipath4.png"></p>
</div></details>

<p>第二個條件也可以被滿足，因為我們可以用 <code>[m-1][n]</code> 以及 <code>[m][n-1]</code> 來去得到 <code>[m][n]</code> 的最佳解</p>
<blockquote>
<p>所以這個步驟要達成的目標很簡單，<strong>那就是讓重複計算的部分只計算一次，並想辦法安全地保存起來(<em>memoization</em>)</strong></p>
</blockquote>
<p>儲存的目的是要讓後續重複計算的部分能夠方便查找，來降低計算量，因此在後續儲存中查找，<strong>也希望盡量達到 $O(1)$ 的複雜度</strong>，可以看情況用陣列或者是雜湊表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[m][n])&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[m][n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">1</span> || n==<span class="number">1</span>) &#123;</span><br><span class="line">            dp[m][n]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> dp[m][n];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[m][n] = <span class="built_in">helper</span>(m<span class="number">-1</span>,n) + <span class="built_in">helper</span>(m,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span>  <span class="built_in">helper</span>(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面這是修正後的結果，主要透過一個2D Vector 來存放計算過的路徑數量，而由於要初始化陣列大小為 <em>m+1 x n+1</em> (這裡是怕存取超出邊界)，因此分成兩個函數進行操作。對於這題來說，需要改動的地方也不多，對於原先的邏輯只需要改動有兩處:</p>
<ul>
<li><strong>儲存遞迴呼叫結果</strong></li>
<li><strong>當一個遞迴呼叫已經存在於陣列中，則返回儲存值</strong> (i.e. <code>helper(m,n)</code> 的結果已經儲存在 <code>dp[m][n]</code> 當中)</li>
</ul>
<blockquote>
<p>這時再次執行，就會發現 Submit Accepted 了</p>
</blockquote>
<p>並且這樣執行的時間複雜度為 $O(M \times N)$，相比步驟一的做法為 $O(2^{M+N})$ (因為遞迴的每一層會將問題分解為兩個子問題) 提升更多效率，雖然時間複雜度降低了，但所使用的空間複雜度卻提升了，但這也說明了 <strong>DP 會是一種用空間換取時間的做法</strong>，這其實是非常值得的，<strong>因為這麼做的空間複雜度大多都是線性成長，但卻能夠指數型的改善時間複雜度</strong></p>
<blockquote>
<p>所以到目前為止的進度是，先能夠提出暴力解的遞迴做法後，接著透過額外的記憶體空間來去改善先前的做法! (面試的話到這一步已經很讚了)<br>那是否還有其他可以進一步最佳化的地方呢? 這就會到第三步</p>
</blockquote>
<h2 id="步驟三-Iteration-Tabulation"><a href="#步驟三-Iteration-Tabulation" class="headerlink" title="步驟三 : Iteration + Tabulation"></a>步驟三 : Iteration + Tabulation</h2><p>正常而言，如果在上一步中沒有明顯的效能提升 (或者面試官希望你進一步改善你的答案)，那就會需要第三步。這一步驟中使用 <em>Tabulation</em>，而非 <em>Memoization</em>，並且使透過 Iteration 而非 Recursion 的方式實作。</p>
<blockquote>
<p>但無論是 <em>Tabulation</em> 或者是 <em>Memoization</em> 他們的目標都一樣，<strong>就是要將先前計算結果儲存，在後續重複計算時取出使用</strong></p>
</blockquote>
<p>兩者的區別主要在於資料的儲存方式，<em>Tabulation</em> 主要是透過 <strong>陣列儲存 (通常是二微陣列)</strong> ，而 <em>Memoization</em> 則通常是用 Set, Hash Table 等方式儲存。 <strong>所以 <em>Tabulation</em> 會透過迭代的方式來走遍每個陣列，而 <em>Memoization</em> 則是藉助於遞迴呼叫。</strong></p>
<div class="note info flat"><p>這個變更不一定會讓時間或空間複雜度改善，但重點是， <strong>使用迭代陣列的方式可以容納更大的 Input Size，而不會受限於遞迴呼叫的 Call Stack 的最大上限</strong>  (Call Stack 太深還有機會 Stack Overflow)</p>
</div>

<p>所以回頭看原先 Unique Paths的題目，如果要用 Iterations，就可以透過迴圈反向迭代。</p>
<p><img src="/img/LeetCode/dp/unipath5.png"></p>
<p>可以看這張圖的右邊，原則上就是從右下角往左上角走，而作者在這裡選擇從倒數第二行和倒數第二列那格開始往回做的原因是，因為最下面那列和最右邊那行的可走路徑數量都會是 1，因此對於 <code>gird[1][5]</code> 從新的起點走到它會有的步驟數等於 <code>grid[2][5]</code> 和 <code>grid[1][6]</code>，因此可以得到一個關係式為 $F(m,n) &#x3D; F(m+1, n) + F(m, n+1)$。</p>
<p>重新改寫程式後會像是下面這樣:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// init a m x n 2D vector with value 1</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-2</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="comment">// do it backwardly</span></span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j] + dp[i][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這裡詳細解釋程式碼的變更步驟:</p>
<ol>
<li>宣告一個大小 m x n 的2D Vector，其值為 1 (代表一整個網格，默認的路徑數量是 1)</li>
<li>建立迴圈，將倒數第二行以及到數第二列的格子 (<code>[m-2][n-2]</code>) 作為迴圈的起點，每次迭代都會將index 減去 1</li>
<li>走訪每個格子，並且規則就是我們剛剛得出的關係式</li>
<li>從右下角一路迭代回 <code>[0][0]</code>，一旦抵達 <code>[0][0]</code>，其儲存值就會是所有的路徑值</li>
</ol>
<p>如果把走訪過程視覺化就會像是下圖</p>
<p><img src="/img/LeetCode/dp/tab.png"></p>
<blockquote>
<p>執行結果和複雜度也跟步驟二一樣，並且也都是100% Runtime!<br>另外文章作者也提到這種做法很適合用在這種從A走到B 類型的題目，要做的事情就是填表格而已</p>
</blockquote>
<h2 id="步驟四-Iteration-Tabulation-Optimized"><a href="#步驟四-Iteration-Tabulation-Optimized" class="headerlink" title="步驟四: Iteration + Tabulation [Optimized]"></a>步驟四: Iteration + Tabulation [Optimized]</h2><blockquote>
<p>不一定每次都需要到此步驟，如果面試有到前三步驟，那就已經很好了</p>
</blockquote>
<p>本步驟的 <strong>目標在於降低空間複雜度</strong> ，經過前幾個步驟，時間複雜度應該已經是 Optimized了。之所以還有機會繼續最佳化空間複雜度，是因為儘管我們前面建立了 m x n 的網格來迭代儲存路徑數量， <strong>但實際上我們並不一定要一次持續存取整個表格。</strong></p>
<p>如果觀察到目前為止建立的遞迴關係 (可以觀察上面的走訪過程圖)，<strong>對任意格來說，所需要的格子只有它的正下方以及正右方的格子</strong>，因此在宣告陣列時僅需要 <code>m=2</code> 的 2 x n 陣列 (對於 Unique Paths 這題僅需這樣大小的空間就好)。 那這樣又要如何存放路徑值呢?</p>
<p>這裡的起點一樣會是 <code>[m-2][n-2]</code>，也就是步驟三的倒數第二列跟第二行的那格，可以想像成是擷取了原先 m x n 表格中的最下面兩列，並且一樣進行迭代，迭代規則就如同剛剛提到的，對於任意格來說只需要他的正下方以及正右方的格子，因此對於第一列 (<code>i=0</code>) 來說，規則會是 $F(m, n) &#x3D; F(m+1, n) + F(m,n+1) $，一旦第一列算完後，那用來計算第一列的第二列 (應該都會先是1) 就沒有利用價值了，這時候就將第一列的數值全部複製到第二列，用來計算新的第一列，跟著一樣的迭代規則走，最後的 $F(0, 0)$ 就會是整體路徑數量。</p>
<p><img src="/img/LeetCode/dp/tab2.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// init a m x n 2D vector with value 1</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-2</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="comment">// Handloe first row</span></span><br><span class="line">                <span class="comment">// (m+n) = (cell below) + (cell on the right)</span></span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">1</span>][j] + dp[<span class="number">0</span>][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Move to second row</span></span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這裡可以比對步驟三以及步驟四之間空間複雜度的差異，步驟三因為要存放整張表格，因此空間複雜度會是 $O(n \times m)$，而步驟四僅存放 $2*n$ 個表格，因此空間複雜度會是$O(2 \times n) &#x3D; O(n)$。</p>
<p>這裡也可以從結果中觀察差異:</p>
<p><em>步驟三</em><br><img src="/img/LeetCode/dp/result1.png"></p>
<p><em>步驟四</em><br><img src="/img/LeetCode/dp/result2.jpeg"></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://medium.com/@al.eks/the-ultimate-guide-to-dynamic-programming-65865ef7ec5b">https://medium.com/@al.eks/the-ultimate-guide-to-dynamic-programming-65865ef7ec5b</a><br><a target="_blank" rel="noopener" href="https://shannonhung.github.io/posts/lecture-dp/">https://shannonhung.github.io/posts/lecture-dp/</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://leozzmc.github.io">Kevin Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章連結: </span><span class="post-copyright-info"><a href="https://leozzmc.github.io/posts/dynamic_programming.html">https://leozzmc.github.io/posts/dynamic_programming.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 授權協議。轉載請註明來源 <a href="https://leozzmc.github.io" target="_blank">Kevin Liu's 部落格 || Technical || Travel</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a><a class="post-meta__tags" href="/tags/Dynamic-Programming/">Dynamic Programming</a></div><div class="post-share"><div class="social-share" data-image="/img/LeetCode/dp/cover.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/94b01956.html" title="重新排序鏈結 | Medium | LeetCode#143. Reorder List"><img class="cover" src="/img/LeetCode/143/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">重新排序鏈結 | Medium | LeetCode#143. Reorder List</div></div><div class="info-2"><div class="info-item-1">題目敘述   題目難度: Medium 題目敘述: 題目給定一個 single linked list，L0 → L1 → … → Ln - 1 → Ln 請將這個 list 重組成 L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … 在這當中請不要改動節點值。  解法一開始的想法 由於排序看起來像是把一個 linked list 頭尾對折然後再交互連接，因此我的想法會是先找到鏈結的中間節點，再將其拆分成兩個 list，之後將後半部分的 list 進行反序排列，接著再跟前半部分的list交互排列。 我的解法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-link...</div></div></div></a><a class="pagination-related" href="/posts/355cc876.html" title="爬樓梯問題 | Easy | LeetCode#70. Climbing Stairs"><img class="cover" src="/img/LeetCode/70/cover.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">爬樓梯問題 | Easy | LeetCode#70. Climbing Stairs</div></div><div class="info-2"><div class="info-item-1">題目敘述  題目難度：Easy  題目敘述：題目描述要爬階梯，需要 n 階可以到頂端，每次可以跨一步或是兩步，有多少種爬到頂端的方式?   解法一開始的想法首先要先思考這題的遞迴關係，任意階的步驟數，會是由什麼組成？ 這裡可以觀察到如果 n=1 也就是往上一層有幾種走法，答案就是 1 因為只能走一步，那 n=2 這時就可以選擇走兩次一步 [1,1] 或者是一次走兩步 [2]，也就是有兩種選擇，那若 n=3 呢？ 往上三階其實就是往上一階和往上兩街的組合，因此他們對應的走法數量也會是 n=1 和 n=2 的加總 1234n=1 | output1=1n=2 | output2=2n=3 = 2+1 | output= output1+ output2  因此可以總結遞回式為 $F(n) &#x3D; F(n-1) + F(n-2)$，把它寫成程式如下： 123456int climbS...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/cd4d1860.html" title="三角形 | Medium | LeetCode#120. Triangle"><img class="cover" src="/img/LeetCode/120/cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-19</div><div class="info-item-2">三角形 | Medium | LeetCode#120. Triangle</div></div><div class="info-2"><div class="info-item-1">題目敘述  題目難度: Medium 題目敘述: 題目給定一個2D陣列 triangle，求從最頂端走到最底端的最小路徑總和值  對於每個 row 只能往下一層走，並且每次都會有兩種走法，假設現在在當前row的位置是 i，則下一層能夠選擇繼續走到 i 或者是 i+1 的位置。   123456範例:   2  3 4 6 5 74 1 8 3最短路徑總和會是: 2 + 3 + 5 + 1 = 11  解法一開始的想法想法其實也還蠻單純的，就是每層都可以有選或不選特定路徑，由於要找最短的路徑和， 因此需要兩條路徑都選擇，比較回傳結果大小 ，然後選小的回傳，這樣整體遞迴呼叫完畢後就能夠求出最短路徑和。 我的解法Recursive1234567891011121314151617181920212223class Solution &#123;public:        int help...</div></div></div></a><a class="pagination-related" href="/posts/a0e35335.html" title="買賣股票的最佳時機 | Easy | LeetCode#121. Best Time to Buy and Sell Stock"><img class="cover" src="/img/LeetCode/121/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-09</div><div class="info-item-2">買賣股票的最佳時機 | Easy | LeetCode#121. Best Time to Buy and Sell Stock</div></div><div class="info-2"><div class="info-item-1">前言這題是股票買賣系列的題目，與他類似的題目會是  122. Best Time to Buy and Sell Stock II123. Best Time to Buy and Sell Stock III188. Best Time to Buy and Sell Stock IV309. Best Time to Buy and Sell Stock with Cooldown 題目敘述  題目難度： Easy 題目描述： 給定一個陣列 prices，prices[i] 代表在第 i 天的股票價格。請選一天進買入股票，但在不同天賣出股票 (買賣股票不能在同一天，且須先買股票才能賣股票)，求股票的最大化收益。  解法一開始的想法一開始的想法複雜度其實比較高，就是透過一個迴圈來決定買入，透過另一個內部迴圈決定賣出，然後透過一個變數 maxValue 保存第 i 天買入然後第 j ...</div></div></div></a><a class="pagination-related" href="/posts/cfc810b0.html" title="買賣股票的最佳時機III | Hard | LeetCode#123. Best Time to Buy and Sell Stock III"><img class="cover" src="/img/LeetCode/123/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-12</div><div class="info-item-2">買賣股票的最佳時機III | Hard | LeetCode#123. Best Time to Buy and Sell Stock III</div></div><div class="info-2"><div class="info-item-1">前言這題是股票買賣系列的題目: 121. Best Time to Buy and Sell Stock122. Best Time to Buy and Sell Stock II188. Best Time to Buy and Sell Stock IV309. Best Time to Buy and Sell Stock with Cooldown 題目敘述  題目難度：Hard 題目描述： 給定一個整數陣列 prices，prices[i] 代表第 i 天的股票價格，每一天可以選擇買或賣股票，最多只能交易兩次 (買賣兩次)，請找出最大收益。  與先前幾題的原則一樣，只能先買後賣，並且不允許同時有多筆交易，手上股票要賣出才能夠繼續買   解法一開始的想法一開始的想法蠻簡單的，就是與前面幾題一樣，假設 prices=[3,4,5,0,0,3,1,4] 那漲跌幅值如下 1+1 ...</div></div></div></a><a class="pagination-related" href="/posts/bea79d96.html" title="二元樹最大路徑總和 | Hard | LeetCode#124. Binary Tree Maximum Path Sum"><img class="cover" src="/img/LeetCode/124/cover.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-07</div><div class="info-item-2">二元樹最大路徑總和 | Hard | LeetCode#124. Binary Tree Maximum Path Sum</div></div><div class="info-2"><div class="info-item-1">題目敘述   題目難度：Hard 題目敘述： 題目給定你一個 Binary Tree 的 root，求這棵二元樹中的所有路徑中，最大路徑和  這裡二元樹的路徑的代表的是 節點序列，序列由每個由邊連接的相鄰節點組成。一個節點最多只能在序列中出現一次。請注意，該路徑不需要經過Root節點   解法 這是第一次解 Hard，真的花比較久的時間，但也學習到很多  一開始的想法我一開始的想法是有問題的，但還是紀錄一下這個錯誤思路，我一開始想得太簡單了，以為就先把所有二元樹的節點DFS 走訪一遍，就能夠得到一個節點順序，接著就是 backtracking 中的子集問題，在序列中找子集元素和最大的組合就是答案。   但這有一個缺陷，那就是DFS(inorder)走訪過程的順序不滿足題目敘述的節點序列  像是下面這個例子，經過 inorder 走訪過後的順序會是 -8, 10, 20, -5, -1...</div></div></div></a><a class="pagination-related" href="/posts/fcfb0850.html" title="買賣股票的最佳時機II | Medium | LeetCode#122. Best Time to Buy and Sell Stock II"><img class="cover" src="/img/LeetCode/122/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-11</div><div class="info-item-2">買賣股票的最佳時機II | Medium | LeetCode#122. Best Time to Buy and Sell Stock II</div></div><div class="info-2"><div class="info-item-1">前言這題是股票買賣系列的題目: 121. Best Time to Buy and Sell Stock123. Best Time to Buy and Sell Stock III309. Best Time to Buy and Sell Stock with Cooldown 題目敘述  題目難度: Medium 題目描述： 給定一個整數陣列 prices，prices[i] 代表第 i 天的股票價格，每一天可以選擇買或賣股票，允許當日買在當日立刻賣出，然而任意時間段最多僅能持有一份股票  解法一開始的想法這題跟 LeetCode-121 Best Time to Buy and Sell Stock 不太一樣的是，這題允許多次交易，所以要求的是， 多筆買賣的總收益要最大化。 假設今天 prices = &#123;7, 1, 5, 3, 6, 4&#125; 則在股價為 1...</div></div></div></a><a class="pagination-related" href="/posts/9081d01d.html" title="拆分字句 | Medium | LeetCode#139. Word Break"><img class="cover" src="/img/LeetCode/139/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-18</div><div class="info-item-2">拆分字句 | Medium | LeetCode#139. Word Break</div></div><div class="info-2"><div class="info-item-1">題目敘述  題目難度：Medium 題目描述：給定一個字串 s，以及一個字串形成的陣列 wordDict，若 s 可以被分割成一個或多個 wordDict 當中的單字序列，則回傳 True  Note that the same word in the dictionary may be reused multiple times in the segmentation.   解法一開始的想法s 中的每個字元可以 選或不選，每次形成一個子字串，就去跟 wordDict 進行比較看當前子字串是否存在於 wordDict 當中，一旦嘗試過每個子字串，則回傳結果。 我的解答1234567891011121314151617181920212223242526class Solution &#123;public:    vector&lt;int&gt; dp;     bool help...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 評論</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Kevin Liu</div><div class="author-info-description">👍👍👍👍👍</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">119</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/leozzmc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/leozzmc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zzmczzmczzmc870125@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #e0ad5a;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/kevin-liu087" target="_blank" title="LinkedIn"><i class="fa-brands fa-linkedin" style="color: #0373fc;"></i></a><a class="social-icon" href="https://www.youtube.com/channel/UC2AU_vpxPu0oKcgZl3UJSNg" target="_blank" title="Youtube"><i class="fa-brands fa-youtube" style="color: #dc1e1e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">🛫🛬</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9A%E9%BA%BC%E6%98%AF-Dynamic-Programming-DP"><span class="toc-number">2.</span> <span class="toc-text">甚麼是 Dynamic Programming(DP)?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%A9%9F%E4%B8%80-Recursion"><span class="toc-number">2.1.</span> <span class="toc-text">步驟一: Recursion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%A9%9F%E4%BA%8C-Recursion-Memoization"><span class="toc-number">2.2.</span> <span class="toc-text">步驟二: Recursion + Memoization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%A9%9F%E4%B8%89-Iteration-Tabulation"><span class="toc-number">2.3.</span> <span class="toc-text">步驟三 : Iteration + Tabulation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%A9%9F%E5%9B%9B-Iteration-Tabulation-Optimized"><span class="toc-number">2.4.</span> <span class="toc-text">步驟四: Iteration + Tabulation [Optimized]</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-number">3.</span> <span class="toc-text">Reference</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/d0fc136d.html" title="LeetCode 刷題知識總整理">LeetCode 刷題知識總整理</a><time datetime="2100-11-29T01:08:02.000Z" title="發表於 2100-11-29 09:08:02">2100-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dce71546.html" title="DevOps技能樹知識整理 |【筆記目錄】"><img src="/img/devops/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DevOps技能樹知識整理 |【筆記目錄】"/></a><div class="content"><a class="title" href="/posts/dce71546.html" title="DevOps技能樹知識整理 |【筆記目錄】">DevOps技能樹知識整理 |【筆記目錄】</a><time datetime="2060-11-05T13:45:50.000Z" title="發表於 2060-11-05 21:45:50">2060-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/22911275.html" title="Git for DevOps 筆記 |【DevOps技能樹】"><img src="/img/devops/git/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git for DevOps 筆記 |【DevOps技能樹】"/></a><div class="content"><a class="title" href="/posts/22911275.html" title="Git for DevOps 筆記 |【DevOps技能樹】">Git for DevOps 筆記 |【DevOps技能樹】</a><time datetime="2025-11-11T03:45:46.000Z" title="發表於 2025-11-11 11:45:46">2025-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/85addf17.html" title="合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String"><img src="/img/LeetCode/678/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String"/></a><div class="content"><a class="title" href="/posts/85addf17.html" title="合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String">合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String</a><time datetime="2025-10-26T07:05:24.000Z" title="發表於 2025-10-26 15:05:24">2025-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8a835d3b.html" title="Pow(x, n) | Medium | LeetCode#50. Pow(x, n)"><img src="/img/LeetCode/50/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Pow(x, n) | Medium | LeetCode#50. Pow(x, n)"/></a><div class="content"><a class="title" href="/posts/8a835d3b.html" title="Pow(x, n) | Medium | LeetCode#50. Pow(x, n)">Pow(x, n) | Medium | LeetCode#50. Pow(x, n)</a><time datetime="2025-10-23T06:03:36.000Z" title="發表於 2025-10-23 14:03:36">2025-10-23</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By Kevin Liu</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="繁簡轉換">EN</button><button id="darkmode" type="button" title="日夜模式切換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往評論"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到頂端"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'dark'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null
  const getUtterancesTheme = theme => theme === 'dark' ? 'photon-dark' : 'github-light'

  const loadUtterances = (el = document, key) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyUtterances = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const config = {
      src: 'https://utteranc.es/client.js',
      repo: 'leozzmc/Blog_Reply',
      theme: getUtterancesTheme(document.documentElement.getAttribute('data-theme')),
      crossorigin: 'anonymous',
      async: true,
      ...option,
      'issue-term': isShuoshuo ? key : (option && option['issue-term']) || 'pathname'
    }

    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => ele.setAttribute(key, value))
    el.querySelector('#utterances-wrap').appendChild(ele)
  }

  const changeUtterancesTheme = theme => {
    const iframe = document.querySelector('#utterances-wrap iframe')
    if (iframe) {
      const message = {
        type: 'set-theme',
        theme: getUtterancesTheme(theme)
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es')
    }
  }

  btf.addGlobalFn('themeChange', changeUtterancesTheme, 'utterances')

  if (isShuoshuo) {
    'Utterances' === 'Utterances'
      ? window.shuoshuoComment = { loadComment: loadUtterances }
      : window.loadOtherComment = loadUtterances
    return
  }
  
  if ('Utterances' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script></div><script data-pjax src="/self/btf.js"></script><script data-pjax src="/self/tw_en.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script data-pjax src="/self/calendar.js"></script><script data-pjax src="/self/languages.js"></script><script id="canvas_nest" defer="defer" color="34,34,34" opacity="0.8" zIndex="-1" count="350" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>